/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.2.1
 */

#ifndef __SOURCE_CPP__
#define __SOURCE_CPP__
#include "source.h"
#include "dynamic-unwrap.h"
/** ## BEGIN VkDebugUtilsMessengerEXT ## **/
//#include "VkDebugUtilsMessengerEXT.h"

Napi::FunctionReference _VkDebugUtilsMessengerEXT::constructor;

_VkDebugUtilsMessengerEXT::_VkDebugUtilsMessengerEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugUtilsMessengerEXT>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDebugUtilsMessengerEXT constructor cannot be invoked without 'new'");
}

_VkDebugUtilsMessengerEXT::~_VkDebugUtilsMessengerEXT() {}

Napi::Object _VkDebugUtilsMessengerEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugUtilsMessengerEXT", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugUtilsMessengerEXT", func);
  return exports;
}

/** ## END VkDebugUtilsMessengerEXT ## **/

/** ## BEGIN VkDebugReportCallbackEXT ## **/
//#include "VkDebugReportCallbackEXT.h"

Napi::FunctionReference _VkDebugReportCallbackEXT::constructor;

_VkDebugReportCallbackEXT::_VkDebugReportCallbackEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugReportCallbackEXT>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDebugReportCallbackEXT constructor cannot be invoked without 'new'");
}

_VkDebugReportCallbackEXT::~_VkDebugReportCallbackEXT() {}

Napi::Object _VkDebugReportCallbackEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugReportCallbackEXT", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugReportCallbackEXT", func);
  return exports;
}

/** ## END VkDebugReportCallbackEXT ## **/

/** ## BEGIN VkSwapchainKHR ## **/
//#include "VkSwapchainKHR.h"

Napi::FunctionReference _VkSwapchainKHR::constructor;

_VkSwapchainKHR::_VkSwapchainKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSwapchainKHR>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkSwapchainKHR constructor cannot be invoked without 'new'");
}

_VkSwapchainKHR::~_VkSwapchainKHR() {}

Napi::Object _VkSwapchainKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSwapchainKHR", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSwapchainKHR", func);
  return exports;
}

/** ## END VkSwapchainKHR ## **/

/** ## BEGIN VkSurfaceKHR ## **/
//#include "VkSurfaceKHR.h"

Napi::FunctionReference _VkSurfaceKHR::constructor;

_VkSurfaceKHR::_VkSurfaceKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSurfaceKHR>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkSurfaceKHR constructor cannot be invoked without 'new'");
}

_VkSurfaceKHR::~_VkSurfaceKHR() {}

Napi::Object _VkSurfaceKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSurfaceKHR", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSurfaceKHR", func);
  return exports;
}

/** ## END VkSurfaceKHR ## **/

/** ## BEGIN VkDisplayModeKHR ## **/
//#include "VkDisplayModeKHR.h"

Napi::FunctionReference _VkDisplayModeKHR::constructor;

_VkDisplayModeKHR::_VkDisplayModeKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayModeKHR>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDisplayModeKHR constructor cannot be invoked without 'new'");
}

_VkDisplayModeKHR::~_VkDisplayModeKHR() {}

Napi::Object _VkDisplayModeKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayModeKHR", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayModeKHR", func);
  return exports;
}

/** ## END VkDisplayModeKHR ## **/

/** ## BEGIN VkDisplayKHR ## **/
//#include "VkDisplayKHR.h"

Napi::FunctionReference _VkDisplayKHR::constructor;

_VkDisplayKHR::_VkDisplayKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayKHR>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDisplayKHR constructor cannot be invoked without 'new'");
}

_VkDisplayKHR::~_VkDisplayKHR() {}

Napi::Object _VkDisplayKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayKHR", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayKHR", func);
  return exports;
}

/** ## END VkDisplayKHR ## **/

/** ## BEGIN VkValidationCacheEXT ## **/
//#include "VkValidationCacheEXT.h"

Napi::FunctionReference _VkValidationCacheEXT::constructor;

_VkValidationCacheEXT::_VkValidationCacheEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkValidationCacheEXT>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkValidationCacheEXT constructor cannot be invoked without 'new'");
}

_VkValidationCacheEXT::~_VkValidationCacheEXT() {}

Napi::Object _VkValidationCacheEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkValidationCacheEXT", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkValidationCacheEXT", func);
  return exports;
}

/** ## END VkValidationCacheEXT ## **/

/** ## BEGIN VkSamplerYcbcrConversion ## **/
//#include "VkSamplerYcbcrConversion.h"

Napi::FunctionReference _VkSamplerYcbcrConversion::constructor;

_VkSamplerYcbcrConversion::_VkSamplerYcbcrConversion(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversion>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkSamplerYcbcrConversion constructor cannot be invoked without 'new'");
}

_VkSamplerYcbcrConversion::~_VkSamplerYcbcrConversion() {}

Napi::Object _VkSamplerYcbcrConversion::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversion", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversion", func);
  return exports;
}

/** ## END VkSamplerYcbcrConversion ## **/

/** ## BEGIN VkDescriptorUpdateTemplate ## **/
//#include "VkDescriptorUpdateTemplate.h"

Napi::FunctionReference _VkDescriptorUpdateTemplate::constructor;

_VkDescriptorUpdateTemplate::_VkDescriptorUpdateTemplate(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorUpdateTemplate>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDescriptorUpdateTemplate constructor cannot be invoked without 'new'");
}

_VkDescriptorUpdateTemplate::~_VkDescriptorUpdateTemplate() {}

Napi::Object _VkDescriptorUpdateTemplate::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorUpdateTemplate", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorUpdateTemplate", func);
  return exports;
}

/** ## END VkDescriptorUpdateTemplate ## **/

/** ## BEGIN VkIndirectCommandsLayoutNVX ## **/
//#include "VkIndirectCommandsLayoutNVX.h"

Napi::FunctionReference _VkIndirectCommandsLayoutNVX::constructor;

_VkIndirectCommandsLayoutNVX::_VkIndirectCommandsLayoutNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkIndirectCommandsLayoutNVX>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkIndirectCommandsLayoutNVX constructor cannot be invoked without 'new'");
}

_VkIndirectCommandsLayoutNVX::~_VkIndirectCommandsLayoutNVX() {}

Napi::Object _VkIndirectCommandsLayoutNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkIndirectCommandsLayoutNVX", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkIndirectCommandsLayoutNVX", func);
  return exports;
}

/** ## END VkIndirectCommandsLayoutNVX ## **/

/** ## BEGIN VkObjectTableNVX ## **/
//#include "VkObjectTableNVX.h"

Napi::FunctionReference _VkObjectTableNVX::constructor;

_VkObjectTableNVX::_VkObjectTableNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTableNVX>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkObjectTableNVX constructor cannot be invoked without 'new'");
}

_VkObjectTableNVX::~_VkObjectTableNVX() {}

Napi::Object _VkObjectTableNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTableNVX", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTableNVX", func);
  return exports;
}

/** ## END VkObjectTableNVX ## **/

/** ## BEGIN VkPipelineCache ## **/
//#include "VkPipelineCache.h"

Napi::FunctionReference _VkPipelineCache::constructor;

_VkPipelineCache::_VkPipelineCache(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineCache>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkPipelineCache constructor cannot be invoked without 'new'");
}

_VkPipelineCache::~_VkPipelineCache() {}

Napi::Object _VkPipelineCache::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineCache", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineCache", func);
  return exports;
}

/** ## END VkPipelineCache ## **/

/** ## BEGIN VkRenderPass ## **/
//#include "VkRenderPass.h"

Napi::FunctionReference _VkRenderPass::constructor;

_VkRenderPass::_VkRenderPass(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPass>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkRenderPass constructor cannot be invoked without 'new'");
}

_VkRenderPass::~_VkRenderPass() {}

Napi::Object _VkRenderPass::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPass", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPass", func);
  return exports;
}

/** ## END VkRenderPass ## **/

/** ## BEGIN VkFramebuffer ## **/
//#include "VkFramebuffer.h"

Napi::FunctionReference _VkFramebuffer::constructor;

_VkFramebuffer::_VkFramebuffer(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFramebuffer>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkFramebuffer constructor cannot be invoked without 'new'");
}

_VkFramebuffer::~_VkFramebuffer() {}

Napi::Object _VkFramebuffer::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFramebuffer", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFramebuffer", func);
  return exports;
}

/** ## END VkFramebuffer ## **/

/** ## BEGIN VkQueryPool ## **/
//#include "VkQueryPool.h"

Napi::FunctionReference _VkQueryPool::constructor;

_VkQueryPool::_VkQueryPool(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueryPool>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkQueryPool constructor cannot be invoked without 'new'");
}

_VkQueryPool::~_VkQueryPool() {}

Napi::Object _VkQueryPool::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueryPool", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueryPool", func);
  return exports;
}

/** ## END VkQueryPool ## **/

/** ## BEGIN VkEvent ## **/
//#include "VkEvent.h"

Napi::FunctionReference _VkEvent::constructor;

_VkEvent::_VkEvent(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkEvent>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkEvent constructor cannot be invoked without 'new'");
}

_VkEvent::~_VkEvent() {}

Napi::Object _VkEvent::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkEvent", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkEvent", func);
  return exports;
}

/** ## END VkEvent ## **/

/** ## BEGIN VkSemaphore ## **/
//#include "VkSemaphore.h"

Napi::FunctionReference _VkSemaphore::constructor;

_VkSemaphore::_VkSemaphore(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSemaphore>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkSemaphore constructor cannot be invoked without 'new'");
}

_VkSemaphore::~_VkSemaphore() {}

Napi::Object _VkSemaphore::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSemaphore", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSemaphore", func);
  return exports;
}

/** ## END VkSemaphore ## **/

/** ## BEGIN VkFence ## **/
//#include "VkFence.h"

Napi::FunctionReference _VkFence::constructor;

_VkFence::_VkFence(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFence>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkFence constructor cannot be invoked without 'new'");
}

_VkFence::~_VkFence() {}

Napi::Object _VkFence::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFence", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFence", func);
  return exports;
}

/** ## END VkFence ## **/

/** ## BEGIN VkDescriptorPool ## **/
//#include "VkDescriptorPool.h"

Napi::FunctionReference _VkDescriptorPool::constructor;

_VkDescriptorPool::_VkDescriptorPool(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorPool>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDescriptorPool constructor cannot be invoked without 'new'");
}

_VkDescriptorPool::~_VkDescriptorPool() {}

Napi::Object _VkDescriptorPool::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorPool", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorPool", func);
  return exports;
}

/** ## END VkDescriptorPool ## **/

/** ## BEGIN VkDescriptorSetLayout ## **/
//#include "VkDescriptorSetLayout.h"

Napi::FunctionReference _VkDescriptorSetLayout::constructor;

_VkDescriptorSetLayout::_VkDescriptorSetLayout(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetLayout>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDescriptorSetLayout constructor cannot be invoked without 'new'");
}

_VkDescriptorSetLayout::~_VkDescriptorSetLayout() {}

Napi::Object _VkDescriptorSetLayout::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetLayout", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetLayout", func);
  return exports;
}

/** ## END VkDescriptorSetLayout ## **/

/** ## BEGIN VkDescriptorSet ## **/
//#include "VkDescriptorSet.h"

Napi::FunctionReference _VkDescriptorSet::constructor;

_VkDescriptorSet::_VkDescriptorSet(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSet>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDescriptorSet constructor cannot be invoked without 'new'");
}

_VkDescriptorSet::~_VkDescriptorSet() {}

Napi::Object _VkDescriptorSet::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSet", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSet", func);
  return exports;
}

/** ## END VkDescriptorSet ## **/

/** ## BEGIN VkSampler ## **/
//#include "VkSampler.h"

Napi::FunctionReference _VkSampler::constructor;

_VkSampler::_VkSampler(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSampler>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkSampler constructor cannot be invoked without 'new'");
}

_VkSampler::~_VkSampler() {}

Napi::Object _VkSampler::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSampler", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSampler", func);
  return exports;
}

/** ## END VkSampler ## **/

/** ## BEGIN VkPipelineLayout ## **/
//#include "VkPipelineLayout.h"

Napi::FunctionReference _VkPipelineLayout::constructor;

_VkPipelineLayout::_VkPipelineLayout(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineLayout>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkPipelineLayout constructor cannot be invoked without 'new'");
}

_VkPipelineLayout::~_VkPipelineLayout() {}

Napi::Object _VkPipelineLayout::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineLayout", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineLayout", func);
  return exports;
}

/** ## END VkPipelineLayout ## **/

/** ## BEGIN VkPipeline ## **/
//#include "VkPipeline.h"

Napi::FunctionReference _VkPipeline::constructor;

_VkPipeline::_VkPipeline(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipeline>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkPipeline constructor cannot be invoked without 'new'");
}

_VkPipeline::~_VkPipeline() {}

Napi::Object _VkPipeline::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipeline", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipeline", func);
  return exports;
}

/** ## END VkPipeline ## **/

/** ## BEGIN VkShaderModule ## **/
//#include "VkShaderModule.h"

Napi::FunctionReference _VkShaderModule::constructor;

_VkShaderModule::_VkShaderModule(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkShaderModule>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkShaderModule constructor cannot be invoked without 'new'");
}

_VkShaderModule::~_VkShaderModule() {}

Napi::Object _VkShaderModule::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkShaderModule", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkShaderModule", func);
  return exports;
}

/** ## END VkShaderModule ## **/

/** ## BEGIN VkImageView ## **/
//#include "VkImageView.h"

Napi::FunctionReference _VkImageView::constructor;

_VkImageView::_VkImageView(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageView>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkImageView constructor cannot be invoked without 'new'");
}

_VkImageView::~_VkImageView() {}

Napi::Object _VkImageView::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageView", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageView", func);
  return exports;
}

/** ## END VkImageView ## **/

/** ## BEGIN VkImage ## **/
//#include "VkImage.h"

Napi::FunctionReference _VkImage::constructor;

_VkImage::_VkImage(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImage>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkImage constructor cannot be invoked without 'new'");
}

_VkImage::~_VkImage() {}

Napi::Object _VkImage::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImage", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImage", func);
  return exports;
}

/** ## END VkImage ## **/

/** ## BEGIN VkBufferView ## **/
//#include "VkBufferView.h"

Napi::FunctionReference _VkBufferView::constructor;

_VkBufferView::_VkBufferView(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferView>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkBufferView constructor cannot be invoked without 'new'");
}

_VkBufferView::~_VkBufferView() {}

Napi::Object _VkBufferView::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferView", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferView", func);
  return exports;
}

/** ## END VkBufferView ## **/

/** ## BEGIN VkBuffer ## **/
//#include "VkBuffer.h"

Napi::FunctionReference _VkBuffer::constructor;

_VkBuffer::_VkBuffer(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBuffer>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkBuffer constructor cannot be invoked without 'new'");
}

_VkBuffer::~_VkBuffer() {}

Napi::Object _VkBuffer::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBuffer", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBuffer", func);
  return exports;
}

/** ## END VkBuffer ## **/

/** ## BEGIN VkCommandPool ## **/
//#include "VkCommandPool.h"

Napi::FunctionReference _VkCommandPool::constructor;

_VkCommandPool::_VkCommandPool(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandPool>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkCommandPool constructor cannot be invoked without 'new'");
}

_VkCommandPool::~_VkCommandPool() {}

Napi::Object _VkCommandPool::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandPool", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandPool", func);
  return exports;
}

/** ## END VkCommandPool ## **/

/** ## BEGIN VkDeviceMemory ## **/
//#include "VkDeviceMemory.h"

Napi::FunctionReference _VkDeviceMemory::constructor;

_VkDeviceMemory::_VkDeviceMemory(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceMemory>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDeviceMemory constructor cannot be invoked without 'new'");
}

_VkDeviceMemory::~_VkDeviceMemory() {}

Napi::Object _VkDeviceMemory::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceMemory", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceMemory", func);
  return exports;
}

/** ## END VkDeviceMemory ## **/

/** ## BEGIN VkCommandBuffer ## **/
//#include "VkCommandBuffer.h"

Napi::FunctionReference _VkCommandBuffer::constructor;

_VkCommandBuffer::_VkCommandBuffer(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandBuffer>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkCommandBuffer constructor cannot be invoked without 'new'");
}

_VkCommandBuffer::~_VkCommandBuffer() {}

Napi::Object _VkCommandBuffer::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandBuffer", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandBuffer", func);
  return exports;
}

/** ## END VkCommandBuffer ## **/

/** ## BEGIN VkQueue ## **/
//#include "VkQueue.h"

Napi::FunctionReference _VkQueue::constructor;

_VkQueue::_VkQueue(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueue>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkQueue constructor cannot be invoked without 'new'");
}

_VkQueue::~_VkQueue() {}

Napi::Object _VkQueue::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueue", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueue", func);
  return exports;
}

/** ## END VkQueue ## **/

/** ## BEGIN VkDevice ## **/
//#include "VkDevice.h"

Napi::FunctionReference _VkDevice::constructor;

_VkDevice::_VkDevice(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDevice>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkDevice constructor cannot be invoked without 'new'");
}

_VkDevice::~_VkDevice() {}

Napi::Object _VkDevice::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDevice", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDevice", func);
  return exports;
}

/** ## END VkDevice ## **/

/** ## BEGIN VkPhysicalDevice ## **/
//#include "VkPhysicalDevice.h"

Napi::FunctionReference _VkPhysicalDevice::constructor;

_VkPhysicalDevice::_VkPhysicalDevice(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevice>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkPhysicalDevice constructor cannot be invoked without 'new'");
}

_VkPhysicalDevice::~_VkPhysicalDevice() {}

Napi::Object _VkPhysicalDevice::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevice", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevice", func);
  return exports;
}

/** ## END VkPhysicalDevice ## **/

/** ## BEGIN VkInstance ## **/
//#include "VkInstance.h"

Napi::FunctionReference _VkInstance::constructor;

_VkInstance::_VkInstance(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkInstance>(info) {
  Napi::Env env = info.Env();
  if (!info.IsConstructCall()) Napi::Error::New(env, "VkInstance constructor cannot be invoked without 'new'");
}

_VkInstance::~_VkInstance() {}

Napi::Object _VkInstance::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkInstance", {});

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkInstance", func);
  return exports;
}

/** ## END VkInstance ## **/

/** ## BEGIN VkClearValue ## **/

Napi::FunctionReference _VkClearValue::constructor;

_VkClearValue::_VkClearValue(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkClearValue>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "color");
      Napi::String sAccess1 = Napi::String::New(env, "depthStencil");
      if (obj.Has(sAccess0)) this->Setcolor(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdepthStencil(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkClearValue constructor cannot be invoked without 'new'");
    }
  }
}

_VkClearValue::~_VkClearValue() {
  
  color.Reset();
  
  depthStencil.Reset();
  
}

Napi::Object _VkClearValue::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkClearValue", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkClearValue::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkClearValue::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "color",
    &_VkClearValue::Getcolor,
    &_VkClearValue::Setcolor,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthStencil",
    &_VkClearValue::GetdepthStencil,
    &_VkClearValue::SetdepthStencil,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkClearValue", func);
  return exports;
}

Napi::Value _VkClearValue::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkClearValue::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearValue *)0)->color));
    uint32_t byteLength = sizeof(((VkClearValue *)0)->color);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearValue *)0)->depthStencil));
    uint32_t byteLength = sizeof(((VkClearValue *)0)->depthStencil);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkClearValue::flush() {
  _VkClearValue *self = this;
  if (!(self->color.IsEmpty())) {
    Napi::Value value = self->color.Value();
    
    _VkClearColorValue* result = Napi::ObjectWrap<_VkClearColorValue>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.color = result->instance;
  }if (!(self->depthStencil.IsEmpty())) {
    Napi::Value value = self->depthStencil.Value();
    
    _VkClearDepthStencilValue* result = Napi::ObjectWrap<_VkClearDepthStencilValue>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.depthStencil = result->instance;
  }
  return true;
}

// color
Napi::Value _VkClearValue::Getcolor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->color.IsEmpty()) return env.Null();
  return this->color.Value().As<Napi::Object>();
}void _VkClearValue::Setcolor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkClearColorValue::constructor.Value())) {
      
      this->color.Reset(value.ToObject(), 1);
      _VkClearColorValue* inst = Napi::ObjectWrap<_VkClearColorValue>::Unwrap(obj);
      inst->flush();
      this->instance.color = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkClearValue.color", "[object VkClearColorValue]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->color.Reset();
    memset(&this->instance.color, 0, sizeof(VkClearColorValue));
  } else {
    
    NapiObjectTypeError(value, "VkClearValue.color", "[object VkClearColorValue]");
  
    return;
  }
}// depthStencil
Napi::Value _VkClearValue::GetdepthStencil(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->depthStencil.IsEmpty()) return env.Null();
  return this->depthStencil.Value().As<Napi::Object>();
}void _VkClearValue::SetdepthStencil(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkClearDepthStencilValue::constructor.Value())) {
      
      this->depthStencil.Reset(value.ToObject(), 1);
      _VkClearDepthStencilValue* inst = Napi::ObjectWrap<_VkClearDepthStencilValue>::Unwrap(obj);
      inst->flush();
      this->instance.depthStencil = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkClearValue.depthStencil", "[object VkClearDepthStencilValue]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->depthStencil.Reset();
    memset(&this->instance.depthStencil, 0, sizeof(VkClearDepthStencilValue));
  } else {
    
    NapiObjectTypeError(value, "VkClearValue.depthStencil", "[object VkClearDepthStencilValue]");
  
    return;
  }
}
/** ## END VkClearValue ## **/

/** ## BEGIN VkClearColorValue ## **/

Napi::FunctionReference _VkClearColorValue::constructor;

_VkClearColorValue::_VkClearColorValue(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkClearColorValue>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vfloat32 = new std::vector<float>;
    vint32 = new std::vector<int32_t>;
    vuint32 = new std::vector<uint32_t>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "float32");
      Napi::String sAccess1 = Napi::String::New(env, "int32");
      Napi::String sAccess2 = Napi::String::New(env, "uint32");
      if (obj.Has(sAccess0)) this->Setfloat32(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setint32(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setuint32(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkClearColorValue constructor cannot be invoked without 'new'");
    }
  }
}

_VkClearColorValue::~_VkClearColorValue() {
  
  vfloat32->clear();
  delete vfloat32;
  
  float32.Reset();
  
  vint32->clear();
  delete vint32;
  
  int32.Reset();
  
  vuint32->clear();
  delete vuint32;
  
  uint32.Reset();
  
}

Napi::Object _VkClearColorValue::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkClearColorValue", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkClearColorValue::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkClearColorValue::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "float32",
    &_VkClearColorValue::Getfloat32,
    &_VkClearColorValue::Setfloat32,
    napi_enumerable
  ),
  InstanceAccessor(
    "int32",
    &_VkClearColorValue::Getint32,
    &_VkClearColorValue::Setint32,
    napi_enumerable
  ),
  InstanceAccessor(
    "uint32",
    &_VkClearColorValue::Getuint32,
    &_VkClearColorValue::Setuint32,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkClearColorValue", func);
  return exports;
}

Napi::Value _VkClearColorValue::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkClearColorValue::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearColorValue *)0)->float32));
    uint32_t byteLength = sizeof(((VkClearColorValue *)0)->float32);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearColorValue *)0)->int32));
    uint32_t byteLength = sizeof(((VkClearColorValue *)0)->int32);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearColorValue *)0)->uint32));
    uint32_t byteLength = sizeof(((VkClearColorValue *)0)->uint32);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkClearColorValue::flush() {
  _VkClearColorValue *self = this;
  if (!(self->float32.IsEmpty())) {
    Napi::Value value = self->float32.Value();
    
    if (value.IsArray()) {
      // validate length
      if (value.As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '4' for 'VkClearColorValue.float32'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(this->instance.float32, array.data(), sizeof(float) * 4);
    } else if (value.IsNull()) {
      memset(&this->instance.float32, 0, sizeof(float));
    } else {
      
    NapiObjectTypeError(value, "VkClearColorValue.float32", "Array");
  
      return false;
    }
  }if (!(self->int32.IsEmpty())) {
    Napi::Value value = self->int32.Value();
    
    if (value.IsArray()) {
      // validate length
      if (value.As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '4' for 'VkClearColorValue.int32'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<int32_t> array = createArrayOfV8Numbers<int32_t>(value);
      memcpy(this->instance.int32, array.data(), sizeof(int32_t) * 4);
    } else if (value.IsNull()) {
      memset(&this->instance.int32, 0, sizeof(int32_t));
    } else {
      
    NapiObjectTypeError(value, "VkClearColorValue.int32", "Array");
  
      return false;
    }
  }if (!(self->uint32.IsEmpty())) {
    Napi::Value value = self->uint32.Value();
    
    if (value.IsArray()) {
      // validate length
      if (value.As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '4' for 'VkClearColorValue.uint32'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<uint32_t> array = createArrayOfV8Numbers<uint32_t>(value);
      memcpy(this->instance.uint32, array.data(), sizeof(uint32_t) * 4);
    } else if (value.IsNull()) {
      memset(&this->instance.uint32, 0, sizeof(uint32_t));
    } else {
      
    NapiObjectTypeError(value, "VkClearColorValue.uint32", "Array");
  
      return false;
    }
  }
  return true;
}

// float32
Napi::Value _VkClearColorValue::Getfloat32(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->float32.IsEmpty()) return env.Null();
  return this->float32.Value().As<Napi::Array>();
}void _VkClearColorValue::Setfloat32(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->float32.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->float32.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkClearColorValue.float32", "Array");
  
    return;
  }
}// int32
Napi::Value _VkClearColorValue::Getint32(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->int32.IsEmpty()) return env.Null();
  return this->int32.Value().As<Napi::Array>();
}void _VkClearColorValue::Setint32(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->int32.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->int32.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkClearColorValue.int32", "Array");
  
    return;
  }
}// uint32
Napi::Value _VkClearColorValue::Getuint32(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->uint32.IsEmpty()) return env.Null();
  return this->uint32.Value().As<Napi::Array>();
}void _VkClearColorValue::Setuint32(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->uint32.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->uint32.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkClearColorValue.uint32", "Array");
  
    return;
  }
}
/** ## END VkClearColorValue ## **/

/** ## BEGIN VkCheckpointDataNV ## **/

Napi::FunctionReference _VkCheckpointDataNV::constructor;

_VkCheckpointDataNV::_VkCheckpointDataNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCheckpointDataNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess3 = Napi::String::New(env, "pCheckpointMarker");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess3)) this->SetpCheckpointMarker(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkCheckpointDataNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkCheckpointDataNV::~_VkCheckpointDataNV() {
  
  
  pNext.Reset();
  
  
  pCheckpointMarker.Reset();
  
}

Napi::Object _VkCheckpointDataNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCheckpointDataNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCheckpointDataNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCheckpointDataNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCheckpointDataNV::GetsType,
    &_VkCheckpointDataNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCheckpointDataNV::GetpNext,
    &_VkCheckpointDataNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "stage",
    &_VkCheckpointDataNV::Getstage,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCheckpointMarker",
    &_VkCheckpointDataNV::GetpCheckpointMarker,
    &_VkCheckpointDataNV::SetpCheckpointMarker,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCheckpointDataNV", func);
  return exports;
}

Napi::Value _VkCheckpointDataNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCheckpointDataNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCheckpointDataNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkCheckpointDataNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCheckpointDataNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCheckpointDataNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCheckpointDataNV *)0)->stage));
    uint32_t byteLength = sizeof(((VkCheckpointDataNV *)0)->stage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCheckpointDataNV *)0)->pCheckpointMarker));
    uint32_t byteLength = sizeof(((VkCheckpointDataNV *)0)->pCheckpointMarker);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCheckpointDataNV::flush() {
  _VkCheckpointDataNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkCheckpointDataNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCheckpointDataNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCheckpointDataNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCheckpointDataNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCheckpointDataNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCheckpointDataNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCheckpointDataNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCheckpointDataNV.pNext", "[object Object]");
  
    return;
  }
}// stage
Napi::Value _VkCheckpointDataNV::Getstage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stage);
}// pCheckpointMarker
Napi::Value _VkCheckpointDataNV::GetpCheckpointMarker(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCheckpointMarker.IsEmpty()) return env.Null();
  return this->pCheckpointMarker.Value().As<Napi::Object>();
}void _VkCheckpointDataNV::SetpCheckpointMarker(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pCheckpointMarker = buffer.Data();
    this->pCheckpointMarker.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pCheckpointMarker = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCheckpointDataNV.pCheckpointMarker", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkCheckpointDataNV ## **/

/** ## BEGIN VkQueueFamilyCheckpointPropertiesNV ## **/

Napi::FunctionReference _VkQueueFamilyCheckpointPropertiesNV::constructor;

_VkQueueFamilyCheckpointPropertiesNV::_VkQueueFamilyCheckpointPropertiesNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueueFamilyCheckpointPropertiesNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkQueueFamilyCheckpointPropertiesNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkQueueFamilyCheckpointPropertiesNV::~_VkQueueFamilyCheckpointPropertiesNV() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkQueueFamilyCheckpointPropertiesNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueueFamilyCheckpointPropertiesNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkQueueFamilyCheckpointPropertiesNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkQueueFamilyCheckpointPropertiesNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkQueueFamilyCheckpointPropertiesNV::GetsType,
    &_VkQueueFamilyCheckpointPropertiesNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkQueueFamilyCheckpointPropertiesNV::GetpNext,
    &_VkQueueFamilyCheckpointPropertiesNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "checkpointExecutionStageMask",
    &_VkQueueFamilyCheckpointPropertiesNV::GetcheckpointExecutionStageMask,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueueFamilyCheckpointPropertiesNV", func);
  return exports;
}

Napi::Value _VkQueueFamilyCheckpointPropertiesNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkQueueFamilyCheckpointPropertiesNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyCheckpointPropertiesNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkQueueFamilyCheckpointPropertiesNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyCheckpointPropertiesNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkQueueFamilyCheckpointPropertiesNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyCheckpointPropertiesNV *)0)->checkpointExecutionStageMask));
    uint32_t byteLength = sizeof(((VkQueueFamilyCheckpointPropertiesNV *)0)->checkpointExecutionStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkQueueFamilyCheckpointPropertiesNV::flush() {
  _VkQueueFamilyCheckpointPropertiesNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkQueueFamilyCheckpointPropertiesNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkQueueFamilyCheckpointPropertiesNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueueFamilyCheckpointPropertiesNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkQueueFamilyCheckpointPropertiesNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkQueueFamilyCheckpointPropertiesNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkQueueFamilyCheckpointPropertiesNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkQueueFamilyCheckpointPropertiesNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkQueueFamilyCheckpointPropertiesNV.pNext", "[object Object]");
  
    return;
  }
}// checkpointExecutionStageMask
Napi::Value _VkQueueFamilyCheckpointPropertiesNV::GetcheckpointExecutionStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.checkpointExecutionStageMask);
}
/** ## END VkQueueFamilyCheckpointPropertiesNV ## **/

/** ## BEGIN VkPhysicalDeviceConditionalRenderingFeaturesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceConditionalRenderingFeaturesEXT::constructor;

_VkPhysicalDeviceConditionalRenderingFeaturesEXT::_VkPhysicalDeviceConditionalRenderingFeaturesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "conditionalRendering");
      Napi::String sAccess3 = Napi::String::New(env, "inheritedConditionalRendering");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetconditionalRendering(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetinheritedConditionalRendering(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceConditionalRenderingFeaturesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceConditionalRenderingFeaturesEXT::~_VkPhysicalDeviceConditionalRenderingFeaturesEXT() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceConditionalRenderingFeaturesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceConditionalRenderingFeaturesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetsType,
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetpNext,
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "conditionalRendering",
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetconditionalRendering,
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetconditionalRendering,
    napi_enumerable
  ),
  InstanceAccessor(
    "inheritedConditionalRendering",
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetinheritedConditionalRendering,
    &_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetinheritedConditionalRendering,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceConditionalRenderingFeaturesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->conditionalRendering));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->conditionalRendering);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->inheritedConditionalRendering));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConditionalRenderingFeaturesEXT *)0)->inheritedConditionalRendering);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceConditionalRenderingFeaturesEXT::flush() {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceConditionalRenderingFeaturesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.pNext", "[object Object]");
  
    return;
  }
}// conditionalRendering
Napi::Value _VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetconditionalRendering(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.conditionalRendering);
}void _VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetconditionalRendering(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.conditionalRendering = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.conditionalRendering = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.conditionalRendering", "Number");
  
    return;
  }
}// inheritedConditionalRendering
Napi::Value _VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetinheritedConditionalRendering(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inheritedConditionalRendering);
}void _VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetinheritedConditionalRendering(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.inheritedConditionalRendering = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.inheritedConditionalRendering = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.inheritedConditionalRendering", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceConditionalRenderingFeaturesEXT ## **/

/** ## BEGIN VkPhysicalDevice8BitStorageFeaturesKHR ## **/

Napi::FunctionReference _VkPhysicalDevice8BitStorageFeaturesKHR::constructor;

_VkPhysicalDevice8BitStorageFeaturesKHR::_VkPhysicalDevice8BitStorageFeaturesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "storageBuffer8BitAccess");
      Napi::String sAccess3 = Napi::String::New(env, "uniformAndStorageBuffer8BitAccess");
      Napi::String sAccess4 = Napi::String::New(env, "storagePushConstant8");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetstorageBuffer8BitAccess(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetuniformAndStorageBuffer8BitAccess(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetstoragePushConstant8(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDevice8BitStorageFeaturesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDevice8BitStorageFeaturesKHR::~_VkPhysicalDevice8BitStorageFeaturesKHR() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPhysicalDevice8BitStorageFeaturesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevice8BitStorageFeaturesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDevice8BitStorageFeaturesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDevice8BitStorageFeaturesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDevice8BitStorageFeaturesKHR::GetsType,
    &_VkPhysicalDevice8BitStorageFeaturesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDevice8BitStorageFeaturesKHR::GetpNext,
    &_VkPhysicalDevice8BitStorageFeaturesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "storageBuffer8BitAccess",
    &_VkPhysicalDevice8BitStorageFeaturesKHR::GetstorageBuffer8BitAccess,
    &_VkPhysicalDevice8BitStorageFeaturesKHR::SetstorageBuffer8BitAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "uniformAndStorageBuffer8BitAccess",
    &_VkPhysicalDevice8BitStorageFeaturesKHR::GetuniformAndStorageBuffer8BitAccess,
    &_VkPhysicalDevice8BitStorageFeaturesKHR::SetuniformAndStorageBuffer8BitAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "storagePushConstant8",
    &_VkPhysicalDevice8BitStorageFeaturesKHR::GetstoragePushConstant8,
    &_VkPhysicalDevice8BitStorageFeaturesKHR::SetstoragePushConstant8,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevice8BitStorageFeaturesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->storageBuffer8BitAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->storageBuffer8BitAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->uniformAndStorageBuffer8BitAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->uniformAndStorageBuffer8BitAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->storagePushConstant8));
    uint32_t byteLength = sizeof(((VkPhysicalDevice8BitStorageFeaturesKHR *)0)->storagePushConstant8);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDevice8BitStorageFeaturesKHR::flush() {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDevice8BitStorageFeaturesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDevice8BitStorageFeaturesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDevice8BitStorageFeaturesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.pNext", "[object Object]");
  
    return;
  }
}// storageBuffer8BitAccess
Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetstorageBuffer8BitAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storageBuffer8BitAccess);
}void _VkPhysicalDevice8BitStorageFeaturesKHR::SetstorageBuffer8BitAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storageBuffer8BitAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storageBuffer8BitAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.storageBuffer8BitAccess", "Number");
  
    return;
  }
}// uniformAndStorageBuffer8BitAccess
Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetuniformAndStorageBuffer8BitAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.uniformAndStorageBuffer8BitAccess);
}void _VkPhysicalDevice8BitStorageFeaturesKHR::SetuniformAndStorageBuffer8BitAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.uniformAndStorageBuffer8BitAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.uniformAndStorageBuffer8BitAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.uniformAndStorageBuffer8BitAccess", "Number");
  
    return;
  }
}// storagePushConstant8
Napi::Value _VkPhysicalDevice8BitStorageFeaturesKHR::GetstoragePushConstant8(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storagePushConstant8);
}void _VkPhysicalDevice8BitStorageFeaturesKHR::SetstoragePushConstant8(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storagePushConstant8 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storagePushConstant8 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.storagePushConstant8", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDevice8BitStorageFeaturesKHR ## **/

/** ## BEGIN VkCommandBufferInheritanceConditionalRenderingInfoEXT ## **/

Napi::FunctionReference _VkCommandBufferInheritanceConditionalRenderingInfoEXT::constructor;

_VkCommandBufferInheritanceConditionalRenderingInfoEXT::_VkCommandBufferInheritanceConditionalRenderingInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "conditionalRenderingEnable");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetconditionalRenderingEnable(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkCommandBufferInheritanceConditionalRenderingInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkCommandBufferInheritanceConditionalRenderingInfoEXT::~_VkCommandBufferInheritanceConditionalRenderingInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkCommandBufferInheritanceConditionalRenderingInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandBufferInheritanceConditionalRenderingInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetsType,
    &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetpNext,
    &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "conditionalRenderingEnable",
    &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetconditionalRenderingEnable,
    &_VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetconditionalRenderingEnable,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandBufferInheritanceConditionalRenderingInfoEXT", func);
  return exports;
}

Napi::Value _VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceConditionalRenderingInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceConditionalRenderingInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceConditionalRenderingInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceConditionalRenderingInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceConditionalRenderingInfoEXT *)0)->conditionalRenderingEnable));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceConditionalRenderingInfoEXT *)0)->conditionalRenderingEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCommandBufferInheritanceConditionalRenderingInfoEXT::flush() {
  _VkCommandBufferInheritanceConditionalRenderingInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCommandBufferInheritanceConditionalRenderingInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// conditionalRenderingEnable
Napi::Value _VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetconditionalRenderingEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.conditionalRenderingEnable);
}void _VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetconditionalRenderingEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.conditionalRenderingEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.conditionalRenderingEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.conditionalRenderingEnable", "Number");
  
    return;
  }
}
/** ## END VkCommandBufferInheritanceConditionalRenderingInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::constructor;

_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "maxVertexAttribDivisor");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetmaxVertexAttribDivisor(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::~_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetsType,
    &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVertexAttribDivisor",
    &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmaxVertexAttribDivisor,
    &_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::SetmaxVertexAttribDivisor,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)0)->maxVertexAttribDivisor));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)0)->maxVertexAttribDivisor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::flush() {
  _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// maxVertexAttribDivisor
Napi::Value _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmaxVertexAttribDivisor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVertexAttribDivisor);
}void _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::SetmaxVertexAttribDivisor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxVertexAttribDivisor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.maxVertexAttribDivisor", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ## **/

/** ## BEGIN VkPipelineVertexInputDivisorStateCreateInfoEXT ## **/

Napi::FunctionReference _VkPipelineVertexInputDivisorStateCreateInfoEXT::constructor;

_VkPipelineVertexInputDivisorStateCreateInfoEXT::_VkPipelineVertexInputDivisorStateCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
    vpVertexBindingDivisors = new std::vector<VkVertexInputBindingDivisorDescriptionEXT>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "vertexBindingDivisorCount");
      Napi::String sAccess3 = Napi::String::New(env, "pVertexBindingDivisors");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetvertexBindingDivisorCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpVertexBindingDivisors(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPipelineVertexInputDivisorStateCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineVertexInputDivisorStateCreateInfoEXT::~_VkPipelineVertexInputDivisorStateCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  vpVertexBindingDivisors->clear();
  delete vpVertexBindingDivisors;
  
  pVertexBindingDivisors.Reset();
  
}

Napi::Object _VkPipelineVertexInputDivisorStateCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineVertexInputDivisorStateCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetsType,
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetpNext,
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "vertexBindingDivisorCount",
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetvertexBindingDivisorCount,
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetvertexBindingDivisorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pVertexBindingDivisors",
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetpVertexBindingDivisors,
    &_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetpVertexBindingDivisors,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineVertexInputDivisorStateCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkPipelineVertexInputDivisorStateCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineVertexInputDivisorStateCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->vertexBindingDivisorCount));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->vertexBindingDivisorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->pVertexBindingDivisors));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputDivisorStateCreateInfoEXT *)0)->pVertexBindingDivisors);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineVertexInputDivisorStateCreateInfoEXT::flush() {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pVertexBindingDivisors.IsEmpty())) {
    Napi::Value value = self->pVertexBindingDivisors.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.vertexBindingDivisorCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'vertexBindingDivisorCount' for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkVertexInputBindingDivisorDescriptionEXT>* data = this->vpVertexBindingDivisors;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkVertexInputBindingDivisorDescriptionEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors", "[object VkVertexInputBindingDivisorDescriptionEXT]");
  
        return false;
      }
      _VkVertexInputBindingDivisorDescriptionEXT* result = Napi::ObjectWrap<_VkVertexInputBindingDivisorDescriptionEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pVertexBindingDivisors = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineVertexInputDivisorStateCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineVertexInputDivisorStateCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineVertexInputDivisorStateCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineVertexInputDivisorStateCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineVertexInputDivisorStateCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// vertexBindingDivisorCount
Napi::Value _VkPipelineVertexInputDivisorStateCreateInfoEXT::GetvertexBindingDivisorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vertexBindingDivisorCount);
}void _VkPipelineVertexInputDivisorStateCreateInfoEXT::SetvertexBindingDivisorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.vertexBindingDivisorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.vertexBindingDivisorCount", "Number");
  
    return;
  }
}// pVertexBindingDivisors
Napi::Value _VkPipelineVertexInputDivisorStateCreateInfoEXT::GetpVertexBindingDivisors(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pVertexBindingDivisors.IsEmpty()) return env.Null();
  return this->pVertexBindingDivisors.Value().As<Napi::Array>();
}void _VkPipelineVertexInputDivisorStateCreateInfoEXT::SetpVertexBindingDivisors(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pVertexBindingDivisors.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pVertexBindingDivisors.Reset();
      this->instance.pVertexBindingDivisors = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors", "[object VkVertexInputBindingDivisorDescriptionEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pVertexBindingDivisors = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors", "[object VkVertexInputBindingDivisorDescriptionEXT]");
  
    return;
  }
}
/** ## END VkPipelineVertexInputDivisorStateCreateInfoEXT ## **/

/** ## BEGIN VkVertexInputBindingDivisorDescriptionEXT ## **/

Napi::FunctionReference _VkVertexInputBindingDivisorDescriptionEXT::constructor;

_VkVertexInputBindingDivisorDescriptionEXT::_VkVertexInputBindingDivisorDescriptionEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkVertexInputBindingDivisorDescriptionEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "binding");
      Napi::String sAccess1 = Napi::String::New(env, "divisor");
      if (obj.Has(sAccess0)) this->Setbinding(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setdivisor(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkVertexInputBindingDivisorDescriptionEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkVertexInputBindingDivisorDescriptionEXT::~_VkVertexInputBindingDivisorDescriptionEXT() {
  
  
  
}

Napi::Object _VkVertexInputBindingDivisorDescriptionEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkVertexInputBindingDivisorDescriptionEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkVertexInputBindingDivisorDescriptionEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkVertexInputBindingDivisorDescriptionEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "binding",
    &_VkVertexInputBindingDivisorDescriptionEXT::Getbinding,
    &_VkVertexInputBindingDivisorDescriptionEXT::Setbinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "divisor",
    &_VkVertexInputBindingDivisorDescriptionEXT::Getdivisor,
    &_VkVertexInputBindingDivisorDescriptionEXT::Setdivisor,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkVertexInputBindingDivisorDescriptionEXT", func);
  return exports;
}

Napi::Value _VkVertexInputBindingDivisorDescriptionEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkVertexInputBindingDivisorDescriptionEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputBindingDivisorDescriptionEXT *)0)->binding));
    uint32_t byteLength = sizeof(((VkVertexInputBindingDivisorDescriptionEXT *)0)->binding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputBindingDivisorDescriptionEXT *)0)->divisor));
    uint32_t byteLength = sizeof(((VkVertexInputBindingDivisorDescriptionEXT *)0)->divisor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkVertexInputBindingDivisorDescriptionEXT::flush() {
  _VkVertexInputBindingDivisorDescriptionEXT *self = this;
  
  return true;
}

// binding
Napi::Value _VkVertexInputBindingDivisorDescriptionEXT::Getbinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.binding);
}void _VkVertexInputBindingDivisorDescriptionEXT::Setbinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.binding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputBindingDivisorDescriptionEXT.binding", "Number");
  
    return;
  }
}// divisor
Napi::Value _VkVertexInputBindingDivisorDescriptionEXT::Getdivisor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.divisor);
}void _VkVertexInputBindingDivisorDescriptionEXT::Setdivisor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.divisor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputBindingDivisorDescriptionEXT.divisor", "Number");
  
    return;
  }
}
/** ## END VkVertexInputBindingDivisorDescriptionEXT ## **/

/** ## BEGIN VkSubpassEndInfoKHR ## **/

Napi::FunctionReference _VkSubpassEndInfoKHR::constructor;

_VkSubpassEndInfoKHR::_VkSubpassEndInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassEndInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSubpassEndInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassEndInfoKHR::~_VkSubpassEndInfoKHR() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkSubpassEndInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassEndInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassEndInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassEndInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSubpassEndInfoKHR::GetsType,
    &_VkSubpassEndInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSubpassEndInfoKHR::GetpNext,
    &_VkSubpassEndInfoKHR::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassEndInfoKHR", func);
  return exports;
}

Napi::Value _VkSubpassEndInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassEndInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassEndInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSubpassEndInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassEndInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSubpassEndInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassEndInfoKHR::flush() {
  _VkSubpassEndInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSubpassEndInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSubpassEndInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassEndInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSubpassEndInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSubpassEndInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSubpassEndInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSubpassEndInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassEndInfoKHR.pNext", "[object Object]");
  
    return;
  }
}
/** ## END VkSubpassEndInfoKHR ## **/

/** ## BEGIN VkSubpassBeginInfoKHR ## **/

Napi::FunctionReference _VkSubpassBeginInfoKHR::constructor;

_VkSubpassBeginInfoKHR::_VkSubpassBeginInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassBeginInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "contents");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setcontents(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSubpassBeginInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassBeginInfoKHR::~_VkSubpassBeginInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSubpassBeginInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassBeginInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassBeginInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassBeginInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSubpassBeginInfoKHR::GetsType,
    &_VkSubpassBeginInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSubpassBeginInfoKHR::GetpNext,
    &_VkSubpassBeginInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "contents",
    &_VkSubpassBeginInfoKHR::Getcontents,
    &_VkSubpassBeginInfoKHR::Setcontents,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassBeginInfoKHR", func);
  return exports;
}

Napi::Value _VkSubpassBeginInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassBeginInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassBeginInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSubpassBeginInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassBeginInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSubpassBeginInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassBeginInfoKHR *)0)->contents));
    uint32_t byteLength = sizeof(((VkSubpassBeginInfoKHR *)0)->contents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassBeginInfoKHR::flush() {
  _VkSubpassBeginInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSubpassBeginInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSubpassBeginInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassBeginInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSubpassBeginInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSubpassBeginInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSubpassBeginInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSubpassBeginInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassBeginInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// contents
Napi::Value _VkSubpassBeginInfoKHR::Getcontents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.contents);
}void _VkSubpassBeginInfoKHR::Setcontents(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.contents = static_cast<VkSubpassContents>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassBeginInfoKHR.contents", "Number");
  
    return;
  }
}
/** ## END VkSubpassBeginInfoKHR ## **/

/** ## BEGIN VkRenderPassCreateInfo2KHR ## **/

Napi::FunctionReference _VkRenderPassCreateInfo2KHR::constructor;

_VkRenderPassCreateInfo2KHR::_VkRenderPassCreateInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassCreateInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR;
    vpAttachments = new std::vector<VkAttachmentDescription2KHR>;
    vpSubpasses = new std::vector<VkSubpassDescription2KHR>;
    vpDependencies = new std::vector<VkSubpassDependency2KHR>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "attachmentCount");
      Napi::String sAccess4 = Napi::String::New(env, "pAttachments");
      Napi::String sAccess5 = Napi::String::New(env, "subpassCount");
      Napi::String sAccess6 = Napi::String::New(env, "pSubpasses");
      Napi::String sAccess7 = Napi::String::New(env, "dependencyCount");
      Napi::String sAccess8 = Napi::String::New(env, "pDependencies");
      Napi::String sAccess9 = Napi::String::New(env, "correlatedViewMaskCount");
      Napi::String sAccess10 = Napi::String::New(env, "pCorrelatedViewMasks");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetattachmentCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpAttachments(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetsubpassCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpSubpasses(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdependencyCount(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpDependencies(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetcorrelatedViewMaskCount(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetpCorrelatedViewMasks(info, obj.Get(sAccess10));
      
    } else {
      Napi::Error::New(env, "VkRenderPassCreateInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassCreateInfo2KHR::~_VkRenderPassCreateInfo2KHR() {
  
  
  pNext.Reset();
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  
  vpSubpasses->clear();
  delete vpSubpasses;
  
  pSubpasses.Reset();
  
  
  vpDependencies->clear();
  delete vpDependencies;
  
  pDependencies.Reset();
  
  
  pCorrelatedViewMasks.Reset();
  
}

Napi::Object _VkRenderPassCreateInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassCreateInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassCreateInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassCreateInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassCreateInfo2KHR::GetsType,
    &_VkRenderPassCreateInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassCreateInfo2KHR::GetpNext,
    &_VkRenderPassCreateInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkRenderPassCreateInfo2KHR::Getflags,
    &_VkRenderPassCreateInfo2KHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "attachmentCount",
    &_VkRenderPassCreateInfo2KHR::GetattachmentCount,
    &_VkRenderPassCreateInfo2KHR::SetattachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAttachments",
    &_VkRenderPassCreateInfo2KHR::GetpAttachments,
    &_VkRenderPassCreateInfo2KHR::SetpAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "subpassCount",
    &_VkRenderPassCreateInfo2KHR::GetsubpassCount,
    &_VkRenderPassCreateInfo2KHR::SetsubpassCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSubpasses",
    &_VkRenderPassCreateInfo2KHR::GetpSubpasses,
    &_VkRenderPassCreateInfo2KHR::SetpSubpasses,
    napi_enumerable
  ),
  InstanceAccessor(
    "dependencyCount",
    &_VkRenderPassCreateInfo2KHR::GetdependencyCount,
    &_VkRenderPassCreateInfo2KHR::SetdependencyCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDependencies",
    &_VkRenderPassCreateInfo2KHR::GetpDependencies,
    &_VkRenderPassCreateInfo2KHR::SetpDependencies,
    napi_enumerable
  ),
  InstanceAccessor(
    "correlatedViewMaskCount",
    &_VkRenderPassCreateInfo2KHR::GetcorrelatedViewMaskCount,
    &_VkRenderPassCreateInfo2KHR::SetcorrelatedViewMaskCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCorrelatedViewMasks",
    &_VkRenderPassCreateInfo2KHR::GetpCorrelatedViewMasks,
    &_VkRenderPassCreateInfo2KHR::SetpCorrelatedViewMasks,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassCreateInfo2KHR", func);
  return exports;
}

Napi::Value _VkRenderPassCreateInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassCreateInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->attachmentCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->attachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->pAttachments));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->pAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->subpassCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->subpassCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->pSubpasses));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->pSubpasses);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->dependencyCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->dependencyCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->pDependencies));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->pDependencies);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->correlatedViewMaskCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->correlatedViewMaskCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo2KHR *)0)->pCorrelatedViewMasks));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo2KHR *)0)->pCorrelatedViewMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassCreateInfo2KHR::flush() {
  _VkRenderPassCreateInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAttachments.IsEmpty())) {
    Napi::Value value = self->pAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.attachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'attachmentCount' for 'VkRenderPassCreateInfo2KHR.pAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentDescription2KHR>* data = this->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentDescription2KHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pAttachments", "[object VkAttachmentDescription2KHR]");
  
        return false;
      }
      _VkAttachmentDescription2KHR* result = Napi::ObjectWrap<_VkAttachmentDescription2KHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }if (!(self->pSubpasses.IsEmpty())) {
    Napi::Value value = self->pSubpasses.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.subpassCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'subpassCount' for 'VkRenderPassCreateInfo2KHR.pSubpasses'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSubpassDescription2KHR>* data = this->vpSubpasses;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSubpassDescription2KHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pSubpasses", "[object VkSubpassDescription2KHR]");
  
        return false;
      }
      _VkSubpassDescription2KHR* result = Napi::ObjectWrap<_VkSubpassDescription2KHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSubpasses = data->data();
  }if (!(self->pDependencies.IsEmpty())) {
    Napi::Value value = self->pDependencies.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.dependencyCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'dependencyCount' for 'VkRenderPassCreateInfo2KHR.pDependencies'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSubpassDependency2KHR>* data = this->vpDependencies;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSubpassDependency2KHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pDependencies", "[object VkSubpassDependency2KHR]");
  
        return false;
      }
      _VkSubpassDependency2KHR* result = Napi::ObjectWrap<_VkSubpassDependency2KHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDependencies = data->data();
  }
  return true;
}

// sType
Napi::Value _VkRenderPassCreateInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassCreateInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassCreateInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassCreateInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkRenderPassCreateInfo2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkRenderPassCreateInfo2KHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkRenderPassCreateInfo2KHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkRenderPassCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.flags", "Number");
  
    return;
  }
}// attachmentCount
Napi::Value _VkRenderPassCreateInfo2KHR::GetattachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachmentCount);
}void _VkRenderPassCreateInfo2KHR::SetattachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
Napi::Value _VkRenderPassCreateInfo2KHR::GetpAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAttachments.IsEmpty()) return env.Null();
  return this->pAttachments.Value().As<Napi::Array>();
}void _VkRenderPassCreateInfo2KHR::SetpAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAttachments.Reset();
      this->instance.pAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pAttachments", "[object VkAttachmentDescription2KHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pAttachments", "[object VkAttachmentDescription2KHR]");
  
    return;
  }
}// subpassCount
Napi::Value _VkRenderPassCreateInfo2KHR::GetsubpassCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpassCount);
}void _VkRenderPassCreateInfo2KHR::SetsubpassCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpassCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.subpassCount", "Number");
  
    return;
  }
}// pSubpasses
Napi::Value _VkRenderPassCreateInfo2KHR::GetpSubpasses(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSubpasses.IsEmpty()) return env.Null();
  return this->pSubpasses.Value().As<Napi::Array>();
}void _VkRenderPassCreateInfo2KHR::SetpSubpasses(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSubpasses.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSubpasses.Reset();
      this->instance.pSubpasses = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pSubpasses", "[object VkSubpassDescription2KHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSubpasses = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pSubpasses", "[object VkSubpassDescription2KHR]");
  
    return;
  }
}// dependencyCount
Napi::Value _VkRenderPassCreateInfo2KHR::GetdependencyCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dependencyCount);
}void _VkRenderPassCreateInfo2KHR::SetdependencyCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dependencyCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.dependencyCount", "Number");
  
    return;
  }
}// pDependencies
Napi::Value _VkRenderPassCreateInfo2KHR::GetpDependencies(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDependencies.IsEmpty()) return env.Null();
  return this->pDependencies.Value().As<Napi::Array>();
}void _VkRenderPassCreateInfo2KHR::SetpDependencies(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDependencies.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDependencies.Reset();
      this->instance.pDependencies = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pDependencies", "[object VkSubpassDependency2KHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDependencies = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pDependencies", "[object VkSubpassDependency2KHR]");
  
    return;
  }
}// correlatedViewMaskCount
Napi::Value _VkRenderPassCreateInfo2KHR::GetcorrelatedViewMaskCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.correlatedViewMaskCount);
}void _VkRenderPassCreateInfo2KHR::SetcorrelatedViewMaskCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.correlatedViewMaskCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.correlatedViewMaskCount", "Number");
  
    return;
  }
}// pCorrelatedViewMasks
Napi::Value _VkRenderPassCreateInfo2KHR::GetpCorrelatedViewMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCorrelatedViewMasks.IsEmpty()) return env.Null();
  return this->pCorrelatedViewMasks.Value().As<Napi::TypedArray>();
}void _VkRenderPassCreateInfo2KHR::SetpCorrelatedViewMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pCorrelatedViewMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCorrelatedViewMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCorrelatedViewMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pCorrelatedViewMasks = nullptr;
  }
}
/** ## END VkRenderPassCreateInfo2KHR ## **/

/** ## BEGIN VkSubpassDependency2KHR ## **/

Napi::FunctionReference _VkSubpassDependency2KHR::constructor;

_VkSubpassDependency2KHR::_VkSubpassDependency2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassDependency2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcSubpass");
      Napi::String sAccess3 = Napi::String::New(env, "dstSubpass");
      Napi::String sAccess4 = Napi::String::New(env, "srcStageMask");
      Napi::String sAccess5 = Napi::String::New(env, "dstStageMask");
      Napi::String sAccess6 = Napi::String::New(env, "srcAccessMask");
      Napi::String sAccess7 = Napi::String::New(env, "dstAccessMask");
      Napi::String sAccess8 = Napi::String::New(env, "dependencyFlags");
      Napi::String sAccess9 = Napi::String::New(env, "viewOffset");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcSubpass(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstSubpass(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsrcStageMask(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdstStageMask(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetsrcAccessMask(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdstAccessMask(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetdependencyFlags(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetviewOffset(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkSubpassDependency2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassDependency2KHR::~_VkSubpassDependency2KHR() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkSubpassDependency2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassDependency2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassDependency2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassDependency2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSubpassDependency2KHR::GetsType,
    &_VkSubpassDependency2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSubpassDependency2KHR::GetpNext,
    &_VkSubpassDependency2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcSubpass",
    &_VkSubpassDependency2KHR::GetsrcSubpass,
    &_VkSubpassDependency2KHR::SetsrcSubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSubpass",
    &_VkSubpassDependency2KHR::GetdstSubpass,
    &_VkSubpassDependency2KHR::SetdstSubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcStageMask",
    &_VkSubpassDependency2KHR::GetsrcStageMask,
    &_VkSubpassDependency2KHR::SetsrcStageMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstStageMask",
    &_VkSubpassDependency2KHR::GetdstStageMask,
    &_VkSubpassDependency2KHR::SetdstStageMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcAccessMask",
    &_VkSubpassDependency2KHR::GetsrcAccessMask,
    &_VkSubpassDependency2KHR::SetsrcAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstAccessMask",
    &_VkSubpassDependency2KHR::GetdstAccessMask,
    &_VkSubpassDependency2KHR::SetdstAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dependencyFlags",
    &_VkSubpassDependency2KHR::GetdependencyFlags,
    &_VkSubpassDependency2KHR::SetdependencyFlags,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewOffset",
    &_VkSubpassDependency2KHR::GetviewOffset,
    &_VkSubpassDependency2KHR::SetviewOffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassDependency2KHR", func);
  return exports;
}

Napi::Value _VkSubpassDependency2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassDependency2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->srcSubpass));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->srcSubpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->dstSubpass));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->dstSubpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->srcStageMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->srcStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->dstStageMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->dstStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->srcAccessMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->srcAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->dstAccessMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->dstAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->dependencyFlags));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->dependencyFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency2KHR *)0)->viewOffset));
    uint32_t byteLength = sizeof(((VkSubpassDependency2KHR *)0)->viewOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassDependency2KHR::flush() {
  _VkSubpassDependency2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSubpassDependency2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSubpassDependency2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSubpassDependency2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSubpassDependency2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSubpassDependency2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.pNext", "[object Object]");
  
    return;
  }
}// srcSubpass
Napi::Value _VkSubpassDependency2KHR::GetsrcSubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcSubpass);
}void _VkSubpassDependency2KHR::SetsrcSubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcSubpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.srcSubpass", "Number");
  
    return;
  }
}// dstSubpass
Napi::Value _VkSubpassDependency2KHR::GetdstSubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstSubpass);
}void _VkSubpassDependency2KHR::SetdstSubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstSubpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.dstSubpass", "Number");
  
    return;
  }
}// srcStageMask
Napi::Value _VkSubpassDependency2KHR::GetsrcStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcStageMask);
}void _VkSubpassDependency2KHR::SetsrcStageMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcStageMask = static_cast<VkPipelineStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.srcStageMask", "Number");
  
    return;
  }
}// dstStageMask
Napi::Value _VkSubpassDependency2KHR::GetdstStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstStageMask);
}void _VkSubpassDependency2KHR::SetdstStageMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstStageMask = static_cast<VkPipelineStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.dstStageMask", "Number");
  
    return;
  }
}// srcAccessMask
Napi::Value _VkSubpassDependency2KHR::GetsrcAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcAccessMask);
}void _VkSubpassDependency2KHR::SetsrcAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
Napi::Value _VkSubpassDependency2KHR::GetdstAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstAccessMask);
}void _VkSubpassDependency2KHR::SetdstAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.dstAccessMask", "Number");
  
    return;
  }
}// dependencyFlags
Napi::Value _VkSubpassDependency2KHR::GetdependencyFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dependencyFlags);
}void _VkSubpassDependency2KHR::SetdependencyFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dependencyFlags = static_cast<VkDependencyFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.dependencyFlags", "Number");
  
    return;
  }
}// viewOffset
Napi::Value _VkSubpassDependency2KHR::GetviewOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewOffset);
}void _VkSubpassDependency2KHR::SetviewOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewOffset = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency2KHR.viewOffset", "Number");
  
    return;
  }
}
/** ## END VkSubpassDependency2KHR ## **/

/** ## BEGIN VkSubpassDescription2KHR ## **/

Napi::FunctionReference _VkSubpassDescription2KHR::constructor;

_VkSubpassDescription2KHR::_VkSubpassDescription2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassDescription2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR;
    vpInputAttachments = new std::vector<VkAttachmentReference2KHR>;
    vpColorAttachments = new std::vector<VkAttachmentReference2KHR>;
    vpResolveAttachments = new std::vector<VkAttachmentReference2KHR>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "pipelineBindPoint");
      Napi::String sAccess4 = Napi::String::New(env, "viewMask");
      Napi::String sAccess5 = Napi::String::New(env, "inputAttachmentCount");
      Napi::String sAccess6 = Napi::String::New(env, "pInputAttachments");
      Napi::String sAccess7 = Napi::String::New(env, "colorAttachmentCount");
      Napi::String sAccess8 = Napi::String::New(env, "pColorAttachments");
      Napi::String sAccess9 = Napi::String::New(env, "pResolveAttachments");
      Napi::String sAccess10 = Napi::String::New(env, "pDepthStencilAttachment");
      Napi::String sAccess11 = Napi::String::New(env, "preserveAttachmentCount");
      Napi::String sAccess12 = Napi::String::New(env, "pPreserveAttachments");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpipelineBindPoint(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetviewMask(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetinputAttachmentCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpInputAttachments(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetcolorAttachmentCount(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpColorAttachments(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpResolveAttachments(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetpDepthStencilAttachment(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetpreserveAttachmentCount(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetpPreserveAttachments(info, obj.Get(sAccess12));
      
    } else {
      Napi::Error::New(env, "VkSubpassDescription2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassDescription2KHR::~_VkSubpassDescription2KHR() {
  
  
  pNext.Reset();
  
  
  
  
  
  vpInputAttachments->clear();
  delete vpInputAttachments;
  
  pInputAttachments.Reset();
  
  
  vpColorAttachments->clear();
  delete vpColorAttachments;
  
  pColorAttachments.Reset();
  
  vpResolveAttachments->clear();
  delete vpResolveAttachments;
  
  pResolveAttachments.Reset();
  
  pDepthStencilAttachment.Reset();
  
  
  pPreserveAttachments.Reset();
  
}

Napi::Object _VkSubpassDescription2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassDescription2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassDescription2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassDescription2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSubpassDescription2KHR::GetsType,
    &_VkSubpassDescription2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSubpassDescription2KHR::GetpNext,
    &_VkSubpassDescription2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSubpassDescription2KHR::Getflags,
    &_VkSubpassDescription2KHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineBindPoint",
    &_VkSubpassDescription2KHR::GetpipelineBindPoint,
    &_VkSubpassDescription2KHR::SetpipelineBindPoint,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewMask",
    &_VkSubpassDescription2KHR::GetviewMask,
    &_VkSubpassDescription2KHR::SetviewMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "inputAttachmentCount",
    &_VkSubpassDescription2KHR::GetinputAttachmentCount,
    &_VkSubpassDescription2KHR::SetinputAttachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pInputAttachments",
    &_VkSubpassDescription2KHR::GetpInputAttachments,
    &_VkSubpassDescription2KHR::SetpInputAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "colorAttachmentCount",
    &_VkSubpassDescription2KHR::GetcolorAttachmentCount,
    &_VkSubpassDescription2KHR::SetcolorAttachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pColorAttachments",
    &_VkSubpassDescription2KHR::GetpColorAttachments,
    &_VkSubpassDescription2KHR::SetpColorAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "pResolveAttachments",
    &_VkSubpassDescription2KHR::GetpResolveAttachments,
    &_VkSubpassDescription2KHR::SetpResolveAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDepthStencilAttachment",
    &_VkSubpassDescription2KHR::GetpDepthStencilAttachment,
    &_VkSubpassDescription2KHR::SetpDepthStencilAttachment,
    napi_enumerable
  ),
  InstanceAccessor(
    "preserveAttachmentCount",
    &_VkSubpassDescription2KHR::GetpreserveAttachmentCount,
    &_VkSubpassDescription2KHR::SetpreserveAttachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPreserveAttachments",
    &_VkSubpassDescription2KHR::GetpPreserveAttachments,
    &_VkSubpassDescription2KHR::SetpPreserveAttachments,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassDescription2KHR", func);
  return exports;
}

Napi::Value _VkSubpassDescription2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassDescription2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pipelineBindPoint));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pipelineBindPoint);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->viewMask));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->viewMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->inputAttachmentCount));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->inputAttachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pInputAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pInputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->colorAttachmentCount));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->colorAttachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pColorAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pColorAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pResolveAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pResolveAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pDepthStencilAttachment));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pDepthStencilAttachment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->preserveAttachmentCount));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->preserveAttachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription2KHR *)0)->pPreserveAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription2KHR *)0)->pPreserveAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassDescription2KHR::flush() {
  _VkSubpassDescription2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pInputAttachments.IsEmpty())) {
    Napi::Value value = self->pInputAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.inputAttachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'inputAttachmentCount' for 'VkSubpassDescription2KHR.pInputAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentReference2KHR>* data = this->vpInputAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentReference2KHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pInputAttachments", "[object VkAttachmentReference2KHR]");
  
        return false;
      }
      _VkAttachmentReference2KHR* result = Napi::ObjectWrap<_VkAttachmentReference2KHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pInputAttachments = data->data();
  }if (!(self->pColorAttachments.IsEmpty())) {
    Napi::Value value = self->pColorAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.colorAttachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pColorAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentReference2KHR>* data = this->vpColorAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentReference2KHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pColorAttachments", "[object VkAttachmentReference2KHR]");
  
        return false;
      }
      _VkAttachmentReference2KHR* result = Napi::ObjectWrap<_VkAttachmentReference2KHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pColorAttachments = data->data();
  }if (!(self->pResolveAttachments.IsEmpty())) {
    Napi::Value value = self->pResolveAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.colorAttachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pResolveAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentReference2KHR>* data = this->vpResolveAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentReference2KHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pResolveAttachments", "[object VkAttachmentReference2KHR]");
  
        return false;
      }
      _VkAttachmentReference2KHR* result = Napi::ObjectWrap<_VkAttachmentReference2KHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pResolveAttachments = data->data();
  }
  return true;
}

// sType
Napi::Value _VkSubpassDescription2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSubpassDescription2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSubpassDescription2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSubpassDescription2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSubpassDescription2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkSubpassDescription2KHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSubpassDescription2KHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSubpassDescriptionFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.flags", "Number");
  
    return;
  }
}// pipelineBindPoint
Napi::Value _VkSubpassDescription2KHR::GetpipelineBindPoint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineBindPoint);
}void _VkSubpassDescription2KHR::SetpipelineBindPoint(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pipelineBindPoint", "Number");
  
    return;
  }
}// viewMask
Napi::Value _VkSubpassDescription2KHR::GetviewMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewMask);
}void _VkSubpassDescription2KHR::SetviewMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.viewMask", "Number");
  
    return;
  }
}// inputAttachmentCount
Napi::Value _VkSubpassDescription2KHR::GetinputAttachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inputAttachmentCount);
}void _VkSubpassDescription2KHR::SetinputAttachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.inputAttachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.inputAttachmentCount", "Number");
  
    return;
  }
}// pInputAttachments
Napi::Value _VkSubpassDescription2KHR::GetpInputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pInputAttachments.IsEmpty()) return env.Null();
  return this->pInputAttachments.Value().As<Napi::Array>();
}void _VkSubpassDescription2KHR::SetpInputAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pInputAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pInputAttachments.Reset();
      this->instance.pInputAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pInputAttachments", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pInputAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pInputAttachments", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// colorAttachmentCount
Napi::Value _VkSubpassDescription2KHR::GetcolorAttachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.colorAttachmentCount);
}void _VkSubpassDescription2KHR::SetcolorAttachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.colorAttachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.colorAttachmentCount", "Number");
  
    return;
  }
}// pColorAttachments
Napi::Value _VkSubpassDescription2KHR::GetpColorAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pColorAttachments.IsEmpty()) return env.Null();
  return this->pColorAttachments.Value().As<Napi::Array>();
}void _VkSubpassDescription2KHR::SetpColorAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pColorAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pColorAttachments.Reset();
      this->instance.pColorAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pColorAttachments", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pColorAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pColorAttachments", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// pResolveAttachments
Napi::Value _VkSubpassDescription2KHR::GetpResolveAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pResolveAttachments.IsEmpty()) return env.Null();
  return this->pResolveAttachments.Value().As<Napi::Array>();
}void _VkSubpassDescription2KHR::SetpResolveAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pResolveAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pResolveAttachments.Reset();
      this->instance.pResolveAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pResolveAttachments", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pResolveAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pResolveAttachments", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// pDepthStencilAttachment
Napi::Value _VkSubpassDescription2KHR::GetpDepthStencilAttachment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDepthStencilAttachment.IsEmpty()) return env.Null();
  return this->pDepthStencilAttachment.Value().As<Napi::Object>();
}void _VkSubpassDescription2KHR::SetpDepthStencilAttachment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkAttachmentReference2KHR::constructor.Value())) {
      
      this->pDepthStencilAttachment.Reset(value.ToObject(), 1);
      _VkAttachmentReference2KHR* inst = Napi::ObjectWrap<_VkAttachmentReference2KHR>::Unwrap(obj);
      inst->flush();
      this->instance.pDepthStencilAttachment = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pDepthStencilAttachment", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pDepthStencilAttachment.Reset();
    this->instance.pDepthStencilAttachment = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pDepthStencilAttachment", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// preserveAttachmentCount
Napi::Value _VkSubpassDescription2KHR::GetpreserveAttachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.preserveAttachmentCount);
}void _VkSubpassDescription2KHR::SetpreserveAttachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.preserveAttachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.preserveAttachmentCount", "Number");
  
    return;
  }
}// pPreserveAttachments
Napi::Value _VkSubpassDescription2KHR::GetpPreserveAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPreserveAttachments.IsEmpty()) return env.Null();
  return this->pPreserveAttachments.Value().As<Napi::TypedArray>();
}void _VkSubpassDescription2KHR::SetpPreserveAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pPreserveAttachments.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pPreserveAttachments", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pPreserveAttachments.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription2KHR.pPreserveAttachments", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pPreserveAttachments = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pPreserveAttachments = nullptr;
  }
}
/** ## END VkSubpassDescription2KHR ## **/

/** ## BEGIN VkAttachmentReference2KHR ## **/

Napi::FunctionReference _VkAttachmentReference2KHR::constructor;

_VkAttachmentReference2KHR::_VkAttachmentReference2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAttachmentReference2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "attachment");
      Napi::String sAccess3 = Napi::String::New(env, "layout");
      Napi::String sAccess4 = Napi::String::New(env, "aspectMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setattachment(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setlayout(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetaspectMask(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkAttachmentReference2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkAttachmentReference2KHR::~_VkAttachmentReference2KHR() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkAttachmentReference2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAttachmentReference2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAttachmentReference2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAttachmentReference2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkAttachmentReference2KHR::GetsType,
    &_VkAttachmentReference2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkAttachmentReference2KHR::GetpNext,
    &_VkAttachmentReference2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "attachment",
    &_VkAttachmentReference2KHR::Getattachment,
    &_VkAttachmentReference2KHR::Setattachment,
    napi_enumerable
  ),
  InstanceAccessor(
    "layout",
    &_VkAttachmentReference2KHR::Getlayout,
    &_VkAttachmentReference2KHR::Setlayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "aspectMask",
    &_VkAttachmentReference2KHR::GetaspectMask,
    &_VkAttachmentReference2KHR::SetaspectMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAttachmentReference2KHR", func);
  return exports;
}

Napi::Value _VkAttachmentReference2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAttachmentReference2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkAttachmentReference2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkAttachmentReference2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference2KHR *)0)->attachment));
    uint32_t byteLength = sizeof(((VkAttachmentReference2KHR *)0)->attachment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference2KHR *)0)->layout));
    uint32_t byteLength = sizeof(((VkAttachmentReference2KHR *)0)->layout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference2KHR *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkAttachmentReference2KHR *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAttachmentReference2KHR::flush() {
  _VkAttachmentReference2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkAttachmentReference2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkAttachmentReference2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkAttachmentReference2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkAttachmentReference2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkAttachmentReference2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkAttachmentReference2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference2KHR.pNext", "[object Object]");
  
    return;
  }
}// attachment
Napi::Value _VkAttachmentReference2KHR::Getattachment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachment);
}void _VkAttachmentReference2KHR::Setattachment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachment = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference2KHR.attachment", "Number");
  
    return;
  }
}// layout
Napi::Value _VkAttachmentReference2KHR::Getlayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layout);
}void _VkAttachmentReference2KHR::Setlayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference2KHR.layout", "Number");
  
    return;
  }
}// aspectMask
Napi::Value _VkAttachmentReference2KHR::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkAttachmentReference2KHR::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference2KHR.aspectMask", "Number");
  
    return;
  }
}
/** ## END VkAttachmentReference2KHR ## **/

/** ## BEGIN VkAttachmentDescription2KHR ## **/

Napi::FunctionReference _VkAttachmentDescription2KHR::constructor;

_VkAttachmentDescription2KHR::_VkAttachmentDescription2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAttachmentDescription2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "format");
      Napi::String sAccess4 = Napi::String::New(env, "samples");
      Napi::String sAccess5 = Napi::String::New(env, "loadOp");
      Napi::String sAccess6 = Napi::String::New(env, "storeOp");
      Napi::String sAccess7 = Napi::String::New(env, "stencilLoadOp");
      Napi::String sAccess8 = Napi::String::New(env, "stencilStoreOp");
      Napi::String sAccess9 = Napi::String::New(env, "initialLayout");
      Napi::String sAccess10 = Napi::String::New(env, "finalLayout");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setformat(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setsamples(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetloadOp(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetstoreOp(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetstencilLoadOp(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetstencilStoreOp(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetinitialLayout(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetfinalLayout(info, obj.Get(sAccess10));
      
    } else {
      Napi::Error::New(env, "VkAttachmentDescription2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkAttachmentDescription2KHR::~_VkAttachmentDescription2KHR() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkAttachmentDescription2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAttachmentDescription2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAttachmentDescription2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAttachmentDescription2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkAttachmentDescription2KHR::GetsType,
    &_VkAttachmentDescription2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkAttachmentDescription2KHR::GetpNext,
    &_VkAttachmentDescription2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkAttachmentDescription2KHR::Getflags,
    &_VkAttachmentDescription2KHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkAttachmentDescription2KHR::Getformat,
    &_VkAttachmentDescription2KHR::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "samples",
    &_VkAttachmentDescription2KHR::Getsamples,
    &_VkAttachmentDescription2KHR::Setsamples,
    napi_enumerable
  ),
  InstanceAccessor(
    "loadOp",
    &_VkAttachmentDescription2KHR::GetloadOp,
    &_VkAttachmentDescription2KHR::SetloadOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "storeOp",
    &_VkAttachmentDescription2KHR::GetstoreOp,
    &_VkAttachmentDescription2KHR::SetstoreOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "stencilLoadOp",
    &_VkAttachmentDescription2KHR::GetstencilLoadOp,
    &_VkAttachmentDescription2KHR::SetstencilLoadOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "stencilStoreOp",
    &_VkAttachmentDescription2KHR::GetstencilStoreOp,
    &_VkAttachmentDescription2KHR::SetstencilStoreOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "initialLayout",
    &_VkAttachmentDescription2KHR::GetinitialLayout,
    &_VkAttachmentDescription2KHR::SetinitialLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "finalLayout",
    &_VkAttachmentDescription2KHR::GetfinalLayout,
    &_VkAttachmentDescription2KHR::SetfinalLayout,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAttachmentDescription2KHR", func);
  return exports;
}

Napi::Value _VkAttachmentDescription2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAttachmentDescription2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->format));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->samples));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->loadOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->loadOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->storeOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->storeOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->stencilLoadOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->stencilLoadOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->stencilStoreOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->stencilStoreOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->initialLayout));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->initialLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription2KHR *)0)->finalLayout));
    uint32_t byteLength = sizeof(((VkAttachmentDescription2KHR *)0)->finalLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAttachmentDescription2KHR::flush() {
  _VkAttachmentDescription2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkAttachmentDescription2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkAttachmentDescription2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkAttachmentDescription2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkAttachmentDescription2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkAttachmentDescription2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkAttachmentDescription2KHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkAttachmentDescription2KHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkAttachmentDescriptionFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.flags", "Number");
  
    return;
  }
}// format
Napi::Value _VkAttachmentDescription2KHR::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkAttachmentDescription2KHR::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.format", "Number");
  
    return;
  }
}// samples
Napi::Value _VkAttachmentDescription2KHR::Getsamples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samples);
}void _VkAttachmentDescription2KHR::Setsamples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.samples = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.samples", "Number");
  
    return;
  }
}// loadOp
Napi::Value _VkAttachmentDescription2KHR::GetloadOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.loadOp);
}void _VkAttachmentDescription2KHR::SetloadOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.loadOp = static_cast<VkAttachmentLoadOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.loadOp", "Number");
  
    return;
  }
}// storeOp
Napi::Value _VkAttachmentDescription2KHR::GetstoreOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storeOp);
}void _VkAttachmentDescription2KHR::SetstoreOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.storeOp = static_cast<VkAttachmentStoreOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.storeOp", "Number");
  
    return;
  }
}// stencilLoadOp
Napi::Value _VkAttachmentDescription2KHR::GetstencilLoadOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stencilLoadOp);
}void _VkAttachmentDescription2KHR::SetstencilLoadOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stencilLoadOp = static_cast<VkAttachmentLoadOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.stencilLoadOp", "Number");
  
    return;
  }
}// stencilStoreOp
Napi::Value _VkAttachmentDescription2KHR::GetstencilStoreOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stencilStoreOp);
}void _VkAttachmentDescription2KHR::SetstencilStoreOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stencilStoreOp = static_cast<VkAttachmentStoreOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.stencilStoreOp", "Number");
  
    return;
  }
}// initialLayout
Napi::Value _VkAttachmentDescription2KHR::GetinitialLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.initialLayout);
}void _VkAttachmentDescription2KHR::SetinitialLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.initialLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.initialLayout", "Number");
  
    return;
  }
}// finalLayout
Napi::Value _VkAttachmentDescription2KHR::GetfinalLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.finalLayout);
}void _VkAttachmentDescription2KHR::SetfinalLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.finalLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription2KHR.finalLayout", "Number");
  
    return;
  }
}
/** ## END VkAttachmentDescription2KHR ## **/

/** ## BEGIN VkDescriptorSetVariableDescriptorCountLayoutSupportEXT ## **/

Napi::FunctionReference _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::constructor;

_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::~_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetsType,
    &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetpNext,
    &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVariableDescriptorCount",
    &_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmaxVariableDescriptorCount,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetVariableDescriptorCountLayoutSupportEXT", func);
  return exports;
}

Napi::Value _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *)0)->maxVariableDescriptorCount));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *)0)->maxVariableDescriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::flush() {
  _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.pNext", "[object Object]");
  
    return;
  }
}// maxVariableDescriptorCount
Napi::Value _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmaxVariableDescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVariableDescriptorCount);
}
/** ## END VkDescriptorSetVariableDescriptorCountLayoutSupportEXT ## **/

/** ## BEGIN VkDescriptorSetVariableDescriptorCountAllocateInfoEXT ## **/

Napi::FunctionReference _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::constructor;

_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "descriptorSetCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDescriptorCounts");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdescriptorSetCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDescriptorCounts(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::~_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT() {
  
  
  pNext.Reset();
  
  
  pDescriptorCounts.Reset();
  
}

Napi::Object _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetsType,
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetpNext,
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorSetCount",
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetdescriptorSetCount,
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetdescriptorSetCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDescriptorCounts",
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetpDescriptorCounts,
    &_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetpDescriptorCounts,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetVariableDescriptorCountAllocateInfoEXT", func);
  return exports;
}

Napi::Value _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->descriptorSetCount));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->descriptorSetCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->pDescriptorCounts));
    uint32_t byteLength = sizeof(((VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *)0)->pDescriptorCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::flush() {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// descriptorSetCount
Napi::Value _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetdescriptorSetCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorSetCount);
}void _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetdescriptorSetCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorSetCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.descriptorSetCount", "Number");
  
    return;
  }
}// pDescriptorCounts
Napi::Value _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetpDescriptorCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDescriptorCounts.IsEmpty()) return env.Null();
  return this->pDescriptorCounts.Value().As<Napi::TypedArray>();
}void _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetpDescriptorCounts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pDescriptorCounts.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDescriptorCounts.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDescriptorCounts = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pDescriptorCounts = nullptr;
  }
}
/** ## END VkDescriptorSetVariableDescriptorCountAllocateInfoEXT ## **/

/** ## BEGIN VkDescriptorSetLayoutBindingFlagsCreateInfoEXT ## **/

Napi::FunctionReference _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::constructor;

_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "bindingCount");
      Napi::String sAccess3 = Napi::String::New(env, "pBindingFlags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetbindingCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpBindingFlags(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::~_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  pBindingFlags.Reset();
  
}

Napi::Object _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetsType,
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetpNext,
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "bindingCount",
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetbindingCount,
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetbindingCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBindingFlags",
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetpBindingFlags,
    &_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetpBindingFlags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetLayoutBindingFlagsCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->bindingCount));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->bindingCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->pBindingFlags));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *)0)->pBindingFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::flush() {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// bindingCount
Napi::Value _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetbindingCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bindingCount);
}void _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetbindingCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bindingCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.bindingCount", "Number");
  
    return;
  }
}// pBindingFlags
Napi::Value _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetpBindingFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBindingFlags.IsEmpty()) return env.Null();
  return this->pBindingFlags.Value().As<Napi::TypedArray>();
}void _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetpBindingFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pBindingFlags.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pBindingFlags.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pBindingFlags = reinterpret_cast<const VkDescriptorBindingFlagsEXT *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pBindingFlags = nullptr;
  }
}
/** ## END VkDescriptorSetLayoutBindingFlagsCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceDescriptorIndexingPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::constructor;

_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::~_VkPhysicalDeviceDescriptorIndexingPropertiesEXT() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetsType,
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxUpdateAfterBindDescriptorsInAllPools",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxUpdateAfterBindDescriptorsInAllPools,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderUniformBufferArrayNonUniformIndexingNative",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderUniformBufferArrayNonUniformIndexingNative,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderSampledImageArrayNonUniformIndexingNative",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderSampledImageArrayNonUniformIndexingNative,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageBufferArrayNonUniformIndexingNative",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderStorageBufferArrayNonUniformIndexingNative,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageArrayNonUniformIndexingNative",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderStorageImageArrayNonUniformIndexingNative,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderInputAttachmentArrayNonUniformIndexingNative",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderInputAttachmentArrayNonUniformIndexingNative,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "robustBufferAccessUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetrobustBufferAccessUpdateAfterBind,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "quadDivergentImplicitLod",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetquadDivergentImplicitLod,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUpdateAfterBindSamplers",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindSamplers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUpdateAfterBindUniformBuffers",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindUniformBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUpdateAfterBindStorageBuffers",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindStorageBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUpdateAfterBindSampledImages",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindSampledImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUpdateAfterBindStorageImages",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindStorageImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUpdateAfterBindInputAttachments",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindInputAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageUpdateAfterBindResources",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageUpdateAfterBindResources,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindSamplers",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindSamplers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindUniformBuffers",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindUniformBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindStorageBuffers",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindSampledImages",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindSampledImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindStorageImages",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUpdateAfterBindInputAttachments",
    &_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindInputAttachments,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceDescriptorIndexingPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxUpdateAfterBindDescriptorsInAllPools));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxUpdateAfterBindDescriptorsInAllPools);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderUniformBufferArrayNonUniformIndexingNative));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderUniformBufferArrayNonUniformIndexingNative);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderSampledImageArrayNonUniformIndexingNative));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderSampledImageArrayNonUniformIndexingNative);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderStorageBufferArrayNonUniformIndexingNative));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderStorageBufferArrayNonUniformIndexingNative);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderStorageImageArrayNonUniformIndexingNative));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderStorageImageArrayNonUniformIndexingNative);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderInputAttachmentArrayNonUniformIndexingNative));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->shaderInputAttachmentArrayNonUniformIndexingNative);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->robustBufferAccessUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->robustBufferAccessUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->quadDivergentImplicitLod));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->quadDivergentImplicitLod);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindSamplers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindSamplers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindUniformBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindUniformBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindStorageBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindStorageBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindSampledImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindSampledImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindStorageImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindStorageImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindInputAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageDescriptorUpdateAfterBindInputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageUpdateAfterBindResources));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxPerStageUpdateAfterBindResources);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindSamplers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindSamplers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindUniformBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindUniformBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindStorageBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindStorageBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindSampledImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindSampledImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindStorageImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindStorageImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindInputAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingPropertiesEXT *)0)->maxDescriptorSetUpdateAfterBindInputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::flush() {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// maxUpdateAfterBindDescriptorsInAllPools
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxUpdateAfterBindDescriptorsInAllPools(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxUpdateAfterBindDescriptorsInAllPools);
}// shaderUniformBufferArrayNonUniformIndexingNative
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderUniformBufferArrayNonUniformIndexingNative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderUniformBufferArrayNonUniformIndexingNative);
}// shaderSampledImageArrayNonUniformIndexingNative
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderSampledImageArrayNonUniformIndexingNative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderSampledImageArrayNonUniformIndexingNative);
}// shaderStorageBufferArrayNonUniformIndexingNative
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderStorageBufferArrayNonUniformIndexingNative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageBufferArrayNonUniformIndexingNative);
}// shaderStorageImageArrayNonUniformIndexingNative
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderStorageImageArrayNonUniformIndexingNative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageArrayNonUniformIndexingNative);
}// shaderInputAttachmentArrayNonUniformIndexingNative
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderInputAttachmentArrayNonUniformIndexingNative(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderInputAttachmentArrayNonUniformIndexingNative);
}// robustBufferAccessUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetrobustBufferAccessUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.robustBufferAccessUpdateAfterBind);
}// quadDivergentImplicitLod
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetquadDivergentImplicitLod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.quadDivergentImplicitLod);
}// maxPerStageDescriptorUpdateAfterBindSamplers
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindSamplers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUpdateAfterBindSamplers);
}// maxPerStageDescriptorUpdateAfterBindUniformBuffers
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindUniformBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUpdateAfterBindUniformBuffers);
}// maxPerStageDescriptorUpdateAfterBindStorageBuffers
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindStorageBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUpdateAfterBindStorageBuffers);
}// maxPerStageDescriptorUpdateAfterBindSampledImages
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindSampledImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUpdateAfterBindSampledImages);
}// maxPerStageDescriptorUpdateAfterBindStorageImages
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindStorageImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUpdateAfterBindStorageImages);
}// maxPerStageDescriptorUpdateAfterBindInputAttachments
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindInputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUpdateAfterBindInputAttachments);
}// maxPerStageUpdateAfterBindResources
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageUpdateAfterBindResources(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageUpdateAfterBindResources);
}// maxDescriptorSetUpdateAfterBindSamplers
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindSamplers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindSamplers);
}// maxDescriptorSetUpdateAfterBindUniformBuffers
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindUniformBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindUniformBuffers);
}// maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);
}// maxDescriptorSetUpdateAfterBindStorageBuffers
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindStorageBuffers);
}// maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);
}// maxDescriptorSetUpdateAfterBindSampledImages
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindSampledImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindSampledImages);
}// maxDescriptorSetUpdateAfterBindStorageImages
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindStorageImages);
}// maxDescriptorSetUpdateAfterBindInputAttachments
Napi::Value _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindInputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUpdateAfterBindInputAttachments);
}
/** ## END VkPhysicalDeviceDescriptorIndexingPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceDescriptorIndexingFeaturesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::constructor;

_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "shaderInputAttachmentArrayDynamicIndexing");
      Napi::String sAccess3 = Napi::String::New(env, "shaderUniformTexelBufferArrayDynamicIndexing");
      Napi::String sAccess4 = Napi::String::New(env, "shaderStorageTexelBufferArrayDynamicIndexing");
      Napi::String sAccess5 = Napi::String::New(env, "shaderUniformBufferArrayNonUniformIndexing");
      Napi::String sAccess6 = Napi::String::New(env, "shaderSampledImageArrayNonUniformIndexing");
      Napi::String sAccess7 = Napi::String::New(env, "shaderStorageBufferArrayNonUniformIndexing");
      Napi::String sAccess8 = Napi::String::New(env, "shaderStorageImageArrayNonUniformIndexing");
      Napi::String sAccess9 = Napi::String::New(env, "shaderInputAttachmentArrayNonUniformIndexing");
      Napi::String sAccess10 = Napi::String::New(env, "shaderUniformTexelBufferArrayNonUniformIndexing");
      Napi::String sAccess11 = Napi::String::New(env, "shaderStorageTexelBufferArrayNonUniformIndexing");
      Napi::String sAccess12 = Napi::String::New(env, "descriptorBindingUniformBufferUpdateAfterBind");
      Napi::String sAccess13 = Napi::String::New(env, "descriptorBindingSampledImageUpdateAfterBind");
      Napi::String sAccess14 = Napi::String::New(env, "descriptorBindingStorageImageUpdateAfterBind");
      Napi::String sAccess15 = Napi::String::New(env, "descriptorBindingStorageBufferUpdateAfterBind");
      Napi::String sAccess16 = Napi::String::New(env, "descriptorBindingUniformTexelBufferUpdateAfterBind");
      Napi::String sAccess17 = Napi::String::New(env, "descriptorBindingStorageTexelBufferUpdateAfterBind");
      Napi::String sAccess18 = Napi::String::New(env, "descriptorBindingUpdateUnusedWhilePending");
      Napi::String sAccess19 = Napi::String::New(env, "descriptorBindingPartiallyBound");
      Napi::String sAccess20 = Napi::String::New(env, "descriptorBindingVariableDescriptorCount");
      Napi::String sAccess21 = Napi::String::New(env, "runtimeDescriptorArray");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetshaderInputAttachmentArrayDynamicIndexing(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetshaderUniformTexelBufferArrayDynamicIndexing(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetshaderStorageTexelBufferArrayDynamicIndexing(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetshaderUniformBufferArrayNonUniformIndexing(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetshaderSampledImageArrayNonUniformIndexing(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetshaderStorageBufferArrayNonUniformIndexing(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetshaderStorageImageArrayNonUniformIndexing(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetshaderInputAttachmentArrayNonUniformIndexing(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetshaderUniformTexelBufferArrayNonUniformIndexing(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetshaderStorageTexelBufferArrayNonUniformIndexing(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetdescriptorBindingUniformBufferUpdateAfterBind(info, obj.Get(sAccess12));
      if (obj.Has(sAccess13)) this->SetdescriptorBindingSampledImageUpdateAfterBind(info, obj.Get(sAccess13));
      if (obj.Has(sAccess14)) this->SetdescriptorBindingStorageImageUpdateAfterBind(info, obj.Get(sAccess14));
      if (obj.Has(sAccess15)) this->SetdescriptorBindingStorageBufferUpdateAfterBind(info, obj.Get(sAccess15));
      if (obj.Has(sAccess16)) this->SetdescriptorBindingUniformTexelBufferUpdateAfterBind(info, obj.Get(sAccess16));
      if (obj.Has(sAccess17)) this->SetdescriptorBindingStorageTexelBufferUpdateAfterBind(info, obj.Get(sAccess17));
      if (obj.Has(sAccess18)) this->SetdescriptorBindingUpdateUnusedWhilePending(info, obj.Get(sAccess18));
      if (obj.Has(sAccess19)) this->SetdescriptorBindingPartiallyBound(info, obj.Get(sAccess19));
      if (obj.Has(sAccess20)) this->SetdescriptorBindingVariableDescriptorCount(info, obj.Get(sAccess20));
      if (obj.Has(sAccess21)) this->SetruntimeDescriptorArray(info, obj.Get(sAccess21));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::~_VkPhysicalDeviceDescriptorIndexingFeaturesEXT() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetsType,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetpNext,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderInputAttachmentArrayDynamicIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderInputAttachmentArrayDynamicIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderInputAttachmentArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderUniformTexelBufferArrayDynamicIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformTexelBufferArrayDynamicIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformTexelBufferArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageTexelBufferArrayDynamicIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageTexelBufferArrayDynamicIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageTexelBufferArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderUniformBufferArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformBufferArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformBufferArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderSampledImageArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderSampledImageArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderSampledImageArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageBufferArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageBufferArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageBufferArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageImageArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageImageArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderInputAttachmentArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderInputAttachmentArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderInputAttachmentArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderUniformTexelBufferArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformTexelBufferArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformTexelBufferArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageTexelBufferArrayNonUniformIndexing",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageTexelBufferArrayNonUniformIndexing,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageTexelBufferArrayNonUniformIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingUniformBufferUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUniformBufferUpdateAfterBind,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUniformBufferUpdateAfterBind,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingSampledImageUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingSampledImageUpdateAfterBind,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingSampledImageUpdateAfterBind,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingStorageImageUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageImageUpdateAfterBind,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageImageUpdateAfterBind,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingStorageBufferUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageBufferUpdateAfterBind,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageBufferUpdateAfterBind,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingUniformTexelBufferUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUniformTexelBufferUpdateAfterBind,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUniformTexelBufferUpdateAfterBind,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingStorageTexelBufferUpdateAfterBind",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageTexelBufferUpdateAfterBind,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageTexelBufferUpdateAfterBind,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingUpdateUnusedWhilePending",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUpdateUnusedWhilePending,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUpdateUnusedWhilePending,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingPartiallyBound",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingPartiallyBound,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingPartiallyBound,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorBindingVariableDescriptorCount",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingVariableDescriptorCount,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingVariableDescriptorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "runtimeDescriptorArray",
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetruntimeDescriptorArray,
    &_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetruntimeDescriptorArray,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceDescriptorIndexingFeaturesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderInputAttachmentArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderInputAttachmentArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderUniformTexelBufferArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderUniformTexelBufferArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageTexelBufferArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageTexelBufferArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderUniformBufferArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderUniformBufferArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderSampledImageArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderSampledImageArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageBufferArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageBufferArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageImageArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageImageArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderInputAttachmentArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderInputAttachmentArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderUniformTexelBufferArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderUniformTexelBufferArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageTexelBufferArrayNonUniformIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->shaderStorageTexelBufferArrayNonUniformIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingUniformBufferUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingUniformBufferUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingSampledImageUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingSampledImageUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingStorageImageUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingStorageImageUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingStorageBufferUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingStorageBufferUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingUniformTexelBufferUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingUniformTexelBufferUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingStorageTexelBufferUpdateAfterBind));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingStorageTexelBufferUpdateAfterBind);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingUpdateUnusedWhilePending));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingUpdateUnusedWhilePending);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingPartiallyBound));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingPartiallyBound);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingVariableDescriptorCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->descriptorBindingVariableDescriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->runtimeDescriptorArray));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDescriptorIndexingFeaturesEXT *)0)->runtimeDescriptorArray);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::flush() {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.pNext", "[object Object]");
  
    return;
  }
}// shaderInputAttachmentArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderInputAttachmentArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderInputAttachmentArrayDynamicIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderInputAttachmentArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderInputAttachmentArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderInputAttachmentArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderInputAttachmentArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderUniformTexelBufferArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformTexelBufferArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderUniformTexelBufferArrayDynamicIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformTexelBufferArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderUniformTexelBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderUniformTexelBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderUniformTexelBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderStorageTexelBufferArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageTexelBufferArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageTexelBufferArrayDynamicIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageTexelBufferArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageTexelBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageTexelBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageTexelBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderUniformBufferArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderUniformBufferArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderUniformBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderUniformBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderUniformBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderSampledImageArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderSampledImageArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderSampledImageArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderSampledImageArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderSampledImageArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderSampledImageArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderSampledImageArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderStorageBufferArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageBufferArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderStorageImageArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageImageArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageImageArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageImageArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageImageArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageImageArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderInputAttachmentArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderInputAttachmentArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderInputAttachmentArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderInputAttachmentArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderInputAttachmentArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderInputAttachmentArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderInputAttachmentArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderUniformTexelBufferArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformTexelBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderUniformTexelBufferArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformTexelBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderUniformTexelBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderUniformTexelBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderUniformTexelBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderStorageTexelBufferArrayNonUniformIndexing
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageTexelBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageTexelBufferArrayNonUniformIndexing);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageTexelBufferArrayNonUniformIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageTexelBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageTexelBufferArrayNonUniformIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageTexelBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// descriptorBindingUniformBufferUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUniformBufferUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingUniformBufferUpdateAfterBind);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUniformBufferUpdateAfterBind(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingUniformBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingUniformBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingUniformBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingSampledImageUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingSampledImageUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingSampledImageUpdateAfterBind);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingSampledImageUpdateAfterBind(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingSampledImageUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingSampledImageUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingSampledImageUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingStorageImageUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageImageUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingStorageImageUpdateAfterBind);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageImageUpdateAfterBind(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingStorageImageUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingStorageImageUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingStorageImageUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingStorageBufferUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageBufferUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingStorageBufferUpdateAfterBind);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageBufferUpdateAfterBind(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingStorageBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingStorageBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingStorageBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingUniformTexelBufferUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUniformTexelBufferUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingUniformTexelBufferUpdateAfterBind);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUniformTexelBufferUpdateAfterBind(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingUniformTexelBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingUniformTexelBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingUniformTexelBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingStorageTexelBufferUpdateAfterBind
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageTexelBufferUpdateAfterBind(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingStorageTexelBufferUpdateAfterBind);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageTexelBufferUpdateAfterBind(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingStorageTexelBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingStorageTexelBufferUpdateAfterBind = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingStorageTexelBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingUpdateUnusedWhilePending
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUpdateUnusedWhilePending(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingUpdateUnusedWhilePending);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUpdateUnusedWhilePending(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingUpdateUnusedWhilePending = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingUpdateUnusedWhilePending = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingUpdateUnusedWhilePending", "Number");
  
    return;
  }
}// descriptorBindingPartiallyBound
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingPartiallyBound(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingPartiallyBound);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingPartiallyBound(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingPartiallyBound = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingPartiallyBound = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingPartiallyBound", "Number");
  
    return;
  }
}// descriptorBindingVariableDescriptorCount
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingVariableDescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorBindingVariableDescriptorCount);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingVariableDescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.descriptorBindingVariableDescriptorCount = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.descriptorBindingVariableDescriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingVariableDescriptorCount", "Number");
  
    return;
  }
}// runtimeDescriptorArray
Napi::Value _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetruntimeDescriptorArray(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.runtimeDescriptorArray);
}void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetruntimeDescriptorArray(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.runtimeDescriptorArray = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.runtimeDescriptorArray = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.runtimeDescriptorArray", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceDescriptorIndexingFeaturesEXT ## **/

/** ## BEGIN VkPipelineRasterizationConservativeStateCreateInfoEXT ## **/

Napi::FunctionReference _VkPipelineRasterizationConservativeStateCreateInfoEXT::constructor;

_VkPipelineRasterizationConservativeStateCreateInfoEXT::_VkPipelineRasterizationConservativeStateCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "conservativeRasterizationMode");
      Napi::String sAccess4 = Napi::String::New(env, "extraPrimitiveOverestimationSize");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetconservativeRasterizationMode(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetextraPrimitiveOverestimationSize(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineRasterizationConservativeStateCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineRasterizationConservativeStateCreateInfoEXT::~_VkPipelineRasterizationConservativeStateCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPipelineRasterizationConservativeStateCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineRasterizationConservativeStateCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetsType,
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetpNext,
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::Getflags,
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "conservativeRasterizationMode",
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetconservativeRasterizationMode,
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetconservativeRasterizationMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "extraPrimitiveOverestimationSize",
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetextraPrimitiveOverestimationSize,
    &_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetextraPrimitiveOverestimationSize,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineRasterizationConservativeStateCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->conservativeRasterizationMode));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->conservativeRasterizationMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->extraPrimitiveOverestimationSize));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationConservativeStateCreateInfoEXT *)0)->extraPrimitiveOverestimationSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineRasterizationConservativeStateCreateInfoEXT::flush() {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineRasterizationConservativeStateCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineRasterizationConservativeStateCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineRasterizationConservativeStateCreateInfoEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineRasterizationConservativeStateCreateFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.flags", "Number");
  
    return;
  }
}// conservativeRasterizationMode
Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::GetconservativeRasterizationMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.conservativeRasterizationMode);
}void _VkPipelineRasterizationConservativeStateCreateInfoEXT::SetconservativeRasterizationMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.conservativeRasterizationMode = static_cast<VkConservativeRasterizationModeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode", "Number");
  
    return;
  }
}// extraPrimitiveOverestimationSize
Napi::Value _VkPipelineRasterizationConservativeStateCreateInfoEXT::GetextraPrimitiveOverestimationSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.extraPrimitiveOverestimationSize);
}void _VkPipelineRasterizationConservativeStateCreateInfoEXT::SetextraPrimitiveOverestimationSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.extraPrimitiveOverestimationSize = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.extraPrimitiveOverestimationSize", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationConservativeStateCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceShaderCorePropertiesAMD ## **/

Napi::FunctionReference _VkPhysicalDeviceShaderCorePropertiesAMD::constructor;

_VkPhysicalDeviceShaderCorePropertiesAMD::_VkPhysicalDeviceShaderCorePropertiesAMD(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceShaderCorePropertiesAMD constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceShaderCorePropertiesAMD::~_VkPhysicalDeviceShaderCorePropertiesAMD() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceShaderCorePropertiesAMD::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceShaderCorePropertiesAMD", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceShaderCorePropertiesAMD::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceShaderCorePropertiesAMD::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetsType,
    &_VkPhysicalDeviceShaderCorePropertiesAMD::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetpNext,
    &_VkPhysicalDeviceShaderCorePropertiesAMD::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderEngineCount",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetshaderEngineCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderArraysPerEngineCount",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetshaderArraysPerEngineCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "computeUnitsPerShaderArray",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetcomputeUnitsPerShaderArray,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "simdPerComputeUnit",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetsimdPerComputeUnit,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "wavefrontsPerSimd",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetwavefrontsPerSimd,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "wavefrontSize",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetwavefrontSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sgprsPerSimd",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetsgprsPerSimd,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minSgprAllocation",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetminSgprAllocation,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSgprAllocation",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetmaxSgprAllocation,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sgprAllocationGranularity",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetsgprAllocationGranularity,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "vgprsPerSimd",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetvgprsPerSimd,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minVgprAllocation",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetminVgprAllocation,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVgprAllocation",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetmaxVgprAllocation,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "vgprAllocationGranularity",
    &_VkPhysicalDeviceShaderCorePropertiesAMD::GetvgprAllocationGranularity,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceShaderCorePropertiesAMD", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->shaderEngineCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->shaderEngineCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->shaderArraysPerEngineCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->shaderArraysPerEngineCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->computeUnitsPerShaderArray));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->computeUnitsPerShaderArray);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->simdPerComputeUnit));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->simdPerComputeUnit);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->wavefrontsPerSimd));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->wavefrontsPerSimd);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->wavefrontSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->wavefrontSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->sgprsPerSimd));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->sgprsPerSimd);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->minSgprAllocation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->minSgprAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->maxSgprAllocation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->maxSgprAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->sgprAllocationGranularity));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->sgprAllocationGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->vgprsPerSimd));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->vgprsPerSimd);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->minVgprAllocation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->minVgprAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->maxVgprAllocation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->maxVgprAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->vgprAllocationGranularity));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderCorePropertiesAMD *)0)->vgprAllocationGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceShaderCorePropertiesAMD::flush() {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceShaderCorePropertiesAMD::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderCorePropertiesAMD.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceShaderCorePropertiesAMD::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceShaderCorePropertiesAMD.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderCorePropertiesAMD.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderCorePropertiesAMD.pNext", "[object Object]");
  
    return;
  }
}// shaderEngineCount
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetshaderEngineCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderEngineCount);
}// shaderArraysPerEngineCount
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetshaderArraysPerEngineCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderArraysPerEngineCount);
}// computeUnitsPerShaderArray
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetcomputeUnitsPerShaderArray(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.computeUnitsPerShaderArray);
}// simdPerComputeUnit
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetsimdPerComputeUnit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.simdPerComputeUnit);
}// wavefrontsPerSimd
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetwavefrontsPerSimd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.wavefrontsPerSimd);
}// wavefrontSize
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetwavefrontSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.wavefrontSize);
}// sgprsPerSimd
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetsgprsPerSimd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sgprsPerSimd);
}// minSgprAllocation
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetminSgprAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minSgprAllocation);
}// maxSgprAllocation
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetmaxSgprAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSgprAllocation);
}// sgprAllocationGranularity
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetsgprAllocationGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sgprAllocationGranularity);
}// vgprsPerSimd
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetvgprsPerSimd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vgprsPerSimd);
}// minVgprAllocation
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetminVgprAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minVgprAllocation);
}// maxVgprAllocation
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetmaxVgprAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVgprAllocation);
}// vgprAllocationGranularity
Napi::Value _VkPhysicalDeviceShaderCorePropertiesAMD::GetvgprAllocationGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vgprAllocationGranularity);
}
/** ## END VkPhysicalDeviceShaderCorePropertiesAMD ## **/

/** ## BEGIN VkPhysicalDeviceConservativeRasterizationPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::constructor;

_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "primitiveOverestimationSize");
      Napi::String sAccess3 = Napi::String::New(env, "maxExtraPrimitiveOverestimationSize");
      Napi::String sAccess4 = Napi::String::New(env, "extraPrimitiveOverestimationSizeGranularity");
      Napi::String sAccess5 = Napi::String::New(env, "primitiveUnderestimation");
      Napi::String sAccess6 = Napi::String::New(env, "conservativePointAndLineRasterization");
      Napi::String sAccess7 = Napi::String::New(env, "degenerateTrianglesRasterized");
      Napi::String sAccess8 = Napi::String::New(env, "degenerateLinesRasterized");
      Napi::String sAccess9 = Napi::String::New(env, "fullyCoveredFragmentShaderInputVariable");
      Napi::String sAccess10 = Napi::String::New(env, "conservativeRasterizationPostDepthCoverage");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetprimitiveOverestimationSize(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmaxExtraPrimitiveOverestimationSize(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetextraPrimitiveOverestimationSizeGranularity(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetprimitiveUnderestimation(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetconservativePointAndLineRasterization(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdegenerateTrianglesRasterized(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetdegenerateLinesRasterized(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetfullyCoveredFragmentShaderInputVariable(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetconservativeRasterizationPostDepthCoverage(info, obj.Get(sAccess10));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::~_VkPhysicalDeviceConservativeRasterizationPropertiesEXT() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetsType,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "primitiveOverestimationSize",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetprimitiveOverestimationSize,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetprimitiveOverestimationSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxExtraPrimitiveOverestimationSize",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmaxExtraPrimitiveOverestimationSize,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetmaxExtraPrimitiveOverestimationSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "extraPrimitiveOverestimationSizeGranularity",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetextraPrimitiveOverestimationSizeGranularity,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetextraPrimitiveOverestimationSizeGranularity,
    napi_enumerable
  ),
  InstanceAccessor(
    "primitiveUnderestimation",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetprimitiveUnderestimation,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetprimitiveUnderestimation,
    napi_enumerable
  ),
  InstanceAccessor(
    "conservativePointAndLineRasterization",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetconservativePointAndLineRasterization,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetconservativePointAndLineRasterization,
    napi_enumerable
  ),
  InstanceAccessor(
    "degenerateTrianglesRasterized",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetdegenerateTrianglesRasterized,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetdegenerateTrianglesRasterized,
    napi_enumerable
  ),
  InstanceAccessor(
    "degenerateLinesRasterized",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetdegenerateLinesRasterized,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetdegenerateLinesRasterized,
    napi_enumerable
  ),
  InstanceAccessor(
    "fullyCoveredFragmentShaderInputVariable",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetfullyCoveredFragmentShaderInputVariable,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetfullyCoveredFragmentShaderInputVariable,
    napi_enumerable
  ),
  InstanceAccessor(
    "conservativeRasterizationPostDepthCoverage",
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetconservativeRasterizationPostDepthCoverage,
    &_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetconservativeRasterizationPostDepthCoverage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceConservativeRasterizationPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->primitiveOverestimationSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->primitiveOverestimationSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->maxExtraPrimitiveOverestimationSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->maxExtraPrimitiveOverestimationSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->extraPrimitiveOverestimationSizeGranularity));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->extraPrimitiveOverestimationSizeGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->primitiveUnderestimation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->primitiveUnderestimation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->conservativePointAndLineRasterization));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->conservativePointAndLineRasterization);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->degenerateTrianglesRasterized));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->degenerateTrianglesRasterized);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->degenerateLinesRasterized));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->degenerateLinesRasterized);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->fullyCoveredFragmentShaderInputVariable));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->fullyCoveredFragmentShaderInputVariable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->conservativeRasterizationPostDepthCoverage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)0)->conservativeRasterizationPostDepthCoverage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::flush() {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// primitiveOverestimationSize
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetprimitiveOverestimationSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.primitiveOverestimationSize);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetprimitiveOverestimationSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.primitiveOverestimationSize = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.primitiveOverestimationSize", "Number");
  
    return;
  }
}// maxExtraPrimitiveOverestimationSize
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmaxExtraPrimitiveOverestimationSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxExtraPrimitiveOverestimationSize);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetmaxExtraPrimitiveOverestimationSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxExtraPrimitiveOverestimationSize = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.maxExtraPrimitiveOverestimationSize", "Number");
  
    return;
  }
}// extraPrimitiveOverestimationSizeGranularity
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetextraPrimitiveOverestimationSizeGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.extraPrimitiveOverestimationSizeGranularity);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetextraPrimitiveOverestimationSizeGranularity(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.extraPrimitiveOverestimationSizeGranularity = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.extraPrimitiveOverestimationSizeGranularity", "Number");
  
    return;
  }
}// primitiveUnderestimation
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetprimitiveUnderestimation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.primitiveUnderestimation);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetprimitiveUnderestimation(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.primitiveUnderestimation = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.primitiveUnderestimation = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.primitiveUnderestimation", "Number");
  
    return;
  }
}// conservativePointAndLineRasterization
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetconservativePointAndLineRasterization(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.conservativePointAndLineRasterization);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetconservativePointAndLineRasterization(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.conservativePointAndLineRasterization = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.conservativePointAndLineRasterization = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.conservativePointAndLineRasterization", "Number");
  
    return;
  }
}// degenerateTrianglesRasterized
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetdegenerateTrianglesRasterized(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.degenerateTrianglesRasterized);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetdegenerateTrianglesRasterized(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.degenerateTrianglesRasterized = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.degenerateTrianglesRasterized = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.degenerateTrianglesRasterized", "Number");
  
    return;
  }
}// degenerateLinesRasterized
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetdegenerateLinesRasterized(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.degenerateLinesRasterized);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetdegenerateLinesRasterized(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.degenerateLinesRasterized = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.degenerateLinesRasterized = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.degenerateLinesRasterized", "Number");
  
    return;
  }
}// fullyCoveredFragmentShaderInputVariable
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetfullyCoveredFragmentShaderInputVariable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fullyCoveredFragmentShaderInputVariable);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetfullyCoveredFragmentShaderInputVariable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.fullyCoveredFragmentShaderInputVariable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.fullyCoveredFragmentShaderInputVariable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.fullyCoveredFragmentShaderInputVariable", "Number");
  
    return;
  }
}// conservativeRasterizationPostDepthCoverage
Napi::Value _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetconservativeRasterizationPostDepthCoverage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.conservativeRasterizationPostDepthCoverage);
}void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::SetconservativeRasterizationPostDepthCoverage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.conservativeRasterizationPostDepthCoverage = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.conservativeRasterizationPostDepthCoverage = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.conservativeRasterizationPostDepthCoverage", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceConservativeRasterizationPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceExternalMemoryHostPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::constructor;

_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "minImportedHostPointerAlignment");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetminImportedHostPointerAlignment(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::~_VkPhysicalDeviceExternalMemoryHostPropertiesEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetsType,
    &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "minImportedHostPointerAlignment",
    &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetminImportedHostPointerAlignment,
    &_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::SetminImportedHostPointerAlignment,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalMemoryHostPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)0)->minImportedHostPointerAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)0)->minImportedHostPointerAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::flush() {
  _VkPhysicalDeviceExternalMemoryHostPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// minImportedHostPointerAlignment
Napi::Value _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetminImportedHostPointerAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minImportedHostPointerAlignment);
}void _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::SetminImportedHostPointerAlignment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minImportedHostPointerAlignment = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.minImportedHostPointerAlignment", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalMemoryHostPropertiesEXT ## **/

/** ## BEGIN VkMemoryHostPointerPropertiesEXT ## **/

Napi::FunctionReference _VkMemoryHostPointerPropertiesEXT::constructor;

_VkMemoryHostPointerPropertiesEXT::_VkMemoryHostPointerPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryHostPointerPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "memoryTypeBits");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetmemoryTypeBits(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkMemoryHostPointerPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryHostPointerPropertiesEXT::~_VkMemoryHostPointerPropertiesEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkMemoryHostPointerPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryHostPointerPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryHostPointerPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryHostPointerPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryHostPointerPropertiesEXT::GetsType,
    &_VkMemoryHostPointerPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryHostPointerPropertiesEXT::GetpNext,
    &_VkMemoryHostPointerPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryTypeBits",
    &_VkMemoryHostPointerPropertiesEXT::GetmemoryTypeBits,
    &_VkMemoryHostPointerPropertiesEXT::SetmemoryTypeBits,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryHostPointerPropertiesEXT", func);
  return exports;
}

Napi::Value _VkMemoryHostPointerPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryHostPointerPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryHostPointerPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryHostPointerPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryHostPointerPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryHostPointerPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryHostPointerPropertiesEXT *)0)->memoryTypeBits));
    uint32_t byteLength = sizeof(((VkMemoryHostPointerPropertiesEXT *)0)->memoryTypeBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryHostPointerPropertiesEXT::flush() {
  _VkMemoryHostPointerPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryHostPointerPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryHostPointerPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryHostPointerPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryHostPointerPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryHostPointerPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryHostPointerPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryHostPointerPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryHostPointerPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// memoryTypeBits
Napi::Value _VkMemoryHostPointerPropertiesEXT::GetmemoryTypeBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryTypeBits);
}void _VkMemoryHostPointerPropertiesEXT::SetmemoryTypeBits(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryTypeBits = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryHostPointerPropertiesEXT.memoryTypeBits", "Number");
  
    return;
  }
}
/** ## END VkMemoryHostPointerPropertiesEXT ## **/

/** ## BEGIN VkImportMemoryHostPointerInfoEXT ## **/

Napi::FunctionReference _VkImportMemoryHostPointerInfoEXT::constructor;

_VkImportMemoryHostPointerInfoEXT::_VkImportMemoryHostPointerInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportMemoryHostPointerInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      Napi::String sAccess3 = Napi::String::New(env, "pHostPointer");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpHostPointer(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkImportMemoryHostPointerInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportMemoryHostPointerInfoEXT::~_VkImportMemoryHostPointerInfoEXT() {
  
  
  pNext.Reset();
  
  
  pHostPointer.Reset();
  
}

Napi::Object _VkImportMemoryHostPointerInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportMemoryHostPointerInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportMemoryHostPointerInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportMemoryHostPointerInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportMemoryHostPointerInfoEXT::GetsType,
    &_VkImportMemoryHostPointerInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportMemoryHostPointerInfoEXT::GetpNext,
    &_VkImportMemoryHostPointerInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportMemoryHostPointerInfoEXT::GethandleType,
    &_VkImportMemoryHostPointerInfoEXT::SethandleType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pHostPointer",
    &_VkImportMemoryHostPointerInfoEXT::GetpHostPointer,
    &_VkImportMemoryHostPointerInfoEXT::SetpHostPointer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportMemoryHostPointerInfoEXT", func);
  return exports;
}

Napi::Value _VkImportMemoryHostPointerInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportMemoryHostPointerInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryHostPointerInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportMemoryHostPointerInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryHostPointerInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportMemoryHostPointerInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryHostPointerInfoEXT *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportMemoryHostPointerInfoEXT *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryHostPointerInfoEXT *)0)->pHostPointer));
    uint32_t byteLength = sizeof(((VkImportMemoryHostPointerInfoEXT *)0)->pHostPointer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportMemoryHostPointerInfoEXT::flush() {
  _VkImportMemoryHostPointerInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportMemoryHostPointerInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportMemoryHostPointerInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryHostPointerInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportMemoryHostPointerInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportMemoryHostPointerInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportMemoryHostPointerInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportMemoryHostPointerInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryHostPointerInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkImportMemoryHostPointerInfoEXT::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportMemoryHostPointerInfoEXT::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryHostPointerInfoEXT.handleType", "Number");
  
    return;
  }
}// pHostPointer
Napi::Value _VkImportMemoryHostPointerInfoEXT::GetpHostPointer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pHostPointer.IsEmpty()) return env.Null();
  return this->pHostPointer.Value().As<Napi::Object>();
}void _VkImportMemoryHostPointerInfoEXT::SetpHostPointer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pHostPointer = buffer.Data();
    this->pHostPointer.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pHostPointer = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryHostPointerInfoEXT.pHostPointer", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkImportMemoryHostPointerInfoEXT ## **/

/** ## BEGIN VkDebugUtilsMessengerCallbackDataEXT ## **/

Napi::FunctionReference _VkDebugUtilsMessengerCallbackDataEXT::constructor;

_VkDebugUtilsMessengerCallbackDataEXT::_VkDebugUtilsMessengerCallbackDataEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugUtilsMessengerCallbackDataEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
    vpQueueLabels = new std::vector<VkDebugUtilsLabelEXT>;
    vpCmdBufLabels = new std::vector<VkDebugUtilsLabelEXT>;
    vpObjects = new std::vector<VkDebugUtilsObjectNameInfoEXT>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "pMessageIdName");
      Napi::String sAccess4 = Napi::String::New(env, "messageIdNumber");
      Napi::String sAccess5 = Napi::String::New(env, "pMessage");
      Napi::String sAccess6 = Napi::String::New(env, "queueLabelCount");
      Napi::String sAccess7 = Napi::String::New(env, "pQueueLabels");
      Napi::String sAccess8 = Napi::String::New(env, "cmdBufLabelCount");
      Napi::String sAccess9 = Napi::String::New(env, "pCmdBufLabels");
      Napi::String sAccess10 = Napi::String::New(env, "objectCount");
      Napi::String sAccess11 = Napi::String::New(env, "pObjects");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpMessageIdName(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmessageIdNumber(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpMessage(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetqueueLabelCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpQueueLabels(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetcmdBufLabelCount(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpCmdBufLabels(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetobjectCount(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetpObjects(info, obj.Get(sAccess11));
      
    } else {
      Napi::Error::New(env, "VkDebugUtilsMessengerCallbackDataEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugUtilsMessengerCallbackDataEXT::~_VkDebugUtilsMessengerCallbackDataEXT() {
  
  
  pNext.Reset();
  
  
  pMessageIdName.Reset();
  
  
  pMessage.Reset();
  
  
  vpQueueLabels->clear();
  delete vpQueueLabels;
  
  pQueueLabels.Reset();
  
  
  vpCmdBufLabels->clear();
  delete vpCmdBufLabels;
  
  pCmdBufLabels.Reset();
  
  
  vpObjects->clear();
  delete vpObjects;
  
  pObjects.Reset();
  
}

Napi::Object _VkDebugUtilsMessengerCallbackDataEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugUtilsMessengerCallbackDataEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugUtilsMessengerCallbackDataEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugUtilsMessengerCallbackDataEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetsType,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetpNext,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDebugUtilsMessengerCallbackDataEXT::Getflags,
    &_VkDebugUtilsMessengerCallbackDataEXT::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pMessageIdName",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetpMessageIdName,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetpMessageIdName,
    napi_enumerable
  ),
  InstanceAccessor(
    "messageIdNumber",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetmessageIdNumber,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetmessageIdNumber,
    napi_enumerable
  ),
  InstanceAccessor(
    "pMessage",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetpMessage,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetpMessage,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueLabelCount",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetqueueLabelCount,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetqueueLabelCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pQueueLabels",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetpQueueLabels,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetpQueueLabels,
    napi_enumerable
  ),
  InstanceAccessor(
    "cmdBufLabelCount",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetcmdBufLabelCount,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetcmdBufLabelCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCmdBufLabels",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetpCmdBufLabels,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetpCmdBufLabels,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectCount",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetobjectCount,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetobjectCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pObjects",
    &_VkDebugUtilsMessengerCallbackDataEXT::GetpObjects,
    &_VkDebugUtilsMessengerCallbackDataEXT::SetpObjects,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugUtilsMessengerCallbackDataEXT", func);
  return exports;
}

Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pMessageIdName));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pMessageIdName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->messageIdNumber));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->messageIdNumber);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pMessage));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pMessage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->queueLabelCount));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->queueLabelCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pQueueLabels));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pQueueLabels);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->cmdBufLabelCount));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->cmdBufLabelCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pCmdBufLabels));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pCmdBufLabels);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->objectCount));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->objectCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pObjects));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCallbackDataEXT *)0)->pObjects);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugUtilsMessengerCallbackDataEXT::flush() {
  _VkDebugUtilsMessengerCallbackDataEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pQueueLabels.IsEmpty())) {
    Napi::Value value = self->pQueueLabels.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.queueLabelCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'queueLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDebugUtilsLabelEXT>* data = this->vpQueueLabels;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDebugUtilsLabelEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels", "[object VkDebugUtilsLabelEXT]");
  
        return false;
      }
      _VkDebugUtilsLabelEXT* result = Napi::ObjectWrap<_VkDebugUtilsLabelEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pQueueLabels = data->data();
  }if (!(self->pCmdBufLabels.IsEmpty())) {
    Napi::Value value = self->pCmdBufLabels.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.cmdBufLabelCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'cmdBufLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDebugUtilsLabelEXT>* data = this->vpCmdBufLabels;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDebugUtilsLabelEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels", "[object VkDebugUtilsLabelEXT]");
  
        return false;
      }
      _VkDebugUtilsLabelEXT* result = Napi::ObjectWrap<_VkDebugUtilsLabelEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pCmdBufLabels = data->data();
  }if (!(self->pObjects.IsEmpty())) {
    Napi::Value value = self->pObjects.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.objectCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'objectCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDebugUtilsObjectNameInfoEXT>* data = this->vpObjects;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDebugUtilsObjectNameInfoEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pObjects", "[object VkDebugUtilsObjectNameInfoEXT]");
  
        return false;
      }
      _VkDebugUtilsObjectNameInfoEXT* result = Napi::ObjectWrap<_VkDebugUtilsObjectNameInfoEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pObjects = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugUtilsMessengerCallbackDataEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugUtilsMessengerCallbackDataEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugUtilsMessengerCallbackDataEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDebugUtilsMessengerCallbackDataEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDebugUtilsMessengerCallbackDataFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.flags", "Number");
  
    return;
  }
}// pMessageIdName
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetpMessageIdName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pMessageIdName.IsEmpty()) return env.Null();
  return this->pMessageIdName.Value().ToString();
}void _VkDebugUtilsMessengerCallbackDataEXT::SetpMessageIdName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pMessageIdName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pMessageIdName) delete[] this->instance.pMessageIdName;
    this->instance.pMessageIdName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pMessageIdName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pMessageIdName", "String");
  
    return;
  }
}// messageIdNumber
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetmessageIdNumber(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.messageIdNumber);
}void _VkDebugUtilsMessengerCallbackDataEXT::SetmessageIdNumber(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.messageIdNumber = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.messageIdNumber", "Number");
  
    return;
  }
}// pMessage
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetpMessage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pMessage.IsEmpty()) return env.Null();
  return this->pMessage.Value().ToString();
}void _VkDebugUtilsMessengerCallbackDataEXT::SetpMessage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pMessage.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pMessage) delete[] this->instance.pMessage;
    this->instance.pMessage = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pMessage = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pMessage", "String");
  
    return;
  }
}// queueLabelCount
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetqueueLabelCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueLabelCount);
}void _VkDebugUtilsMessengerCallbackDataEXT::SetqueueLabelCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueLabelCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.queueLabelCount", "Number");
  
    return;
  }
}// pQueueLabels
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetpQueueLabels(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pQueueLabels.IsEmpty()) return env.Null();
  return this->pQueueLabels.Value().As<Napi::Array>();
}void _VkDebugUtilsMessengerCallbackDataEXT::SetpQueueLabels(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pQueueLabels.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pQueueLabels.Reset();
      this->instance.pQueueLabels = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels", "[object VkDebugUtilsLabelEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pQueueLabels = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels", "[object VkDebugUtilsLabelEXT]");
  
    return;
  }
}// cmdBufLabelCount
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetcmdBufLabelCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.cmdBufLabelCount);
}void _VkDebugUtilsMessengerCallbackDataEXT::SetcmdBufLabelCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.cmdBufLabelCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.cmdBufLabelCount", "Number");
  
    return;
  }
}// pCmdBufLabels
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetpCmdBufLabels(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCmdBufLabels.IsEmpty()) return env.Null();
  return this->pCmdBufLabels.Value().As<Napi::Array>();
}void _VkDebugUtilsMessengerCallbackDataEXT::SetpCmdBufLabels(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pCmdBufLabels.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pCmdBufLabels.Reset();
      this->instance.pCmdBufLabels = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels", "[object VkDebugUtilsLabelEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pCmdBufLabels = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels", "[object VkDebugUtilsLabelEXT]");
  
    return;
  }
}// objectCount
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetobjectCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectCount);
}void _VkDebugUtilsMessengerCallbackDataEXT::SetobjectCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.objectCount", "Number");
  
    return;
  }
}// pObjects
Napi::Value _VkDebugUtilsMessengerCallbackDataEXT::GetpObjects(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pObjects.IsEmpty()) return env.Null();
  return this->pObjects.Value().As<Napi::Array>();
}void _VkDebugUtilsMessengerCallbackDataEXT::SetpObjects(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pObjects.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pObjects.Reset();
      this->instance.pObjects = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pObjects", "[object VkDebugUtilsObjectNameInfoEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pObjects = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pObjects", "[object VkDebugUtilsObjectNameInfoEXT]");
  
    return;
  }
}
/** ## END VkDebugUtilsMessengerCallbackDataEXT ## **/

/** ## BEGIN VkDebugUtilsMessengerCreateInfoEXT ## **/

Napi::FunctionReference _VkDebugUtilsMessengerCreateInfoEXT::constructor;

_VkDebugUtilsMessengerCreateInfoEXT::_VkDebugUtilsMessengerCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugUtilsMessengerCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "messageSeverity");
      Napi::String sAccess4 = Napi::String::New(env, "messageType");
      Napi::String sAccess6 = Napi::String::New(env, "pUserData");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmessageSeverity(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmessageType(info, obj.Get(sAccess4));
      if (obj.Has(sAccess6)) this->SetpUserData(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkDebugUtilsMessengerCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugUtilsMessengerCreateInfoEXT::~_VkDebugUtilsMessengerCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  
  pUserData.Reset();
  
}

Napi::Object _VkDebugUtilsMessengerCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugUtilsMessengerCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugUtilsMessengerCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugUtilsMessengerCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugUtilsMessengerCreateInfoEXT::GetsType,
    &_VkDebugUtilsMessengerCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugUtilsMessengerCreateInfoEXT::GetpNext,
    &_VkDebugUtilsMessengerCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDebugUtilsMessengerCreateInfoEXT::Getflags,
    &_VkDebugUtilsMessengerCreateInfoEXT::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "messageSeverity",
    &_VkDebugUtilsMessengerCreateInfoEXT::GetmessageSeverity,
    &_VkDebugUtilsMessengerCreateInfoEXT::SetmessageSeverity,
    napi_enumerable
  ),
  InstanceAccessor(
    "messageType",
    &_VkDebugUtilsMessengerCreateInfoEXT::GetmessageType,
    &_VkDebugUtilsMessengerCreateInfoEXT::SetmessageType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pUserData",
    &_VkDebugUtilsMessengerCreateInfoEXT::GetpUserData,
    &_VkDebugUtilsMessengerCreateInfoEXT::SetpUserData,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugUtilsMessengerCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCreateInfoEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCreateInfoEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCreateInfoEXT *)0)->messageSeverity));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCreateInfoEXT *)0)->messageSeverity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCreateInfoEXT *)0)->messageType));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCreateInfoEXT *)0)->messageType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsMessengerCreateInfoEXT *)0)->pUserData));
    uint32_t byteLength = sizeof(((VkDebugUtilsMessengerCreateInfoEXT *)0)->pUserData);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugUtilsMessengerCreateInfoEXT::flush() {
  _VkDebugUtilsMessengerCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugUtilsMessengerCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugUtilsMessengerCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugUtilsMessengerCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDebugUtilsMessengerCreateInfoEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDebugUtilsMessengerCreateFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.flags", "Number");
  
    return;
  }
}// messageSeverity
Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetmessageSeverity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.messageSeverity);
}void _VkDebugUtilsMessengerCreateInfoEXT::SetmessageSeverity(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.messageSeverity = static_cast<VkDebugUtilsMessageSeverityFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.messageSeverity", "Number");
  
    return;
  }
}// messageType
Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetmessageType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.messageType);
}void _VkDebugUtilsMessengerCreateInfoEXT::SetmessageType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.messageType = static_cast<VkDebugUtilsMessageTypeFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.messageType", "Number");
  
    return;
  }
}// pUserData
Napi::Value _VkDebugUtilsMessengerCreateInfoEXT::GetpUserData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pUserData.IsEmpty()) return env.Null();
  return this->pUserData.Value().As<Napi::Object>();
}void _VkDebugUtilsMessengerCreateInfoEXT::SetpUserData(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pUserData = buffer.Data();
    this->pUserData.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pUserData = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.pUserData", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkDebugUtilsMessengerCreateInfoEXT ## **/

/** ## BEGIN VkDebugUtilsLabelEXT ## **/

Napi::FunctionReference _VkDebugUtilsLabelEXT::constructor;

_VkDebugUtilsLabelEXT::_VkDebugUtilsLabelEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugUtilsLabelEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
    vcolor = new std::vector<float>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "pLabelName");
      Napi::String sAccess3 = Napi::String::New(env, "color");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpLabelName(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setcolor(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDebugUtilsLabelEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugUtilsLabelEXT::~_VkDebugUtilsLabelEXT() {
  
  
  pNext.Reset();
  
  pLabelName.Reset();
  
  vcolor->clear();
  delete vcolor;
  
  color.Reset();
  
}

Napi::Object _VkDebugUtilsLabelEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugUtilsLabelEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugUtilsLabelEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugUtilsLabelEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugUtilsLabelEXT::GetsType,
    &_VkDebugUtilsLabelEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugUtilsLabelEXT::GetpNext,
    &_VkDebugUtilsLabelEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "pLabelName",
    &_VkDebugUtilsLabelEXT::GetpLabelName,
    &_VkDebugUtilsLabelEXT::SetpLabelName,
    napi_enumerable
  ),
  InstanceAccessor(
    "color",
    &_VkDebugUtilsLabelEXT::Getcolor,
    &_VkDebugUtilsLabelEXT::Setcolor,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugUtilsLabelEXT", func);
  return exports;
}

Napi::Value _VkDebugUtilsLabelEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugUtilsLabelEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsLabelEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugUtilsLabelEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsLabelEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugUtilsLabelEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsLabelEXT *)0)->pLabelName));
    uint32_t byteLength = sizeof(((VkDebugUtilsLabelEXT *)0)->pLabelName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsLabelEXT *)0)->color));
    uint32_t byteLength = sizeof(((VkDebugUtilsLabelEXT *)0)->color);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugUtilsLabelEXT::flush() {
  _VkDebugUtilsLabelEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->color.IsEmpty())) {
    Napi::Value value = self->color.Value();
    
    if (value.IsArray()) {
      // validate length
      if (value.As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '4' for 'VkDebugUtilsLabelEXT.color'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(this->instance.color, array.data(), sizeof(float) * 4);
    } else if (value.IsNull()) {
      memset(&this->instance.color, 0, sizeof(float));
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsLabelEXT.color", "Array");
  
      return false;
    }
  }
  return true;
}

// sType
Napi::Value _VkDebugUtilsLabelEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugUtilsLabelEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsLabelEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugUtilsLabelEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugUtilsLabelEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugUtilsLabelEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsLabelEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsLabelEXT.pNext", "[object Object]");
  
    return;
  }
}// pLabelName
Napi::Value _VkDebugUtilsLabelEXT::GetpLabelName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pLabelName.IsEmpty()) return env.Null();
  return this->pLabelName.Value().ToString();
}void _VkDebugUtilsLabelEXT::SetpLabelName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pLabelName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pLabelName) delete[] this->instance.pLabelName;
    this->instance.pLabelName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pLabelName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsLabelEXT.pLabelName", "String");
  
    return;
  }
}// color
Napi::Value _VkDebugUtilsLabelEXT::Getcolor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->color.IsEmpty()) return env.Null();
  return this->color.Value().As<Napi::Array>();
}void _VkDebugUtilsLabelEXT::Setcolor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->color.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->color.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsLabelEXT.color", "Array");
  
    return;
  }
}
/** ## END VkDebugUtilsLabelEXT ## **/

/** ## BEGIN VkDebugUtilsObjectTagInfoEXT ## **/

Napi::FunctionReference _VkDebugUtilsObjectTagInfoEXT::constructor;

_VkDebugUtilsObjectTagInfoEXT::_VkDebugUtilsObjectTagInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugUtilsObjectTagInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectType");
      Napi::String sAccess3 = Napi::String::New(env, "objectHandle");
      Napi::String sAccess4 = Napi::String::New(env, "tagName");
      Napi::String sAccess5 = Napi::String::New(env, "tagSize");
      Napi::String sAccess6 = Napi::String::New(env, "pTag");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectType(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetobjectHandle(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SettagName(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SettagSize(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpTag(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkDebugUtilsObjectTagInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugUtilsObjectTagInfoEXT::~_VkDebugUtilsObjectTagInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  
  
  pTag.Reset();
  
}

Napi::Object _VkDebugUtilsObjectTagInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugUtilsObjectTagInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugUtilsObjectTagInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugUtilsObjectTagInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugUtilsObjectTagInfoEXT::GetsType,
    &_VkDebugUtilsObjectTagInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugUtilsObjectTagInfoEXT::GetpNext,
    &_VkDebugUtilsObjectTagInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectType",
    &_VkDebugUtilsObjectTagInfoEXT::GetobjectType,
    &_VkDebugUtilsObjectTagInfoEXT::SetobjectType,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectHandle",
    &_VkDebugUtilsObjectTagInfoEXT::GetobjectHandle,
    &_VkDebugUtilsObjectTagInfoEXT::SetobjectHandle,
    napi_enumerable
  ),
  InstanceAccessor(
    "tagName",
    &_VkDebugUtilsObjectTagInfoEXT::GettagName,
    &_VkDebugUtilsObjectTagInfoEXT::SettagName,
    napi_enumerable
  ),
  InstanceAccessor(
    "tagSize",
    &_VkDebugUtilsObjectTagInfoEXT::GettagSize,
    &_VkDebugUtilsObjectTagInfoEXT::SettagSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "pTag",
    &_VkDebugUtilsObjectTagInfoEXT::GetpTag,
    &_VkDebugUtilsObjectTagInfoEXT::SetpTag,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugUtilsObjectTagInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->objectType));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->objectType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->objectHandle));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->objectHandle);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->tagName));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->tagName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->tagSize));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->tagSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectTagInfoEXT *)0)->pTag));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectTagInfoEXT *)0)->pTag);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugUtilsObjectTagInfoEXT::flush() {
  _VkDebugUtilsObjectTagInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugUtilsObjectTagInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugUtilsObjectTagInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugUtilsObjectTagInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// objectType
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetobjectType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectType);
}void _VkDebugUtilsObjectTagInfoEXT::SetobjectType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectType = static_cast<VkObjectType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.objectType", "Number");
  
    return;
  }
}// objectHandle
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetobjectHandle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectHandle);
}void _VkDebugUtilsObjectTagInfoEXT::SetobjectHandle(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectHandle = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.objectHandle", "Number");
  
    return;
  }
}// tagName
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GettagName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tagName);
}void _VkDebugUtilsObjectTagInfoEXT::SettagName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tagName = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.tagName", "Number");
  
    return;
  }
}// tagSize
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GettagSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tagSize);
}void _VkDebugUtilsObjectTagInfoEXT::SettagSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tagSize = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.tagSize", "Number");
  
    return;
  }
}// pTag
Napi::Value _VkDebugUtilsObjectTagInfoEXT::GetpTag(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pTag.IsEmpty()) return env.Null();
  return this->pTag.Value().As<Napi::Object>();
}void _VkDebugUtilsObjectTagInfoEXT::SetpTag(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pTag = buffer.Data();
    this->pTag.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pTag = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectTagInfoEXT.pTag", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkDebugUtilsObjectTagInfoEXT ## **/

/** ## BEGIN VkDebugUtilsObjectNameInfoEXT ## **/

Napi::FunctionReference _VkDebugUtilsObjectNameInfoEXT::constructor;

_VkDebugUtilsObjectNameInfoEXT::_VkDebugUtilsObjectNameInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugUtilsObjectNameInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectType");
      Napi::String sAccess3 = Napi::String::New(env, "objectHandle");
      Napi::String sAccess4 = Napi::String::New(env, "pObjectName");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectType(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetobjectHandle(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpObjectName(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDebugUtilsObjectNameInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugUtilsObjectNameInfoEXT::~_VkDebugUtilsObjectNameInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  pObjectName.Reset();
  
}

Napi::Object _VkDebugUtilsObjectNameInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugUtilsObjectNameInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugUtilsObjectNameInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugUtilsObjectNameInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugUtilsObjectNameInfoEXT::GetsType,
    &_VkDebugUtilsObjectNameInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugUtilsObjectNameInfoEXT::GetpNext,
    &_VkDebugUtilsObjectNameInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectType",
    &_VkDebugUtilsObjectNameInfoEXT::GetobjectType,
    &_VkDebugUtilsObjectNameInfoEXT::SetobjectType,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectHandle",
    &_VkDebugUtilsObjectNameInfoEXT::GetobjectHandle,
    &_VkDebugUtilsObjectNameInfoEXT::SetobjectHandle,
    napi_enumerable
  ),
  InstanceAccessor(
    "pObjectName",
    &_VkDebugUtilsObjectNameInfoEXT::GetpObjectName,
    &_VkDebugUtilsObjectNameInfoEXT::SetpObjectName,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugUtilsObjectNameInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectNameInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectNameInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectNameInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectNameInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectNameInfoEXT *)0)->objectType));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectNameInfoEXT *)0)->objectType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectNameInfoEXT *)0)->objectHandle));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectNameInfoEXT *)0)->objectHandle);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugUtilsObjectNameInfoEXT *)0)->pObjectName));
    uint32_t byteLength = sizeof(((VkDebugUtilsObjectNameInfoEXT *)0)->pObjectName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugUtilsObjectNameInfoEXT::flush() {
  _VkDebugUtilsObjectNameInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugUtilsObjectNameInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectNameInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugUtilsObjectNameInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugUtilsObjectNameInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugUtilsObjectNameInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectNameInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// objectType
Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetobjectType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectType);
}void _VkDebugUtilsObjectNameInfoEXT::SetobjectType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectType = static_cast<VkObjectType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectNameInfoEXT.objectType", "Number");
  
    return;
  }
}// objectHandle
Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetobjectHandle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectHandle);
}void _VkDebugUtilsObjectNameInfoEXT::SetobjectHandle(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectHandle = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectNameInfoEXT.objectHandle", "Number");
  
    return;
  }
}// pObjectName
Napi::Value _VkDebugUtilsObjectNameInfoEXT::GetpObjectName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pObjectName.IsEmpty()) return env.Null();
  return this->pObjectName.Value().ToString();
}void _VkDebugUtilsObjectNameInfoEXT::SetpObjectName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pObjectName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pObjectName) delete[] this->instance.pObjectName;
    this->instance.pObjectName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pObjectName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugUtilsObjectNameInfoEXT.pObjectName", "String");
  
    return;
  }
}
/** ## END VkDebugUtilsObjectNameInfoEXT ## **/

/** ## BEGIN VkDeviceQueueGlobalPriorityCreateInfoEXT ## **/

Napi::FunctionReference _VkDeviceQueueGlobalPriorityCreateInfoEXT::constructor;

_VkDeviceQueueGlobalPriorityCreateInfoEXT::_VkDeviceQueueGlobalPriorityCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceQueueGlobalPriorityCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "globalPriority");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetglobalPriority(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDeviceQueueGlobalPriorityCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceQueueGlobalPriorityCreateInfoEXT::~_VkDeviceQueueGlobalPriorityCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDeviceQueueGlobalPriorityCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceQueueGlobalPriorityCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetsType,
    &_VkDeviceQueueGlobalPriorityCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetpNext,
    &_VkDeviceQueueGlobalPriorityCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "globalPriority",
    &_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetglobalPriority,
    &_VkDeviceQueueGlobalPriorityCreateInfoEXT::SetglobalPriority,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceQueueGlobalPriorityCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkDeviceQueueGlobalPriorityCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceQueueGlobalPriorityCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueGlobalPriorityCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceQueueGlobalPriorityCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueGlobalPriorityCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceQueueGlobalPriorityCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueGlobalPriorityCreateInfoEXT *)0)->globalPriority));
    uint32_t byteLength = sizeof(((VkDeviceQueueGlobalPriorityCreateInfoEXT *)0)->globalPriority);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceQueueGlobalPriorityCreateInfoEXT::flush() {
  _VkDeviceQueueGlobalPriorityCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceQueueGlobalPriorityCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceQueueGlobalPriorityCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceQueueGlobalPriorityCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceQueueGlobalPriorityCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// globalPriority
Napi::Value _VkDeviceQueueGlobalPriorityCreateInfoEXT::GetglobalPriority(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.globalPriority);
}void _VkDeviceQueueGlobalPriorityCreateInfoEXT::SetglobalPriority(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.globalPriority = static_cast<VkQueueGlobalPriorityEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority", "Number");
  
    return;
  }
}
/** ## END VkDeviceQueueGlobalPriorityCreateInfoEXT ## **/

/** ## BEGIN VkShaderStatisticsInfoAMD ## **/

Napi::FunctionReference _VkShaderStatisticsInfoAMD::constructor;

_VkShaderStatisticsInfoAMD::_VkShaderStatisticsInfoAMD(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkShaderStatisticsInfoAMD>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vcomputeWorkGroupSize = new std::vector<uint32_t>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkShaderStatisticsInfoAMD constructor cannot be invoked without 'new'");
    }
  }
}

_VkShaderStatisticsInfoAMD::~_VkShaderStatisticsInfoAMD() {
  
  
  resourceUsage.Reset();
  
  
  
  
  
  vcomputeWorkGroupSize->clear();
  delete vcomputeWorkGroupSize;
  
  computeWorkGroupSize.Reset();
  
}

Napi::Object _VkShaderStatisticsInfoAMD::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkShaderStatisticsInfoAMD", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkShaderStatisticsInfoAMD::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkShaderStatisticsInfoAMD::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "shaderStageMask",
    &_VkShaderStatisticsInfoAMD::GetshaderStageMask,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "resourceUsage",
    &_VkShaderStatisticsInfoAMD::GetresourceUsage,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "numPhysicalVgprs",
    &_VkShaderStatisticsInfoAMD::GetnumPhysicalVgprs,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "numPhysicalSgprs",
    &_VkShaderStatisticsInfoAMD::GetnumPhysicalSgprs,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "numAvailableVgprs",
    &_VkShaderStatisticsInfoAMD::GetnumAvailableVgprs,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "numAvailableSgprs",
    &_VkShaderStatisticsInfoAMD::GetnumAvailableSgprs,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "computeWorkGroupSize",
    &_VkShaderStatisticsInfoAMD::GetcomputeWorkGroupSize,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkShaderStatisticsInfoAMD", func);
  return exports;
}

Napi::Value _VkShaderStatisticsInfoAMD::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkShaderStatisticsInfoAMD::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->shaderStageMask));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->shaderStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->resourceUsage));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->resourceUsage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->numPhysicalVgprs));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->numPhysicalVgprs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->numPhysicalSgprs));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->numPhysicalSgprs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->numAvailableVgprs));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->numAvailableVgprs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->numAvailableSgprs));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->numAvailableSgprs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderStatisticsInfoAMD *)0)->computeWorkGroupSize));
    uint32_t byteLength = sizeof(((VkShaderStatisticsInfoAMD *)0)->computeWorkGroupSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkShaderStatisticsInfoAMD::flush() {
  _VkShaderStatisticsInfoAMD *self = this;
  if (!(self->resourceUsage.IsEmpty())) {
    Napi::Value value = self->resourceUsage.Value();
    
  }if (!(self->computeWorkGroupSize.IsEmpty())) {
    Napi::Value value = self->computeWorkGroupSize.Value();
    
  }
  return true;
}

// shaderStageMask
Napi::Value _VkShaderStatisticsInfoAMD::GetshaderStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStageMask);
}// resourceUsage
Napi::Value _VkShaderStatisticsInfoAMD::GetresourceUsage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->resourceUsage.IsEmpty()) return env.Null();
  return this->resourceUsage.Value().As<Napi::Object>();
}// numPhysicalVgprs
Napi::Value _VkShaderStatisticsInfoAMD::GetnumPhysicalVgprs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.numPhysicalVgprs);
}// numPhysicalSgprs
Napi::Value _VkShaderStatisticsInfoAMD::GetnumPhysicalSgprs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.numPhysicalSgprs);
}// numAvailableVgprs
Napi::Value _VkShaderStatisticsInfoAMD::GetnumAvailableVgprs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.numAvailableVgprs);
}// numAvailableSgprs
Napi::Value _VkShaderStatisticsInfoAMD::GetnumAvailableSgprs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.numAvailableSgprs);
}// computeWorkGroupSize
Napi::Value _VkShaderStatisticsInfoAMD::GetcomputeWorkGroupSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->computeWorkGroupSize.IsEmpty()) return env.Null();
  return this->computeWorkGroupSize.Value().As<Napi::Array>();
}
/** ## END VkShaderStatisticsInfoAMD ## **/

/** ## BEGIN VkShaderResourceUsageAMD ## **/

Napi::FunctionReference _VkShaderResourceUsageAMD::constructor;

_VkShaderResourceUsageAMD::_VkShaderResourceUsageAMD(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkShaderResourceUsageAMD>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkShaderResourceUsageAMD constructor cannot be invoked without 'new'");
    }
  }
}

_VkShaderResourceUsageAMD::~_VkShaderResourceUsageAMD() {
  
  
  
  
  
  
}

Napi::Object _VkShaderResourceUsageAMD::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkShaderResourceUsageAMD", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkShaderResourceUsageAMD::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkShaderResourceUsageAMD::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "numUsedVgprs",
    &_VkShaderResourceUsageAMD::GetnumUsedVgprs,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "numUsedSgprs",
    &_VkShaderResourceUsageAMD::GetnumUsedSgprs,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "ldsSizePerLocalWorkGroup",
    &_VkShaderResourceUsageAMD::GetldsSizePerLocalWorkGroup,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "ldsUsageSizeInBytes",
    &_VkShaderResourceUsageAMD::GetldsUsageSizeInBytes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "scratchMemUsageInBytes",
    &_VkShaderResourceUsageAMD::GetscratchMemUsageInBytes,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkShaderResourceUsageAMD", func);
  return exports;
}

Napi::Value _VkShaderResourceUsageAMD::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkShaderResourceUsageAMD::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderResourceUsageAMD *)0)->numUsedVgprs));
    uint32_t byteLength = sizeof(((VkShaderResourceUsageAMD *)0)->numUsedVgprs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderResourceUsageAMD *)0)->numUsedSgprs));
    uint32_t byteLength = sizeof(((VkShaderResourceUsageAMD *)0)->numUsedSgprs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderResourceUsageAMD *)0)->ldsSizePerLocalWorkGroup));
    uint32_t byteLength = sizeof(((VkShaderResourceUsageAMD *)0)->ldsSizePerLocalWorkGroup);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderResourceUsageAMD *)0)->ldsUsageSizeInBytes));
    uint32_t byteLength = sizeof(((VkShaderResourceUsageAMD *)0)->ldsUsageSizeInBytes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderResourceUsageAMD *)0)->scratchMemUsageInBytes));
    uint32_t byteLength = sizeof(((VkShaderResourceUsageAMD *)0)->scratchMemUsageInBytes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkShaderResourceUsageAMD::flush() {
  _VkShaderResourceUsageAMD *self = this;
  
  return true;
}

// numUsedVgprs
Napi::Value _VkShaderResourceUsageAMD::GetnumUsedVgprs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.numUsedVgprs);
}// numUsedSgprs
Napi::Value _VkShaderResourceUsageAMD::GetnumUsedSgprs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.numUsedSgprs);
}// ldsSizePerLocalWorkGroup
Napi::Value _VkShaderResourceUsageAMD::GetldsSizePerLocalWorkGroup(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ldsSizePerLocalWorkGroup);
}// ldsUsageSizeInBytes
Napi::Value _VkShaderResourceUsageAMD::GetldsUsageSizeInBytes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ldsUsageSizeInBytes);
}// scratchMemUsageInBytes
Napi::Value _VkShaderResourceUsageAMD::GetscratchMemUsageInBytes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.scratchMemUsageInBytes);
}
/** ## END VkShaderResourceUsageAMD ## **/

/** ## BEGIN VkPhysicalDeviceShaderDrawParameterFeatures ## **/

Napi::FunctionReference _VkPhysicalDeviceShaderDrawParameterFeatures::constructor;

_VkPhysicalDeviceShaderDrawParameterFeatures::_VkPhysicalDeviceShaderDrawParameterFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceShaderDrawParameterFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "shaderDrawParameters");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetshaderDrawParameters(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceShaderDrawParameterFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceShaderDrawParameterFeatures::~_VkPhysicalDeviceShaderDrawParameterFeatures() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceShaderDrawParameterFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceShaderDrawParameterFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceShaderDrawParameterFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceShaderDrawParameterFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceShaderDrawParameterFeatures::GetsType,
    &_VkPhysicalDeviceShaderDrawParameterFeatures::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceShaderDrawParameterFeatures::GetpNext,
    &_VkPhysicalDeviceShaderDrawParameterFeatures::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderDrawParameters",
    &_VkPhysicalDeviceShaderDrawParameterFeatures::GetshaderDrawParameters,
    &_VkPhysicalDeviceShaderDrawParameterFeatures::SetshaderDrawParameters,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceShaderDrawParameterFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceShaderDrawParameterFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceShaderDrawParameterFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderDrawParameterFeatures *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderDrawParameterFeatures *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderDrawParameterFeatures *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderDrawParameterFeatures *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceShaderDrawParameterFeatures *)0)->shaderDrawParameters));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceShaderDrawParameterFeatures *)0)->shaderDrawParameters);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceShaderDrawParameterFeatures::flush() {
  _VkPhysicalDeviceShaderDrawParameterFeatures *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceShaderDrawParameterFeatures::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceShaderDrawParameterFeatures::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderDrawParameterFeatures.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceShaderDrawParameterFeatures::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceShaderDrawParameterFeatures::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceShaderDrawParameterFeatures.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderDrawParameterFeatures.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderDrawParameterFeatures.pNext", "[object Object]");
  
    return;
  }
}// shaderDrawParameters
Napi::Value _VkPhysicalDeviceShaderDrawParameterFeatures::GetshaderDrawParameters(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderDrawParameters);
}void _VkPhysicalDeviceShaderDrawParameterFeatures::SetshaderDrawParameters(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderDrawParameters = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderDrawParameters = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceShaderDrawParameterFeatures.shaderDrawParameters", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceShaderDrawParameterFeatures ## **/

/** ## BEGIN VkDescriptorSetLayoutSupportKHR ## **/

Napi::FunctionReference _VkDescriptorSetLayoutSupportKHR::constructor;

_VkDescriptorSetLayoutSupportKHR::_VkDescriptorSetLayoutSupportKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetLayoutSupportKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetLayoutSupportKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetLayoutSupportKHR::~_VkDescriptorSetLayoutSupportKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDescriptorSetLayoutSupportKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetLayoutSupportKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetLayoutSupportKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetLayoutSupportKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetLayoutSupportKHR::GetsType,
    &_VkDescriptorSetLayoutSupportKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetLayoutSupportKHR::GetpNext,
    &_VkDescriptorSetLayoutSupportKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "supported",
    &_VkDescriptorSetLayoutSupportKHR::Getsupported,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetLayoutSupportKHR", func);
  return exports;
}

Napi::Value _VkDescriptorSetLayoutSupportKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetLayoutSupportKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutSupportKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutSupportKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutSupportKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutSupportKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutSupportKHR *)0)->supported));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutSupportKHR *)0)->supported);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetLayoutSupportKHR::flush() {
  _VkDescriptorSetLayoutSupportKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetLayoutSupportKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetLayoutSupportKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutSupportKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetLayoutSupportKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetLayoutSupportKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutSupportKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutSupportKHR.pNext", "[object Object]");
  
    return;
  }
}// supported
Napi::Value _VkDescriptorSetLayoutSupportKHR::Getsupported(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supported);
}
/** ## END VkDescriptorSetLayoutSupportKHR ## **/

/** ## BEGIN VkDescriptorSetLayoutSupport ## **/

Napi::FunctionReference _VkDescriptorSetLayoutSupport::constructor;

_VkDescriptorSetLayoutSupport::_VkDescriptorSetLayoutSupport(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetLayoutSupport>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetLayoutSupport constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetLayoutSupport::~_VkDescriptorSetLayoutSupport() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDescriptorSetLayoutSupport::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetLayoutSupport", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetLayoutSupport::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetLayoutSupport::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetLayoutSupport::GetsType,
    &_VkDescriptorSetLayoutSupport::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetLayoutSupport::GetpNext,
    &_VkDescriptorSetLayoutSupport::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "supported",
    &_VkDescriptorSetLayoutSupport::Getsupported,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetLayoutSupport", func);
  return exports;
}

Napi::Value _VkDescriptorSetLayoutSupport::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetLayoutSupport::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutSupport *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutSupport *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutSupport *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutSupport *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutSupport *)0)->supported));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutSupport *)0)->supported);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetLayoutSupport::flush() {
  _VkDescriptorSetLayoutSupport *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetLayoutSupport::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetLayoutSupport::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutSupport.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetLayoutSupport::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetLayoutSupport::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkDescriptorSetLayoutSupport.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutSupport.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutSupport.pNext", "[object Object]");
  
    return;
  }
}// supported
Napi::Value _VkDescriptorSetLayoutSupport::Getsupported(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supported);
}
/** ## END VkDescriptorSetLayoutSupport ## **/

/** ## BEGIN VkPhysicalDeviceMaintenance3PropertiesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceMaintenance3PropertiesKHR::constructor;

_VkPhysicalDeviceMaintenance3PropertiesKHR::_VkPhysicalDeviceMaintenance3PropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMaintenance3PropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMaintenance3PropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMaintenance3PropertiesKHR::~_VkPhysicalDeviceMaintenance3PropertiesKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceMaintenance3PropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMaintenance3PropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMaintenance3PropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMaintenance3PropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMaintenance3PropertiesKHR::GetsType,
    &_VkPhysicalDeviceMaintenance3PropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMaintenance3PropertiesKHR::GetpNext,
    &_VkPhysicalDeviceMaintenance3PropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerSetDescriptors",
    &_VkPhysicalDeviceMaintenance3PropertiesKHR::GetmaxPerSetDescriptors,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMemoryAllocationSize",
    &_VkPhysicalDeviceMaintenance3PropertiesKHR::GetmaxMemoryAllocationSize,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMaintenance3PropertiesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMaintenance3PropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMaintenance3PropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->maxPerSetDescriptors));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->maxPerSetDescriptors);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->maxMemoryAllocationSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3PropertiesKHR *)0)->maxMemoryAllocationSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMaintenance3PropertiesKHR::flush() {
  _VkPhysicalDeviceMaintenance3PropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMaintenance3PropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMaintenance3PropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMaintenance3PropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMaintenance3PropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMaintenance3PropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMaintenance3PropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMaintenance3PropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMaintenance3PropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// maxPerSetDescriptors
Napi::Value _VkPhysicalDeviceMaintenance3PropertiesKHR::GetmaxPerSetDescriptors(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerSetDescriptors);
}// maxMemoryAllocationSize
Napi::Value _VkPhysicalDeviceMaintenance3PropertiesKHR::GetmaxMemoryAllocationSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMemoryAllocationSize);
}
/** ## END VkPhysicalDeviceMaintenance3PropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceMaintenance3Properties ## **/

Napi::FunctionReference _VkPhysicalDeviceMaintenance3Properties::constructor;

_VkPhysicalDeviceMaintenance3Properties::_VkPhysicalDeviceMaintenance3Properties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMaintenance3Properties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMaintenance3Properties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMaintenance3Properties::~_VkPhysicalDeviceMaintenance3Properties() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceMaintenance3Properties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMaintenance3Properties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMaintenance3Properties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMaintenance3Properties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMaintenance3Properties::GetsType,
    &_VkPhysicalDeviceMaintenance3Properties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMaintenance3Properties::GetpNext,
    &_VkPhysicalDeviceMaintenance3Properties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerSetDescriptors",
    &_VkPhysicalDeviceMaintenance3Properties::GetmaxPerSetDescriptors,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMemoryAllocationSize",
    &_VkPhysicalDeviceMaintenance3Properties::GetmaxMemoryAllocationSize,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMaintenance3Properties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMaintenance3Properties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMaintenance3Properties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3Properties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3Properties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3Properties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3Properties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3Properties *)0)->maxPerSetDescriptors));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3Properties *)0)->maxPerSetDescriptors);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMaintenance3Properties *)0)->maxMemoryAllocationSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMaintenance3Properties *)0)->maxMemoryAllocationSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMaintenance3Properties::flush() {
  _VkPhysicalDeviceMaintenance3Properties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMaintenance3Properties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMaintenance3Properties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMaintenance3Properties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMaintenance3Properties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMaintenance3Properties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMaintenance3Properties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMaintenance3Properties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMaintenance3Properties.pNext", "[object Object]");
  
    return;
  }
}// maxPerSetDescriptors
Napi::Value _VkPhysicalDeviceMaintenance3Properties::GetmaxPerSetDescriptors(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerSetDescriptors);
}// maxMemoryAllocationSize
Napi::Value _VkPhysicalDeviceMaintenance3Properties::GetmaxMemoryAllocationSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMemoryAllocationSize);
}
/** ## END VkPhysicalDeviceMaintenance3Properties ## **/

/** ## BEGIN VkShaderModuleValidationCacheCreateInfoEXT ## **/

Napi::FunctionReference _VkShaderModuleValidationCacheCreateInfoEXT::constructor;

_VkShaderModuleValidationCacheCreateInfoEXT::_VkShaderModuleValidationCacheCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkShaderModuleValidationCacheCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "validationCache");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetvalidationCache(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkShaderModuleValidationCacheCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkShaderModuleValidationCacheCreateInfoEXT::~_VkShaderModuleValidationCacheCreateInfoEXT() {
  
  
  pNext.Reset();
  
  validationCache.Reset();
  
}

Napi::Object _VkShaderModuleValidationCacheCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkShaderModuleValidationCacheCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkShaderModuleValidationCacheCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkShaderModuleValidationCacheCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkShaderModuleValidationCacheCreateInfoEXT::GetsType,
    &_VkShaderModuleValidationCacheCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkShaderModuleValidationCacheCreateInfoEXT::GetpNext,
    &_VkShaderModuleValidationCacheCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "validationCache",
    &_VkShaderModuleValidationCacheCreateInfoEXT::GetvalidationCache,
    &_VkShaderModuleValidationCacheCreateInfoEXT::SetvalidationCache,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkShaderModuleValidationCacheCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkShaderModuleValidationCacheCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkShaderModuleValidationCacheCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleValidationCacheCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkShaderModuleValidationCacheCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleValidationCacheCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkShaderModuleValidationCacheCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleValidationCacheCreateInfoEXT *)0)->validationCache));
    uint32_t byteLength = sizeof(((VkShaderModuleValidationCacheCreateInfoEXT *)0)->validationCache);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkShaderModuleValidationCacheCreateInfoEXT::flush() {
  _VkShaderModuleValidationCacheCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkShaderModuleValidationCacheCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkShaderModuleValidationCacheCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkShaderModuleValidationCacheCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkShaderModuleValidationCacheCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkShaderModuleValidationCacheCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// validationCache
Napi::Value _VkShaderModuleValidationCacheCreateInfoEXT::GetvalidationCache(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->validationCache.IsEmpty()) return env.Null();
  return this->validationCache.Value().As<Napi::Object>();
}void _VkShaderModuleValidationCacheCreateInfoEXT::SetvalidationCache(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkValidationCacheEXT::constructor.Value())) {
      
      this->validationCache.Reset(value.ToObject(), 1);
      _VkValidationCacheEXT* inst = Napi::ObjectWrap<_VkValidationCacheEXT>::Unwrap(obj);
      ;
      this->instance.validationCache = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.validationCache", "[object VkValidationCacheEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->validationCache.Reset();
    this->instance.validationCache = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.validationCache", "[object VkValidationCacheEXT]");
  
    return;
  }
}
/** ## END VkShaderModuleValidationCacheCreateInfoEXT ## **/

/** ## BEGIN VkValidationCacheCreateInfoEXT ## **/

Napi::FunctionReference _VkValidationCacheCreateInfoEXT::constructor;

_VkValidationCacheCreateInfoEXT::_VkValidationCacheCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkValidationCacheCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "initialDataSize");
      Napi::String sAccess4 = Napi::String::New(env, "pInitialData");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetinitialDataSize(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpInitialData(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkValidationCacheCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkValidationCacheCreateInfoEXT::~_VkValidationCacheCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  pInitialData.Reset();
  
}

Napi::Object _VkValidationCacheCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkValidationCacheCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkValidationCacheCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkValidationCacheCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkValidationCacheCreateInfoEXT::GetsType,
    &_VkValidationCacheCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkValidationCacheCreateInfoEXT::GetpNext,
    &_VkValidationCacheCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkValidationCacheCreateInfoEXT::Getflags,
    &_VkValidationCacheCreateInfoEXT::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "initialDataSize",
    &_VkValidationCacheCreateInfoEXT::GetinitialDataSize,
    &_VkValidationCacheCreateInfoEXT::SetinitialDataSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "pInitialData",
    &_VkValidationCacheCreateInfoEXT::GetpInitialData,
    &_VkValidationCacheCreateInfoEXT::SetpInitialData,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkValidationCacheCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkValidationCacheCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkValidationCacheCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationCacheCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkValidationCacheCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationCacheCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkValidationCacheCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationCacheCreateInfoEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkValidationCacheCreateInfoEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationCacheCreateInfoEXT *)0)->initialDataSize));
    uint32_t byteLength = sizeof(((VkValidationCacheCreateInfoEXT *)0)->initialDataSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationCacheCreateInfoEXT *)0)->pInitialData));
    uint32_t byteLength = sizeof(((VkValidationCacheCreateInfoEXT *)0)->pInitialData);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkValidationCacheCreateInfoEXT::flush() {
  _VkValidationCacheCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkValidationCacheCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkValidationCacheCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkValidationCacheCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkValidationCacheCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkValidationCacheCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkValidationCacheCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkValidationCacheCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkValidationCacheCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkValidationCacheCreateInfoEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkValidationCacheCreateInfoEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkValidationCacheCreateFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkValidationCacheCreateInfoEXT.flags", "Number");
  
    return;
  }
}// initialDataSize
Napi::Value _VkValidationCacheCreateInfoEXT::GetinitialDataSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.initialDataSize);
}void _VkValidationCacheCreateInfoEXT::SetinitialDataSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.initialDataSize = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkValidationCacheCreateInfoEXT.initialDataSize", "Number");
  
    return;
  }
}// pInitialData
Napi::Value _VkValidationCacheCreateInfoEXT::GetpInitialData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pInitialData.IsEmpty()) return env.Null();
  return this->pInitialData.Value().As<Napi::Object>();
}void _VkValidationCacheCreateInfoEXT::SetpInitialData(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pInitialData = buffer.Data();
    this->pInitialData.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pInitialData = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkValidationCacheCreateInfoEXT.pInitialData", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkValidationCacheCreateInfoEXT ## **/

/** ## BEGIN VkImageFormatListCreateInfoKHR ## **/

Napi::FunctionReference _VkImageFormatListCreateInfoKHR::constructor;

_VkImageFormatListCreateInfoKHR::_VkImageFormatListCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageFormatListCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "viewFormatCount");
      Napi::String sAccess3 = Napi::String::New(env, "pViewFormats");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetviewFormatCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpViewFormats(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkImageFormatListCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageFormatListCreateInfoKHR::~_VkImageFormatListCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  pViewFormats.Reset();
  
}

Napi::Object _VkImageFormatListCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageFormatListCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageFormatListCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageFormatListCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageFormatListCreateInfoKHR::GetsType,
    &_VkImageFormatListCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageFormatListCreateInfoKHR::GetpNext,
    &_VkImageFormatListCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewFormatCount",
    &_VkImageFormatListCreateInfoKHR::GetviewFormatCount,
    &_VkImageFormatListCreateInfoKHR::SetviewFormatCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewFormats",
    &_VkImageFormatListCreateInfoKHR::GetpViewFormats,
    &_VkImageFormatListCreateInfoKHR::SetpViewFormats,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageFormatListCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkImageFormatListCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageFormatListCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatListCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageFormatListCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatListCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageFormatListCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatListCreateInfoKHR *)0)->viewFormatCount));
    uint32_t byteLength = sizeof(((VkImageFormatListCreateInfoKHR *)0)->viewFormatCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatListCreateInfoKHR *)0)->pViewFormats));
    uint32_t byteLength = sizeof(((VkImageFormatListCreateInfoKHR *)0)->pViewFormats);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageFormatListCreateInfoKHR::flush() {
  _VkImageFormatListCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageFormatListCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageFormatListCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatListCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageFormatListCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageFormatListCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImageFormatListCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImageFormatListCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatListCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// viewFormatCount
Napi::Value _VkImageFormatListCreateInfoKHR::GetviewFormatCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewFormatCount);
}void _VkImageFormatListCreateInfoKHR::SetviewFormatCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewFormatCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatListCreateInfoKHR.viewFormatCount", "Number");
  
    return;
  }
}// pViewFormats
Napi::Value _VkImageFormatListCreateInfoKHR::GetpViewFormats(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewFormats.IsEmpty()) return env.Null();
  return this->pViewFormats.Value().As<Napi::TypedArray>();
}void _VkImageFormatListCreateInfoKHR::SetpViewFormats(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pViewFormats.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkImageFormatListCreateInfoKHR.pViewFormats", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pViewFormats.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkImageFormatListCreateInfoKHR.pViewFormats", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pViewFormats = reinterpret_cast<const VkFormat *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pViewFormats = nullptr;
  }
}
/** ## END VkImageFormatListCreateInfoKHR ## **/

/** ## BEGIN VkPipelineCoverageModulationStateCreateInfoNV ## **/

Napi::FunctionReference _VkPipelineCoverageModulationStateCreateInfoNV::constructor;

_VkPipelineCoverageModulationStateCreateInfoNV::_VkPipelineCoverageModulationStateCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "coverageModulationMode");
      Napi::String sAccess4 = Napi::String::New(env, "coverageModulationTableEnable");
      Napi::String sAccess5 = Napi::String::New(env, "coverageModulationTableCount");
      Napi::String sAccess6 = Napi::String::New(env, "pCoverageModulationTable");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetcoverageModulationMode(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcoverageModulationTableEnable(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetcoverageModulationTableCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpCoverageModulationTable(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPipelineCoverageModulationStateCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineCoverageModulationStateCreateInfoNV::~_VkPipelineCoverageModulationStateCreateInfoNV() {
  
  
  pNext.Reset();
  
  
  
  
  
  pCoverageModulationTable.Reset();
  
}

Napi::Object _VkPipelineCoverageModulationStateCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineCoverageModulationStateCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineCoverageModulationStateCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineCoverageModulationStateCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineCoverageModulationStateCreateInfoNV::GetsType,
    &_VkPipelineCoverageModulationStateCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineCoverageModulationStateCreateInfoNV::GetpNext,
    &_VkPipelineCoverageModulationStateCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineCoverageModulationStateCreateInfoNV::Getflags,
    &_VkPipelineCoverageModulationStateCreateInfoNV::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "coverageModulationMode",
    &_VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationMode,
    &_VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "coverageModulationTableEnable",
    &_VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationTableEnable,
    &_VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationTableEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "coverageModulationTableCount",
    &_VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationTableCount,
    &_VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationTableCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCoverageModulationTable",
    &_VkPipelineCoverageModulationStateCreateInfoNV::GetpCoverageModulationTable,
    &_VkPipelineCoverageModulationStateCreateInfoNV::SetpCoverageModulationTable,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineCoverageModulationStateCreateInfoNV", func);
  return exports;
}

Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->coverageModulationMode));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->coverageModulationMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->coverageModulationTableEnable));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->coverageModulationTableEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->coverageModulationTableCount));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->coverageModulationTableCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->pCoverageModulationTable));
    uint32_t byteLength = sizeof(((VkPipelineCoverageModulationStateCreateInfoNV *)0)->pCoverageModulationTable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineCoverageModulationStateCreateInfoNV::flush() {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineCoverageModulationStateCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineCoverageModulationStateCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineCoverageModulationStateCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineCoverageModulationStateCreateInfoNV::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineCoverageModulationStateCreateFlagsNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.flags", "Number");
  
    return;
  }
}// coverageModulationMode
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.coverageModulationMode);
}void _VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.coverageModulationMode = static_cast<VkCoverageModulationModeNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode", "Number");
  
    return;
  }
}// coverageModulationTableEnable
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationTableEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.coverageModulationTableEnable);
}void _VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationTableEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.coverageModulationTableEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.coverageModulationTableEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableEnable", "Number");
  
    return;
  }
}// coverageModulationTableCount
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationTableCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.coverageModulationTableCount);
}void _VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationTableCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.coverageModulationTableCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount", "Number");
  
    return;
  }
}// pCoverageModulationTable
Napi::Value _VkPipelineCoverageModulationStateCreateInfoNV::GetpCoverageModulationTable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCoverageModulationTable.IsEmpty()) return env.Null();
  return this->pCoverageModulationTable.Value().As<Napi::TypedArray>();
}void _VkPipelineCoverageModulationStateCreateInfoNV::SetpCoverageModulationTable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_float32_array) {
        this->pCoverageModulationTable.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable", "Float32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCoverageModulationTable.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable", "Float32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCoverageModulationTable = getTypedArrayData<float>(value, nullptr);
  } else {
    this->instance.pCoverageModulationTable = nullptr;
  }
}
/** ## END VkPipelineCoverageModulationStateCreateInfoNV ## **/

/** ## BEGIN VkPipelineColorBlendAdvancedStateCreateInfoEXT ## **/

Napi::FunctionReference _VkPipelineColorBlendAdvancedStateCreateInfoEXT::constructor;

_VkPipelineColorBlendAdvancedStateCreateInfoEXT::_VkPipelineColorBlendAdvancedStateCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcPremultiplied");
      Napi::String sAccess3 = Napi::String::New(env, "dstPremultiplied");
      Napi::String sAccess4 = Napi::String::New(env, "blendOverlap");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcPremultiplied(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstPremultiplied(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetblendOverlap(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineColorBlendAdvancedStateCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineColorBlendAdvancedStateCreateInfoEXT::~_VkPipelineColorBlendAdvancedStateCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPipelineColorBlendAdvancedStateCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineColorBlendAdvancedStateCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetsType,
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetpNext,
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcPremultiplied",
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetsrcPremultiplied,
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetsrcPremultiplied,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstPremultiplied",
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetdstPremultiplied,
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetdstPremultiplied,
    napi_enumerable
  ),
  InstanceAccessor(
    "blendOverlap",
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetblendOverlap,
    &_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetblendOverlap,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineColorBlendAdvancedStateCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->srcPremultiplied));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->srcPremultiplied);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->dstPremultiplied));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->dstPremultiplied);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->blendOverlap));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAdvancedStateCreateInfoEXT *)0)->blendOverlap);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineColorBlendAdvancedStateCreateInfoEXT::flush() {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// srcPremultiplied
Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetsrcPremultiplied(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcPremultiplied);
}void _VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetsrcPremultiplied(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.srcPremultiplied = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.srcPremultiplied = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.srcPremultiplied", "Number");
  
    return;
  }
}// dstPremultiplied
Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetdstPremultiplied(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstPremultiplied);
}void _VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetdstPremultiplied(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.dstPremultiplied = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.dstPremultiplied = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.dstPremultiplied", "Number");
  
    return;
  }
}// blendOverlap
Napi::Value _VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetblendOverlap(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.blendOverlap);
}void _VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetblendOverlap(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.blendOverlap = static_cast<VkBlendOverlapEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap", "Number");
  
    return;
  }
}
/** ## END VkPipelineColorBlendAdvancedStateCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::constructor;

_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::~_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetsType,
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendMaxColorAttachments",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendMaxColorAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendIndependentBlend",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendIndependentBlend,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendNonPremultipliedSrcColor",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendNonPremultipliedSrcColor,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendNonPremultipliedDstColor",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendNonPremultipliedDstColor,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendCorrelatedOverlap",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendCorrelatedOverlap,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendAllOperations",
    &_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendAllOperations,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendMaxColorAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendMaxColorAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendIndependentBlend));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendIndependentBlend);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendNonPremultipliedSrcColor));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendNonPremultipliedSrcColor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendNonPremultipliedDstColor));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendNonPremultipliedDstColor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendCorrelatedOverlap));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendCorrelatedOverlap);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendAllOperations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)0)->advancedBlendAllOperations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::flush() {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// advancedBlendMaxColorAttachments
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendMaxColorAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendMaxColorAttachments);
}// advancedBlendIndependentBlend
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendIndependentBlend(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendIndependentBlend);
}// advancedBlendNonPremultipliedSrcColor
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendNonPremultipliedSrcColor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendNonPremultipliedSrcColor);
}// advancedBlendNonPremultipliedDstColor
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendNonPremultipliedDstColor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendNonPremultipliedDstColor);
}// advancedBlendCorrelatedOverlap
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendCorrelatedOverlap(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendCorrelatedOverlap);
}// advancedBlendAllOperations
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendAllOperations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendAllOperations);
}
/** ## END VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::constructor;

_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "advancedBlendCoherentOperations");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetadvancedBlendCoherentOperations(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::~_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetsType,
    &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetpNext,
    &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "advancedBlendCoherentOperations",
    &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetadvancedBlendCoherentOperations,
    &_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetadvancedBlendCoherentOperations,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)0)->advancedBlendCoherentOperations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)0)->advancedBlendCoherentOperations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::flush() {
  _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext", "[object Object]");
  
    return;
  }
}// advancedBlendCoherentOperations
Napi::Value _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetadvancedBlendCoherentOperations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.advancedBlendCoherentOperations);
}void _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetadvancedBlendCoherentOperations(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.advancedBlendCoherentOperations = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.advancedBlendCoherentOperations = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.advancedBlendCoherentOperations", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ## **/

/** ## BEGIN VkSamplerReductionModeCreateInfoEXT ## **/

Napi::FunctionReference _VkSamplerReductionModeCreateInfoEXT::constructor;

_VkSamplerReductionModeCreateInfoEXT::_VkSamplerReductionModeCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerReductionModeCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "reductionMode");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetreductionMode(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSamplerReductionModeCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerReductionModeCreateInfoEXT::~_VkSamplerReductionModeCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSamplerReductionModeCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerReductionModeCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerReductionModeCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerReductionModeCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerReductionModeCreateInfoEXT::GetsType,
    &_VkSamplerReductionModeCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerReductionModeCreateInfoEXT::GetpNext,
    &_VkSamplerReductionModeCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "reductionMode",
    &_VkSamplerReductionModeCreateInfoEXT::GetreductionMode,
    &_VkSamplerReductionModeCreateInfoEXT::SetreductionMode,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerReductionModeCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkSamplerReductionModeCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerReductionModeCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerReductionModeCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerReductionModeCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerReductionModeCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerReductionModeCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerReductionModeCreateInfoEXT *)0)->reductionMode));
    uint32_t byteLength = sizeof(((VkSamplerReductionModeCreateInfoEXT *)0)->reductionMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerReductionModeCreateInfoEXT::flush() {
  _VkSamplerReductionModeCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSamplerReductionModeCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerReductionModeCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerReductionModeCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerReductionModeCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerReductionModeCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSamplerReductionModeCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSamplerReductionModeCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerReductionModeCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// reductionMode
Napi::Value _VkSamplerReductionModeCreateInfoEXT::GetreductionMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.reductionMode);
}void _VkSamplerReductionModeCreateInfoEXT::SetreductionMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.reductionMode = static_cast<VkSamplerReductionModeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerReductionModeCreateInfoEXT.reductionMode", "Number");
  
    return;
  }
}
/** ## END VkSamplerReductionModeCreateInfoEXT ## **/

/** ## BEGIN VkMultisamplePropertiesEXT ## **/

Napi::FunctionReference _VkMultisamplePropertiesEXT::constructor;

_VkMultisamplePropertiesEXT::_VkMultisamplePropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMultisamplePropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMultisamplePropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkMultisamplePropertiesEXT::~_VkMultisamplePropertiesEXT() {
  
  
  pNext.Reset();
  
  maxSampleLocationGridSize.Reset();
  
}

Napi::Object _VkMultisamplePropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMultisamplePropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMultisamplePropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMultisamplePropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMultisamplePropertiesEXT::GetsType,
    &_VkMultisamplePropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMultisamplePropertiesEXT::GetpNext,
    &_VkMultisamplePropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSampleLocationGridSize",
    &_VkMultisamplePropertiesEXT::GetmaxSampleLocationGridSize,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMultisamplePropertiesEXT", func);
  return exports;
}

Napi::Value _VkMultisamplePropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMultisamplePropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMultisamplePropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkMultisamplePropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMultisamplePropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMultisamplePropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMultisamplePropertiesEXT *)0)->maxSampleLocationGridSize));
    uint32_t byteLength = sizeof(((VkMultisamplePropertiesEXT *)0)->maxSampleLocationGridSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMultisamplePropertiesEXT::flush() {
  _VkMultisamplePropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->maxSampleLocationGridSize.IsEmpty())) {
    Napi::Value value = self->maxSampleLocationGridSize.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMultisamplePropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMultisamplePropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMultisamplePropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMultisamplePropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMultisamplePropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMultisamplePropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMultisamplePropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMultisamplePropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// maxSampleLocationGridSize
Napi::Value _VkMultisamplePropertiesEXT::GetmaxSampleLocationGridSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxSampleLocationGridSize.IsEmpty()) return env.Null();
  return this->maxSampleLocationGridSize.Value().As<Napi::Object>();
}
/** ## END VkMultisamplePropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceSampleLocationsPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceSampleLocationsPropertiesEXT::constructor;

_VkPhysicalDeviceSampleLocationsPropertiesEXT::_VkPhysicalDeviceSampleLocationsPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
    vsampleLocationCoordinateRange = new std::vector<float>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSampleLocationsPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSampleLocationsPropertiesEXT::~_VkPhysicalDeviceSampleLocationsPropertiesEXT() {
  
  
  pNext.Reset();
  
  
  maxSampleLocationGridSize.Reset();
  
  vsampleLocationCoordinateRange->clear();
  delete vsampleLocationCoordinateRange;
  
  sampleLocationCoordinateRange.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceSampleLocationsPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSampleLocationsPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsType,
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationSampleCounts",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSampleLocationGridSize",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmaxSampleLocationGridSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationCoordinateRange",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationCoordinateRange,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationSubPixelBits",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationSubPixelBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "variableSampleLocations",
    &_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetvariableSampleLocations,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSampleLocationsPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sampleLocationSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sampleLocationSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->maxSampleLocationGridSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->maxSampleLocationGridSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sampleLocationCoordinateRange));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sampleLocationCoordinateRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sampleLocationSubPixelBits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->sampleLocationSubPixelBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->variableSampleLocations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSampleLocationsPropertiesEXT *)0)->variableSampleLocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSampleLocationsPropertiesEXT::flush() {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->maxSampleLocationGridSize.IsEmpty())) {
    Napi::Value value = self->maxSampleLocationGridSize.Value();
    
  }if (!(self->sampleLocationCoordinateRange.IsEmpty())) {
    Napi::Value value = self->sampleLocationCoordinateRange.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSampleLocationsPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSampleLocationsPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSampleLocationsPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// sampleLocationSampleCounts
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleLocationSampleCounts);
}// maxSampleLocationGridSize
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmaxSampleLocationGridSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxSampleLocationGridSize.IsEmpty()) return env.Null();
  return this->maxSampleLocationGridSize.Value().As<Napi::Object>();
}// sampleLocationCoordinateRange
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationCoordinateRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sampleLocationCoordinateRange.IsEmpty()) return env.Null();
  return this->sampleLocationCoordinateRange.Value().As<Napi::Array>();
}// sampleLocationSubPixelBits
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationSubPixelBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleLocationSubPixelBits);
}// variableSampleLocations
Napi::Value _VkPhysicalDeviceSampleLocationsPropertiesEXT::GetvariableSampleLocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.variableSampleLocations);
}
/** ## END VkPhysicalDeviceSampleLocationsPropertiesEXT ## **/

/** ## BEGIN VkPipelineSampleLocationsStateCreateInfoEXT ## **/

Napi::FunctionReference _VkPipelineSampleLocationsStateCreateInfoEXT::constructor;

_VkPipelineSampleLocationsStateCreateInfoEXT::_VkPipelineSampleLocationsStateCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "sampleLocationsEnable");
      Napi::String sAccess3 = Napi::String::New(env, "sampleLocationsInfo");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsampleLocationsEnable(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetsampleLocationsInfo(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPipelineSampleLocationsStateCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineSampleLocationsStateCreateInfoEXT::~_VkPipelineSampleLocationsStateCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  sampleLocationsInfo.Reset();
  
}

Napi::Object _VkPipelineSampleLocationsStateCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineSampleLocationsStateCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineSampleLocationsStateCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineSampleLocationsStateCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineSampleLocationsStateCreateInfoEXT::GetsType,
    &_VkPipelineSampleLocationsStateCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineSampleLocationsStateCreateInfoEXT::GetpNext,
    &_VkPipelineSampleLocationsStateCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationsEnable",
    &_VkPipelineSampleLocationsStateCreateInfoEXT::GetsampleLocationsEnable,
    &_VkPipelineSampleLocationsStateCreateInfoEXT::SetsampleLocationsEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationsInfo",
    &_VkPipelineSampleLocationsStateCreateInfoEXT::GetsampleLocationsInfo,
    &_VkPipelineSampleLocationsStateCreateInfoEXT::SetsampleLocationsInfo,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineSampleLocationsStateCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkPipelineSampleLocationsStateCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineSampleLocationsStateCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->sampleLocationsEnable));
    uint32_t byteLength = sizeof(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->sampleLocationsEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->sampleLocationsInfo));
    uint32_t byteLength = sizeof(((VkPipelineSampleLocationsStateCreateInfoEXT *)0)->sampleLocationsInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineSampleLocationsStateCreateInfoEXT::flush() {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->sampleLocationsInfo.IsEmpty())) {
    Napi::Value value = self->sampleLocationsInfo.Value();
    
    _VkSampleLocationsInfoEXT* result = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.sampleLocationsInfo = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkPipelineSampleLocationsStateCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineSampleLocationsStateCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineSampleLocationsStateCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineSampleLocationsStateCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineSampleLocationsStateCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// sampleLocationsEnable
Napi::Value _VkPipelineSampleLocationsStateCreateInfoEXT::GetsampleLocationsEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleLocationsEnable);
}void _VkPipelineSampleLocationsStateCreateInfoEXT::SetsampleLocationsEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sampleLocationsEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sampleLocationsEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsEnable", "Number");
  
    return;
  }
}// sampleLocationsInfo
Napi::Value _VkPipelineSampleLocationsStateCreateInfoEXT::GetsampleLocationsInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sampleLocationsInfo.IsEmpty()) return env.Null();
  return this->sampleLocationsInfo.Value().As<Napi::Object>();
}void _VkPipelineSampleLocationsStateCreateInfoEXT::SetsampleLocationsInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSampleLocationsInfoEXT::constructor.Value())) {
      
      this->sampleLocationsInfo.Reset(value.ToObject(), 1);
      _VkSampleLocationsInfoEXT* inst = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(obj);
      inst->flush();
      this->instance.sampleLocationsInfo = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sampleLocationsInfo.Reset();
    memset(&this->instance.sampleLocationsInfo, 0, sizeof(VkSampleLocationsInfoEXT));
  } else {
    
    NapiObjectTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
    return;
  }
}
/** ## END VkPipelineSampleLocationsStateCreateInfoEXT ## **/

/** ## BEGIN VkRenderPassSampleLocationsBeginInfoEXT ## **/

Napi::FunctionReference _VkRenderPassSampleLocationsBeginInfoEXT::constructor;

_VkRenderPassSampleLocationsBeginInfoEXT::_VkRenderPassSampleLocationsBeginInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
    vpAttachmentInitialSampleLocations = new std::vector<VkAttachmentSampleLocationsEXT>;
    vpPostSubpassSampleLocations = new std::vector<VkSubpassSampleLocationsEXT>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "attachmentInitialSampleLocationsCount");
      Napi::String sAccess3 = Napi::String::New(env, "pAttachmentInitialSampleLocations");
      Napi::String sAccess4 = Napi::String::New(env, "postSubpassSampleLocationsCount");
      Napi::String sAccess5 = Napi::String::New(env, "pPostSubpassSampleLocations");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetattachmentInitialSampleLocationsCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpAttachmentInitialSampleLocations(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpostSubpassSampleLocationsCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpPostSubpassSampleLocations(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkRenderPassSampleLocationsBeginInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassSampleLocationsBeginInfoEXT::~_VkRenderPassSampleLocationsBeginInfoEXT() {
  
  
  pNext.Reset();
  
  
  vpAttachmentInitialSampleLocations->clear();
  delete vpAttachmentInitialSampleLocations;
  
  pAttachmentInitialSampleLocations.Reset();
  
  
  vpPostSubpassSampleLocations->clear();
  delete vpPostSubpassSampleLocations;
  
  pPostSubpassSampleLocations.Reset();
  
}

Napi::Object _VkRenderPassSampleLocationsBeginInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassSampleLocationsBeginInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassSampleLocationsBeginInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassSampleLocationsBeginInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassSampleLocationsBeginInfoEXT::GetsType,
    &_VkRenderPassSampleLocationsBeginInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassSampleLocationsBeginInfoEXT::GetpNext,
    &_VkRenderPassSampleLocationsBeginInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "attachmentInitialSampleLocationsCount",
    &_VkRenderPassSampleLocationsBeginInfoEXT::GetattachmentInitialSampleLocationsCount,
    &_VkRenderPassSampleLocationsBeginInfoEXT::SetattachmentInitialSampleLocationsCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAttachmentInitialSampleLocations",
    &_VkRenderPassSampleLocationsBeginInfoEXT::GetpAttachmentInitialSampleLocations,
    &_VkRenderPassSampleLocationsBeginInfoEXT::SetpAttachmentInitialSampleLocations,
    napi_enumerable
  ),
  InstanceAccessor(
    "postSubpassSampleLocationsCount",
    &_VkRenderPassSampleLocationsBeginInfoEXT::GetpostSubpassSampleLocationsCount,
    &_VkRenderPassSampleLocationsBeginInfoEXT::SetpostSubpassSampleLocationsCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPostSubpassSampleLocations",
    &_VkRenderPassSampleLocationsBeginInfoEXT::GetpPostSubpassSampleLocations,
    &_VkRenderPassSampleLocationsBeginInfoEXT::SetpPostSubpassSampleLocations,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassSampleLocationsBeginInfoEXT", func);
  return exports;
}

Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->attachmentInitialSampleLocationsCount));
    uint32_t byteLength = sizeof(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->attachmentInitialSampleLocationsCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->pAttachmentInitialSampleLocations));
    uint32_t byteLength = sizeof(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->pAttachmentInitialSampleLocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->postSubpassSampleLocationsCount));
    uint32_t byteLength = sizeof(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->postSubpassSampleLocationsCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->pPostSubpassSampleLocations));
    uint32_t byteLength = sizeof(((VkRenderPassSampleLocationsBeginInfoEXT *)0)->pPostSubpassSampleLocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassSampleLocationsBeginInfoEXT::flush() {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAttachmentInitialSampleLocations.IsEmpty())) {
    Napi::Value value = self->pAttachmentInitialSampleLocations.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.attachmentInitialSampleLocationsCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'attachmentInitialSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentSampleLocationsEXT>* data = this->vpAttachmentInitialSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentSampleLocationsEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations", "[object VkAttachmentSampleLocationsEXT]");
  
        return false;
      }
      _VkAttachmentSampleLocationsEXT* result = Napi::ObjectWrap<_VkAttachmentSampleLocationsEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachmentInitialSampleLocations = data->data();
  }if (!(self->pPostSubpassSampleLocations.IsEmpty())) {
    Napi::Value value = self->pPostSubpassSampleLocations.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.postSubpassSampleLocationsCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'postSubpassSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSubpassSampleLocationsEXT>* data = this->vpPostSubpassSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSubpassSampleLocationsEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations", "[object VkSubpassSampleLocationsEXT]");
  
        return false;
      }
      _VkSubpassSampleLocationsEXT* result = Napi::ObjectWrap<_VkSubpassSampleLocationsEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPostSubpassSampleLocations = data->data();
  }
  return true;
}

// sType
Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassSampleLocationsBeginInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassSampleLocationsBeginInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkRenderPassSampleLocationsBeginInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// attachmentInitialSampleLocationsCount
Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetattachmentInitialSampleLocationsCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachmentInitialSampleLocationsCount);
}void _VkRenderPassSampleLocationsBeginInfoEXT::SetattachmentInitialSampleLocationsCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachmentInitialSampleLocationsCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.attachmentInitialSampleLocationsCount", "Number");
  
    return;
  }
}// pAttachmentInitialSampleLocations
Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetpAttachmentInitialSampleLocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAttachmentInitialSampleLocations.IsEmpty()) return env.Null();
  return this->pAttachmentInitialSampleLocations.Value().As<Napi::Array>();
}void _VkRenderPassSampleLocationsBeginInfoEXT::SetpAttachmentInitialSampleLocations(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAttachmentInitialSampleLocations.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAttachmentInitialSampleLocations.Reset();
      this->instance.pAttachmentInitialSampleLocations = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations", "[object VkAttachmentSampleLocationsEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAttachmentInitialSampleLocations = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations", "[object VkAttachmentSampleLocationsEXT]");
  
    return;
  }
}// postSubpassSampleLocationsCount
Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetpostSubpassSampleLocationsCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.postSubpassSampleLocationsCount);
}void _VkRenderPassSampleLocationsBeginInfoEXT::SetpostSubpassSampleLocationsCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.postSubpassSampleLocationsCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.postSubpassSampleLocationsCount", "Number");
  
    return;
  }
}// pPostSubpassSampleLocations
Napi::Value _VkRenderPassSampleLocationsBeginInfoEXT::GetpPostSubpassSampleLocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPostSubpassSampleLocations.IsEmpty()) return env.Null();
  return this->pPostSubpassSampleLocations.Value().As<Napi::Array>();
}void _VkRenderPassSampleLocationsBeginInfoEXT::SetpPostSubpassSampleLocations(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pPostSubpassSampleLocations.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pPostSubpassSampleLocations.Reset();
      this->instance.pPostSubpassSampleLocations = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations", "[object VkSubpassSampleLocationsEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pPostSubpassSampleLocations = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations", "[object VkSubpassSampleLocationsEXT]");
  
    return;
  }
}
/** ## END VkRenderPassSampleLocationsBeginInfoEXT ## **/

/** ## BEGIN VkSubpassSampleLocationsEXT ## **/

Napi::FunctionReference _VkSubpassSampleLocationsEXT::constructor;

_VkSubpassSampleLocationsEXT::_VkSubpassSampleLocationsEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassSampleLocationsEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "subpassIndex");
      Napi::String sAccess1 = Napi::String::New(env, "sampleLocationsInfo");
      if (obj.Has(sAccess0)) this->SetsubpassIndex(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetsampleLocationsInfo(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSubpassSampleLocationsEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassSampleLocationsEXT::~_VkSubpassSampleLocationsEXT() {
  
  
  sampleLocationsInfo.Reset();
  
}

Napi::Object _VkSubpassSampleLocationsEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassSampleLocationsEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassSampleLocationsEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassSampleLocationsEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "subpassIndex",
    &_VkSubpassSampleLocationsEXT::GetsubpassIndex,
    &_VkSubpassSampleLocationsEXT::SetsubpassIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationsInfo",
    &_VkSubpassSampleLocationsEXT::GetsampleLocationsInfo,
    &_VkSubpassSampleLocationsEXT::SetsampleLocationsInfo,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassSampleLocationsEXT", func);
  return exports;
}

Napi::Value _VkSubpassSampleLocationsEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassSampleLocationsEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassSampleLocationsEXT *)0)->subpassIndex));
    uint32_t byteLength = sizeof(((VkSubpassSampleLocationsEXT *)0)->subpassIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassSampleLocationsEXT *)0)->sampleLocationsInfo));
    uint32_t byteLength = sizeof(((VkSubpassSampleLocationsEXT *)0)->sampleLocationsInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassSampleLocationsEXT::flush() {
  _VkSubpassSampleLocationsEXT *self = this;
  if (!(self->sampleLocationsInfo.IsEmpty())) {
    Napi::Value value = self->sampleLocationsInfo.Value();
    
    _VkSampleLocationsInfoEXT* result = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.sampleLocationsInfo = result->instance;
  }
  return true;
}

// subpassIndex
Napi::Value _VkSubpassSampleLocationsEXT::GetsubpassIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpassIndex);
}void _VkSubpassSampleLocationsEXT::SetsubpassIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpassIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassSampleLocationsEXT.subpassIndex", "Number");
  
    return;
  }
}// sampleLocationsInfo
Napi::Value _VkSubpassSampleLocationsEXT::GetsampleLocationsInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sampleLocationsInfo.IsEmpty()) return env.Null();
  return this->sampleLocationsInfo.Value().As<Napi::Object>();
}void _VkSubpassSampleLocationsEXT::SetsampleLocationsInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSampleLocationsInfoEXT::constructor.Value())) {
      
      this->sampleLocationsInfo.Reset(value.ToObject(), 1);
      _VkSampleLocationsInfoEXT* inst = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(obj);
      inst->flush();
      this->instance.sampleLocationsInfo = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sampleLocationsInfo.Reset();
    memset(&this->instance.sampleLocationsInfo, 0, sizeof(VkSampleLocationsInfoEXT));
  } else {
    
    NapiObjectTypeError(value, "VkSubpassSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
    return;
  }
}
/** ## END VkSubpassSampleLocationsEXT ## **/

/** ## BEGIN VkAttachmentSampleLocationsEXT ## **/

Napi::FunctionReference _VkAttachmentSampleLocationsEXT::constructor;

_VkAttachmentSampleLocationsEXT::_VkAttachmentSampleLocationsEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAttachmentSampleLocationsEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "attachmentIndex");
      Napi::String sAccess1 = Napi::String::New(env, "sampleLocationsInfo");
      if (obj.Has(sAccess0)) this->SetattachmentIndex(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetsampleLocationsInfo(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkAttachmentSampleLocationsEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkAttachmentSampleLocationsEXT::~_VkAttachmentSampleLocationsEXT() {
  
  
  sampleLocationsInfo.Reset();
  
}

Napi::Object _VkAttachmentSampleLocationsEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAttachmentSampleLocationsEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAttachmentSampleLocationsEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAttachmentSampleLocationsEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "attachmentIndex",
    &_VkAttachmentSampleLocationsEXT::GetattachmentIndex,
    &_VkAttachmentSampleLocationsEXT::SetattachmentIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationsInfo",
    &_VkAttachmentSampleLocationsEXT::GetsampleLocationsInfo,
    &_VkAttachmentSampleLocationsEXT::SetsampleLocationsInfo,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAttachmentSampleLocationsEXT", func);
  return exports;
}

Napi::Value _VkAttachmentSampleLocationsEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAttachmentSampleLocationsEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentSampleLocationsEXT *)0)->attachmentIndex));
    uint32_t byteLength = sizeof(((VkAttachmentSampleLocationsEXT *)0)->attachmentIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentSampleLocationsEXT *)0)->sampleLocationsInfo));
    uint32_t byteLength = sizeof(((VkAttachmentSampleLocationsEXT *)0)->sampleLocationsInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAttachmentSampleLocationsEXT::flush() {
  _VkAttachmentSampleLocationsEXT *self = this;
  if (!(self->sampleLocationsInfo.IsEmpty())) {
    Napi::Value value = self->sampleLocationsInfo.Value();
    
    _VkSampleLocationsInfoEXT* result = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.sampleLocationsInfo = result->instance;
  }
  return true;
}

// attachmentIndex
Napi::Value _VkAttachmentSampleLocationsEXT::GetattachmentIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachmentIndex);
}void _VkAttachmentSampleLocationsEXT::SetattachmentIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachmentIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentSampleLocationsEXT.attachmentIndex", "Number");
  
    return;
  }
}// sampleLocationsInfo
Napi::Value _VkAttachmentSampleLocationsEXT::GetsampleLocationsInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sampleLocationsInfo.IsEmpty()) return env.Null();
  return this->sampleLocationsInfo.Value().As<Napi::Object>();
}void _VkAttachmentSampleLocationsEXT::SetsampleLocationsInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSampleLocationsInfoEXT::constructor.Value())) {
      
      this->sampleLocationsInfo.Reset(value.ToObject(), 1);
      _VkSampleLocationsInfoEXT* inst = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(obj);
      inst->flush();
      this->instance.sampleLocationsInfo = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkAttachmentSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sampleLocationsInfo.Reset();
    memset(&this->instance.sampleLocationsInfo, 0, sizeof(VkSampleLocationsInfoEXT));
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
    return;
  }
}
/** ## END VkAttachmentSampleLocationsEXT ## **/

/** ## BEGIN VkSampleLocationsInfoEXT ## **/

Napi::FunctionReference _VkSampleLocationsInfoEXT::constructor;

_VkSampleLocationsInfoEXT::_VkSampleLocationsInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSampleLocationsInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
    vpSampleLocations = new std::vector<VkSampleLocationEXT>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "sampleLocationsPerPixel");
      Napi::String sAccess3 = Napi::String::New(env, "sampleLocationGridSize");
      Napi::String sAccess4 = Napi::String::New(env, "sampleLocationsCount");
      Napi::String sAccess5 = Napi::String::New(env, "pSampleLocations");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsampleLocationsPerPixel(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetsampleLocationGridSize(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsampleLocationsCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpSampleLocations(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkSampleLocationsInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkSampleLocationsInfoEXT::~_VkSampleLocationsInfoEXT() {
  
  
  pNext.Reset();
  
  
  sampleLocationGridSize.Reset();
  
  
  vpSampleLocations->clear();
  delete vpSampleLocations;
  
  pSampleLocations.Reset();
  
}

Napi::Object _VkSampleLocationsInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSampleLocationsInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSampleLocationsInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSampleLocationsInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSampleLocationsInfoEXT::GetsType,
    &_VkSampleLocationsInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSampleLocationsInfoEXT::GetpNext,
    &_VkSampleLocationsInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationsPerPixel",
    &_VkSampleLocationsInfoEXT::GetsampleLocationsPerPixel,
    &_VkSampleLocationsInfoEXT::SetsampleLocationsPerPixel,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationGridSize",
    &_VkSampleLocationsInfoEXT::GetsampleLocationGridSize,
    &_VkSampleLocationsInfoEXT::SetsampleLocationGridSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleLocationsCount",
    &_VkSampleLocationsInfoEXT::GetsampleLocationsCount,
    &_VkSampleLocationsInfoEXT::SetsampleLocationsCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSampleLocations",
    &_VkSampleLocationsInfoEXT::GetpSampleLocations,
    &_VkSampleLocationsInfoEXT::SetpSampleLocations,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSampleLocationsInfoEXT", func);
  return exports;
}

Napi::Value _VkSampleLocationsInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSampleLocationsInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationsInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkSampleLocationsInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationsInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSampleLocationsInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationsInfoEXT *)0)->sampleLocationsPerPixel));
    uint32_t byteLength = sizeof(((VkSampleLocationsInfoEXT *)0)->sampleLocationsPerPixel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationsInfoEXT *)0)->sampleLocationGridSize));
    uint32_t byteLength = sizeof(((VkSampleLocationsInfoEXT *)0)->sampleLocationGridSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationsInfoEXT *)0)->sampleLocationsCount));
    uint32_t byteLength = sizeof(((VkSampleLocationsInfoEXT *)0)->sampleLocationsCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationsInfoEXT *)0)->pSampleLocations));
    uint32_t byteLength = sizeof(((VkSampleLocationsInfoEXT *)0)->pSampleLocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSampleLocationsInfoEXT::flush() {
  _VkSampleLocationsInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->sampleLocationGridSize.IsEmpty())) {
    Napi::Value value = self->sampleLocationGridSize.Value();
    
    _VkExtent2D* result = Napi::ObjectWrap<_VkExtent2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.sampleLocationGridSize = result->instance;
  }if (!(self->pSampleLocations.IsEmpty())) {
    Napi::Value value = self->pSampleLocations.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.sampleLocationsCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'sampleLocationsCount' for 'VkSampleLocationsInfoEXT.pSampleLocations'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSampleLocationEXT>* data = this->vpSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSampleLocationEXT::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.pSampleLocations", "[object VkSampleLocationEXT]");
  
        return false;
      }
      _VkSampleLocationEXT* result = Napi::ObjectWrap<_VkSampleLocationEXT>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSampleLocations = data->data();
  }
  return true;
}

// sType
Napi::Value _VkSampleLocationsInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSampleLocationsInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSampleLocationsInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSampleLocationsInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSampleLocationsInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// sampleLocationsPerPixel
Napi::Value _VkSampleLocationsInfoEXT::GetsampleLocationsPerPixel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleLocationsPerPixel);
}void _VkSampleLocationsInfoEXT::SetsampleLocationsPerPixel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sampleLocationsPerPixel = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationsPerPixel", "Number");
  
    return;
  }
}// sampleLocationGridSize
Napi::Value _VkSampleLocationsInfoEXT::GetsampleLocationGridSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sampleLocationGridSize.IsEmpty()) return env.Null();
  return this->sampleLocationGridSize.Value().As<Napi::Object>();
}void _VkSampleLocationsInfoEXT::SetsampleLocationGridSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent2D::constructor.Value())) {
      
      this->sampleLocationGridSize.Reset(value.ToObject(), 1);
      _VkExtent2D* inst = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
      inst->flush();
      this->instance.sampleLocationGridSize = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationGridSize", "[object VkExtent2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sampleLocationGridSize.Reset();
    memset(&this->instance.sampleLocationGridSize, 0, sizeof(VkExtent2D));
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationGridSize", "[object VkExtent2D]");
  
    return;
  }
}// sampleLocationsCount
Napi::Value _VkSampleLocationsInfoEXT::GetsampleLocationsCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleLocationsCount);
}void _VkSampleLocationsInfoEXT::SetsampleLocationsCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sampleLocationsCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationsCount", "Number");
  
    return;
  }
}// pSampleLocations
Napi::Value _VkSampleLocationsInfoEXT::GetpSampleLocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSampleLocations.IsEmpty()) return env.Null();
  return this->pSampleLocations.Value().As<Napi::Array>();
}void _VkSampleLocationsInfoEXT::SetpSampleLocations(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSampleLocations.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSampleLocations.Reset();
      this->instance.pSampleLocations = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.pSampleLocations", "[object VkSampleLocationEXT]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSampleLocations = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationsInfoEXT.pSampleLocations", "[object VkSampleLocationEXT]");
  
    return;
  }
}
/** ## END VkSampleLocationsInfoEXT ## **/

/** ## BEGIN VkSampleLocationEXT ## **/

Napi::FunctionReference _VkSampleLocationEXT::constructor;

_VkSampleLocationEXT::_VkSampleLocationEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSampleLocationEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSampleLocationEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkSampleLocationEXT::~_VkSampleLocationEXT() {
  
  
  
}

Napi::Object _VkSampleLocationEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSampleLocationEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSampleLocationEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSampleLocationEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkSampleLocationEXT::Getx,
    &_VkSampleLocationEXT::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkSampleLocationEXT::Gety,
    &_VkSampleLocationEXT::Sety,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSampleLocationEXT", func);
  return exports;
}

Napi::Value _VkSampleLocationEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSampleLocationEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationEXT *)0)->x));
    uint32_t byteLength = sizeof(((VkSampleLocationEXT *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSampleLocationEXT *)0)->y));
    uint32_t byteLength = sizeof(((VkSampleLocationEXT *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSampleLocationEXT::flush() {
  _VkSampleLocationEXT *self = this;
  
  return true;
}

// x
Napi::Value _VkSampleLocationEXT::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkSampleLocationEXT::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationEXT.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkSampleLocationEXT::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkSampleLocationEXT::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSampleLocationEXT.y", "Number");
  
    return;
  }
}
/** ## END VkSampleLocationEXT ## **/

/** ## BEGIN VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::constructor;

_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::~_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetsType,
    &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetpNext,
    &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "filterMinmaxSingleComponentFormats",
    &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetfilterMinmaxSingleComponentFormats,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "filterMinmaxImageComponentMapping",
    &_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetfilterMinmaxImageComponentMapping,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->filterMinmaxSingleComponentFormats));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->filterMinmaxSingleComponentFormats);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->filterMinmaxImageComponentMapping));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *)0)->filterMinmaxImageComponentMapping);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::flush() {
  _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// filterMinmaxSingleComponentFormats
Napi::Value _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetfilterMinmaxSingleComponentFormats(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.filterMinmaxSingleComponentFormats);
}// filterMinmaxImageComponentMapping
Napi::Value _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetfilterMinmaxImageComponentMapping(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.filterMinmaxImageComponentMapping);
}
/** ## END VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ## **/

/** ## BEGIN VkPipelineCoverageToColorStateCreateInfoNV ## **/

Napi::FunctionReference _VkPipelineCoverageToColorStateCreateInfoNV::constructor;

_VkPipelineCoverageToColorStateCreateInfoNV::_VkPipelineCoverageToColorStateCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "coverageToColorEnable");
      Napi::String sAccess4 = Napi::String::New(env, "coverageToColorLocation");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetcoverageToColorEnable(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcoverageToColorLocation(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineCoverageToColorStateCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineCoverageToColorStateCreateInfoNV::~_VkPipelineCoverageToColorStateCreateInfoNV() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPipelineCoverageToColorStateCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineCoverageToColorStateCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineCoverageToColorStateCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineCoverageToColorStateCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineCoverageToColorStateCreateInfoNV::GetsType,
    &_VkPipelineCoverageToColorStateCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineCoverageToColorStateCreateInfoNV::GetpNext,
    &_VkPipelineCoverageToColorStateCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineCoverageToColorStateCreateInfoNV::Getflags,
    &_VkPipelineCoverageToColorStateCreateInfoNV::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "coverageToColorEnable",
    &_VkPipelineCoverageToColorStateCreateInfoNV::GetcoverageToColorEnable,
    &_VkPipelineCoverageToColorStateCreateInfoNV::SetcoverageToColorEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "coverageToColorLocation",
    &_VkPipelineCoverageToColorStateCreateInfoNV::GetcoverageToColorLocation,
    &_VkPipelineCoverageToColorStateCreateInfoNV::SetcoverageToColorLocation,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineCoverageToColorStateCreateInfoNV", func);
  return exports;
}

Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->coverageToColorEnable));
    uint32_t byteLength = sizeof(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->coverageToColorEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->coverageToColorLocation));
    uint32_t byteLength = sizeof(((VkPipelineCoverageToColorStateCreateInfoNV *)0)->coverageToColorLocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineCoverageToColorStateCreateInfoNV::flush() {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineCoverageToColorStateCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineCoverageToColorStateCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineCoverageToColorStateCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineCoverageToColorStateCreateInfoNV::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineCoverageToColorStateCreateFlagsNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.flags", "Number");
  
    return;
  }
}// coverageToColorEnable
Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::GetcoverageToColorEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.coverageToColorEnable);
}void _VkPipelineCoverageToColorStateCreateInfoNV::SetcoverageToColorEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.coverageToColorEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.coverageToColorEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorEnable", "Number");
  
    return;
  }
}// coverageToColorLocation
Napi::Value _VkPipelineCoverageToColorStateCreateInfoNV::GetcoverageToColorLocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.coverageToColorLocation);
}void _VkPipelineCoverageToColorStateCreateInfoNV::SetcoverageToColorLocation(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.coverageToColorLocation = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation", "Number");
  
    return;
  }
}
/** ## END VkPipelineCoverageToColorStateCreateInfoNV ## **/

/** ## BEGIN VkDeviceQueueInfo2 ## **/

Napi::FunctionReference _VkDeviceQueueInfo2::constructor;

_VkDeviceQueueInfo2::_VkDeviceQueueInfo2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceQueueInfo2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "queueFamilyIndex");
      Napi::String sAccess4 = Napi::String::New(env, "queueIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetqueueFamilyIndex(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetqueueIndex(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDeviceQueueInfo2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceQueueInfo2::~_VkDeviceQueueInfo2() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkDeviceQueueInfo2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceQueueInfo2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceQueueInfo2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceQueueInfo2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceQueueInfo2::GetsType,
    &_VkDeviceQueueInfo2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceQueueInfo2::GetpNext,
    &_VkDeviceQueueInfo2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDeviceQueueInfo2::Getflags,
    &_VkDeviceQueueInfo2::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyIndex",
    &_VkDeviceQueueInfo2::GetqueueFamilyIndex,
    &_VkDeviceQueueInfo2::SetqueueFamilyIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueIndex",
    &_VkDeviceQueueInfo2::GetqueueIndex,
    &_VkDeviceQueueInfo2::SetqueueIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceQueueInfo2", func);
  return exports;
}

Napi::Value _VkDeviceQueueInfo2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceQueueInfo2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueInfo2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceQueueInfo2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueInfo2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceQueueInfo2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueInfo2 *)0)->flags));
    uint32_t byteLength = sizeof(((VkDeviceQueueInfo2 *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueInfo2 *)0)->queueFamilyIndex));
    uint32_t byteLength = sizeof(((VkDeviceQueueInfo2 *)0)->queueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueInfo2 *)0)->queueIndex));
    uint32_t byteLength = sizeof(((VkDeviceQueueInfo2 *)0)->queueIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceQueueInfo2::flush() {
  _VkDeviceQueueInfo2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceQueueInfo2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceQueueInfo2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueInfo2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceQueueInfo2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceQueueInfo2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceQueueInfo2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceQueueInfo2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueInfo2.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDeviceQueueInfo2::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDeviceQueueInfo2::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDeviceQueueCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueInfo2.flags", "Number");
  
    return;
  }
}// queueFamilyIndex
Napi::Value _VkDeviceQueueInfo2::GetqueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFamilyIndex);
}void _VkDeviceQueueInfo2::SetqueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueInfo2.queueFamilyIndex", "Number");
  
    return;
  }
}// queueIndex
Napi::Value _VkDeviceQueueInfo2::GetqueueIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueIndex);
}void _VkDeviceQueueInfo2::SetqueueIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueInfo2.queueIndex", "Number");
  
    return;
  }
}
/** ## END VkDeviceQueueInfo2 ## **/

/** ## BEGIN VkPhysicalDeviceProtectedMemoryProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceProtectedMemoryProperties::constructor;

_VkPhysicalDeviceProtectedMemoryProperties::_VkPhysicalDeviceProtectedMemoryProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceProtectedMemoryProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "protectedNoFault");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetprotectedNoFault(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceProtectedMemoryProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceProtectedMemoryProperties::~_VkPhysicalDeviceProtectedMemoryProperties() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceProtectedMemoryProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceProtectedMemoryProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceProtectedMemoryProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceProtectedMemoryProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceProtectedMemoryProperties::GetsType,
    &_VkPhysicalDeviceProtectedMemoryProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceProtectedMemoryProperties::GetpNext,
    &_VkPhysicalDeviceProtectedMemoryProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "protectedNoFault",
    &_VkPhysicalDeviceProtectedMemoryProperties::GetprotectedNoFault,
    &_VkPhysicalDeviceProtectedMemoryProperties::SetprotectedNoFault,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceProtectedMemoryProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceProtectedMemoryProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceProtectedMemoryProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProtectedMemoryProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProtectedMemoryProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProtectedMemoryProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProtectedMemoryProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProtectedMemoryProperties *)0)->protectedNoFault));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProtectedMemoryProperties *)0)->protectedNoFault);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceProtectedMemoryProperties::flush() {
  _VkPhysicalDeviceProtectedMemoryProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceProtectedMemoryProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceProtectedMemoryProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceProtectedMemoryProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceProtectedMemoryProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceProtectedMemoryProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryProperties.pNext", "[object Object]");
  
    return;
  }
}// protectedNoFault
Napi::Value _VkPhysicalDeviceProtectedMemoryProperties::GetprotectedNoFault(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.protectedNoFault);
}void _VkPhysicalDeviceProtectedMemoryProperties::SetprotectedNoFault(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.protectedNoFault = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.protectedNoFault = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryProperties.protectedNoFault", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceProtectedMemoryProperties ## **/

/** ## BEGIN VkPhysicalDeviceProtectedMemoryFeatures ## **/

Napi::FunctionReference _VkPhysicalDeviceProtectedMemoryFeatures::constructor;

_VkPhysicalDeviceProtectedMemoryFeatures::_VkPhysicalDeviceProtectedMemoryFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceProtectedMemoryFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "protectedMemory");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetprotectedMemory(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceProtectedMemoryFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceProtectedMemoryFeatures::~_VkPhysicalDeviceProtectedMemoryFeatures() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceProtectedMemoryFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceProtectedMemoryFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceProtectedMemoryFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceProtectedMemoryFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceProtectedMemoryFeatures::GetsType,
    &_VkPhysicalDeviceProtectedMemoryFeatures::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceProtectedMemoryFeatures::GetpNext,
    &_VkPhysicalDeviceProtectedMemoryFeatures::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "protectedMemory",
    &_VkPhysicalDeviceProtectedMemoryFeatures::GetprotectedMemory,
    &_VkPhysicalDeviceProtectedMemoryFeatures::SetprotectedMemory,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceProtectedMemoryFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceProtectedMemoryFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceProtectedMemoryFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProtectedMemoryFeatures *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProtectedMemoryFeatures *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProtectedMemoryFeatures *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProtectedMemoryFeatures *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProtectedMemoryFeatures *)0)->protectedMemory));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProtectedMemoryFeatures *)0)->protectedMemory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceProtectedMemoryFeatures::flush() {
  _VkPhysicalDeviceProtectedMemoryFeatures *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceProtectedMemoryFeatures::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceProtectedMemoryFeatures::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryFeatures.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceProtectedMemoryFeatures::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceProtectedMemoryFeatures::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceProtectedMemoryFeatures.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryFeatures.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryFeatures.pNext", "[object Object]");
  
    return;
  }
}// protectedMemory
Napi::Value _VkPhysicalDeviceProtectedMemoryFeatures::GetprotectedMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.protectedMemory);
}void _VkPhysicalDeviceProtectedMemoryFeatures::SetprotectedMemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.protectedMemory = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.protectedMemory = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProtectedMemoryFeatures.protectedMemory", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceProtectedMemoryFeatures ## **/

/** ## BEGIN VkProtectedSubmitInfo ## **/

Napi::FunctionReference _VkProtectedSubmitInfo::constructor;

_VkProtectedSubmitInfo::_VkProtectedSubmitInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkProtectedSubmitInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "protectedSubmit");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetprotectedSubmit(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkProtectedSubmitInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkProtectedSubmitInfo::~_VkProtectedSubmitInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkProtectedSubmitInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkProtectedSubmitInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkProtectedSubmitInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkProtectedSubmitInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkProtectedSubmitInfo::GetsType,
    &_VkProtectedSubmitInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkProtectedSubmitInfo::GetpNext,
    &_VkProtectedSubmitInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "protectedSubmit",
    &_VkProtectedSubmitInfo::GetprotectedSubmit,
    &_VkProtectedSubmitInfo::SetprotectedSubmit,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkProtectedSubmitInfo", func);
  return exports;
}

Napi::Value _VkProtectedSubmitInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkProtectedSubmitInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkProtectedSubmitInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkProtectedSubmitInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkProtectedSubmitInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkProtectedSubmitInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkProtectedSubmitInfo *)0)->protectedSubmit));
    uint32_t byteLength = sizeof(((VkProtectedSubmitInfo *)0)->protectedSubmit);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkProtectedSubmitInfo::flush() {
  _VkProtectedSubmitInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkProtectedSubmitInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkProtectedSubmitInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkProtectedSubmitInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkProtectedSubmitInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkProtectedSubmitInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkProtectedSubmitInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkProtectedSubmitInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkProtectedSubmitInfo.pNext", "[object Object]");
  
    return;
  }
}// protectedSubmit
Napi::Value _VkProtectedSubmitInfo::GetprotectedSubmit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.protectedSubmit);
}void _VkProtectedSubmitInfo::SetprotectedSubmit(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.protectedSubmit = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.protectedSubmit = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkProtectedSubmitInfo.protectedSubmit", "Number");
  
    return;
  }
}
/** ## END VkProtectedSubmitInfo ## **/

/** ## BEGIN VkConditionalRenderingBeginInfoEXT ## **/

Napi::FunctionReference _VkConditionalRenderingBeginInfoEXT::constructor;

_VkConditionalRenderingBeginInfoEXT::_VkConditionalRenderingBeginInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkConditionalRenderingBeginInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      Napi::String sAccess3 = Napi::String::New(env, "offset");
      Napi::String sAccess4 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setoffset(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setflags(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkConditionalRenderingBeginInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkConditionalRenderingBeginInfoEXT::~_VkConditionalRenderingBeginInfoEXT() {
  
  
  pNext.Reset();
  
  buffer.Reset();
  
  
  
}

Napi::Object _VkConditionalRenderingBeginInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkConditionalRenderingBeginInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkConditionalRenderingBeginInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkConditionalRenderingBeginInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkConditionalRenderingBeginInfoEXT::GetsType,
    &_VkConditionalRenderingBeginInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkConditionalRenderingBeginInfoEXT::GetpNext,
    &_VkConditionalRenderingBeginInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkConditionalRenderingBeginInfoEXT::Getbuffer,
    &_VkConditionalRenderingBeginInfoEXT::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkConditionalRenderingBeginInfoEXT::Getoffset,
    &_VkConditionalRenderingBeginInfoEXT::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkConditionalRenderingBeginInfoEXT::Getflags,
    &_VkConditionalRenderingBeginInfoEXT::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkConditionalRenderingBeginInfoEXT", func);
  return exports;
}

Napi::Value _VkConditionalRenderingBeginInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkConditionalRenderingBeginInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkConditionalRenderingBeginInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkConditionalRenderingBeginInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkConditionalRenderingBeginInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkConditionalRenderingBeginInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkConditionalRenderingBeginInfoEXT *)0)->buffer));
    uint32_t byteLength = sizeof(((VkConditionalRenderingBeginInfoEXT *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkConditionalRenderingBeginInfoEXT *)0)->offset));
    uint32_t byteLength = sizeof(((VkConditionalRenderingBeginInfoEXT *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkConditionalRenderingBeginInfoEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkConditionalRenderingBeginInfoEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkConditionalRenderingBeginInfoEXT::flush() {
  _VkConditionalRenderingBeginInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkConditionalRenderingBeginInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkConditionalRenderingBeginInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkConditionalRenderingBeginInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkConditionalRenderingBeginInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkConditionalRenderingBeginInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// buffer
Napi::Value _VkConditionalRenderingBeginInfoEXT::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkConditionalRenderingBeginInfoEXT::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
Napi::Value _VkConditionalRenderingBeginInfoEXT::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkConditionalRenderingBeginInfoEXT::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.offset", "Number");
  
    return;
  }
}// flags
Napi::Value _VkConditionalRenderingBeginInfoEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkConditionalRenderingBeginInfoEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkConditionalRenderingFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkConditionalRenderingBeginInfoEXT.flags", "Number");
  
    return;
  }
}
/** ## END VkConditionalRenderingBeginInfoEXT ## **/

/** ## BEGIN VkTextureLODGatherFormatPropertiesAMD ## **/

Napi::FunctionReference _VkTextureLODGatherFormatPropertiesAMD::constructor;

_VkTextureLODGatherFormatPropertiesAMD::_VkTextureLODGatherFormatPropertiesAMD(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkTextureLODGatherFormatPropertiesAMD>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkTextureLODGatherFormatPropertiesAMD constructor cannot be invoked without 'new'");
    }
  }
}

_VkTextureLODGatherFormatPropertiesAMD::~_VkTextureLODGatherFormatPropertiesAMD() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkTextureLODGatherFormatPropertiesAMD::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkTextureLODGatherFormatPropertiesAMD", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkTextureLODGatherFormatPropertiesAMD::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkTextureLODGatherFormatPropertiesAMD::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkTextureLODGatherFormatPropertiesAMD::GetsType,
    &_VkTextureLODGatherFormatPropertiesAMD::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkTextureLODGatherFormatPropertiesAMD::GetpNext,
    &_VkTextureLODGatherFormatPropertiesAMD::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportsTextureGatherLODBiasAMD",
    &_VkTextureLODGatherFormatPropertiesAMD::GetsupportsTextureGatherLODBiasAMD,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkTextureLODGatherFormatPropertiesAMD", func);
  return exports;
}

Napi::Value _VkTextureLODGatherFormatPropertiesAMD::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkTextureLODGatherFormatPropertiesAMD::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkTextureLODGatherFormatPropertiesAMD *)0)->sType));
    uint32_t byteLength = sizeof(((VkTextureLODGatherFormatPropertiesAMD *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkTextureLODGatherFormatPropertiesAMD *)0)->pNext));
    uint32_t byteLength = sizeof(((VkTextureLODGatherFormatPropertiesAMD *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkTextureLODGatherFormatPropertiesAMD *)0)->supportsTextureGatherLODBiasAMD));
    uint32_t byteLength = sizeof(((VkTextureLODGatherFormatPropertiesAMD *)0)->supportsTextureGatherLODBiasAMD);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkTextureLODGatherFormatPropertiesAMD::flush() {
  _VkTextureLODGatherFormatPropertiesAMD *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkTextureLODGatherFormatPropertiesAMD::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkTextureLODGatherFormatPropertiesAMD::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkTextureLODGatherFormatPropertiesAMD.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkTextureLODGatherFormatPropertiesAMD::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkTextureLODGatherFormatPropertiesAMD::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkTextureLODGatherFormatPropertiesAMD.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkTextureLODGatherFormatPropertiesAMD.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkTextureLODGatherFormatPropertiesAMD.pNext", "[object Object]");
  
    return;
  }
}// supportsTextureGatherLODBiasAMD
Napi::Value _VkTextureLODGatherFormatPropertiesAMD::GetsupportsTextureGatherLODBiasAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportsTextureGatherLODBiasAMD);
}
/** ## END VkTextureLODGatherFormatPropertiesAMD ## **/

/** ## BEGIN VkSamplerYcbcrConversionImageFormatPropertiesKHR ## **/

Napi::FunctionReference _VkSamplerYcbcrConversionImageFormatPropertiesKHR::constructor;

_VkSamplerYcbcrConversionImageFormatPropertiesKHR::_VkSamplerYcbcrConversionImageFormatPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversionImageFormatPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSamplerYcbcrConversionImageFormatPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerYcbcrConversionImageFormatPropertiesKHR::~_VkSamplerYcbcrConversionImageFormatPropertiesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSamplerYcbcrConversionImageFormatPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversionImageFormatPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetsType,
    &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetpNext,
    &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "combinedImageSamplerDescriptorCount",
    &_VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetcombinedImageSamplerDescriptorCount,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversionImageFormatPropertiesKHR", func);
  return exports;
}

Napi::Value _VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionImageFormatPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionImageFormatPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionImageFormatPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionImageFormatPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionImageFormatPropertiesKHR *)0)->combinedImageSamplerDescriptorCount));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionImageFormatPropertiesKHR *)0)->combinedImageSamplerDescriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerYcbcrConversionImageFormatPropertiesKHR::flush() {
  _VkSamplerYcbcrConversionImageFormatPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerYcbcrConversionImageFormatPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionImageFormatPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionImageFormatPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// combinedImageSamplerDescriptorCount
Napi::Value _VkSamplerYcbcrConversionImageFormatPropertiesKHR::GetcombinedImageSamplerDescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.combinedImageSamplerDescriptorCount);
}
/** ## END VkSamplerYcbcrConversionImageFormatPropertiesKHR ## **/

/** ## BEGIN VkSamplerYcbcrConversionImageFormatProperties ## **/

Napi::FunctionReference _VkSamplerYcbcrConversionImageFormatProperties::constructor;

_VkSamplerYcbcrConversionImageFormatProperties::_VkSamplerYcbcrConversionImageFormatProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversionImageFormatProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSamplerYcbcrConversionImageFormatProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerYcbcrConversionImageFormatProperties::~_VkSamplerYcbcrConversionImageFormatProperties() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSamplerYcbcrConversionImageFormatProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversionImageFormatProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerYcbcrConversionImageFormatProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerYcbcrConversionImageFormatProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerYcbcrConversionImageFormatProperties::GetsType,
    &_VkSamplerYcbcrConversionImageFormatProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerYcbcrConversionImageFormatProperties::GetpNext,
    &_VkSamplerYcbcrConversionImageFormatProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "combinedImageSamplerDescriptorCount",
    &_VkSamplerYcbcrConversionImageFormatProperties::GetcombinedImageSamplerDescriptorCount,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversionImageFormatProperties", func);
  return exports;
}

Napi::Value _VkSamplerYcbcrConversionImageFormatProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerYcbcrConversionImageFormatProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionImageFormatProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionImageFormatProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionImageFormatProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionImageFormatProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionImageFormatProperties *)0)->combinedImageSamplerDescriptorCount));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionImageFormatProperties *)0)->combinedImageSamplerDescriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerYcbcrConversionImageFormatProperties::flush() {
  _VkSamplerYcbcrConversionImageFormatProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSamplerYcbcrConversionImageFormatProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerYcbcrConversionImageFormatProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionImageFormatProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerYcbcrConversionImageFormatProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionImageFormatProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSamplerYcbcrConversionImageFormatProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionImageFormatProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionImageFormatProperties.pNext", "[object Object]");
  
    return;
  }
}// combinedImageSamplerDescriptorCount
Napi::Value _VkSamplerYcbcrConversionImageFormatProperties::GetcombinedImageSamplerDescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.combinedImageSamplerDescriptorCount);
}
/** ## END VkSamplerYcbcrConversionImageFormatProperties ## **/

/** ## BEGIN VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::constructor;

_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "samplerYcbcrConversion");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsamplerYcbcrConversion(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::~_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetsType,
    &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetpNext,
    &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "samplerYcbcrConversion",
    &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetsamplerYcbcrConversion,
    &_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::SetsamplerYcbcrConversion,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *)0)->samplerYcbcrConversion));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *)0)->samplerYcbcrConversion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::flush() {
  _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext", "[object Object]");
  
    return;
  }
}// samplerYcbcrConversion
Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::GetsamplerYcbcrConversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samplerYcbcrConversion);
}void _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::SetsamplerYcbcrConversion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.samplerYcbcrConversion = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.samplerYcbcrConversion = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.samplerYcbcrConversion", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceSamplerYcbcrConversionFeatures ## **/

Napi::FunctionReference _VkPhysicalDeviceSamplerYcbcrConversionFeatures::constructor;

_VkPhysicalDeviceSamplerYcbcrConversionFeatures::_VkPhysicalDeviceSamplerYcbcrConversionFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "samplerYcbcrConversion");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsamplerYcbcrConversion(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSamplerYcbcrConversionFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSamplerYcbcrConversionFeatures::~_VkPhysicalDeviceSamplerYcbcrConversionFeatures() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceSamplerYcbcrConversionFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSamplerYcbcrConversionFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetsType,
    &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetpNext,
    &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "samplerYcbcrConversion",
    &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetsamplerYcbcrConversion,
    &_VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetsamplerYcbcrConversion,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSamplerYcbcrConversionFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerYcbcrConversionFeatures *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerYcbcrConversionFeatures *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerYcbcrConversionFeatures *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerYcbcrConversionFeatures *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSamplerYcbcrConversionFeatures *)0)->samplerYcbcrConversion));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSamplerYcbcrConversionFeatures *)0)->samplerYcbcrConversion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSamplerYcbcrConversionFeatures::flush() {
  _VkPhysicalDeviceSamplerYcbcrConversionFeatures *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSamplerYcbcrConversionFeatures.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.pNext", "[object Object]");
  
    return;
  }
}// samplerYcbcrConversion
Napi::Value _VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetsamplerYcbcrConversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samplerYcbcrConversion);
}void _VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetsamplerYcbcrConversion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.samplerYcbcrConversion = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.samplerYcbcrConversion = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.samplerYcbcrConversion", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSamplerYcbcrConversionFeatures ## **/

/** ## BEGIN VkImagePlaneMemoryRequirementsInfoKHR ## **/

Napi::FunctionReference _VkImagePlaneMemoryRequirementsInfoKHR::constructor;

_VkImagePlaneMemoryRequirementsInfoKHR::_VkImagePlaneMemoryRequirementsInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImagePlaneMemoryRequirementsInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "planeAspect");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetplaneAspect(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImagePlaneMemoryRequirementsInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImagePlaneMemoryRequirementsInfoKHR::~_VkImagePlaneMemoryRequirementsInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkImagePlaneMemoryRequirementsInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImagePlaneMemoryRequirementsInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImagePlaneMemoryRequirementsInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImagePlaneMemoryRequirementsInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImagePlaneMemoryRequirementsInfoKHR::GetsType,
    &_VkImagePlaneMemoryRequirementsInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImagePlaneMemoryRequirementsInfoKHR::GetpNext,
    &_VkImagePlaneMemoryRequirementsInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeAspect",
    &_VkImagePlaneMemoryRequirementsInfoKHR::GetplaneAspect,
    &_VkImagePlaneMemoryRequirementsInfoKHR::SetplaneAspect,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImagePlaneMemoryRequirementsInfoKHR", func);
  return exports;
}

Napi::Value _VkImagePlaneMemoryRequirementsInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImagePlaneMemoryRequirementsInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImagePlaneMemoryRequirementsInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImagePlaneMemoryRequirementsInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImagePlaneMemoryRequirementsInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImagePlaneMemoryRequirementsInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImagePlaneMemoryRequirementsInfoKHR *)0)->planeAspect));
    uint32_t byteLength = sizeof(((VkImagePlaneMemoryRequirementsInfoKHR *)0)->planeAspect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImagePlaneMemoryRequirementsInfoKHR::flush() {
  _VkImagePlaneMemoryRequirementsInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImagePlaneMemoryRequirementsInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImagePlaneMemoryRequirementsInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImagePlaneMemoryRequirementsInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImagePlaneMemoryRequirementsInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImagePlaneMemoryRequirementsInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// planeAspect
Napi::Value _VkImagePlaneMemoryRequirementsInfoKHR::GetplaneAspect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeAspect);
}void _VkImagePlaneMemoryRequirementsInfoKHR::SetplaneAspect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeAspect = static_cast<VkImageAspectFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfoKHR.planeAspect", "Number");
  
    return;
  }
}
/** ## END VkImagePlaneMemoryRequirementsInfoKHR ## **/

/** ## BEGIN VkImagePlaneMemoryRequirementsInfo ## **/

Napi::FunctionReference _VkImagePlaneMemoryRequirementsInfo::constructor;

_VkImagePlaneMemoryRequirementsInfo::_VkImagePlaneMemoryRequirementsInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImagePlaneMemoryRequirementsInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "planeAspect");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetplaneAspect(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImagePlaneMemoryRequirementsInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkImagePlaneMemoryRequirementsInfo::~_VkImagePlaneMemoryRequirementsInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkImagePlaneMemoryRequirementsInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImagePlaneMemoryRequirementsInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImagePlaneMemoryRequirementsInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImagePlaneMemoryRequirementsInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImagePlaneMemoryRequirementsInfo::GetsType,
    &_VkImagePlaneMemoryRequirementsInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImagePlaneMemoryRequirementsInfo::GetpNext,
    &_VkImagePlaneMemoryRequirementsInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeAspect",
    &_VkImagePlaneMemoryRequirementsInfo::GetplaneAspect,
    &_VkImagePlaneMemoryRequirementsInfo::SetplaneAspect,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImagePlaneMemoryRequirementsInfo", func);
  return exports;
}

Napi::Value _VkImagePlaneMemoryRequirementsInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImagePlaneMemoryRequirementsInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImagePlaneMemoryRequirementsInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkImagePlaneMemoryRequirementsInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImagePlaneMemoryRequirementsInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImagePlaneMemoryRequirementsInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImagePlaneMemoryRequirementsInfo *)0)->planeAspect));
    uint32_t byteLength = sizeof(((VkImagePlaneMemoryRequirementsInfo *)0)->planeAspect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImagePlaneMemoryRequirementsInfo::flush() {
  _VkImagePlaneMemoryRequirementsInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImagePlaneMemoryRequirementsInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImagePlaneMemoryRequirementsInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImagePlaneMemoryRequirementsInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImagePlaneMemoryRequirementsInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImagePlaneMemoryRequirementsInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfo.pNext", "[object Object]");
  
    return;
  }
}// planeAspect
Napi::Value _VkImagePlaneMemoryRequirementsInfo::GetplaneAspect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeAspect);
}void _VkImagePlaneMemoryRequirementsInfo::SetplaneAspect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeAspect = static_cast<VkImageAspectFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImagePlaneMemoryRequirementsInfo.planeAspect", "Number");
  
    return;
  }
}
/** ## END VkImagePlaneMemoryRequirementsInfo ## **/

/** ## BEGIN VkBindImagePlaneMemoryInfoKHR ## **/

Napi::FunctionReference _VkBindImagePlaneMemoryInfoKHR::constructor;

_VkBindImagePlaneMemoryInfoKHR::_VkBindImagePlaneMemoryInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImagePlaneMemoryInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "planeAspect");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetplaneAspect(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkBindImagePlaneMemoryInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImagePlaneMemoryInfoKHR::~_VkBindImagePlaneMemoryInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkBindImagePlaneMemoryInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImagePlaneMemoryInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImagePlaneMemoryInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImagePlaneMemoryInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImagePlaneMemoryInfoKHR::GetsType,
    &_VkBindImagePlaneMemoryInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImagePlaneMemoryInfoKHR::GetpNext,
    &_VkBindImagePlaneMemoryInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeAspect",
    &_VkBindImagePlaneMemoryInfoKHR::GetplaneAspect,
    &_VkBindImagePlaneMemoryInfoKHR::SetplaneAspect,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImagePlaneMemoryInfoKHR", func);
  return exports;
}

Napi::Value _VkBindImagePlaneMemoryInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImagePlaneMemoryInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImagePlaneMemoryInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImagePlaneMemoryInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImagePlaneMemoryInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImagePlaneMemoryInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImagePlaneMemoryInfoKHR *)0)->planeAspect));
    uint32_t byteLength = sizeof(((VkBindImagePlaneMemoryInfoKHR *)0)->planeAspect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImagePlaneMemoryInfoKHR::flush() {
  _VkBindImagePlaneMemoryInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBindImagePlaneMemoryInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImagePlaneMemoryInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImagePlaneMemoryInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImagePlaneMemoryInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindImagePlaneMemoryInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// planeAspect
Napi::Value _VkBindImagePlaneMemoryInfoKHR::GetplaneAspect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeAspect);
}void _VkBindImagePlaneMemoryInfoKHR::SetplaneAspect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeAspect = static_cast<VkImageAspectFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfoKHR.planeAspect", "Number");
  
    return;
  }
}
/** ## END VkBindImagePlaneMemoryInfoKHR ## **/

/** ## BEGIN VkBindImagePlaneMemoryInfo ## **/

Napi::FunctionReference _VkBindImagePlaneMemoryInfo::constructor;

_VkBindImagePlaneMemoryInfo::_VkBindImagePlaneMemoryInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImagePlaneMemoryInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "planeAspect");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetplaneAspect(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkBindImagePlaneMemoryInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImagePlaneMemoryInfo::~_VkBindImagePlaneMemoryInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkBindImagePlaneMemoryInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImagePlaneMemoryInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImagePlaneMemoryInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImagePlaneMemoryInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImagePlaneMemoryInfo::GetsType,
    &_VkBindImagePlaneMemoryInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImagePlaneMemoryInfo::GetpNext,
    &_VkBindImagePlaneMemoryInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeAspect",
    &_VkBindImagePlaneMemoryInfo::GetplaneAspect,
    &_VkBindImagePlaneMemoryInfo::SetplaneAspect,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImagePlaneMemoryInfo", func);
  return exports;
}

Napi::Value _VkBindImagePlaneMemoryInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImagePlaneMemoryInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImagePlaneMemoryInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImagePlaneMemoryInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImagePlaneMemoryInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImagePlaneMemoryInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImagePlaneMemoryInfo *)0)->planeAspect));
    uint32_t byteLength = sizeof(((VkBindImagePlaneMemoryInfo *)0)->planeAspect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImagePlaneMemoryInfo::flush() {
  _VkBindImagePlaneMemoryInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBindImagePlaneMemoryInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImagePlaneMemoryInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImagePlaneMemoryInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImagePlaneMemoryInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindImagePlaneMemoryInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfo.pNext", "[object Object]");
  
    return;
  }
}// planeAspect
Napi::Value _VkBindImagePlaneMemoryInfo::GetplaneAspect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeAspect);
}void _VkBindImagePlaneMemoryInfo::SetplaneAspect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeAspect = static_cast<VkImageAspectFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImagePlaneMemoryInfo.planeAspect", "Number");
  
    return;
  }
}
/** ## END VkBindImagePlaneMemoryInfo ## **/

/** ## BEGIN VkSamplerYcbcrConversionCreateInfoKHR ## **/

Napi::FunctionReference _VkSamplerYcbcrConversionCreateInfoKHR::constructor;

_VkSamplerYcbcrConversionCreateInfoKHR::_VkSamplerYcbcrConversionCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversionCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "ycbcrModel");
      Napi::String sAccess4 = Napi::String::New(env, "ycbcrRange");
      Napi::String sAccess5 = Napi::String::New(env, "components");
      Napi::String sAccess6 = Napi::String::New(env, "xChromaOffset");
      Napi::String sAccess7 = Napi::String::New(env, "yChromaOffset");
      Napi::String sAccess8 = Napi::String::New(env, "chromaFilter");
      Napi::String sAccess9 = Napi::String::New(env, "forceExplicitReconstruction");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetycbcrModel(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetycbcrRange(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setcomponents(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetxChromaOffset(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetyChromaOffset(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetchromaFilter(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetforceExplicitReconstruction(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkSamplerYcbcrConversionCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerYcbcrConversionCreateInfoKHR::~_VkSamplerYcbcrConversionCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  
  
  components.Reset();
  
  
  
  
  
}

Napi::Object _VkSamplerYcbcrConversionCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversionCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerYcbcrConversionCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerYcbcrConversionCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetsType,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetpNext,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkSamplerYcbcrConversionCreateInfoKHR::Getformat,
    &_VkSamplerYcbcrConversionCreateInfoKHR::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "ycbcrModel",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetycbcrModel,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetycbcrModel,
    napi_enumerable
  ),
  InstanceAccessor(
    "ycbcrRange",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetycbcrRange,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetycbcrRange,
    napi_enumerable
  ),
  InstanceAccessor(
    "components",
    &_VkSamplerYcbcrConversionCreateInfoKHR::Getcomponents,
    &_VkSamplerYcbcrConversionCreateInfoKHR::Setcomponents,
    napi_enumerable
  ),
  InstanceAccessor(
    "xChromaOffset",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetxChromaOffset,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetxChromaOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "yChromaOffset",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetyChromaOffset,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetyChromaOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "chromaFilter",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetchromaFilter,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetchromaFilter,
    napi_enumerable
  ),
  InstanceAccessor(
    "forceExplicitReconstruction",
    &_VkSamplerYcbcrConversionCreateInfoKHR::GetforceExplicitReconstruction,
    &_VkSamplerYcbcrConversionCreateInfoKHR::SetforceExplicitReconstruction,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversionCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->format));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->ycbcrModel));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->ycbcrModel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->ycbcrRange));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->ycbcrRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->components));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->components);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->xChromaOffset));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->xChromaOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->yChromaOffset));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->yChromaOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->chromaFilter));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->chromaFilter);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->forceExplicitReconstruction));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfoKHR *)0)->forceExplicitReconstruction);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerYcbcrConversionCreateInfoKHR::flush() {
  _VkSamplerYcbcrConversionCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
  }if (!(self->components.IsEmpty())) {
    Napi::Value value = self->components.Value();
    
    _VkComponentMapping* result = Napi::ObjectWrap<_VkComponentMapping>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.components = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// format
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkSamplerYcbcrConversionCreateInfoKHR::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.format", "Number");
  
    return;
  }
}// ycbcrModel
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetycbcrModel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ycbcrModel);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetycbcrModel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.ycbcrModel = static_cast<VkSamplerYcbcrModelConversion>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.ycbcrModel", "Number");
  
    return;
  }
}// ycbcrRange
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetycbcrRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ycbcrRange);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetycbcrRange(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.ycbcrRange = static_cast<VkSamplerYcbcrRange>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.ycbcrRange", "Number");
  
    return;
  }
}// components
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::Getcomponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->components.IsEmpty()) return env.Null();
  return this->components.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionCreateInfoKHR::Setcomponents(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkComponentMapping::constructor.Value())) {
      
      this->components.Reset(value.ToObject(), 1);
      _VkComponentMapping* inst = Napi::ObjectWrap<_VkComponentMapping>::Unwrap(obj);
      inst->flush();
      this->instance.components = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.components", "[object VkComponentMapping]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->components.Reset();
    memset(&this->instance.components, 0, sizeof(VkComponentMapping));
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.components", "[object VkComponentMapping]");
  
    return;
  }
}// xChromaOffset
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetxChromaOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.xChromaOffset);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetxChromaOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.xChromaOffset = static_cast<VkChromaLocation>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.xChromaOffset", "Number");
  
    return;
  }
}// yChromaOffset
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetyChromaOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.yChromaOffset);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetyChromaOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.yChromaOffset = static_cast<VkChromaLocation>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.yChromaOffset", "Number");
  
    return;
  }
}// chromaFilter
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetchromaFilter(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.chromaFilter);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetchromaFilter(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.chromaFilter = static_cast<VkFilter>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.chromaFilter", "Number");
  
    return;
  }
}// forceExplicitReconstruction
Napi::Value _VkSamplerYcbcrConversionCreateInfoKHR::GetforceExplicitReconstruction(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.forceExplicitReconstruction);
}void _VkSamplerYcbcrConversionCreateInfoKHR::SetforceExplicitReconstruction(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.forceExplicitReconstruction = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.forceExplicitReconstruction = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfoKHR.forceExplicitReconstruction", "Number");
  
    return;
  }
}
/** ## END VkSamplerYcbcrConversionCreateInfoKHR ## **/

/** ## BEGIN VkSamplerYcbcrConversionCreateInfo ## **/

Napi::FunctionReference _VkSamplerYcbcrConversionCreateInfo::constructor;

_VkSamplerYcbcrConversionCreateInfo::_VkSamplerYcbcrConversionCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversionCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "ycbcrModel");
      Napi::String sAccess4 = Napi::String::New(env, "ycbcrRange");
      Napi::String sAccess5 = Napi::String::New(env, "components");
      Napi::String sAccess6 = Napi::String::New(env, "xChromaOffset");
      Napi::String sAccess7 = Napi::String::New(env, "yChromaOffset");
      Napi::String sAccess8 = Napi::String::New(env, "chromaFilter");
      Napi::String sAccess9 = Napi::String::New(env, "forceExplicitReconstruction");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetycbcrModel(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetycbcrRange(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setcomponents(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetxChromaOffset(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetyChromaOffset(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetchromaFilter(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetforceExplicitReconstruction(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkSamplerYcbcrConversionCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerYcbcrConversionCreateInfo::~_VkSamplerYcbcrConversionCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  components.Reset();
  
  
  
  
  
}

Napi::Object _VkSamplerYcbcrConversionCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversionCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerYcbcrConversionCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerYcbcrConversionCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerYcbcrConversionCreateInfo::GetsType,
    &_VkSamplerYcbcrConversionCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerYcbcrConversionCreateInfo::GetpNext,
    &_VkSamplerYcbcrConversionCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkSamplerYcbcrConversionCreateInfo::Getformat,
    &_VkSamplerYcbcrConversionCreateInfo::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "ycbcrModel",
    &_VkSamplerYcbcrConversionCreateInfo::GetycbcrModel,
    &_VkSamplerYcbcrConversionCreateInfo::SetycbcrModel,
    napi_enumerable
  ),
  InstanceAccessor(
    "ycbcrRange",
    &_VkSamplerYcbcrConversionCreateInfo::GetycbcrRange,
    &_VkSamplerYcbcrConversionCreateInfo::SetycbcrRange,
    napi_enumerable
  ),
  InstanceAccessor(
    "components",
    &_VkSamplerYcbcrConversionCreateInfo::Getcomponents,
    &_VkSamplerYcbcrConversionCreateInfo::Setcomponents,
    napi_enumerable
  ),
  InstanceAccessor(
    "xChromaOffset",
    &_VkSamplerYcbcrConversionCreateInfo::GetxChromaOffset,
    &_VkSamplerYcbcrConversionCreateInfo::SetxChromaOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "yChromaOffset",
    &_VkSamplerYcbcrConversionCreateInfo::GetyChromaOffset,
    &_VkSamplerYcbcrConversionCreateInfo::SetyChromaOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "chromaFilter",
    &_VkSamplerYcbcrConversionCreateInfo::GetchromaFilter,
    &_VkSamplerYcbcrConversionCreateInfo::SetchromaFilter,
    napi_enumerable
  ),
  InstanceAccessor(
    "forceExplicitReconstruction",
    &_VkSamplerYcbcrConversionCreateInfo::GetforceExplicitReconstruction,
    &_VkSamplerYcbcrConversionCreateInfo::SetforceExplicitReconstruction,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversionCreateInfo", func);
  return exports;
}

Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->format));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->ycbcrModel));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->ycbcrModel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->ycbcrRange));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->ycbcrRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->components));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->components);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->xChromaOffset));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->xChromaOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->yChromaOffset));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->yChromaOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->chromaFilter));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->chromaFilter);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionCreateInfo *)0)->forceExplicitReconstruction));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionCreateInfo *)0)->forceExplicitReconstruction);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerYcbcrConversionCreateInfo::flush() {
  _VkSamplerYcbcrConversionCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
  }if (!(self->components.IsEmpty())) {
    Napi::Value value = self->components.Value();
    
    _VkComponentMapping* result = Napi::ObjectWrap<_VkComponentMapping>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.components = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerYcbcrConversionCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// format
Napi::Value _VkSamplerYcbcrConversionCreateInfo::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkSamplerYcbcrConversionCreateInfo::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.format", "Number");
  
    return;
  }
}// ycbcrModel
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetycbcrModel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ycbcrModel);
}void _VkSamplerYcbcrConversionCreateInfo::SetycbcrModel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.ycbcrModel = static_cast<VkSamplerYcbcrModelConversion>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.ycbcrModel", "Number");
  
    return;
  }
}// ycbcrRange
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetycbcrRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ycbcrRange);
}void _VkSamplerYcbcrConversionCreateInfo::SetycbcrRange(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.ycbcrRange = static_cast<VkSamplerYcbcrRange>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.ycbcrRange", "Number");
  
    return;
  }
}// components
Napi::Value _VkSamplerYcbcrConversionCreateInfo::Getcomponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->components.IsEmpty()) return env.Null();
  return this->components.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionCreateInfo::Setcomponents(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkComponentMapping::constructor.Value())) {
      
      this->components.Reset(value.ToObject(), 1);
      _VkComponentMapping* inst = Napi::ObjectWrap<_VkComponentMapping>::Unwrap(obj);
      inst->flush();
      this->instance.components = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.components", "[object VkComponentMapping]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->components.Reset();
    memset(&this->instance.components, 0, sizeof(VkComponentMapping));
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.components", "[object VkComponentMapping]");
  
    return;
  }
}// xChromaOffset
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetxChromaOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.xChromaOffset);
}void _VkSamplerYcbcrConversionCreateInfo::SetxChromaOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.xChromaOffset = static_cast<VkChromaLocation>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.xChromaOffset", "Number");
  
    return;
  }
}// yChromaOffset
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetyChromaOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.yChromaOffset);
}void _VkSamplerYcbcrConversionCreateInfo::SetyChromaOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.yChromaOffset = static_cast<VkChromaLocation>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.yChromaOffset", "Number");
  
    return;
  }
}// chromaFilter
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetchromaFilter(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.chromaFilter);
}void _VkSamplerYcbcrConversionCreateInfo::SetchromaFilter(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.chromaFilter = static_cast<VkFilter>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.chromaFilter", "Number");
  
    return;
  }
}// forceExplicitReconstruction
Napi::Value _VkSamplerYcbcrConversionCreateInfo::GetforceExplicitReconstruction(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.forceExplicitReconstruction);
}void _VkSamplerYcbcrConversionCreateInfo::SetforceExplicitReconstruction(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.forceExplicitReconstruction = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.forceExplicitReconstruction = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionCreateInfo.forceExplicitReconstruction", "Number");
  
    return;
  }
}
/** ## END VkSamplerYcbcrConversionCreateInfo ## **/

/** ## BEGIN VkSamplerYcbcrConversionInfoKHR ## **/

Napi::FunctionReference _VkSamplerYcbcrConversionInfoKHR::constructor;

_VkSamplerYcbcrConversionInfoKHR::_VkSamplerYcbcrConversionInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversionInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "conversion");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setconversion(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSamplerYcbcrConversionInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerYcbcrConversionInfoKHR::~_VkSamplerYcbcrConversionInfoKHR() {
  
  
  pNext.Reset();
  
  conversion.Reset();
  
}

Napi::Object _VkSamplerYcbcrConversionInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversionInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerYcbcrConversionInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerYcbcrConversionInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerYcbcrConversionInfoKHR::GetsType,
    &_VkSamplerYcbcrConversionInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerYcbcrConversionInfoKHR::GetpNext,
    &_VkSamplerYcbcrConversionInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "conversion",
    &_VkSamplerYcbcrConversionInfoKHR::Getconversion,
    &_VkSamplerYcbcrConversionInfoKHR::Setconversion,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversionInfoKHR", func);
  return exports;
}

Napi::Value _VkSamplerYcbcrConversionInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerYcbcrConversionInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionInfoKHR *)0)->conversion));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionInfoKHR *)0)->conversion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerYcbcrConversionInfoKHR::flush() {
  _VkSamplerYcbcrConversionInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSamplerYcbcrConversionInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerYcbcrConversionInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerYcbcrConversionInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSamplerYcbcrConversionInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// conversion
Napi::Value _VkSamplerYcbcrConversionInfoKHR::Getconversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->conversion.IsEmpty()) return env.Null();
  return this->conversion.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionInfoKHR::Setconversion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSamplerYcbcrConversion::constructor.Value())) {
      
      this->conversion.Reset(value.ToObject(), 1);
      _VkSamplerYcbcrConversion* inst = Napi::ObjectWrap<_VkSamplerYcbcrConversion>::Unwrap(obj);
      ;
      this->instance.conversion = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfoKHR.conversion", "[object VkSamplerYcbcrConversion]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->conversion.Reset();
    this->instance.conversion = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfoKHR.conversion", "[object VkSamplerYcbcrConversion]");
  
    return;
  }
}
/** ## END VkSamplerYcbcrConversionInfoKHR ## **/

/** ## BEGIN VkSamplerYcbcrConversionInfo ## **/

Napi::FunctionReference _VkSamplerYcbcrConversionInfo::constructor;

_VkSamplerYcbcrConversionInfo::_VkSamplerYcbcrConversionInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerYcbcrConversionInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "conversion");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setconversion(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSamplerYcbcrConversionInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerYcbcrConversionInfo::~_VkSamplerYcbcrConversionInfo() {
  
  
  pNext.Reset();
  
  conversion.Reset();
  
}

Napi::Object _VkSamplerYcbcrConversionInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerYcbcrConversionInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerYcbcrConversionInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerYcbcrConversionInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerYcbcrConversionInfo::GetsType,
    &_VkSamplerYcbcrConversionInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerYcbcrConversionInfo::GetpNext,
    &_VkSamplerYcbcrConversionInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "conversion",
    &_VkSamplerYcbcrConversionInfo::Getconversion,
    &_VkSamplerYcbcrConversionInfo::Setconversion,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerYcbcrConversionInfo", func);
  return exports;
}

Napi::Value _VkSamplerYcbcrConversionInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerYcbcrConversionInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerYcbcrConversionInfo *)0)->conversion));
    uint32_t byteLength = sizeof(((VkSamplerYcbcrConversionInfo *)0)->conversion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerYcbcrConversionInfo::flush() {
  _VkSamplerYcbcrConversionInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSamplerYcbcrConversionInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerYcbcrConversionInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerYcbcrConversionInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSamplerYcbcrConversionInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfo.pNext", "[object Object]");
  
    return;
  }
}// conversion
Napi::Value _VkSamplerYcbcrConversionInfo::Getconversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->conversion.IsEmpty()) return env.Null();
  return this->conversion.Value().As<Napi::Object>();
}void _VkSamplerYcbcrConversionInfo::Setconversion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSamplerYcbcrConversion::constructor.Value())) {
      
      this->conversion.Reset(value.ToObject(), 1);
      _VkSamplerYcbcrConversion* inst = Napi::ObjectWrap<_VkSamplerYcbcrConversion>::Unwrap(obj);
      ;
      this->instance.conversion = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfo.conversion", "[object VkSamplerYcbcrConversion]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->conversion.Reset();
    this->instance.conversion = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerYcbcrConversionInfo.conversion", "[object VkSamplerYcbcrConversion]");
  
    return;
  }
}
/** ## END VkSamplerYcbcrConversionInfo ## **/

/** ## BEGIN VkPipelineTessellationDomainOriginStateCreateInfoKHR ## **/

Napi::FunctionReference _VkPipelineTessellationDomainOriginStateCreateInfoKHR::constructor;

_VkPipelineTessellationDomainOriginStateCreateInfoKHR::_VkPipelineTessellationDomainOriginStateCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineTessellationDomainOriginStateCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "domainOrigin");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdomainOrigin(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPipelineTessellationDomainOriginStateCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineTessellationDomainOriginStateCreateInfoKHR::~_VkPipelineTessellationDomainOriginStateCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPipelineTessellationDomainOriginStateCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineTessellationDomainOriginStateCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetsType,
    &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetpNext,
    &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "domainOrigin",
    &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetdomainOrigin,
    &_VkPipelineTessellationDomainOriginStateCreateInfoKHR::SetdomainOrigin,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineTessellationDomainOriginStateCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationDomainOriginStateCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineTessellationDomainOriginStateCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationDomainOriginStateCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineTessellationDomainOriginStateCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationDomainOriginStateCreateInfoKHR *)0)->domainOrigin));
    uint32_t byteLength = sizeof(((VkPipelineTessellationDomainOriginStateCreateInfoKHR *)0)->domainOrigin);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineTessellationDomainOriginStateCreateInfoKHR::flush() {
  _VkPipelineTessellationDomainOriginStateCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineTessellationDomainOriginStateCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineTessellationDomainOriginStateCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// domainOrigin
Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfoKHR::GetdomainOrigin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.domainOrigin);
}void _VkPipelineTessellationDomainOriginStateCreateInfoKHR::SetdomainOrigin(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.domainOrigin = static_cast<VkTessellationDomainOrigin>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfoKHR.domainOrigin", "Number");
  
    return;
  }
}
/** ## END VkPipelineTessellationDomainOriginStateCreateInfoKHR ## **/

/** ## BEGIN VkPipelineTessellationDomainOriginStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineTessellationDomainOriginStateCreateInfo::constructor;

_VkPipelineTessellationDomainOriginStateCreateInfo::_VkPipelineTessellationDomainOriginStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineTessellationDomainOriginStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "domainOrigin");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdomainOrigin(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPipelineTessellationDomainOriginStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineTessellationDomainOriginStateCreateInfo::~_VkPipelineTessellationDomainOriginStateCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPipelineTessellationDomainOriginStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineTessellationDomainOriginStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineTessellationDomainOriginStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineTessellationDomainOriginStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineTessellationDomainOriginStateCreateInfo::GetsType,
    &_VkPipelineTessellationDomainOriginStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineTessellationDomainOriginStateCreateInfo::GetpNext,
    &_VkPipelineTessellationDomainOriginStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "domainOrigin",
    &_VkPipelineTessellationDomainOriginStateCreateInfo::GetdomainOrigin,
    &_VkPipelineTessellationDomainOriginStateCreateInfo::SetdomainOrigin,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineTessellationDomainOriginStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationDomainOriginStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineTessellationDomainOriginStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationDomainOriginStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineTessellationDomainOriginStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationDomainOriginStateCreateInfo *)0)->domainOrigin));
    uint32_t byteLength = sizeof(((VkPipelineTessellationDomainOriginStateCreateInfo *)0)->domainOrigin);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineTessellationDomainOriginStateCreateInfo::flush() {
  _VkPipelineTessellationDomainOriginStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineTessellationDomainOriginStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineTessellationDomainOriginStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineTessellationDomainOriginStateCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// domainOrigin
Napi::Value _VkPipelineTessellationDomainOriginStateCreateInfo::GetdomainOrigin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.domainOrigin);
}void _VkPipelineTessellationDomainOriginStateCreateInfo::SetdomainOrigin(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.domainOrigin = static_cast<VkTessellationDomainOrigin>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfo.domainOrigin", "Number");
  
    return;
  }
}
/** ## END VkPipelineTessellationDomainOriginStateCreateInfo ## **/

/** ## BEGIN VkImageViewUsageCreateInfoKHR ## **/

Napi::FunctionReference _VkImageViewUsageCreateInfoKHR::constructor;

_VkImageViewUsageCreateInfoKHR::_VkImageViewUsageCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageViewUsageCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "usage");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setusage(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageViewUsageCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageViewUsageCreateInfoKHR::~_VkImageViewUsageCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkImageViewUsageCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageViewUsageCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageViewUsageCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageViewUsageCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageViewUsageCreateInfoKHR::GetsType,
    &_VkImageViewUsageCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageViewUsageCreateInfoKHR::GetpNext,
    &_VkImageViewUsageCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkImageViewUsageCreateInfoKHR::Getusage,
    &_VkImageViewUsageCreateInfoKHR::Setusage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageViewUsageCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkImageViewUsageCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageViewUsageCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewUsageCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageViewUsageCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewUsageCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageViewUsageCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewUsageCreateInfoKHR *)0)->usage));
    uint32_t byteLength = sizeof(((VkImageViewUsageCreateInfoKHR *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageViewUsageCreateInfoKHR::flush() {
  _VkImageViewUsageCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageViewUsageCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageViewUsageCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageViewUsageCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageViewUsageCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImageViewUsageCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// usage
Napi::Value _VkImageViewUsageCreateInfoKHR::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkImageViewUsageCreateInfoKHR::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfoKHR.usage", "Number");
  
    return;
  }
}
/** ## END VkImageViewUsageCreateInfoKHR ## **/

/** ## BEGIN VkImageViewUsageCreateInfo ## **/

Napi::FunctionReference _VkImageViewUsageCreateInfo::constructor;

_VkImageViewUsageCreateInfo::_VkImageViewUsageCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageViewUsageCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "usage");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setusage(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageViewUsageCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageViewUsageCreateInfo::~_VkImageViewUsageCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkImageViewUsageCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageViewUsageCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageViewUsageCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageViewUsageCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageViewUsageCreateInfo::GetsType,
    &_VkImageViewUsageCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageViewUsageCreateInfo::GetpNext,
    &_VkImageViewUsageCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkImageViewUsageCreateInfo::Getusage,
    &_VkImageViewUsageCreateInfo::Setusage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageViewUsageCreateInfo", func);
  return exports;
}

Napi::Value _VkImageViewUsageCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageViewUsageCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewUsageCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageViewUsageCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewUsageCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageViewUsageCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewUsageCreateInfo *)0)->usage));
    uint32_t byteLength = sizeof(((VkImageViewUsageCreateInfo *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageViewUsageCreateInfo::flush() {
  _VkImageViewUsageCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageViewUsageCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageViewUsageCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageViewUsageCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageViewUsageCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImageViewUsageCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// usage
Napi::Value _VkImageViewUsageCreateInfo::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkImageViewUsageCreateInfo::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewUsageCreateInfo.usage", "Number");
  
    return;
  }
}
/** ## END VkImageViewUsageCreateInfo ## **/

/** ## BEGIN VkMemoryDedicatedAllocateInfoKHR ## **/

Napi::FunctionReference _VkMemoryDedicatedAllocateInfoKHR::constructor;

_VkMemoryDedicatedAllocateInfoKHR::_VkMemoryDedicatedAllocateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryDedicatedAllocateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      Napi::String sAccess3 = Napi::String::New(env, "buffer");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setbuffer(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryDedicatedAllocateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryDedicatedAllocateInfoKHR::~_VkMemoryDedicatedAllocateInfoKHR() {
  
  
  pNext.Reset();
  
  image.Reset();
  
  buffer.Reset();
  
}

Napi::Object _VkMemoryDedicatedAllocateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryDedicatedAllocateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryDedicatedAllocateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryDedicatedAllocateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryDedicatedAllocateInfoKHR::GetsType,
    &_VkMemoryDedicatedAllocateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryDedicatedAllocateInfoKHR::GetpNext,
    &_VkMemoryDedicatedAllocateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkMemoryDedicatedAllocateInfoKHR::Getimage,
    &_VkMemoryDedicatedAllocateInfoKHR::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkMemoryDedicatedAllocateInfoKHR::Getbuffer,
    &_VkMemoryDedicatedAllocateInfoKHR::Setbuffer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryDedicatedAllocateInfoKHR", func);
  return exports;
}

Napi::Value _VkMemoryDedicatedAllocateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryDedicatedAllocateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfoKHR *)0)->image));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfoKHR *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfoKHR *)0)->buffer));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfoKHR *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryDedicatedAllocateInfoKHR::flush() {
  _VkMemoryDedicatedAllocateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryDedicatedAllocateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryDedicatedAllocateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryDedicatedAllocateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryDedicatedAllocateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryDedicatedAllocateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkMemoryDedicatedAllocateInfoKHR::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkMemoryDedicatedAllocateInfoKHR::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.image", "[object VkImage]");
  
    return;
  }
}// buffer
Napi::Value _VkMemoryDedicatedAllocateInfoKHR::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkMemoryDedicatedAllocateInfoKHR::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfoKHR.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkMemoryDedicatedAllocateInfoKHR ## **/

/** ## BEGIN VkMemoryDedicatedAllocateInfo ## **/

Napi::FunctionReference _VkMemoryDedicatedAllocateInfo::constructor;

_VkMemoryDedicatedAllocateInfo::_VkMemoryDedicatedAllocateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryDedicatedAllocateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      Napi::String sAccess3 = Napi::String::New(env, "buffer");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setbuffer(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryDedicatedAllocateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryDedicatedAllocateInfo::~_VkMemoryDedicatedAllocateInfo() {
  
  
  pNext.Reset();
  
  image.Reset();
  
  buffer.Reset();
  
}

Napi::Object _VkMemoryDedicatedAllocateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryDedicatedAllocateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryDedicatedAllocateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryDedicatedAllocateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryDedicatedAllocateInfo::GetsType,
    &_VkMemoryDedicatedAllocateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryDedicatedAllocateInfo::GetpNext,
    &_VkMemoryDedicatedAllocateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkMemoryDedicatedAllocateInfo::Getimage,
    &_VkMemoryDedicatedAllocateInfo::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkMemoryDedicatedAllocateInfo::Getbuffer,
    &_VkMemoryDedicatedAllocateInfo::Setbuffer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryDedicatedAllocateInfo", func);
  return exports;
}

Napi::Value _VkMemoryDedicatedAllocateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryDedicatedAllocateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfo *)0)->image));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfo *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedAllocateInfo *)0)->buffer));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedAllocateInfo *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryDedicatedAllocateInfo::flush() {
  _VkMemoryDedicatedAllocateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryDedicatedAllocateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryDedicatedAllocateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryDedicatedAllocateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryDedicatedAllocateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryDedicatedAllocateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkMemoryDedicatedAllocateInfo::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkMemoryDedicatedAllocateInfo::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.image", "[object VkImage]");
  
    return;
  }
}// buffer
Napi::Value _VkMemoryDedicatedAllocateInfo::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkMemoryDedicatedAllocateInfo::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedAllocateInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkMemoryDedicatedAllocateInfo ## **/

/** ## BEGIN VkMemoryDedicatedRequirementsKHR ## **/

Napi::FunctionReference _VkMemoryDedicatedRequirementsKHR::constructor;

_VkMemoryDedicatedRequirementsKHR::_VkMemoryDedicatedRequirementsKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryDedicatedRequirementsKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMemoryDedicatedRequirementsKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryDedicatedRequirementsKHR::~_VkMemoryDedicatedRequirementsKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkMemoryDedicatedRequirementsKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryDedicatedRequirementsKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryDedicatedRequirementsKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryDedicatedRequirementsKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryDedicatedRequirementsKHR::GetsType,
    &_VkMemoryDedicatedRequirementsKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryDedicatedRequirementsKHR::GetpNext,
    &_VkMemoryDedicatedRequirementsKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "prefersDedicatedAllocation",
    &_VkMemoryDedicatedRequirementsKHR::GetprefersDedicatedAllocation,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "requiresDedicatedAllocation",
    &_VkMemoryDedicatedRequirementsKHR::GetrequiresDedicatedAllocation,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryDedicatedRequirementsKHR", func);
  return exports;
}

Napi::Value _VkMemoryDedicatedRequirementsKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryDedicatedRequirementsKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirementsKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirementsKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirementsKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirementsKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirementsKHR *)0)->prefersDedicatedAllocation));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirementsKHR *)0)->prefersDedicatedAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirementsKHR *)0)->requiresDedicatedAllocation));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirementsKHR *)0)->requiresDedicatedAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryDedicatedRequirementsKHR::flush() {
  _VkMemoryDedicatedRequirementsKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryDedicatedRequirementsKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryDedicatedRequirementsKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedRequirementsKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryDedicatedRequirementsKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryDedicatedRequirementsKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryDedicatedRequirementsKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedRequirementsKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedRequirementsKHR.pNext", "[object Object]");
  
    return;
  }
}// prefersDedicatedAllocation
Napi::Value _VkMemoryDedicatedRequirementsKHR::GetprefersDedicatedAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.prefersDedicatedAllocation);
}// requiresDedicatedAllocation
Napi::Value _VkMemoryDedicatedRequirementsKHR::GetrequiresDedicatedAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.requiresDedicatedAllocation);
}
/** ## END VkMemoryDedicatedRequirementsKHR ## **/

/** ## BEGIN VkMemoryDedicatedRequirements ## **/

Napi::FunctionReference _VkMemoryDedicatedRequirements::constructor;

_VkMemoryDedicatedRequirements::_VkMemoryDedicatedRequirements(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryDedicatedRequirements>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMemoryDedicatedRequirements constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryDedicatedRequirements::~_VkMemoryDedicatedRequirements() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkMemoryDedicatedRequirements::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryDedicatedRequirements", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryDedicatedRequirements::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryDedicatedRequirements::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryDedicatedRequirements::GetsType,
    &_VkMemoryDedicatedRequirements::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryDedicatedRequirements::GetpNext,
    &_VkMemoryDedicatedRequirements::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "prefersDedicatedAllocation",
    &_VkMemoryDedicatedRequirements::GetprefersDedicatedAllocation,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "requiresDedicatedAllocation",
    &_VkMemoryDedicatedRequirements::GetrequiresDedicatedAllocation,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryDedicatedRequirements", func);
  return exports;
}

Napi::Value _VkMemoryDedicatedRequirements::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryDedicatedRequirements::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirements *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirements *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirements *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirements *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirements *)0)->prefersDedicatedAllocation));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirements *)0)->prefersDedicatedAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryDedicatedRequirements *)0)->requiresDedicatedAllocation));
    uint32_t byteLength = sizeof(((VkMemoryDedicatedRequirements *)0)->requiresDedicatedAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryDedicatedRequirements::flush() {
  _VkMemoryDedicatedRequirements *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryDedicatedRequirements::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryDedicatedRequirements::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedRequirements.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryDedicatedRequirements::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryDedicatedRequirements::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryDedicatedRequirements.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryDedicatedRequirements.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryDedicatedRequirements.pNext", "[object Object]");
  
    return;
  }
}// prefersDedicatedAllocation
Napi::Value _VkMemoryDedicatedRequirements::GetprefersDedicatedAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.prefersDedicatedAllocation);
}// requiresDedicatedAllocation
Napi::Value _VkMemoryDedicatedRequirements::GetrequiresDedicatedAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.requiresDedicatedAllocation);
}
/** ## END VkMemoryDedicatedRequirements ## **/

/** ## BEGIN VkPhysicalDevicePointClippingPropertiesKHR ## **/

Napi::FunctionReference _VkPhysicalDevicePointClippingPropertiesKHR::constructor;

_VkPhysicalDevicePointClippingPropertiesKHR::_VkPhysicalDevicePointClippingPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevicePointClippingPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDevicePointClippingPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDevicePointClippingPropertiesKHR::~_VkPhysicalDevicePointClippingPropertiesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDevicePointClippingPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevicePointClippingPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDevicePointClippingPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDevicePointClippingPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDevicePointClippingPropertiesKHR::GetsType,
    &_VkPhysicalDevicePointClippingPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDevicePointClippingPropertiesKHR::GetpNext,
    &_VkPhysicalDevicePointClippingPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "pointClippingBehavior",
    &_VkPhysicalDevicePointClippingPropertiesKHR::GetpointClippingBehavior,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevicePointClippingPropertiesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDevicePointClippingPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDevicePointClippingPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePointClippingPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePointClippingPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePointClippingPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePointClippingPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePointClippingPropertiesKHR *)0)->pointClippingBehavior));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePointClippingPropertiesKHR *)0)->pointClippingBehavior);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDevicePointClippingPropertiesKHR::flush() {
  _VkPhysicalDevicePointClippingPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDevicePointClippingPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDevicePointClippingPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePointClippingPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDevicePointClippingPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDevicePointClippingPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDevicePointClippingPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDevicePointClippingPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePointClippingPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// pointClippingBehavior
Napi::Value _VkPhysicalDevicePointClippingPropertiesKHR::GetpointClippingBehavior(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pointClippingBehavior);
}
/** ## END VkPhysicalDevicePointClippingPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDevicePointClippingProperties ## **/

Napi::FunctionReference _VkPhysicalDevicePointClippingProperties::constructor;

_VkPhysicalDevicePointClippingProperties::_VkPhysicalDevicePointClippingProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevicePointClippingProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDevicePointClippingProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDevicePointClippingProperties::~_VkPhysicalDevicePointClippingProperties() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDevicePointClippingProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevicePointClippingProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDevicePointClippingProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDevicePointClippingProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDevicePointClippingProperties::GetsType,
    &_VkPhysicalDevicePointClippingProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDevicePointClippingProperties::GetpNext,
    &_VkPhysicalDevicePointClippingProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "pointClippingBehavior",
    &_VkPhysicalDevicePointClippingProperties::GetpointClippingBehavior,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevicePointClippingProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDevicePointClippingProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDevicePointClippingProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePointClippingProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePointClippingProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePointClippingProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePointClippingProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePointClippingProperties *)0)->pointClippingBehavior));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePointClippingProperties *)0)->pointClippingBehavior);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDevicePointClippingProperties::flush() {
  _VkPhysicalDevicePointClippingProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDevicePointClippingProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDevicePointClippingProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePointClippingProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDevicePointClippingProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDevicePointClippingProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDevicePointClippingProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDevicePointClippingProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePointClippingProperties.pNext", "[object Object]");
  
    return;
  }
}// pointClippingBehavior
Napi::Value _VkPhysicalDevicePointClippingProperties::GetpointClippingBehavior(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pointClippingBehavior);
}
/** ## END VkPhysicalDevicePointClippingProperties ## **/

/** ## BEGIN VkSparseImageMemoryRequirements2KHR ## **/

Napi::FunctionReference _VkSparseImageMemoryRequirements2KHR::constructor;

_VkSparseImageMemoryRequirements2KHR::_VkSparseImageMemoryRequirements2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageMemoryRequirements2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSparseImageMemoryRequirements2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageMemoryRequirements2KHR::~_VkSparseImageMemoryRequirements2KHR() {
  
  
  pNext.Reset();
  
  memoryRequirements.Reset();
  
}

Napi::Object _VkSparseImageMemoryRequirements2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageMemoryRequirements2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageMemoryRequirements2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageMemoryRequirements2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSparseImageMemoryRequirements2KHR::GetsType,
    &_VkSparseImageMemoryRequirements2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSparseImageMemoryRequirements2KHR::GetpNext,
    &_VkSparseImageMemoryRequirements2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryRequirements",
    &_VkSparseImageMemoryRequirements2KHR::GetmemoryRequirements,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageMemoryRequirements2KHR", func);
  return exports;
}

Napi::Value _VkSparseImageMemoryRequirements2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageMemoryRequirements2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements2KHR *)0)->memoryRequirements));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements2KHR *)0)->memoryRequirements);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageMemoryRequirements2KHR::flush() {
  _VkSparseImageMemoryRequirements2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->memoryRequirements.IsEmpty())) {
    Napi::Value value = self->memoryRequirements.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSparseImageMemoryRequirements2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSparseImageMemoryRequirements2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryRequirements2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSparseImageMemoryRequirements2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSparseImageMemoryRequirements2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSparseImageMemoryRequirements2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryRequirements2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryRequirements2KHR.pNext", "[object Object]");
  
    return;
  }
}// memoryRequirements
Napi::Value _VkSparseImageMemoryRequirements2KHR::GetmemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryRequirements.IsEmpty()) return env.Null();
  return this->memoryRequirements.Value().As<Napi::Object>();
}
/** ## END VkSparseImageMemoryRequirements2KHR ## **/

/** ## BEGIN VkSparseImageMemoryRequirements2 ## **/

Napi::FunctionReference _VkSparseImageMemoryRequirements2::constructor;

_VkSparseImageMemoryRequirements2::_VkSparseImageMemoryRequirements2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageMemoryRequirements2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSparseImageMemoryRequirements2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageMemoryRequirements2::~_VkSparseImageMemoryRequirements2() {
  
  
  pNext.Reset();
  
  memoryRequirements.Reset();
  
}

Napi::Object _VkSparseImageMemoryRequirements2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageMemoryRequirements2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageMemoryRequirements2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageMemoryRequirements2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSparseImageMemoryRequirements2::GetsType,
    &_VkSparseImageMemoryRequirements2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSparseImageMemoryRequirements2::GetpNext,
    &_VkSparseImageMemoryRequirements2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryRequirements",
    &_VkSparseImageMemoryRequirements2::GetmemoryRequirements,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageMemoryRequirements2", func);
  return exports;
}

Napi::Value _VkSparseImageMemoryRequirements2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageMemoryRequirements2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements2 *)0)->memoryRequirements));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements2 *)0)->memoryRequirements);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageMemoryRequirements2::flush() {
  _VkSparseImageMemoryRequirements2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->memoryRequirements.IsEmpty())) {
    Napi::Value value = self->memoryRequirements.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSparseImageMemoryRequirements2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSparseImageMemoryRequirements2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryRequirements2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSparseImageMemoryRequirements2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSparseImageMemoryRequirements2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSparseImageMemoryRequirements2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryRequirements2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryRequirements2.pNext", "[object Object]");
  
    return;
  }
}// memoryRequirements
Napi::Value _VkSparseImageMemoryRequirements2::GetmemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryRequirements.IsEmpty()) return env.Null();
  return this->memoryRequirements.Value().As<Napi::Object>();
}
/** ## END VkSparseImageMemoryRequirements2 ## **/

/** ## BEGIN VkMemoryRequirements2KHR ## **/

Napi::FunctionReference _VkMemoryRequirements2KHR::constructor;

_VkMemoryRequirements2KHR::_VkMemoryRequirements2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryRequirements2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMemoryRequirements2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryRequirements2KHR::~_VkMemoryRequirements2KHR() {
  
  
  pNext.Reset();
  
  memoryRequirements.Reset();
  
}

Napi::Object _VkMemoryRequirements2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryRequirements2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryRequirements2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryRequirements2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryRequirements2KHR::GetsType,
    &_VkMemoryRequirements2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryRequirements2KHR::GetpNext,
    &_VkMemoryRequirements2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryRequirements",
    &_VkMemoryRequirements2KHR::GetmemoryRequirements,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryRequirements2KHR", func);
  return exports;
}

Napi::Value _VkMemoryRequirements2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryRequirements2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryRequirements2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryRequirements2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements2KHR *)0)->memoryRequirements));
    uint32_t byteLength = sizeof(((VkMemoryRequirements2KHR *)0)->memoryRequirements);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryRequirements2KHR::flush() {
  _VkMemoryRequirements2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->memoryRequirements.IsEmpty())) {
    Napi::Value value = self->memoryRequirements.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryRequirements2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryRequirements2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryRequirements2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryRequirements2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryRequirements2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkMemoryRequirements2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkMemoryRequirements2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryRequirements2KHR.pNext", "[object Object]");
  
    return;
  }
}// memoryRequirements
Napi::Value _VkMemoryRequirements2KHR::GetmemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryRequirements.IsEmpty()) return env.Null();
  return this->memoryRequirements.Value().As<Napi::Object>();
}
/** ## END VkMemoryRequirements2KHR ## **/

/** ## BEGIN VkMemoryRequirements2 ## **/

Napi::FunctionReference _VkMemoryRequirements2::constructor;

_VkMemoryRequirements2::_VkMemoryRequirements2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryRequirements2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMemoryRequirements2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryRequirements2::~_VkMemoryRequirements2() {
  
  
  pNext.Reset();
  
  memoryRequirements.Reset();
  
}

Napi::Object _VkMemoryRequirements2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryRequirements2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryRequirements2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryRequirements2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryRequirements2::GetsType,
    &_VkMemoryRequirements2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryRequirements2::GetpNext,
    &_VkMemoryRequirements2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryRequirements",
    &_VkMemoryRequirements2::GetmemoryRequirements,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryRequirements2", func);
  return exports;
}

Napi::Value _VkMemoryRequirements2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryRequirements2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryRequirements2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryRequirements2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements2 *)0)->memoryRequirements));
    uint32_t byteLength = sizeof(((VkMemoryRequirements2 *)0)->memoryRequirements);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryRequirements2::flush() {
  _VkMemoryRequirements2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->memoryRequirements.IsEmpty())) {
    Napi::Value value = self->memoryRequirements.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryRequirements2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryRequirements2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryRequirements2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryRequirements2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryRequirements2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkMemoryRequirements2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkMemoryRequirements2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryRequirements2.pNext", "[object Object]");
  
    return;
  }
}// memoryRequirements
Napi::Value _VkMemoryRequirements2::GetmemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryRequirements.IsEmpty()) return env.Null();
  return this->memoryRequirements.Value().As<Napi::Object>();
}
/** ## END VkMemoryRequirements2 ## **/

/** ## BEGIN VkImageSparseMemoryRequirementsInfo2KHR ## **/

Napi::FunctionReference _VkImageSparseMemoryRequirementsInfo2KHR::constructor;

_VkImageSparseMemoryRequirementsInfo2KHR::_VkImageSparseMemoryRequirementsInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageSparseMemoryRequirementsInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageSparseMemoryRequirementsInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageSparseMemoryRequirementsInfo2KHR::~_VkImageSparseMemoryRequirementsInfo2KHR() {
  
  
  pNext.Reset();
  
  image.Reset();
  
}

Napi::Object _VkImageSparseMemoryRequirementsInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageSparseMemoryRequirementsInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageSparseMemoryRequirementsInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageSparseMemoryRequirementsInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageSparseMemoryRequirementsInfo2KHR::GetsType,
    &_VkImageSparseMemoryRequirementsInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageSparseMemoryRequirementsInfo2KHR::GetpNext,
    &_VkImageSparseMemoryRequirementsInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkImageSparseMemoryRequirementsInfo2KHR::Getimage,
    &_VkImageSparseMemoryRequirementsInfo2KHR::Setimage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageSparseMemoryRequirementsInfo2KHR", func);
  return exports;
}

Napi::Value _VkImageSparseMemoryRequirementsInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageSparseMemoryRequirementsInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSparseMemoryRequirementsInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageSparseMemoryRequirementsInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSparseMemoryRequirementsInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageSparseMemoryRequirementsInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSparseMemoryRequirementsInfo2KHR *)0)->image));
    uint32_t byteLength = sizeof(((VkImageSparseMemoryRequirementsInfo2KHR *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageSparseMemoryRequirementsInfo2KHR::flush() {
  _VkImageSparseMemoryRequirementsInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageSparseMemoryRequirementsInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageSparseMemoryRequirementsInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageSparseMemoryRequirementsInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageSparseMemoryRequirementsInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImageSparseMemoryRequirementsInfo2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkImageSparseMemoryRequirementsInfo2KHR::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkImageSparseMemoryRequirementsInfo2KHR::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2KHR.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2KHR.image", "[object VkImage]");
  
    return;
  }
}
/** ## END VkImageSparseMemoryRequirementsInfo2KHR ## **/

/** ## BEGIN VkImageSparseMemoryRequirementsInfo2 ## **/

Napi::FunctionReference _VkImageSparseMemoryRequirementsInfo2::constructor;

_VkImageSparseMemoryRequirementsInfo2::_VkImageSparseMemoryRequirementsInfo2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageSparseMemoryRequirementsInfo2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageSparseMemoryRequirementsInfo2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageSparseMemoryRequirementsInfo2::~_VkImageSparseMemoryRequirementsInfo2() {
  
  
  pNext.Reset();
  
  image.Reset();
  
}

Napi::Object _VkImageSparseMemoryRequirementsInfo2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageSparseMemoryRequirementsInfo2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageSparseMemoryRequirementsInfo2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageSparseMemoryRequirementsInfo2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageSparseMemoryRequirementsInfo2::GetsType,
    &_VkImageSparseMemoryRequirementsInfo2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageSparseMemoryRequirementsInfo2::GetpNext,
    &_VkImageSparseMemoryRequirementsInfo2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkImageSparseMemoryRequirementsInfo2::Getimage,
    &_VkImageSparseMemoryRequirementsInfo2::Setimage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageSparseMemoryRequirementsInfo2", func);
  return exports;
}

Napi::Value _VkImageSparseMemoryRequirementsInfo2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageSparseMemoryRequirementsInfo2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSparseMemoryRequirementsInfo2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageSparseMemoryRequirementsInfo2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSparseMemoryRequirementsInfo2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageSparseMemoryRequirementsInfo2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSparseMemoryRequirementsInfo2 *)0)->image));
    uint32_t byteLength = sizeof(((VkImageSparseMemoryRequirementsInfo2 *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageSparseMemoryRequirementsInfo2::flush() {
  _VkImageSparseMemoryRequirementsInfo2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageSparseMemoryRequirementsInfo2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageSparseMemoryRequirementsInfo2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageSparseMemoryRequirementsInfo2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageSparseMemoryRequirementsInfo2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImageSparseMemoryRequirementsInfo2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkImageSparseMemoryRequirementsInfo2::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkImageSparseMemoryRequirementsInfo2::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageSparseMemoryRequirementsInfo2.image", "[object VkImage]");
  
    return;
  }
}
/** ## END VkImageSparseMemoryRequirementsInfo2 ## **/

/** ## BEGIN VkImageMemoryRequirementsInfo2KHR ## **/

Napi::FunctionReference _VkImageMemoryRequirementsInfo2KHR::constructor;

_VkImageMemoryRequirementsInfo2KHR::_VkImageMemoryRequirementsInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageMemoryRequirementsInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageMemoryRequirementsInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageMemoryRequirementsInfo2KHR::~_VkImageMemoryRequirementsInfo2KHR() {
  
  
  pNext.Reset();
  
  image.Reset();
  
}

Napi::Object _VkImageMemoryRequirementsInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageMemoryRequirementsInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageMemoryRequirementsInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageMemoryRequirementsInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageMemoryRequirementsInfo2KHR::GetsType,
    &_VkImageMemoryRequirementsInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageMemoryRequirementsInfo2KHR::GetpNext,
    &_VkImageMemoryRequirementsInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkImageMemoryRequirementsInfo2KHR::Getimage,
    &_VkImageMemoryRequirementsInfo2KHR::Setimage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageMemoryRequirementsInfo2KHR", func);
  return exports;
}

Napi::Value _VkImageMemoryRequirementsInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageMemoryRequirementsInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryRequirementsInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageMemoryRequirementsInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryRequirementsInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageMemoryRequirementsInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryRequirementsInfo2KHR *)0)->image));
    uint32_t byteLength = sizeof(((VkImageMemoryRequirementsInfo2KHR *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageMemoryRequirementsInfo2KHR::flush() {
  _VkImageMemoryRequirementsInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO) {
      _VkImagePlaneMemoryRequirementsInfo* structExt = Napi::ObjectWrap<_VkImagePlaneMemoryRequirementsInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkImageMemoryRequirementsInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageMemoryRequirementsInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageMemoryRequirementsInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageMemoryRequirementsInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkImageMemoryRequirementsInfo2KHR::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkImageMemoryRequirementsInfo2KHR::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2KHR.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2KHR.image", "[object VkImage]");
  
    return;
  }
}
/** ## END VkImageMemoryRequirementsInfo2KHR ## **/

/** ## BEGIN VkImageMemoryRequirementsInfo2 ## **/

Napi::FunctionReference _VkImageMemoryRequirementsInfo2::constructor;

_VkImageMemoryRequirementsInfo2::_VkImageMemoryRequirementsInfo2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageMemoryRequirementsInfo2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageMemoryRequirementsInfo2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageMemoryRequirementsInfo2::~_VkImageMemoryRequirementsInfo2() {
  
  
  pNext.Reset();
  
  image.Reset();
  
}

Napi::Object _VkImageMemoryRequirementsInfo2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageMemoryRequirementsInfo2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageMemoryRequirementsInfo2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageMemoryRequirementsInfo2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageMemoryRequirementsInfo2::GetsType,
    &_VkImageMemoryRequirementsInfo2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageMemoryRequirementsInfo2::GetpNext,
    &_VkImageMemoryRequirementsInfo2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkImageMemoryRequirementsInfo2::Getimage,
    &_VkImageMemoryRequirementsInfo2::Setimage,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageMemoryRequirementsInfo2", func);
  return exports;
}

Napi::Value _VkImageMemoryRequirementsInfo2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageMemoryRequirementsInfo2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryRequirementsInfo2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageMemoryRequirementsInfo2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryRequirementsInfo2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageMemoryRequirementsInfo2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryRequirementsInfo2 *)0)->image));
    uint32_t byteLength = sizeof(((VkImageMemoryRequirementsInfo2 *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageMemoryRequirementsInfo2::flush() {
  _VkImageMemoryRequirementsInfo2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO) {
      _VkImagePlaneMemoryRequirementsInfo* structExt = Napi::ObjectWrap<_VkImagePlaneMemoryRequirementsInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkImageMemoryRequirementsInfo2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageMemoryRequirementsInfo2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageMemoryRequirementsInfo2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageMemoryRequirementsInfo2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkImageMemoryRequirementsInfo2::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkImageMemoryRequirementsInfo2::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryRequirementsInfo2.image", "[object VkImage]");
  
    return;
  }
}
/** ## END VkImageMemoryRequirementsInfo2 ## **/

/** ## BEGIN VkBufferMemoryRequirementsInfo2KHR ## **/

Napi::FunctionReference _VkBufferMemoryRequirementsInfo2KHR::constructor;

_VkBufferMemoryRequirementsInfo2KHR::_VkBufferMemoryRequirementsInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferMemoryRequirementsInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkBufferMemoryRequirementsInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferMemoryRequirementsInfo2KHR::~_VkBufferMemoryRequirementsInfo2KHR() {
  
  
  pNext.Reset();
  
  buffer.Reset();
  
}

Napi::Object _VkBufferMemoryRequirementsInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferMemoryRequirementsInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferMemoryRequirementsInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferMemoryRequirementsInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBufferMemoryRequirementsInfo2KHR::GetsType,
    &_VkBufferMemoryRequirementsInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBufferMemoryRequirementsInfo2KHR::GetpNext,
    &_VkBufferMemoryRequirementsInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkBufferMemoryRequirementsInfo2KHR::Getbuffer,
    &_VkBufferMemoryRequirementsInfo2KHR::Setbuffer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferMemoryRequirementsInfo2KHR", func);
  return exports;
}

Napi::Value _VkBufferMemoryRequirementsInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferMemoryRequirementsInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryRequirementsInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBufferMemoryRequirementsInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryRequirementsInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBufferMemoryRequirementsInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryRequirementsInfo2KHR *)0)->buffer));
    uint32_t byteLength = sizeof(((VkBufferMemoryRequirementsInfo2KHR *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferMemoryRequirementsInfo2KHR::flush() {
  _VkBufferMemoryRequirementsInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBufferMemoryRequirementsInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBufferMemoryRequirementsInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBufferMemoryRequirementsInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBufferMemoryRequirementsInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBufferMemoryRequirementsInfo2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// buffer
Napi::Value _VkBufferMemoryRequirementsInfo2KHR::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkBufferMemoryRequirementsInfo2KHR::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2KHR.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2KHR.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkBufferMemoryRequirementsInfo2KHR ## **/

/** ## BEGIN VkBufferMemoryRequirementsInfo2 ## **/

Napi::FunctionReference _VkBufferMemoryRequirementsInfo2::constructor;

_VkBufferMemoryRequirementsInfo2::_VkBufferMemoryRequirementsInfo2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferMemoryRequirementsInfo2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkBufferMemoryRequirementsInfo2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferMemoryRequirementsInfo2::~_VkBufferMemoryRequirementsInfo2() {
  
  
  pNext.Reset();
  
  buffer.Reset();
  
}

Napi::Object _VkBufferMemoryRequirementsInfo2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferMemoryRequirementsInfo2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferMemoryRequirementsInfo2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferMemoryRequirementsInfo2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBufferMemoryRequirementsInfo2::GetsType,
    &_VkBufferMemoryRequirementsInfo2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBufferMemoryRequirementsInfo2::GetpNext,
    &_VkBufferMemoryRequirementsInfo2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkBufferMemoryRequirementsInfo2::Getbuffer,
    &_VkBufferMemoryRequirementsInfo2::Setbuffer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferMemoryRequirementsInfo2", func);
  return exports;
}

Napi::Value _VkBufferMemoryRequirementsInfo2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferMemoryRequirementsInfo2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryRequirementsInfo2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkBufferMemoryRequirementsInfo2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryRequirementsInfo2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBufferMemoryRequirementsInfo2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryRequirementsInfo2 *)0)->buffer));
    uint32_t byteLength = sizeof(((VkBufferMemoryRequirementsInfo2 *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferMemoryRequirementsInfo2::flush() {
  _VkBufferMemoryRequirementsInfo2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBufferMemoryRequirementsInfo2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBufferMemoryRequirementsInfo2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBufferMemoryRequirementsInfo2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBufferMemoryRequirementsInfo2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBufferMemoryRequirementsInfo2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2.pNext", "[object Object]");
  
    return;
  }
}// buffer
Napi::Value _VkBufferMemoryRequirementsInfo2::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkBufferMemoryRequirementsInfo2::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryRequirementsInfo2.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkBufferMemoryRequirementsInfo2 ## **/

/** ## BEGIN VkPhysicalDeviceSubgroupProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceSubgroupProperties::constructor;

_VkPhysicalDeviceSubgroupProperties::_VkPhysicalDeviceSubgroupProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSubgroupProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSubgroupProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSubgroupProperties::~_VkPhysicalDeviceSubgroupProperties() {
  
  
  pNext.Reset();
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceSubgroupProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSubgroupProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSubgroupProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSubgroupProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSubgroupProperties::GetsType,
    &_VkPhysicalDeviceSubgroupProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSubgroupProperties::GetpNext,
    &_VkPhysicalDeviceSubgroupProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "subgroupSize",
    &_VkPhysicalDeviceSubgroupProperties::GetsubgroupSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedStages",
    &_VkPhysicalDeviceSubgroupProperties::GetsupportedStages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedOperations",
    &_VkPhysicalDeviceSubgroupProperties::GetsupportedOperations,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "quadOperationsInAllStages",
    &_VkPhysicalDeviceSubgroupProperties::GetquadOperationsInAllStages,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSubgroupProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSubgroupProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSubgroupProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSubgroupProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSubgroupProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSubgroupProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSubgroupProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSubgroupProperties *)0)->subgroupSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSubgroupProperties *)0)->subgroupSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSubgroupProperties *)0)->supportedStages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSubgroupProperties *)0)->supportedStages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSubgroupProperties *)0)->supportedOperations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSubgroupProperties *)0)->supportedOperations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSubgroupProperties *)0)->quadOperationsInAllStages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSubgroupProperties *)0)->quadOperationsInAllStages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSubgroupProperties::flush() {
  _VkPhysicalDeviceSubgroupProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSubgroupProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSubgroupProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSubgroupProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSubgroupProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSubgroupProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSubgroupProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSubgroupProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSubgroupProperties.pNext", "[object Object]");
  
    return;
  }
}// subgroupSize
Napi::Value _VkPhysicalDeviceSubgroupProperties::GetsubgroupSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subgroupSize);
}// supportedStages
Napi::Value _VkPhysicalDeviceSubgroupProperties::GetsupportedStages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedStages);
}// supportedOperations
Napi::Value _VkPhysicalDeviceSubgroupProperties::GetsupportedOperations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedOperations);
}// quadOperationsInAllStages
Napi::Value _VkPhysicalDeviceSubgroupProperties::GetquadOperationsInAllStages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.quadOperationsInAllStages);
}
/** ## END VkPhysicalDeviceSubgroupProperties ## **/

/** ## BEGIN VkPhysicalDevice16BitStorageFeaturesKHR ## **/

Napi::FunctionReference _VkPhysicalDevice16BitStorageFeaturesKHR::constructor;

_VkPhysicalDevice16BitStorageFeaturesKHR::_VkPhysicalDevice16BitStorageFeaturesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevice16BitStorageFeaturesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "storageBuffer16BitAccess");
      Napi::String sAccess3 = Napi::String::New(env, "uniformAndStorageBuffer16BitAccess");
      Napi::String sAccess4 = Napi::String::New(env, "storagePushConstant16");
      Napi::String sAccess5 = Napi::String::New(env, "storageInputOutput16");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetstorageBuffer16BitAccess(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetuniformAndStorageBuffer16BitAccess(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetstoragePushConstant16(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetstorageInputOutput16(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDevice16BitStorageFeaturesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDevice16BitStorageFeaturesKHR::~_VkPhysicalDevice16BitStorageFeaturesKHR() {
  
  
  pNext.Reset();
  
  
  
  
  
}

Napi::Object _VkPhysicalDevice16BitStorageFeaturesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevice16BitStorageFeaturesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDevice16BitStorageFeaturesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDevice16BitStorageFeaturesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDevice16BitStorageFeaturesKHR::GetsType,
    &_VkPhysicalDevice16BitStorageFeaturesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDevice16BitStorageFeaturesKHR::GetpNext,
    &_VkPhysicalDevice16BitStorageFeaturesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "storageBuffer16BitAccess",
    &_VkPhysicalDevice16BitStorageFeaturesKHR::GetstorageBuffer16BitAccess,
    &_VkPhysicalDevice16BitStorageFeaturesKHR::SetstorageBuffer16BitAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "uniformAndStorageBuffer16BitAccess",
    &_VkPhysicalDevice16BitStorageFeaturesKHR::GetuniformAndStorageBuffer16BitAccess,
    &_VkPhysicalDevice16BitStorageFeaturesKHR::SetuniformAndStorageBuffer16BitAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "storagePushConstant16",
    &_VkPhysicalDevice16BitStorageFeaturesKHR::GetstoragePushConstant16,
    &_VkPhysicalDevice16BitStorageFeaturesKHR::SetstoragePushConstant16,
    napi_enumerable
  ),
  InstanceAccessor(
    "storageInputOutput16",
    &_VkPhysicalDevice16BitStorageFeaturesKHR::GetstorageInputOutput16,
    &_VkPhysicalDevice16BitStorageFeaturesKHR::SetstorageInputOutput16,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevice16BitStorageFeaturesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->storageBuffer16BitAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->storageBuffer16BitAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->uniformAndStorageBuffer16BitAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->uniformAndStorageBuffer16BitAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->storagePushConstant16));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->storagePushConstant16);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->storageInputOutput16));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeaturesKHR *)0)->storageInputOutput16);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDevice16BitStorageFeaturesKHR::flush() {
  _VkPhysicalDevice16BitStorageFeaturesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDevice16BitStorageFeaturesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDevice16BitStorageFeaturesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDevice16BitStorageFeaturesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.pNext", "[object Object]");
  
    return;
  }
}// storageBuffer16BitAccess
Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetstorageBuffer16BitAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storageBuffer16BitAccess);
}void _VkPhysicalDevice16BitStorageFeaturesKHR::SetstorageBuffer16BitAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.storageBuffer16BitAccess", "Number");
  
    return;
  }
}// uniformAndStorageBuffer16BitAccess
Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetuniformAndStorageBuffer16BitAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.uniformAndStorageBuffer16BitAccess);
}void _VkPhysicalDevice16BitStorageFeaturesKHR::SetuniformAndStorageBuffer16BitAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.uniformAndStorageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.uniformAndStorageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.uniformAndStorageBuffer16BitAccess", "Number");
  
    return;
  }
}// storagePushConstant16
Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetstoragePushConstant16(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storagePushConstant16);
}void _VkPhysicalDevice16BitStorageFeaturesKHR::SetstoragePushConstant16(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storagePushConstant16 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storagePushConstant16 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.storagePushConstant16", "Number");
  
    return;
  }
}// storageInputOutput16
Napi::Value _VkPhysicalDevice16BitStorageFeaturesKHR::GetstorageInputOutput16(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storageInputOutput16);
}void _VkPhysicalDevice16BitStorageFeaturesKHR::SetstorageInputOutput16(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storageInputOutput16 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storageInputOutput16 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeaturesKHR.storageInputOutput16", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDevice16BitStorageFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDevice16BitStorageFeatures ## **/

Napi::FunctionReference _VkPhysicalDevice16BitStorageFeatures::constructor;

_VkPhysicalDevice16BitStorageFeatures::_VkPhysicalDevice16BitStorageFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevice16BitStorageFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "storageBuffer16BitAccess");
      Napi::String sAccess3 = Napi::String::New(env, "uniformAndStorageBuffer16BitAccess");
      Napi::String sAccess4 = Napi::String::New(env, "storagePushConstant16");
      Napi::String sAccess5 = Napi::String::New(env, "storageInputOutput16");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetstorageBuffer16BitAccess(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetuniformAndStorageBuffer16BitAccess(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetstoragePushConstant16(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetstorageInputOutput16(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDevice16BitStorageFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDevice16BitStorageFeatures::~_VkPhysicalDevice16BitStorageFeatures() {
  
  
  pNext.Reset();
  
  
  
  
  
}

Napi::Object _VkPhysicalDevice16BitStorageFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevice16BitStorageFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDevice16BitStorageFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDevice16BitStorageFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDevice16BitStorageFeatures::GetsType,
    &_VkPhysicalDevice16BitStorageFeatures::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDevice16BitStorageFeatures::GetpNext,
    &_VkPhysicalDevice16BitStorageFeatures::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "storageBuffer16BitAccess",
    &_VkPhysicalDevice16BitStorageFeatures::GetstorageBuffer16BitAccess,
    &_VkPhysicalDevice16BitStorageFeatures::SetstorageBuffer16BitAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "uniformAndStorageBuffer16BitAccess",
    &_VkPhysicalDevice16BitStorageFeatures::GetuniformAndStorageBuffer16BitAccess,
    &_VkPhysicalDevice16BitStorageFeatures::SetuniformAndStorageBuffer16BitAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "storagePushConstant16",
    &_VkPhysicalDevice16BitStorageFeatures::GetstoragePushConstant16,
    &_VkPhysicalDevice16BitStorageFeatures::SetstoragePushConstant16,
    napi_enumerable
  ),
  InstanceAccessor(
    "storageInputOutput16",
    &_VkPhysicalDevice16BitStorageFeatures::GetstorageInputOutput16,
    &_VkPhysicalDevice16BitStorageFeatures::SetstorageInputOutput16,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevice16BitStorageFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeatures *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeatures *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeatures *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeatures *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeatures *)0)->storageBuffer16BitAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeatures *)0)->storageBuffer16BitAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeatures *)0)->uniformAndStorageBuffer16BitAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeatures *)0)->uniformAndStorageBuffer16BitAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeatures *)0)->storagePushConstant16));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeatures *)0)->storagePushConstant16);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevice16BitStorageFeatures *)0)->storageInputOutput16));
    uint32_t byteLength = sizeof(((VkPhysicalDevice16BitStorageFeatures *)0)->storageInputOutput16);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDevice16BitStorageFeatures::flush() {
  _VkPhysicalDevice16BitStorageFeatures *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDevice16BitStorageFeatures::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDevice16BitStorageFeatures::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDevice16BitStorageFeatures.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.pNext", "[object Object]");
  
    return;
  }
}// storageBuffer16BitAccess
Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetstorageBuffer16BitAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storageBuffer16BitAccess);
}void _VkPhysicalDevice16BitStorageFeatures::SetstorageBuffer16BitAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.storageBuffer16BitAccess", "Number");
  
    return;
  }
}// uniformAndStorageBuffer16BitAccess
Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetuniformAndStorageBuffer16BitAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.uniformAndStorageBuffer16BitAccess);
}void _VkPhysicalDevice16BitStorageFeatures::SetuniformAndStorageBuffer16BitAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.uniformAndStorageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.uniformAndStorageBuffer16BitAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.uniformAndStorageBuffer16BitAccess", "Number");
  
    return;
  }
}// storagePushConstant16
Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetstoragePushConstant16(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storagePushConstant16);
}void _VkPhysicalDevice16BitStorageFeatures::SetstoragePushConstant16(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storagePushConstant16 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storagePushConstant16 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.storagePushConstant16", "Number");
  
    return;
  }
}// storageInputOutput16
Napi::Value _VkPhysicalDevice16BitStorageFeatures::GetstorageInputOutput16(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storageInputOutput16);
}void _VkPhysicalDevice16BitStorageFeatures::SetstorageInputOutput16(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.storageInputOutput16 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.storageInputOutput16 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevice16BitStorageFeatures.storageInputOutput16", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDevice16BitStorageFeatures ## **/

/** ## BEGIN VkSharedPresentSurfaceCapabilitiesKHR ## **/

Napi::FunctionReference _VkSharedPresentSurfaceCapabilitiesKHR::constructor;

_VkSharedPresentSurfaceCapabilitiesKHR::_VkSharedPresentSurfaceCapabilitiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSharedPresentSurfaceCapabilitiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSharedPresentSurfaceCapabilitiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSharedPresentSurfaceCapabilitiesKHR::~_VkSharedPresentSurfaceCapabilitiesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSharedPresentSurfaceCapabilitiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSharedPresentSurfaceCapabilitiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSharedPresentSurfaceCapabilitiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSharedPresentSurfaceCapabilitiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSharedPresentSurfaceCapabilitiesKHR::GetsType,
    &_VkSharedPresentSurfaceCapabilitiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSharedPresentSurfaceCapabilitiesKHR::GetpNext,
    &_VkSharedPresentSurfaceCapabilitiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "sharedPresentSupportedUsageFlags",
    &_VkSharedPresentSurfaceCapabilitiesKHR::GetsharedPresentSupportedUsageFlags,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSharedPresentSurfaceCapabilitiesKHR", func);
  return exports;
}

Napi::Value _VkSharedPresentSurfaceCapabilitiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSharedPresentSurfaceCapabilitiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSharedPresentSurfaceCapabilitiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSharedPresentSurfaceCapabilitiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSharedPresentSurfaceCapabilitiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSharedPresentSurfaceCapabilitiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSharedPresentSurfaceCapabilitiesKHR *)0)->sharedPresentSupportedUsageFlags));
    uint32_t byteLength = sizeof(((VkSharedPresentSurfaceCapabilitiesKHR *)0)->sharedPresentSupportedUsageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSharedPresentSurfaceCapabilitiesKHR::flush() {
  _VkSharedPresentSurfaceCapabilitiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSharedPresentSurfaceCapabilitiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSharedPresentSurfaceCapabilitiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSharedPresentSurfaceCapabilitiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSharedPresentSurfaceCapabilitiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSharedPresentSurfaceCapabilitiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSharedPresentSurfaceCapabilitiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSharedPresentSurfaceCapabilitiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSharedPresentSurfaceCapabilitiesKHR.pNext", "[object Object]");
  
    return;
  }
}// sharedPresentSupportedUsageFlags
Napi::Value _VkSharedPresentSurfaceCapabilitiesKHR::GetsharedPresentSupportedUsageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sharedPresentSupportedUsageFlags);
}
/** ## END VkSharedPresentSurfaceCapabilitiesKHR ## **/

/** ## BEGIN VkDisplayPlaneCapabilities2KHR ## **/

Napi::FunctionReference _VkDisplayPlaneCapabilities2KHR::constructor;

_VkDisplayPlaneCapabilities2KHR::_VkDisplayPlaneCapabilities2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPlaneCapabilities2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDisplayPlaneCapabilities2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPlaneCapabilities2KHR::~_VkDisplayPlaneCapabilities2KHR() {
  
  
  pNext.Reset();
  
  capabilities.Reset();
  
}

Napi::Object _VkDisplayPlaneCapabilities2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPlaneCapabilities2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPlaneCapabilities2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPlaneCapabilities2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayPlaneCapabilities2KHR::GetsType,
    &_VkDisplayPlaneCapabilities2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayPlaneCapabilities2KHR::GetpNext,
    &_VkDisplayPlaneCapabilities2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "capabilities",
    &_VkDisplayPlaneCapabilities2KHR::Getcapabilities,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPlaneCapabilities2KHR", func);
  return exports;
}

Napi::Value _VkDisplayPlaneCapabilities2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPlaneCapabilities2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilities2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilities2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilities2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilities2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilities2KHR *)0)->capabilities));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilities2KHR *)0)->capabilities);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPlaneCapabilities2KHR::flush() {
  _VkDisplayPlaneCapabilities2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->capabilities.IsEmpty())) {
    Napi::Value value = self->capabilities.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayPlaneCapabilities2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayPlaneCapabilities2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneCapabilities2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayPlaneCapabilities2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayPlaneCapabilities2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayPlaneCapabilities2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPlaneCapabilities2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneCapabilities2KHR.pNext", "[object Object]");
  
    return;
  }
}// capabilities
Napi::Value _VkDisplayPlaneCapabilities2KHR::Getcapabilities(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->capabilities.IsEmpty()) return env.Null();
  return this->capabilities.Value().As<Napi::Object>();
}
/** ## END VkDisplayPlaneCapabilities2KHR ## **/

/** ## BEGIN VkDisplayPlaneInfo2KHR ## **/

Napi::FunctionReference _VkDisplayPlaneInfo2KHR::constructor;

_VkDisplayPlaneInfo2KHR::_VkDisplayPlaneInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPlaneInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "mode");
      Napi::String sAccess3 = Napi::String::New(env, "planeIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmode(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetplaneIndex(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDisplayPlaneInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPlaneInfo2KHR::~_VkDisplayPlaneInfo2KHR() {
  
  
  pNext.Reset();
  
  mode.Reset();
  
  
}

Napi::Object _VkDisplayPlaneInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPlaneInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPlaneInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPlaneInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayPlaneInfo2KHR::GetsType,
    &_VkDisplayPlaneInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayPlaneInfo2KHR::GetpNext,
    &_VkDisplayPlaneInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "mode",
    &_VkDisplayPlaneInfo2KHR::Getmode,
    &_VkDisplayPlaneInfo2KHR::Setmode,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeIndex",
    &_VkDisplayPlaneInfo2KHR::GetplaneIndex,
    &_VkDisplayPlaneInfo2KHR::SetplaneIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPlaneInfo2KHR", func);
  return exports;
}

Napi::Value _VkDisplayPlaneInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPlaneInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayPlaneInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayPlaneInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneInfo2KHR *)0)->mode));
    uint32_t byteLength = sizeof(((VkDisplayPlaneInfo2KHR *)0)->mode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneInfo2KHR *)0)->planeIndex));
    uint32_t byteLength = sizeof(((VkDisplayPlaneInfo2KHR *)0)->planeIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPlaneInfo2KHR::flush() {
  _VkDisplayPlaneInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayPlaneInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayPlaneInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayPlaneInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayPlaneInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayPlaneInfo2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPlaneInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// mode
Napi::Value _VkDisplayPlaneInfo2KHR::Getmode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->mode.IsEmpty()) return env.Null();
  return this->mode.Value().As<Napi::Object>();
}void _VkDisplayPlaneInfo2KHR::Setmode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDisplayModeKHR::constructor.Value())) {
      
      this->mode.Reset(value.ToObject(), 1);
      _VkDisplayModeKHR* inst = Napi::ObjectWrap<_VkDisplayModeKHR>::Unwrap(obj);
      ;
      this->instance.mode = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPlaneInfo2KHR.mode", "[object VkDisplayModeKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->mode.Reset();
    this->instance.mode = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneInfo2KHR.mode", "[object VkDisplayModeKHR]");
  
    return;
  }
}// planeIndex
Napi::Value _VkDisplayPlaneInfo2KHR::GetplaneIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeIndex);
}void _VkDisplayPlaneInfo2KHR::SetplaneIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneInfo2KHR.planeIndex", "Number");
  
    return;
  }
}
/** ## END VkDisplayPlaneInfo2KHR ## **/

/** ## BEGIN VkDisplayModeProperties2KHR ## **/

Napi::FunctionReference _VkDisplayModeProperties2KHR::constructor;

_VkDisplayModeProperties2KHR::_VkDisplayModeProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayModeProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDisplayModeProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayModeProperties2KHR::~_VkDisplayModeProperties2KHR() {
  
  
  pNext.Reset();
  
  displayModeProperties.Reset();
  
}

Napi::Object _VkDisplayModeProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayModeProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayModeProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayModeProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayModeProperties2KHR::GetsType,
    &_VkDisplayModeProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayModeProperties2KHR::GetpNext,
    &_VkDisplayModeProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayModeProperties",
    &_VkDisplayModeProperties2KHR::GetdisplayModeProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayModeProperties2KHR", func);
  return exports;
}

Napi::Value _VkDisplayModeProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayModeProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayModeProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayModeProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeProperties2KHR *)0)->displayModeProperties));
    uint32_t byteLength = sizeof(((VkDisplayModeProperties2KHR *)0)->displayModeProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayModeProperties2KHR::flush() {
  _VkDisplayModeProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->displayModeProperties.IsEmpty())) {
    Napi::Value value = self->displayModeProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayModeProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayModeProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayModeProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayModeProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayModeProperties2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayModeProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// displayModeProperties
Napi::Value _VkDisplayModeProperties2KHR::GetdisplayModeProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayModeProperties.IsEmpty()) return env.Null();
  return this->displayModeProperties.Value().As<Napi::Object>();
}
/** ## END VkDisplayModeProperties2KHR ## **/

/** ## BEGIN VkDisplayPlaneProperties2KHR ## **/

Napi::FunctionReference _VkDisplayPlaneProperties2KHR::constructor;

_VkDisplayPlaneProperties2KHR::_VkDisplayPlaneProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPlaneProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDisplayPlaneProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPlaneProperties2KHR::~_VkDisplayPlaneProperties2KHR() {
  
  
  pNext.Reset();
  
  displayPlaneProperties.Reset();
  
}

Napi::Object _VkDisplayPlaneProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPlaneProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPlaneProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPlaneProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayPlaneProperties2KHR::GetsType,
    &_VkDisplayPlaneProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayPlaneProperties2KHR::GetpNext,
    &_VkDisplayPlaneProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayPlaneProperties",
    &_VkDisplayPlaneProperties2KHR::GetdisplayPlaneProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPlaneProperties2KHR", func);
  return exports;
}

Napi::Value _VkDisplayPlaneProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPlaneProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayPlaneProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayPlaneProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneProperties2KHR *)0)->displayPlaneProperties));
    uint32_t byteLength = sizeof(((VkDisplayPlaneProperties2KHR *)0)->displayPlaneProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPlaneProperties2KHR::flush() {
  _VkDisplayPlaneProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->displayPlaneProperties.IsEmpty())) {
    Napi::Value value = self->displayPlaneProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayPlaneProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayPlaneProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayPlaneProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayPlaneProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayPlaneProperties2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPlaneProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPlaneProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// displayPlaneProperties
Napi::Value _VkDisplayPlaneProperties2KHR::GetdisplayPlaneProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayPlaneProperties.IsEmpty()) return env.Null();
  return this->displayPlaneProperties.Value().As<Napi::Object>();
}
/** ## END VkDisplayPlaneProperties2KHR ## **/

/** ## BEGIN VkDisplayProperties2KHR ## **/

Napi::FunctionReference _VkDisplayProperties2KHR::constructor;

_VkDisplayProperties2KHR::_VkDisplayProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDisplayProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayProperties2KHR::~_VkDisplayProperties2KHR() {
  
  
  pNext.Reset();
  
  displayProperties.Reset();
  
}

Napi::Object _VkDisplayProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayProperties2KHR::GetsType,
    &_VkDisplayProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayProperties2KHR::GetpNext,
    &_VkDisplayProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayProperties",
    &_VkDisplayProperties2KHR::GetdisplayProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayProperties2KHR", func);
  return exports;
}

Napi::Value _VkDisplayProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayProperties2KHR *)0)->displayProperties));
    uint32_t byteLength = sizeof(((VkDisplayProperties2KHR *)0)->displayProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayProperties2KHR::flush() {
  _VkDisplayProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->displayProperties.IsEmpty())) {
    Napi::Value value = self->displayProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayProperties2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// displayProperties
Napi::Value _VkDisplayProperties2KHR::GetdisplayProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayProperties.IsEmpty()) return env.Null();
  return this->displayProperties.Value().As<Napi::Object>();
}
/** ## END VkDisplayProperties2KHR ## **/

/** ## BEGIN VkSurfaceFormat2KHR ## **/

Napi::FunctionReference _VkSurfaceFormat2KHR::constructor;

_VkSurfaceFormat2KHR::_VkSurfaceFormat2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSurfaceFormat2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSurfaceFormat2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSurfaceFormat2KHR::~_VkSurfaceFormat2KHR() {
  
  
  pNext.Reset();
  
  surfaceFormat.Reset();
  
}

Napi::Object _VkSurfaceFormat2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSurfaceFormat2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSurfaceFormat2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSurfaceFormat2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSurfaceFormat2KHR::GetsType,
    &_VkSurfaceFormat2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSurfaceFormat2KHR::GetpNext,
    &_VkSurfaceFormat2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "surfaceFormat",
    &_VkSurfaceFormat2KHR::GetsurfaceFormat,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSurfaceFormat2KHR", func);
  return exports;
}

Napi::Value _VkSurfaceFormat2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSurfaceFormat2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceFormat2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSurfaceFormat2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceFormat2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSurfaceFormat2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceFormat2KHR *)0)->surfaceFormat));
    uint32_t byteLength = sizeof(((VkSurfaceFormat2KHR *)0)->surfaceFormat);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSurfaceFormat2KHR::flush() {
  _VkSurfaceFormat2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->surfaceFormat.IsEmpty())) {
    Napi::Value value = self->surfaceFormat.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSurfaceFormat2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSurfaceFormat2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSurfaceFormat2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSurfaceFormat2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSurfaceFormat2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSurfaceFormat2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSurfaceFormat2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSurfaceFormat2KHR.pNext", "[object Object]");
  
    return;
  }
}// surfaceFormat
Napi::Value _VkSurfaceFormat2KHR::GetsurfaceFormat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->surfaceFormat.IsEmpty()) return env.Null();
  return this->surfaceFormat.Value().As<Napi::Object>();
}
/** ## END VkSurfaceFormat2KHR ## **/

/** ## BEGIN VkSurfaceCapabilities2KHR ## **/

Napi::FunctionReference _VkSurfaceCapabilities2KHR::constructor;

_VkSurfaceCapabilities2KHR::_VkSurfaceCapabilities2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSurfaceCapabilities2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSurfaceCapabilities2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSurfaceCapabilities2KHR::~_VkSurfaceCapabilities2KHR() {
  
  
  pNext.Reset();
  
  surfaceCapabilities.Reset();
  
}

Napi::Object _VkSurfaceCapabilities2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSurfaceCapabilities2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSurfaceCapabilities2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSurfaceCapabilities2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSurfaceCapabilities2KHR::GetsType,
    &_VkSurfaceCapabilities2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSurfaceCapabilities2KHR::GetpNext,
    &_VkSurfaceCapabilities2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "surfaceCapabilities",
    &_VkSurfaceCapabilities2KHR::GetsurfaceCapabilities,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSurfaceCapabilities2KHR", func);
  return exports;
}

Napi::Value _VkSurfaceCapabilities2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSurfaceCapabilities2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2KHR *)0)->surfaceCapabilities));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2KHR *)0)->surfaceCapabilities);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSurfaceCapabilities2KHR::flush() {
  _VkSurfaceCapabilities2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->surfaceCapabilities.IsEmpty())) {
    Napi::Value value = self->surfaceCapabilities.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSurfaceCapabilities2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSurfaceCapabilities2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSurfaceCapabilities2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSurfaceCapabilities2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSurfaceCapabilities2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSurfaceCapabilities2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSurfaceCapabilities2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSurfaceCapabilities2KHR.pNext", "[object Object]");
  
    return;
  }
}// surfaceCapabilities
Napi::Value _VkSurfaceCapabilities2KHR::GetsurfaceCapabilities(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->surfaceCapabilities.IsEmpty()) return env.Null();
  return this->surfaceCapabilities.Value().As<Napi::Object>();
}
/** ## END VkSurfaceCapabilities2KHR ## **/

/** ## BEGIN VkPhysicalDeviceSurfaceInfo2KHR ## **/

Napi::FunctionReference _VkPhysicalDeviceSurfaceInfo2KHR::constructor;

_VkPhysicalDeviceSurfaceInfo2KHR::_VkPhysicalDeviceSurfaceInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSurfaceInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "surface");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsurface(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSurfaceInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSurfaceInfo2KHR::~_VkPhysicalDeviceSurfaceInfo2KHR() {
  
  
  pNext.Reset();
  
  surface.Reset();
  
}

Napi::Object _VkPhysicalDeviceSurfaceInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSurfaceInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSurfaceInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSurfaceInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSurfaceInfo2KHR::GetsType,
    &_VkPhysicalDeviceSurfaceInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSurfaceInfo2KHR::GetpNext,
    &_VkPhysicalDeviceSurfaceInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "surface",
    &_VkPhysicalDeviceSurfaceInfo2KHR::Getsurface,
    &_VkPhysicalDeviceSurfaceInfo2KHR::Setsurface,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSurfaceInfo2KHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSurfaceInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSurfaceInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSurfaceInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSurfaceInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSurfaceInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSurfaceInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSurfaceInfo2KHR *)0)->surface));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSurfaceInfo2KHR *)0)->surface);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSurfaceInfo2KHR::flush() {
  _VkPhysicalDeviceSurfaceInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSurfaceInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSurfaceInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSurfaceInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSurfaceInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSurfaceInfo2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// surface
Napi::Value _VkPhysicalDeviceSurfaceInfo2KHR::Getsurface(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->surface.IsEmpty()) return env.Null();
  return this->surface.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSurfaceInfo2KHR::Setsurface(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSurfaceKHR::constructor.Value())) {
      
      this->surface.Reset(value.ToObject(), 1);
      _VkSurfaceKHR* inst = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
      ;
      this->instance.surface = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.surface", "[object VkSurfaceKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->surface.Reset();
    this->instance.surface = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.surface", "[object VkSurfaceKHR]");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSurfaceInfo2KHR ## **/

/** ## BEGIN VkRenderPassInputAttachmentAspectCreateInfoKHR ## **/

Napi::FunctionReference _VkRenderPassInputAttachmentAspectCreateInfoKHR::constructor;

_VkRenderPassInputAttachmentAspectCreateInfoKHR::_VkRenderPassInputAttachmentAspectCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassInputAttachmentAspectCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR;
    vpAspectReferences = new std::vector<VkInputAttachmentAspectReference>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "aspectReferenceCount");
      Napi::String sAccess3 = Napi::String::New(env, "pAspectReferences");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetaspectReferenceCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpAspectReferences(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkRenderPassInputAttachmentAspectCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassInputAttachmentAspectCreateInfoKHR::~_VkRenderPassInputAttachmentAspectCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  vpAspectReferences->clear();
  delete vpAspectReferences;
  
  pAspectReferences.Reset();
  
}

Napi::Object _VkRenderPassInputAttachmentAspectCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassInputAttachmentAspectCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassInputAttachmentAspectCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassInputAttachmentAspectCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::GetsType,
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::GetpNext,
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "aspectReferenceCount",
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::GetaspectReferenceCount,
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::SetaspectReferenceCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAspectReferences",
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::GetpAspectReferences,
    &_VkRenderPassInputAttachmentAspectCreateInfoKHR::SetpAspectReferences,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassInputAttachmentAspectCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkRenderPassInputAttachmentAspectCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassInputAttachmentAspectCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->aspectReferenceCount));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->aspectReferenceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->pAspectReferences));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfoKHR *)0)->pAspectReferences);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassInputAttachmentAspectCreateInfoKHR::flush() {
  _VkRenderPassInputAttachmentAspectCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAspectReferences.IsEmpty())) {
    Napi::Value value = self->pAspectReferences.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.aspectReferenceCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkInputAttachmentAspectReference>* data = this->vpAspectReferences;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkInputAttachmentAspectReference::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
        return false;
      }
      _VkInputAttachmentAspectReference* result = Napi::ObjectWrap<_VkInputAttachmentAspectReference>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAspectReferences = data->data();
  }
  return true;
}

// sType
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassInputAttachmentAspectCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassInputAttachmentAspectCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// aspectReferenceCount
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfoKHR::GetaspectReferenceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectReferenceCount);
}void _VkRenderPassInputAttachmentAspectCreateInfoKHR::SetaspectReferenceCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectReferenceCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.aspectReferenceCount", "Number");
  
    return;
  }
}// pAspectReferences
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfoKHR::GetpAspectReferences(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAspectReferences.IsEmpty()) return env.Null();
  return this->pAspectReferences.Value().As<Napi::Array>();
}void _VkRenderPassInputAttachmentAspectCreateInfoKHR::SetpAspectReferences(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAspectReferences.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAspectReferences.Reset();
      this->instance.pAspectReferences = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAspectReferences = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
    return;
  }
}
/** ## END VkRenderPassInputAttachmentAspectCreateInfoKHR ## **/

/** ## BEGIN VkRenderPassInputAttachmentAspectCreateInfo ## **/

Napi::FunctionReference _VkRenderPassInputAttachmentAspectCreateInfo::constructor;

_VkRenderPassInputAttachmentAspectCreateInfo::_VkRenderPassInputAttachmentAspectCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    vpAspectReferences = new std::vector<VkInputAttachmentAspectReference>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "aspectReferenceCount");
      Napi::String sAccess3 = Napi::String::New(env, "pAspectReferences");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetaspectReferenceCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpAspectReferences(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkRenderPassInputAttachmentAspectCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassInputAttachmentAspectCreateInfo::~_VkRenderPassInputAttachmentAspectCreateInfo() {
  
  
  pNext.Reset();
  
  
  vpAspectReferences->clear();
  delete vpAspectReferences;
  
  pAspectReferences.Reset();
  
}

Napi::Object _VkRenderPassInputAttachmentAspectCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassInputAttachmentAspectCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassInputAttachmentAspectCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassInputAttachmentAspectCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassInputAttachmentAspectCreateInfo::GetsType,
    &_VkRenderPassInputAttachmentAspectCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassInputAttachmentAspectCreateInfo::GetpNext,
    &_VkRenderPassInputAttachmentAspectCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "aspectReferenceCount",
    &_VkRenderPassInputAttachmentAspectCreateInfo::GetaspectReferenceCount,
    &_VkRenderPassInputAttachmentAspectCreateInfo::SetaspectReferenceCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAspectReferences",
    &_VkRenderPassInputAttachmentAspectCreateInfo::GetpAspectReferences,
    &_VkRenderPassInputAttachmentAspectCreateInfo::SetpAspectReferences,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassInputAttachmentAspectCreateInfo", func);
  return exports;
}

Napi::Value _VkRenderPassInputAttachmentAspectCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassInputAttachmentAspectCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->aspectReferenceCount));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->aspectReferenceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->pAspectReferences));
    uint32_t byteLength = sizeof(((VkRenderPassInputAttachmentAspectCreateInfo *)0)->pAspectReferences);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassInputAttachmentAspectCreateInfo::flush() {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAspectReferences.IsEmpty())) {
    Napi::Value value = self->pAspectReferences.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.aspectReferenceCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkInputAttachmentAspectReference>* data = this->vpAspectReferences;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkInputAttachmentAspectReference::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
        return false;
      }
      _VkInputAttachmentAspectReference* result = Napi::ObjectWrap<_VkInputAttachmentAspectReference>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAspectReferences = data->data();
  }
  return true;
}

// sType
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassInputAttachmentAspectCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassInputAttachmentAspectCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkRenderPassInputAttachmentAspectCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// aspectReferenceCount
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfo::GetaspectReferenceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectReferenceCount);
}void _VkRenderPassInputAttachmentAspectCreateInfo::SetaspectReferenceCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectReferenceCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.aspectReferenceCount", "Number");
  
    return;
  }
}// pAspectReferences
Napi::Value _VkRenderPassInputAttachmentAspectCreateInfo::GetpAspectReferences(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAspectReferences.IsEmpty()) return env.Null();
  return this->pAspectReferences.Value().As<Napi::Array>();
}void _VkRenderPassInputAttachmentAspectCreateInfo::SetpAspectReferences(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAspectReferences.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAspectReferences.Reset();
      this->instance.pAspectReferences = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAspectReferences = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
    return;
  }
}
/** ## END VkRenderPassInputAttachmentAspectCreateInfo ## **/

/** ## BEGIN VkInputAttachmentAspectReferenceKHR ## **/

Napi::FunctionReference _VkInputAttachmentAspectReferenceKHR::constructor;

_VkInputAttachmentAspectReferenceKHR::_VkInputAttachmentAspectReferenceKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkInputAttachmentAspectReferenceKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "subpass");
      Napi::String sAccess1 = Napi::String::New(env, "inputAttachmentIndex");
      Napi::String sAccess2 = Napi::String::New(env, "aspectMask");
      if (obj.Has(sAccess0)) this->Setsubpass(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetinputAttachmentIndex(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetaspectMask(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkInputAttachmentAspectReferenceKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkInputAttachmentAspectReferenceKHR::~_VkInputAttachmentAspectReferenceKHR() {
  
  
  
  
}

Napi::Object _VkInputAttachmentAspectReferenceKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkInputAttachmentAspectReferenceKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkInputAttachmentAspectReferenceKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkInputAttachmentAspectReferenceKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "subpass",
    &_VkInputAttachmentAspectReferenceKHR::Getsubpass,
    &_VkInputAttachmentAspectReferenceKHR::Setsubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "inputAttachmentIndex",
    &_VkInputAttachmentAspectReferenceKHR::GetinputAttachmentIndex,
    &_VkInputAttachmentAspectReferenceKHR::SetinputAttachmentIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "aspectMask",
    &_VkInputAttachmentAspectReferenceKHR::GetaspectMask,
    &_VkInputAttachmentAspectReferenceKHR::SetaspectMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkInputAttachmentAspectReferenceKHR", func);
  return exports;
}

Napi::Value _VkInputAttachmentAspectReferenceKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkInputAttachmentAspectReferenceKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInputAttachmentAspectReferenceKHR *)0)->subpass));
    uint32_t byteLength = sizeof(((VkInputAttachmentAspectReferenceKHR *)0)->subpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInputAttachmentAspectReferenceKHR *)0)->inputAttachmentIndex));
    uint32_t byteLength = sizeof(((VkInputAttachmentAspectReferenceKHR *)0)->inputAttachmentIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInputAttachmentAspectReferenceKHR *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkInputAttachmentAspectReferenceKHR *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkInputAttachmentAspectReferenceKHR::flush() {
  _VkInputAttachmentAspectReferenceKHR *self = this;
  
  return true;
}

// subpass
Napi::Value _VkInputAttachmentAspectReferenceKHR::Getsubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpass);
}void _VkInputAttachmentAspectReferenceKHR::Setsubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkInputAttachmentAspectReferenceKHR.subpass", "Number");
  
    return;
  }
}// inputAttachmentIndex
Napi::Value _VkInputAttachmentAspectReferenceKHR::GetinputAttachmentIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inputAttachmentIndex);
}void _VkInputAttachmentAspectReferenceKHR::SetinputAttachmentIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.inputAttachmentIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkInputAttachmentAspectReferenceKHR.inputAttachmentIndex", "Number");
  
    return;
  }
}// aspectMask
Napi::Value _VkInputAttachmentAspectReferenceKHR::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkInputAttachmentAspectReferenceKHR::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkInputAttachmentAspectReferenceKHR.aspectMask", "Number");
  
    return;
  }
}
/** ## END VkInputAttachmentAspectReferenceKHR ## **/

/** ## BEGIN VkInputAttachmentAspectReference ## **/

Napi::FunctionReference _VkInputAttachmentAspectReference::constructor;

_VkInputAttachmentAspectReference::_VkInputAttachmentAspectReference(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkInputAttachmentAspectReference>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "subpass");
      Napi::String sAccess1 = Napi::String::New(env, "inputAttachmentIndex");
      Napi::String sAccess2 = Napi::String::New(env, "aspectMask");
      if (obj.Has(sAccess0)) this->Setsubpass(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetinputAttachmentIndex(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetaspectMask(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkInputAttachmentAspectReference constructor cannot be invoked without 'new'");
    }
  }
}

_VkInputAttachmentAspectReference::~_VkInputAttachmentAspectReference() {
  
  
  
  
}

Napi::Object _VkInputAttachmentAspectReference::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkInputAttachmentAspectReference", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkInputAttachmentAspectReference::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkInputAttachmentAspectReference::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "subpass",
    &_VkInputAttachmentAspectReference::Getsubpass,
    &_VkInputAttachmentAspectReference::Setsubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "inputAttachmentIndex",
    &_VkInputAttachmentAspectReference::GetinputAttachmentIndex,
    &_VkInputAttachmentAspectReference::SetinputAttachmentIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "aspectMask",
    &_VkInputAttachmentAspectReference::GetaspectMask,
    &_VkInputAttachmentAspectReference::SetaspectMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkInputAttachmentAspectReference", func);
  return exports;
}

Napi::Value _VkInputAttachmentAspectReference::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkInputAttachmentAspectReference::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInputAttachmentAspectReference *)0)->subpass));
    uint32_t byteLength = sizeof(((VkInputAttachmentAspectReference *)0)->subpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInputAttachmentAspectReference *)0)->inputAttachmentIndex));
    uint32_t byteLength = sizeof(((VkInputAttachmentAspectReference *)0)->inputAttachmentIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInputAttachmentAspectReference *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkInputAttachmentAspectReference *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkInputAttachmentAspectReference::flush() {
  _VkInputAttachmentAspectReference *self = this;
  
  return true;
}

// subpass
Napi::Value _VkInputAttachmentAspectReference::Getsubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpass);
}void _VkInputAttachmentAspectReference::Setsubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkInputAttachmentAspectReference.subpass", "Number");
  
    return;
  }
}// inputAttachmentIndex
Napi::Value _VkInputAttachmentAspectReference::GetinputAttachmentIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inputAttachmentIndex);
}void _VkInputAttachmentAspectReference::SetinputAttachmentIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.inputAttachmentIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkInputAttachmentAspectReference.inputAttachmentIndex", "Number");
  
    return;
  }
}// aspectMask
Napi::Value _VkInputAttachmentAspectReference::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkInputAttachmentAspectReference::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkInputAttachmentAspectReference.aspectMask", "Number");
  
    return;
  }
}
/** ## END VkInputAttachmentAspectReference ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ## **/

Napi::FunctionReference _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::constructor;

_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::~_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetsType,
    &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetpNext,
    &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "perViewPositionAllComponents",
    &_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetperViewPositionAllComponents,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *)0)->perViewPositionAllComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *)0)->perViewPositionAllComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::flush() {
  _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext", "[object Object]");
  
    return;
  }
}// perViewPositionAllComponents
Napi::Value _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetperViewPositionAllComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.perViewPositionAllComponents);
}
/** ## END VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ## **/

/** ## BEGIN VkPipelineDiscardRectangleStateCreateInfoEXT ## **/

Napi::FunctionReference _VkPipelineDiscardRectangleStateCreateInfoEXT::constructor;

_VkPipelineDiscardRectangleStateCreateInfoEXT::_VkPipelineDiscardRectangleStateCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
    vpDiscardRectangles = new std::vector<VkRect2D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "discardRectangleMode");
      Napi::String sAccess4 = Napi::String::New(env, "discardRectangleCount");
      Napi::String sAccess5 = Napi::String::New(env, "pDiscardRectangles");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdiscardRectangleMode(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetdiscardRectangleCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpDiscardRectangles(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkPipelineDiscardRectangleStateCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineDiscardRectangleStateCreateInfoEXT::~_VkPipelineDiscardRectangleStateCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  
  vpDiscardRectangles->clear();
  delete vpDiscardRectangles;
  
  pDiscardRectangles.Reset();
  
}

Napi::Object _VkPipelineDiscardRectangleStateCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineDiscardRectangleStateCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetsType,
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetpNext,
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::Getflags,
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "discardRectangleMode",
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetdiscardRectangleMode,
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::SetdiscardRectangleMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "discardRectangleCount",
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetdiscardRectangleCount,
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::SetdiscardRectangleCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDiscardRectangles",
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::GetpDiscardRectangles,
    &_VkPipelineDiscardRectangleStateCreateInfoEXT::SetpDiscardRectangles,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineDiscardRectangleStateCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->discardRectangleMode));
    uint32_t byteLength = sizeof(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->discardRectangleMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->discardRectangleCount));
    uint32_t byteLength = sizeof(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->discardRectangleCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->pDiscardRectangles));
    uint32_t byteLength = sizeof(((VkPipelineDiscardRectangleStateCreateInfoEXT *)0)->pDiscardRectangles);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineDiscardRectangleStateCreateInfoEXT::flush() {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pDiscardRectangles.IsEmpty())) {
    Napi::Value value = self->pDiscardRectangles.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.discardRectangleCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'discardRectangleCount' for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRect2D>* data = this->vpDiscardRectangles;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRect2D::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDiscardRectangles = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineDiscardRectangleStateCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineDiscardRectangleStateCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineDiscardRectangleStateCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineDiscardRectangleStateCreateInfoEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineDiscardRectangleStateCreateFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.flags", "Number");
  
    return;
  }
}// discardRectangleMode
Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetdiscardRectangleMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.discardRectangleMode);
}void _VkPipelineDiscardRectangleStateCreateInfoEXT::SetdiscardRectangleMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.discardRectangleMode = static_cast<VkDiscardRectangleModeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode", "Number");
  
    return;
  }
}// discardRectangleCount
Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetdiscardRectangleCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.discardRectangleCount);
}void _VkPipelineDiscardRectangleStateCreateInfoEXT::SetdiscardRectangleCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.discardRectangleCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount", "Number");
  
    return;
  }
}// pDiscardRectangles
Napi::Value _VkPipelineDiscardRectangleStateCreateInfoEXT::GetpDiscardRectangles(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDiscardRectangles.IsEmpty()) return env.Null();
  return this->pDiscardRectangles.Value().As<Napi::Array>();
}void _VkPipelineDiscardRectangleStateCreateInfoEXT::SetpDiscardRectangles(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDiscardRectangles.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDiscardRectangles.Reset();
      this->instance.pDiscardRectangles = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDiscardRectangles = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkPipelineDiscardRectangleStateCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceDiscardRectanglePropertiesEXT ## **/

Napi::FunctionReference _VkPhysicalDeviceDiscardRectanglePropertiesEXT::constructor;

_VkPhysicalDeviceDiscardRectanglePropertiesEXT::_VkPhysicalDeviceDiscardRectanglePropertiesEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "maxDiscardRectangles");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetmaxDiscardRectangles(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceDiscardRectanglePropertiesEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceDiscardRectanglePropertiesEXT::~_VkPhysicalDeviceDiscardRectanglePropertiesEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceDiscardRectanglePropertiesEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceDiscardRectanglePropertiesEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetsType,
    &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetpNext,
    &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDiscardRectangles",
    &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmaxDiscardRectangles,
    &_VkPhysicalDeviceDiscardRectanglePropertiesEXT::SetmaxDiscardRectangles,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceDiscardRectanglePropertiesEXT", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDiscardRectanglePropertiesEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDiscardRectanglePropertiesEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDiscardRectanglePropertiesEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDiscardRectanglePropertiesEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceDiscardRectanglePropertiesEXT *)0)->maxDiscardRectangles));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceDiscardRectanglePropertiesEXT *)0)->maxDiscardRectangles);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceDiscardRectanglePropertiesEXT::flush() {
  _VkPhysicalDeviceDiscardRectanglePropertiesEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceDiscardRectanglePropertiesEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceDiscardRectanglePropertiesEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext", "[object Object]");
  
    return;
  }
}// maxDiscardRectangles
Napi::Value _VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmaxDiscardRectangles(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDiscardRectangles);
}void _VkPhysicalDeviceDiscardRectanglePropertiesEXT::SetmaxDiscardRectangles(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxDiscardRectangles = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceDiscardRectanglePropertiesEXT.maxDiscardRectangles", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceDiscardRectanglePropertiesEXT ## **/

/** ## BEGIN VkPipelineViewportSwizzleStateCreateInfoNV ## **/

Napi::FunctionReference _VkPipelineViewportSwizzleStateCreateInfoNV::constructor;

_VkPipelineViewportSwizzleStateCreateInfoNV::_VkPipelineViewportSwizzleStateCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
    vpViewportSwizzles = new std::vector<VkViewportSwizzleNV>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "viewportCount");
      Napi::String sAccess4 = Napi::String::New(env, "pViewportSwizzles");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetviewportCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpViewportSwizzles(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineViewportSwizzleStateCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineViewportSwizzleStateCreateInfoNV::~_VkPipelineViewportSwizzleStateCreateInfoNV() {
  
  
  pNext.Reset();
  
  
  
  vpViewportSwizzles->clear();
  delete vpViewportSwizzles;
  
  pViewportSwizzles.Reset();
  
}

Napi::Object _VkPipelineViewportSwizzleStateCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineViewportSwizzleStateCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineViewportSwizzleStateCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineViewportSwizzleStateCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineViewportSwizzleStateCreateInfoNV::GetsType,
    &_VkPipelineViewportSwizzleStateCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineViewportSwizzleStateCreateInfoNV::GetpNext,
    &_VkPipelineViewportSwizzleStateCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineViewportSwizzleStateCreateInfoNV::Getflags,
    &_VkPipelineViewportSwizzleStateCreateInfoNV::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewportCount",
    &_VkPipelineViewportSwizzleStateCreateInfoNV::GetviewportCount,
    &_VkPipelineViewportSwizzleStateCreateInfoNV::SetviewportCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewportSwizzles",
    &_VkPipelineViewportSwizzleStateCreateInfoNV::GetpViewportSwizzles,
    &_VkPipelineViewportSwizzleStateCreateInfoNV::SetpViewportSwizzles,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineViewportSwizzleStateCreateInfoNV", func);
  return exports;
}

Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->viewportCount));
    uint32_t byteLength = sizeof(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->viewportCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->pViewportSwizzles));
    uint32_t byteLength = sizeof(((VkPipelineViewportSwizzleStateCreateInfoNV *)0)->pViewportSwizzles);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineViewportSwizzleStateCreateInfoNV::flush() {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pViewportSwizzles.IsEmpty())) {
    Napi::Value value = self->pViewportSwizzles.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.viewportCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkViewportSwizzleNV>* data = this->vpViewportSwizzles;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkViewportSwizzleNV::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles", "[object VkViewportSwizzleNV]");
  
        return false;
      }
      _VkViewportSwizzleNV* result = Napi::ObjectWrap<_VkViewportSwizzleNV>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pViewportSwizzles = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineViewportSwizzleStateCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineViewportSwizzleStateCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineViewportSwizzleStateCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineViewportSwizzleStateCreateInfoNV::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineViewportSwizzleStateCreateFlagsNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.flags", "Number");
  
    return;
  }
}// viewportCount
Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::GetviewportCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewportCount);
}void _VkPipelineViewportSwizzleStateCreateInfoNV::SetviewportCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewportCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount", "Number");
  
    return;
  }
}// pViewportSwizzles
Napi::Value _VkPipelineViewportSwizzleStateCreateInfoNV::GetpViewportSwizzles(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewportSwizzles.IsEmpty()) return env.Null();
  return this->pViewportSwizzles.Value().As<Napi::Array>();
}void _VkPipelineViewportSwizzleStateCreateInfoNV::SetpViewportSwizzles(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pViewportSwizzles.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pViewportSwizzles.Reset();
      this->instance.pViewportSwizzles = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles", "[object VkViewportSwizzleNV]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pViewportSwizzles = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles", "[object VkViewportSwizzleNV]");
  
    return;
  }
}
/** ## END VkPipelineViewportSwizzleStateCreateInfoNV ## **/

/** ## BEGIN VkViewportSwizzleNV ## **/

Napi::FunctionReference _VkViewportSwizzleNV::constructor;

_VkViewportSwizzleNV::_VkViewportSwizzleNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkViewportSwizzleNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      Napi::String sAccess2 = Napi::String::New(env, "z");
      Napi::String sAccess3 = Napi::String::New(env, "w");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setz(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setw(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkViewportSwizzleNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkViewportSwizzleNV::~_VkViewportSwizzleNV() {
  
  
  
  
  
}

Napi::Object _VkViewportSwizzleNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkViewportSwizzleNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkViewportSwizzleNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkViewportSwizzleNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkViewportSwizzleNV::Getx,
    &_VkViewportSwizzleNV::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkViewportSwizzleNV::Gety,
    &_VkViewportSwizzleNV::Sety,
    napi_enumerable
  ),
  InstanceAccessor(
    "z",
    &_VkViewportSwizzleNV::Getz,
    &_VkViewportSwizzleNV::Setz,
    napi_enumerable
  ),
  InstanceAccessor(
    "w",
    &_VkViewportSwizzleNV::Getw,
    &_VkViewportSwizzleNV::Setw,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkViewportSwizzleNV", func);
  return exports;
}

Napi::Value _VkViewportSwizzleNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkViewportSwizzleNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewportSwizzleNV *)0)->x));
    uint32_t byteLength = sizeof(((VkViewportSwizzleNV *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewportSwizzleNV *)0)->y));
    uint32_t byteLength = sizeof(((VkViewportSwizzleNV *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewportSwizzleNV *)0)->z));
    uint32_t byteLength = sizeof(((VkViewportSwizzleNV *)0)->z);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewportSwizzleNV *)0)->w));
    uint32_t byteLength = sizeof(((VkViewportSwizzleNV *)0)->w);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkViewportSwizzleNV::flush() {
  _VkViewportSwizzleNV *self = this;
  
  return true;
}

// x
Napi::Value _VkViewportSwizzleNV::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkViewportSwizzleNV::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<VkViewportCoordinateSwizzleNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewportSwizzleNV.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkViewportSwizzleNV::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkViewportSwizzleNV::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<VkViewportCoordinateSwizzleNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewportSwizzleNV.y", "Number");
  
    return;
  }
}// z
Napi::Value _VkViewportSwizzleNV::Getz(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.z);
}void _VkViewportSwizzleNV::Setz(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.z = static_cast<VkViewportCoordinateSwizzleNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewportSwizzleNV.z", "Number");
  
    return;
  }
}// w
Napi::Value _VkViewportSwizzleNV::Getw(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.w);
}void _VkViewportSwizzleNV::Setw(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.w = static_cast<VkViewportCoordinateSwizzleNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewportSwizzleNV.w", "Number");
  
    return;
  }
}
/** ## END VkViewportSwizzleNV ## **/

/** ## BEGIN VkPipelineViewportWScalingStateCreateInfoNV ## **/

Napi::FunctionReference _VkPipelineViewportWScalingStateCreateInfoNV::constructor;

_VkPipelineViewportWScalingStateCreateInfoNV::_VkPipelineViewportWScalingStateCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
    vpViewportWScalings = new std::vector<VkViewportWScalingNV>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "viewportWScalingEnable");
      Napi::String sAccess3 = Napi::String::New(env, "viewportCount");
      Napi::String sAccess4 = Napi::String::New(env, "pViewportWScalings");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetviewportWScalingEnable(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetviewportCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpViewportWScalings(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineViewportWScalingStateCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineViewportWScalingStateCreateInfoNV::~_VkPipelineViewportWScalingStateCreateInfoNV() {
  
  
  pNext.Reset();
  
  
  
  vpViewportWScalings->clear();
  delete vpViewportWScalings;
  
  pViewportWScalings.Reset();
  
}

Napi::Object _VkPipelineViewportWScalingStateCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineViewportWScalingStateCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineViewportWScalingStateCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineViewportWScalingStateCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineViewportWScalingStateCreateInfoNV::GetsType,
    &_VkPipelineViewportWScalingStateCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineViewportWScalingStateCreateInfoNV::GetpNext,
    &_VkPipelineViewportWScalingStateCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewportWScalingEnable",
    &_VkPipelineViewportWScalingStateCreateInfoNV::GetviewportWScalingEnable,
    &_VkPipelineViewportWScalingStateCreateInfoNV::SetviewportWScalingEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewportCount",
    &_VkPipelineViewportWScalingStateCreateInfoNV::GetviewportCount,
    &_VkPipelineViewportWScalingStateCreateInfoNV::SetviewportCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewportWScalings",
    &_VkPipelineViewportWScalingStateCreateInfoNV::GetpViewportWScalings,
    &_VkPipelineViewportWScalingStateCreateInfoNV::SetpViewportWScalings,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineViewportWScalingStateCreateInfoNV", func);
  return exports;
}

Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->viewportWScalingEnable));
    uint32_t byteLength = sizeof(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->viewportWScalingEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->viewportCount));
    uint32_t byteLength = sizeof(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->viewportCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->pViewportWScalings));
    uint32_t byteLength = sizeof(((VkPipelineViewportWScalingStateCreateInfoNV *)0)->pViewportWScalings);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineViewportWScalingStateCreateInfoNV::flush() {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pViewportWScalings.IsEmpty())) {
    Napi::Value value = self->pViewportWScalings.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.viewportCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkViewportWScalingNV>* data = this->vpViewportWScalings;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkViewportWScalingNV::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings", "[object VkViewportWScalingNV]");
  
        return false;
      }
      _VkViewportWScalingNV* result = Napi::ObjectWrap<_VkViewportWScalingNV>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pViewportWScalings = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineViewportWScalingStateCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineViewportWScalingStateCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineViewportWScalingStateCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// viewportWScalingEnable
Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetviewportWScalingEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewportWScalingEnable);
}void _VkPipelineViewportWScalingStateCreateInfoNV::SetviewportWScalingEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.viewportWScalingEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.viewportWScalingEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.viewportWScalingEnable", "Number");
  
    return;
  }
}// viewportCount
Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetviewportCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewportCount);
}void _VkPipelineViewportWScalingStateCreateInfoNV::SetviewportCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewportCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.viewportCount", "Number");
  
    return;
  }
}// pViewportWScalings
Napi::Value _VkPipelineViewportWScalingStateCreateInfoNV::GetpViewportWScalings(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewportWScalings.IsEmpty()) return env.Null();
  return this->pViewportWScalings.Value().As<Napi::Array>();
}void _VkPipelineViewportWScalingStateCreateInfoNV::SetpViewportWScalings(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pViewportWScalings.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pViewportWScalings.Reset();
      this->instance.pViewportWScalings = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings", "[object VkViewportWScalingNV]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pViewportWScalings = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings", "[object VkViewportWScalingNV]");
  
    return;
  }
}
/** ## END VkPipelineViewportWScalingStateCreateInfoNV ## **/

/** ## BEGIN VkViewportWScalingNV ## **/

Napi::FunctionReference _VkViewportWScalingNV::constructor;

_VkViewportWScalingNV::_VkViewportWScalingNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkViewportWScalingNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "xcoeff");
      Napi::String sAccess1 = Napi::String::New(env, "ycoeff");
      if (obj.Has(sAccess0)) this->Setxcoeff(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setycoeff(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkViewportWScalingNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkViewportWScalingNV::~_VkViewportWScalingNV() {
  
  
  
}

Napi::Object _VkViewportWScalingNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkViewportWScalingNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkViewportWScalingNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkViewportWScalingNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "xcoeff",
    &_VkViewportWScalingNV::Getxcoeff,
    &_VkViewportWScalingNV::Setxcoeff,
    napi_enumerable
  ),
  InstanceAccessor(
    "ycoeff",
    &_VkViewportWScalingNV::Getycoeff,
    &_VkViewportWScalingNV::Setycoeff,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkViewportWScalingNV", func);
  return exports;
}

Napi::Value _VkViewportWScalingNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkViewportWScalingNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewportWScalingNV *)0)->xcoeff));
    uint32_t byteLength = sizeof(((VkViewportWScalingNV *)0)->xcoeff);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewportWScalingNV *)0)->ycoeff));
    uint32_t byteLength = sizeof(((VkViewportWScalingNV *)0)->ycoeff);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkViewportWScalingNV::flush() {
  _VkViewportWScalingNV *self = this;
  
  return true;
}

// xcoeff
Napi::Value _VkViewportWScalingNV::Getxcoeff(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.xcoeff);
}void _VkViewportWScalingNV::Setxcoeff(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.xcoeff = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewportWScalingNV.xcoeff", "Number");
  
    return;
  }
}// ycoeff
Napi::Value _VkViewportWScalingNV::Getycoeff(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.ycoeff);
}void _VkViewportWScalingNV::Setycoeff(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.ycoeff = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewportWScalingNV.ycoeff", "Number");
  
    return;
  }
}
/** ## END VkViewportWScalingNV ## **/

/** ## BEGIN VkPresentTimeGOOGLE ## **/

Napi::FunctionReference _VkPresentTimeGOOGLE::constructor;

_VkPresentTimeGOOGLE::_VkPresentTimeGOOGLE(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPresentTimeGOOGLE>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "presentID");
      Napi::String sAccess1 = Napi::String::New(env, "desiredPresentTime");
      if (obj.Has(sAccess0)) this->SetpresentID(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdesiredPresentTime(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPresentTimeGOOGLE constructor cannot be invoked without 'new'");
    }
  }
}

_VkPresentTimeGOOGLE::~_VkPresentTimeGOOGLE() {
  
  
  
}

Napi::Object _VkPresentTimeGOOGLE::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPresentTimeGOOGLE", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPresentTimeGOOGLE::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPresentTimeGOOGLE::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "presentID",
    &_VkPresentTimeGOOGLE::GetpresentID,
    &_VkPresentTimeGOOGLE::SetpresentID,
    napi_enumerable
  ),
  InstanceAccessor(
    "desiredPresentTime",
    &_VkPresentTimeGOOGLE::GetdesiredPresentTime,
    &_VkPresentTimeGOOGLE::SetdesiredPresentTime,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPresentTimeGOOGLE", func);
  return exports;
}

Napi::Value _VkPresentTimeGOOGLE::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPresentTimeGOOGLE::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentTimeGOOGLE *)0)->presentID));
    uint32_t byteLength = sizeof(((VkPresentTimeGOOGLE *)0)->presentID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentTimeGOOGLE *)0)->desiredPresentTime));
    uint32_t byteLength = sizeof(((VkPresentTimeGOOGLE *)0)->desiredPresentTime);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPresentTimeGOOGLE::flush() {
  _VkPresentTimeGOOGLE *self = this;
  
  return true;
}

// presentID
Napi::Value _VkPresentTimeGOOGLE::GetpresentID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.presentID);
}void _VkPresentTimeGOOGLE::SetpresentID(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.presentID = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentTimeGOOGLE.presentID", "Number");
  
    return;
  }
}// desiredPresentTime
Napi::Value _VkPresentTimeGOOGLE::GetdesiredPresentTime(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.desiredPresentTime);
}void _VkPresentTimeGOOGLE::SetdesiredPresentTime(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.desiredPresentTime = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentTimeGOOGLE.desiredPresentTime", "Number");
  
    return;
  }
}
/** ## END VkPresentTimeGOOGLE ## **/

/** ## BEGIN VkPresentTimesInfoGOOGLE ## **/

Napi::FunctionReference _VkPresentTimesInfoGOOGLE::constructor;

_VkPresentTimesInfoGOOGLE::_VkPresentTimesInfoGOOGLE(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPresentTimesInfoGOOGLE>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
    vpTimes = new std::vector<VkPresentTimeGOOGLE>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "swapchainCount");
      Napi::String sAccess3 = Napi::String::New(env, "pTimes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetswapchainCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpTimes(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPresentTimesInfoGOOGLE constructor cannot be invoked without 'new'");
    }
  }
}

_VkPresentTimesInfoGOOGLE::~_VkPresentTimesInfoGOOGLE() {
  
  
  pNext.Reset();
  
  
  vpTimes->clear();
  delete vpTimes;
  
  pTimes.Reset();
  
}

Napi::Object _VkPresentTimesInfoGOOGLE::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPresentTimesInfoGOOGLE", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPresentTimesInfoGOOGLE::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPresentTimesInfoGOOGLE::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPresentTimesInfoGOOGLE::GetsType,
    &_VkPresentTimesInfoGOOGLE::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPresentTimesInfoGOOGLE::GetpNext,
    &_VkPresentTimesInfoGOOGLE::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchainCount",
    &_VkPresentTimesInfoGOOGLE::GetswapchainCount,
    &_VkPresentTimesInfoGOOGLE::SetswapchainCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pTimes",
    &_VkPresentTimesInfoGOOGLE::GetpTimes,
    &_VkPresentTimesInfoGOOGLE::SetpTimes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPresentTimesInfoGOOGLE", func);
  return exports;
}

Napi::Value _VkPresentTimesInfoGOOGLE::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPresentTimesInfoGOOGLE::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentTimesInfoGOOGLE *)0)->sType));
    uint32_t byteLength = sizeof(((VkPresentTimesInfoGOOGLE *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentTimesInfoGOOGLE *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPresentTimesInfoGOOGLE *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentTimesInfoGOOGLE *)0)->swapchainCount));
    uint32_t byteLength = sizeof(((VkPresentTimesInfoGOOGLE *)0)->swapchainCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentTimesInfoGOOGLE *)0)->pTimes));
    uint32_t byteLength = sizeof(((VkPresentTimesInfoGOOGLE *)0)->pTimes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPresentTimesInfoGOOGLE::flush() {
  _VkPresentTimesInfoGOOGLE *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pTimes.IsEmpty())) {
    Napi::Value value = self->pTimes.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.swapchainCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'swapchainCount' for 'VkPresentTimesInfoGOOGLE.pTimes'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPresentTimeGOOGLE>* data = this->vpTimes;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPresentTimeGOOGLE::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.pTimes", "[object VkPresentTimeGOOGLE]");
  
        return false;
      }
      _VkPresentTimeGOOGLE* result = Napi::ObjectWrap<_VkPresentTimeGOOGLE>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pTimes = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPresentTimesInfoGOOGLE::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPresentTimesInfoGOOGLE::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPresentTimesInfoGOOGLE::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPresentTimesInfoGOOGLE::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPresentTimesInfoGOOGLE.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.pNext", "[object Object]");
  
    return;
  }
}// swapchainCount
Napi::Value _VkPresentTimesInfoGOOGLE::GetswapchainCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.swapchainCount);
}void _VkPresentTimesInfoGOOGLE::SetswapchainCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.swapchainCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.swapchainCount", "Number");
  
    return;
  }
}// pTimes
Napi::Value _VkPresentTimesInfoGOOGLE::GetpTimes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pTimes.IsEmpty()) return env.Null();
  return this->pTimes.Value().As<Napi::Array>();
}void _VkPresentTimesInfoGOOGLE::SetpTimes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pTimes.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pTimes.Reset();
      this->instance.pTimes = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.pTimes", "[object VkPresentTimeGOOGLE]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pTimes = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPresentTimesInfoGOOGLE.pTimes", "[object VkPresentTimeGOOGLE]");
  
    return;
  }
}
/** ## END VkPresentTimesInfoGOOGLE ## **/

/** ## BEGIN VkPastPresentationTimingGOOGLE ## **/

Napi::FunctionReference _VkPastPresentationTimingGOOGLE::constructor;

_VkPastPresentationTimingGOOGLE::_VkPastPresentationTimingGOOGLE(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPastPresentationTimingGOOGLE>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkPastPresentationTimingGOOGLE constructor cannot be invoked without 'new'");
    }
  }
}

_VkPastPresentationTimingGOOGLE::~_VkPastPresentationTimingGOOGLE() {
  
  
  
  
  
  
}

Napi::Object _VkPastPresentationTimingGOOGLE::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPastPresentationTimingGOOGLE", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPastPresentationTimingGOOGLE::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPastPresentationTimingGOOGLE::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "presentID",
    &_VkPastPresentationTimingGOOGLE::GetpresentID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "desiredPresentTime",
    &_VkPastPresentationTimingGOOGLE::GetdesiredPresentTime,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "actualPresentTime",
    &_VkPastPresentationTimingGOOGLE::GetactualPresentTime,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "earliestPresentTime",
    &_VkPastPresentationTimingGOOGLE::GetearliestPresentTime,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "presentMargin",
    &_VkPastPresentationTimingGOOGLE::GetpresentMargin,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPastPresentationTimingGOOGLE", func);
  return exports;
}

Napi::Value _VkPastPresentationTimingGOOGLE::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPastPresentationTimingGOOGLE::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPastPresentationTimingGOOGLE *)0)->presentID));
    uint32_t byteLength = sizeof(((VkPastPresentationTimingGOOGLE *)0)->presentID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPastPresentationTimingGOOGLE *)0)->desiredPresentTime));
    uint32_t byteLength = sizeof(((VkPastPresentationTimingGOOGLE *)0)->desiredPresentTime);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPastPresentationTimingGOOGLE *)0)->actualPresentTime));
    uint32_t byteLength = sizeof(((VkPastPresentationTimingGOOGLE *)0)->actualPresentTime);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPastPresentationTimingGOOGLE *)0)->earliestPresentTime));
    uint32_t byteLength = sizeof(((VkPastPresentationTimingGOOGLE *)0)->earliestPresentTime);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPastPresentationTimingGOOGLE *)0)->presentMargin));
    uint32_t byteLength = sizeof(((VkPastPresentationTimingGOOGLE *)0)->presentMargin);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPastPresentationTimingGOOGLE::flush() {
  _VkPastPresentationTimingGOOGLE *self = this;
  
  return true;
}

// presentID
Napi::Value _VkPastPresentationTimingGOOGLE::GetpresentID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.presentID);
}// desiredPresentTime
Napi::Value _VkPastPresentationTimingGOOGLE::GetdesiredPresentTime(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.desiredPresentTime);
}// actualPresentTime
Napi::Value _VkPastPresentationTimingGOOGLE::GetactualPresentTime(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.actualPresentTime);
}// earliestPresentTime
Napi::Value _VkPastPresentationTimingGOOGLE::GetearliestPresentTime(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.earliestPresentTime);
}// presentMargin
Napi::Value _VkPastPresentationTimingGOOGLE::GetpresentMargin(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.presentMargin);
}
/** ## END VkPastPresentationTimingGOOGLE ## **/

/** ## BEGIN VkRefreshCycleDurationGOOGLE ## **/

Napi::FunctionReference _VkRefreshCycleDurationGOOGLE::constructor;

_VkRefreshCycleDurationGOOGLE::_VkRefreshCycleDurationGOOGLE(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRefreshCycleDurationGOOGLE>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkRefreshCycleDurationGOOGLE constructor cannot be invoked without 'new'");
    }
  }
}

_VkRefreshCycleDurationGOOGLE::~_VkRefreshCycleDurationGOOGLE() {
  
  
}

Napi::Object _VkRefreshCycleDurationGOOGLE::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRefreshCycleDurationGOOGLE", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRefreshCycleDurationGOOGLE::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRefreshCycleDurationGOOGLE::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "refreshDuration",
    &_VkRefreshCycleDurationGOOGLE::GetrefreshDuration,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRefreshCycleDurationGOOGLE", func);
  return exports;
}

Napi::Value _VkRefreshCycleDurationGOOGLE::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRefreshCycleDurationGOOGLE::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRefreshCycleDurationGOOGLE *)0)->refreshDuration));
    uint32_t byteLength = sizeof(((VkRefreshCycleDurationGOOGLE *)0)->refreshDuration);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRefreshCycleDurationGOOGLE::flush() {
  _VkRefreshCycleDurationGOOGLE *self = this;
  
  return true;
}

// refreshDuration
Napi::Value _VkRefreshCycleDurationGOOGLE::GetrefreshDuration(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.refreshDuration);
}
/** ## END VkRefreshCycleDurationGOOGLE ## **/

/** ## BEGIN VkHdrMetadataEXT ## **/

Napi::FunctionReference _VkHdrMetadataEXT::constructor;

_VkHdrMetadataEXT::_VkHdrMetadataEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkHdrMetadataEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "displayPrimaryRed");
      Napi::String sAccess3 = Napi::String::New(env, "displayPrimaryGreen");
      Napi::String sAccess4 = Napi::String::New(env, "displayPrimaryBlue");
      Napi::String sAccess5 = Napi::String::New(env, "whitePoint");
      Napi::String sAccess6 = Napi::String::New(env, "maxLuminance");
      Napi::String sAccess7 = Napi::String::New(env, "minLuminance");
      Napi::String sAccess8 = Napi::String::New(env, "maxContentLightLevel");
      Napi::String sAccess9 = Napi::String::New(env, "maxFrameAverageLightLevel");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdisplayPrimaryRed(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdisplayPrimaryGreen(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetdisplayPrimaryBlue(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetwhitePoint(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetmaxLuminance(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetminLuminance(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetmaxContentLightLevel(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetmaxFrameAverageLightLevel(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkHdrMetadataEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkHdrMetadataEXT::~_VkHdrMetadataEXT() {
  
  
  pNext.Reset();
  
  displayPrimaryRed.Reset();
  
  displayPrimaryGreen.Reset();
  
  displayPrimaryBlue.Reset();
  
  whitePoint.Reset();
  
  
  
  
  
}

Napi::Object _VkHdrMetadataEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkHdrMetadataEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkHdrMetadataEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkHdrMetadataEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkHdrMetadataEXT::GetsType,
    &_VkHdrMetadataEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkHdrMetadataEXT::GetpNext,
    &_VkHdrMetadataEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayPrimaryRed",
    &_VkHdrMetadataEXT::GetdisplayPrimaryRed,
    &_VkHdrMetadataEXT::SetdisplayPrimaryRed,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayPrimaryGreen",
    &_VkHdrMetadataEXT::GetdisplayPrimaryGreen,
    &_VkHdrMetadataEXT::SetdisplayPrimaryGreen,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayPrimaryBlue",
    &_VkHdrMetadataEXT::GetdisplayPrimaryBlue,
    &_VkHdrMetadataEXT::SetdisplayPrimaryBlue,
    napi_enumerable
  ),
  InstanceAccessor(
    "whitePoint",
    &_VkHdrMetadataEXT::GetwhitePoint,
    &_VkHdrMetadataEXT::SetwhitePoint,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxLuminance",
    &_VkHdrMetadataEXT::GetmaxLuminance,
    &_VkHdrMetadataEXT::SetmaxLuminance,
    napi_enumerable
  ),
  InstanceAccessor(
    "minLuminance",
    &_VkHdrMetadataEXT::GetminLuminance,
    &_VkHdrMetadataEXT::SetminLuminance,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxContentLightLevel",
    &_VkHdrMetadataEXT::GetmaxContentLightLevel,
    &_VkHdrMetadataEXT::SetmaxContentLightLevel,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFrameAverageLightLevel",
    &_VkHdrMetadataEXT::GetmaxFrameAverageLightLevel,
    &_VkHdrMetadataEXT::SetmaxFrameAverageLightLevel,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkHdrMetadataEXT", func);
  return exports;
}

Napi::Value _VkHdrMetadataEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkHdrMetadataEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->displayPrimaryRed));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->displayPrimaryRed);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->displayPrimaryGreen));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->displayPrimaryGreen);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->displayPrimaryBlue));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->displayPrimaryBlue);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->whitePoint));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->whitePoint);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->maxLuminance));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->maxLuminance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->minLuminance));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->minLuminance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->maxContentLightLevel));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->maxContentLightLevel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkHdrMetadataEXT *)0)->maxFrameAverageLightLevel));
    uint32_t byteLength = sizeof(((VkHdrMetadataEXT *)0)->maxFrameAverageLightLevel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkHdrMetadataEXT::flush() {
  _VkHdrMetadataEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->displayPrimaryRed.IsEmpty())) {
    Napi::Value value = self->displayPrimaryRed.Value();
    
    _VkXYColorEXT* result = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.displayPrimaryRed = result->instance;
  }if (!(self->displayPrimaryGreen.IsEmpty())) {
    Napi::Value value = self->displayPrimaryGreen.Value();
    
    _VkXYColorEXT* result = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.displayPrimaryGreen = result->instance;
  }if (!(self->displayPrimaryBlue.IsEmpty())) {
    Napi::Value value = self->displayPrimaryBlue.Value();
    
    _VkXYColorEXT* result = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.displayPrimaryBlue = result->instance;
  }if (!(self->whitePoint.IsEmpty())) {
    Napi::Value value = self->whitePoint.Value();
    
    _VkXYColorEXT* result = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.whitePoint = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkHdrMetadataEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkHdrMetadataEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkHdrMetadataEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkHdrMetadataEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkHdrMetadataEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkHdrMetadataEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.pNext", "[object Object]");
  
    return;
  }
}// displayPrimaryRed
Napi::Value _VkHdrMetadataEXT::GetdisplayPrimaryRed(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayPrimaryRed.IsEmpty()) return env.Null();
  return this->displayPrimaryRed.Value().As<Napi::Object>();
}void _VkHdrMetadataEXT::SetdisplayPrimaryRed(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkXYColorEXT::constructor.Value())) {
      
      this->displayPrimaryRed.Reset(value.ToObject(), 1);
      _VkXYColorEXT* inst = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(obj);
      inst->flush();
      this->instance.displayPrimaryRed = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkHdrMetadataEXT.displayPrimaryRed", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->displayPrimaryRed.Reset();
    memset(&this->instance.displayPrimaryRed, 0, sizeof(VkXYColorEXT));
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.displayPrimaryRed", "[object VkXYColorEXT]");
  
    return;
  }
}// displayPrimaryGreen
Napi::Value _VkHdrMetadataEXT::GetdisplayPrimaryGreen(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayPrimaryGreen.IsEmpty()) return env.Null();
  return this->displayPrimaryGreen.Value().As<Napi::Object>();
}void _VkHdrMetadataEXT::SetdisplayPrimaryGreen(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkXYColorEXT::constructor.Value())) {
      
      this->displayPrimaryGreen.Reset(value.ToObject(), 1);
      _VkXYColorEXT* inst = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(obj);
      inst->flush();
      this->instance.displayPrimaryGreen = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkHdrMetadataEXT.displayPrimaryGreen", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->displayPrimaryGreen.Reset();
    memset(&this->instance.displayPrimaryGreen, 0, sizeof(VkXYColorEXT));
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.displayPrimaryGreen", "[object VkXYColorEXT]");
  
    return;
  }
}// displayPrimaryBlue
Napi::Value _VkHdrMetadataEXT::GetdisplayPrimaryBlue(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayPrimaryBlue.IsEmpty()) return env.Null();
  return this->displayPrimaryBlue.Value().As<Napi::Object>();
}void _VkHdrMetadataEXT::SetdisplayPrimaryBlue(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkXYColorEXT::constructor.Value())) {
      
      this->displayPrimaryBlue.Reset(value.ToObject(), 1);
      _VkXYColorEXT* inst = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(obj);
      inst->flush();
      this->instance.displayPrimaryBlue = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkHdrMetadataEXT.displayPrimaryBlue", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->displayPrimaryBlue.Reset();
    memset(&this->instance.displayPrimaryBlue, 0, sizeof(VkXYColorEXT));
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.displayPrimaryBlue", "[object VkXYColorEXT]");
  
    return;
  }
}// whitePoint
Napi::Value _VkHdrMetadataEXT::GetwhitePoint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->whitePoint.IsEmpty()) return env.Null();
  return this->whitePoint.Value().As<Napi::Object>();
}void _VkHdrMetadataEXT::SetwhitePoint(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkXYColorEXT::constructor.Value())) {
      
      this->whitePoint.Reset(value.ToObject(), 1);
      _VkXYColorEXT* inst = Napi::ObjectWrap<_VkXYColorEXT>::Unwrap(obj);
      inst->flush();
      this->instance.whitePoint = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkHdrMetadataEXT.whitePoint", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->whitePoint.Reset();
    memset(&this->instance.whitePoint, 0, sizeof(VkXYColorEXT));
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.whitePoint", "[object VkXYColorEXT]");
  
    return;
  }
}// maxLuminance
Napi::Value _VkHdrMetadataEXT::GetmaxLuminance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxLuminance);
}void _VkHdrMetadataEXT::SetmaxLuminance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxLuminance = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.maxLuminance", "Number");
  
    return;
  }
}// minLuminance
Napi::Value _VkHdrMetadataEXT::GetminLuminance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minLuminance);
}void _VkHdrMetadataEXT::SetminLuminance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minLuminance = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.minLuminance", "Number");
  
    return;
  }
}// maxContentLightLevel
Napi::Value _VkHdrMetadataEXT::GetmaxContentLightLevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxContentLightLevel);
}void _VkHdrMetadataEXT::SetmaxContentLightLevel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxContentLightLevel = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.maxContentLightLevel", "Number");
  
    return;
  }
}// maxFrameAverageLightLevel
Napi::Value _VkHdrMetadataEXT::GetmaxFrameAverageLightLevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFrameAverageLightLevel);
}void _VkHdrMetadataEXT::SetmaxFrameAverageLightLevel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxFrameAverageLightLevel = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkHdrMetadataEXT.maxFrameAverageLightLevel", "Number");
  
    return;
  }
}
/** ## END VkHdrMetadataEXT ## **/

/** ## BEGIN VkXYColorEXT ## **/

Napi::FunctionReference _VkXYColorEXT::constructor;

_VkXYColorEXT::_VkXYColorEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkXYColorEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkXYColorEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkXYColorEXT::~_VkXYColorEXT() {
  
  
  
}

Napi::Object _VkXYColorEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkXYColorEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkXYColorEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkXYColorEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkXYColorEXT::Getx,
    &_VkXYColorEXT::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkXYColorEXT::Gety,
    &_VkXYColorEXT::Sety,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkXYColorEXT", func);
  return exports;
}

Napi::Value _VkXYColorEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkXYColorEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkXYColorEXT *)0)->x));
    uint32_t byteLength = sizeof(((VkXYColorEXT *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkXYColorEXT *)0)->y));
    uint32_t byteLength = sizeof(((VkXYColorEXT *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkXYColorEXT::flush() {
  _VkXYColorEXT *self = this;
  
  return true;
}

// x
Napi::Value _VkXYColorEXT::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkXYColorEXT::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkXYColorEXT.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkXYColorEXT::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkXYColorEXT::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkXYColorEXT.y", "Number");
  
    return;
  }
}
/** ## END VkXYColorEXT ## **/

/** ## BEGIN VkDescriptorUpdateTemplateCreateInfoKHR ## **/

Napi::FunctionReference _VkDescriptorUpdateTemplateCreateInfoKHR::constructor;

_VkDescriptorUpdateTemplateCreateInfoKHR::_VkDescriptorUpdateTemplateCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorUpdateTemplateCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR;
    vpDescriptorUpdateEntries = new std::vector<VkDescriptorUpdateTemplateEntry>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "descriptorUpdateEntryCount");
      Napi::String sAccess4 = Napi::String::New(env, "pDescriptorUpdateEntries");
      Napi::String sAccess5 = Napi::String::New(env, "templateType");
      Napi::String sAccess6 = Napi::String::New(env, "descriptorSetLayout");
      Napi::String sAccess7 = Napi::String::New(env, "pipelineBindPoint");
      Napi::String sAccess8 = Napi::String::New(env, "pipelineLayout");
      Napi::String sAccess9 = Napi::String::New(env, "set");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdescriptorUpdateEntryCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpDescriptorUpdateEntries(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SettemplateType(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdescriptorSetLayout(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpipelineBindPoint(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpipelineLayout(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->Setset(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkDescriptorUpdateTemplateCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorUpdateTemplateCreateInfoKHR::~_VkDescriptorUpdateTemplateCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  
  vpDescriptorUpdateEntries->clear();
  delete vpDescriptorUpdateEntries;
  
  pDescriptorUpdateEntries.Reset();
  
  
  descriptorSetLayout.Reset();
  
  
  pipelineLayout.Reset();
  
  
}

Napi::Object _VkDescriptorUpdateTemplateCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorUpdateTemplateCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorUpdateTemplateCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorUpdateTemplateCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetsType,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetpNext,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::Getflags,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorUpdateEntryCount",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetdescriptorUpdateEntryCount,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetdescriptorUpdateEntryCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDescriptorUpdateEntries",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetpDescriptorUpdateEntries,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetpDescriptorUpdateEntries,
    napi_enumerable
  ),
  InstanceAccessor(
    "templateType",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GettemplateType,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SettemplateType,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorSetLayout",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetdescriptorSetLayout,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetdescriptorSetLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineBindPoint",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetpipelineBindPoint,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetpipelineBindPoint,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineLayout",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::GetpipelineLayout,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::SetpipelineLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "set",
    &_VkDescriptorUpdateTemplateCreateInfoKHR::Getset,
    &_VkDescriptorUpdateTemplateCreateInfoKHR::Setset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorUpdateTemplateCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->descriptorUpdateEntryCount));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->descriptorUpdateEntryCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pDescriptorUpdateEntries));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pDescriptorUpdateEntries);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->templateType));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->templateType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->descriptorSetLayout));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->descriptorSetLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pipelineBindPoint));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pipelineBindPoint);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pipelineLayout));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->pipelineLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->set));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfoKHR *)0)->set);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorUpdateTemplateCreateInfoKHR::flush() {
  _VkDescriptorUpdateTemplateCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pDescriptorUpdateEntries.IsEmpty())) {
    Napi::Value value = self->pDescriptorUpdateEntries.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorUpdateEntryCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorUpdateTemplateEntry>* data = this->vpDescriptorUpdateEntries;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorUpdateTemplateEntry::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
        return false;
      }
      _VkDescriptorUpdateTemplateEntry* result = Napi::ObjectWrap<_VkDescriptorUpdateTemplateEntry>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDescriptorUpdateEntries = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDescriptorUpdateTemplateCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDescriptorUpdateTemplateCreateInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDescriptorUpdateTemplateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.flags", "Number");
  
    return;
  }
}// descriptorUpdateEntryCount
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetdescriptorUpdateEntryCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorUpdateEntryCount);
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetdescriptorUpdateEntryCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorUpdateEntryCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorUpdateEntryCount", "Number");
  
    return;
  }
}// pDescriptorUpdateEntries
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetpDescriptorUpdateEntries(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDescriptorUpdateEntries.IsEmpty()) return env.Null();
  return this->pDescriptorUpdateEntries.Value().As<Napi::Array>();
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetpDescriptorUpdateEntries(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDescriptorUpdateEntries.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDescriptorUpdateEntries.Reset();
      this->instance.pDescriptorUpdateEntries = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDescriptorUpdateEntries = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
    return;
  }
}// templateType
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GettemplateType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.templateType);
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SettemplateType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.templateType = static_cast<VkDescriptorUpdateTemplateType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.templateType", "Number");
  
    return;
  }
}// descriptorSetLayout
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetdescriptorSetLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->descriptorSetLayout.IsEmpty()) return env.Null();
  return this->descriptorSetLayout.Value().As<Napi::Object>();
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetdescriptorSetLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorSetLayout::constructor.Value())) {
      
      this->descriptorSetLayout.Reset(value.ToObject(), 1);
      _VkDescriptorSetLayout* inst = Napi::ObjectWrap<_VkDescriptorSetLayout>::Unwrap(obj);
      ;
      this->instance.descriptorSetLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout", "[object VkDescriptorSetLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->descriptorSetLayout.Reset();
    this->instance.descriptorSetLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout", "[object VkDescriptorSetLayout]");
  
    return;
  }
}// pipelineBindPoint
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetpipelineBindPoint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineBindPoint);
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetpipelineBindPoint(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint", "Number");
  
    return;
  }
}// pipelineLayout
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::GetpipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pipelineLayout.IsEmpty()) return env.Null();
  return this->pipelineLayout.Value().As<Napi::Object>();
}void _VkDescriptorUpdateTemplateCreateInfoKHR::SetpipelineLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineLayout::constructor.Value())) {
      
      this->pipelineLayout.Reset(value.ToObject(), 1);
      _VkPipelineLayout* inst = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
      ;
      this->instance.pipelineLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pipelineLayout.Reset();
    this->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// set
Napi::Value _VkDescriptorUpdateTemplateCreateInfoKHR::Getset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.set);
}void _VkDescriptorUpdateTemplateCreateInfoKHR::Setset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.set = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfoKHR.set", "Number");
  
    return;
  }
}
/** ## END VkDescriptorUpdateTemplateCreateInfoKHR ## **/

/** ## BEGIN VkDescriptorUpdateTemplateCreateInfo ## **/

Napi::FunctionReference _VkDescriptorUpdateTemplateCreateInfo::constructor;

_VkDescriptorUpdateTemplateCreateInfo::_VkDescriptorUpdateTemplateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorUpdateTemplateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    vpDescriptorUpdateEntries = new std::vector<VkDescriptorUpdateTemplateEntry>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "descriptorUpdateEntryCount");
      Napi::String sAccess4 = Napi::String::New(env, "pDescriptorUpdateEntries");
      Napi::String sAccess5 = Napi::String::New(env, "templateType");
      Napi::String sAccess6 = Napi::String::New(env, "descriptorSetLayout");
      Napi::String sAccess7 = Napi::String::New(env, "pipelineBindPoint");
      Napi::String sAccess8 = Napi::String::New(env, "pipelineLayout");
      Napi::String sAccess9 = Napi::String::New(env, "set");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdescriptorUpdateEntryCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpDescriptorUpdateEntries(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SettemplateType(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdescriptorSetLayout(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpipelineBindPoint(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpipelineLayout(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->Setset(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkDescriptorUpdateTemplateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorUpdateTemplateCreateInfo::~_VkDescriptorUpdateTemplateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpDescriptorUpdateEntries->clear();
  delete vpDescriptorUpdateEntries;
  
  pDescriptorUpdateEntries.Reset();
  
  
  descriptorSetLayout.Reset();
  
  
  pipelineLayout.Reset();
  
  
}

Napi::Object _VkDescriptorUpdateTemplateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorUpdateTemplateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorUpdateTemplateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorUpdateTemplateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorUpdateTemplateCreateInfo::GetsType,
    &_VkDescriptorUpdateTemplateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorUpdateTemplateCreateInfo::GetpNext,
    &_VkDescriptorUpdateTemplateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDescriptorUpdateTemplateCreateInfo::Getflags,
    &_VkDescriptorUpdateTemplateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorUpdateEntryCount",
    &_VkDescriptorUpdateTemplateCreateInfo::GetdescriptorUpdateEntryCount,
    &_VkDescriptorUpdateTemplateCreateInfo::SetdescriptorUpdateEntryCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDescriptorUpdateEntries",
    &_VkDescriptorUpdateTemplateCreateInfo::GetpDescriptorUpdateEntries,
    &_VkDescriptorUpdateTemplateCreateInfo::SetpDescriptorUpdateEntries,
    napi_enumerable
  ),
  InstanceAccessor(
    "templateType",
    &_VkDescriptorUpdateTemplateCreateInfo::GettemplateType,
    &_VkDescriptorUpdateTemplateCreateInfo::SettemplateType,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorSetLayout",
    &_VkDescriptorUpdateTemplateCreateInfo::GetdescriptorSetLayout,
    &_VkDescriptorUpdateTemplateCreateInfo::SetdescriptorSetLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineBindPoint",
    &_VkDescriptorUpdateTemplateCreateInfo::GetpipelineBindPoint,
    &_VkDescriptorUpdateTemplateCreateInfo::SetpipelineBindPoint,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineLayout",
    &_VkDescriptorUpdateTemplateCreateInfo::GetpipelineLayout,
    &_VkDescriptorUpdateTemplateCreateInfo::SetpipelineLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "set",
    &_VkDescriptorUpdateTemplateCreateInfo::Getset,
    &_VkDescriptorUpdateTemplateCreateInfo::Setset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorUpdateTemplateCreateInfo", func);
  return exports;
}

Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->descriptorUpdateEntryCount));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->descriptorUpdateEntryCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->pDescriptorUpdateEntries));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->pDescriptorUpdateEntries);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->templateType));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->templateType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->descriptorSetLayout));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->descriptorSetLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->pipelineBindPoint));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->pipelineBindPoint);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->pipelineLayout));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->pipelineLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateCreateInfo *)0)->set));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateCreateInfo *)0)->set);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorUpdateTemplateCreateInfo::flush() {
  _VkDescriptorUpdateTemplateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pDescriptorUpdateEntries.IsEmpty())) {
    Napi::Value value = self->pDescriptorUpdateEntries.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorUpdateEntryCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorUpdateTemplateEntry>* data = this->vpDescriptorUpdateEntries;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorUpdateTemplateEntry::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
        return false;
      }
      _VkDescriptorUpdateTemplateEntry* result = Napi::ObjectWrap<_VkDescriptorUpdateTemplateEntry>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDescriptorUpdateEntries = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorUpdateTemplateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorUpdateTemplateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDescriptorUpdateTemplateCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDescriptorUpdateTemplateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDescriptorUpdateTemplateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.flags", "Number");
  
    return;
  }
}// descriptorUpdateEntryCount
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetdescriptorUpdateEntryCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorUpdateEntryCount);
}void _VkDescriptorUpdateTemplateCreateInfo::SetdescriptorUpdateEntryCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorUpdateEntryCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorUpdateEntryCount", "Number");
  
    return;
  }
}// pDescriptorUpdateEntries
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetpDescriptorUpdateEntries(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDescriptorUpdateEntries.IsEmpty()) return env.Null();
  return this->pDescriptorUpdateEntries.Value().As<Napi::Array>();
}void _VkDescriptorUpdateTemplateCreateInfo::SetpDescriptorUpdateEntries(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDescriptorUpdateEntries.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDescriptorUpdateEntries.Reset();
      this->instance.pDescriptorUpdateEntries = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDescriptorUpdateEntries = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
    return;
  }
}// templateType
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GettemplateType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.templateType);
}void _VkDescriptorUpdateTemplateCreateInfo::SettemplateType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.templateType = static_cast<VkDescriptorUpdateTemplateType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.templateType", "Number");
  
    return;
  }
}// descriptorSetLayout
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetdescriptorSetLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->descriptorSetLayout.IsEmpty()) return env.Null();
  return this->descriptorSetLayout.Value().As<Napi::Object>();
}void _VkDescriptorUpdateTemplateCreateInfo::SetdescriptorSetLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorSetLayout::constructor.Value())) {
      
      this->descriptorSetLayout.Reset(value.ToObject(), 1);
      _VkDescriptorSetLayout* inst = Napi::ObjectWrap<_VkDescriptorSetLayout>::Unwrap(obj);
      ;
      this->instance.descriptorSetLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout", "[object VkDescriptorSetLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->descriptorSetLayout.Reset();
    this->instance.descriptorSetLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout", "[object VkDescriptorSetLayout]");
  
    return;
  }
}// pipelineBindPoint
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetpipelineBindPoint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineBindPoint);
}void _VkDescriptorUpdateTemplateCreateInfo::SetpipelineBindPoint(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineBindPoint", "Number");
  
    return;
  }
}// pipelineLayout
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::GetpipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pipelineLayout.IsEmpty()) return env.Null();
  return this->pipelineLayout.Value().As<Napi::Object>();
}void _VkDescriptorUpdateTemplateCreateInfo::SetpipelineLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineLayout::constructor.Value())) {
      
      this->pipelineLayout.Reset(value.ToObject(), 1);
      _VkPipelineLayout* inst = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
      ;
      this->instance.pipelineLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pipelineLayout.Reset();
    this->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// set
Napi::Value _VkDescriptorUpdateTemplateCreateInfo::Getset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.set);
}void _VkDescriptorUpdateTemplateCreateInfo::Setset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.set = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.set", "Number");
  
    return;
  }
}
/** ## END VkDescriptorUpdateTemplateCreateInfo ## **/

/** ## BEGIN VkDescriptorUpdateTemplateEntryKHR ## **/

Napi::FunctionReference _VkDescriptorUpdateTemplateEntryKHR::constructor;

_VkDescriptorUpdateTemplateEntryKHR::_VkDescriptorUpdateTemplateEntryKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorUpdateTemplateEntryKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "dstBinding");
      Napi::String sAccess1 = Napi::String::New(env, "dstArrayElement");
      Napi::String sAccess2 = Napi::String::New(env, "descriptorCount");
      Napi::String sAccess3 = Napi::String::New(env, "descriptorType");
      Napi::String sAccess4 = Napi::String::New(env, "offset");
      Napi::String sAccess5 = Napi::String::New(env, "stride");
      if (obj.Has(sAccess0)) this->SetdstBinding(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdstArrayElement(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdescriptorCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdescriptorType(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setoffset(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setstride(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkDescriptorUpdateTemplateEntryKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorUpdateTemplateEntryKHR::~_VkDescriptorUpdateTemplateEntryKHR() {
  
  
  
  
  
  
  
}

Napi::Object _VkDescriptorUpdateTemplateEntryKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorUpdateTemplateEntryKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorUpdateTemplateEntryKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorUpdateTemplateEntryKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "dstBinding",
    &_VkDescriptorUpdateTemplateEntryKHR::GetdstBinding,
    &_VkDescriptorUpdateTemplateEntryKHR::SetdstBinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstArrayElement",
    &_VkDescriptorUpdateTemplateEntryKHR::GetdstArrayElement,
    &_VkDescriptorUpdateTemplateEntryKHR::SetdstArrayElement,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorCount",
    &_VkDescriptorUpdateTemplateEntryKHR::GetdescriptorCount,
    &_VkDescriptorUpdateTemplateEntryKHR::SetdescriptorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorType",
    &_VkDescriptorUpdateTemplateEntryKHR::GetdescriptorType,
    &_VkDescriptorUpdateTemplateEntryKHR::SetdescriptorType,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkDescriptorUpdateTemplateEntryKHR::Getoffset,
    &_VkDescriptorUpdateTemplateEntryKHR::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "stride",
    &_VkDescriptorUpdateTemplateEntryKHR::Getstride,
    &_VkDescriptorUpdateTemplateEntryKHR::Setstride,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorUpdateTemplateEntryKHR", func);
  return exports;
}

Napi::Value _VkDescriptorUpdateTemplateEntryKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorUpdateTemplateEntryKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntryKHR *)0)->dstBinding));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntryKHR *)0)->dstBinding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntryKHR *)0)->dstArrayElement));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntryKHR *)0)->dstArrayElement);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntryKHR *)0)->descriptorCount));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntryKHR *)0)->descriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntryKHR *)0)->descriptorType));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntryKHR *)0)->descriptorType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntryKHR *)0)->offset));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntryKHR *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntryKHR *)0)->stride));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntryKHR *)0)->stride);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorUpdateTemplateEntryKHR::flush() {
  _VkDescriptorUpdateTemplateEntryKHR *self = this;
  
  return true;
}

// dstBinding
Napi::Value _VkDescriptorUpdateTemplateEntryKHR::GetdstBinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstBinding);
}void _VkDescriptorUpdateTemplateEntryKHR::SetdstBinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstBinding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntryKHR.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
Napi::Value _VkDescriptorUpdateTemplateEntryKHR::GetdstArrayElement(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstArrayElement);
}void _VkDescriptorUpdateTemplateEntryKHR::SetdstArrayElement(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstArrayElement = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntryKHR.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
Napi::Value _VkDescriptorUpdateTemplateEntryKHR::GetdescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorCount);
}void _VkDescriptorUpdateTemplateEntryKHR::SetdescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntryKHR.descriptorCount", "Number");
  
    return;
  }
}// descriptorType
Napi::Value _VkDescriptorUpdateTemplateEntryKHR::GetdescriptorType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorType);
}void _VkDescriptorUpdateTemplateEntryKHR::SetdescriptorType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorType = static_cast<VkDescriptorType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntryKHR.descriptorType", "Number");
  
    return;
  }
}// offset
Napi::Value _VkDescriptorUpdateTemplateEntryKHR::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkDescriptorUpdateTemplateEntryKHR::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntryKHR.offset", "Number");
  
    return;
  }
}// stride
Napi::Value _VkDescriptorUpdateTemplateEntryKHR::Getstride(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stride);
}void _VkDescriptorUpdateTemplateEntryKHR::Setstride(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stride = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntryKHR.stride", "Number");
  
    return;
  }
}
/** ## END VkDescriptorUpdateTemplateEntryKHR ## **/

/** ## BEGIN VkDescriptorUpdateTemplateEntry ## **/

Napi::FunctionReference _VkDescriptorUpdateTemplateEntry::constructor;

_VkDescriptorUpdateTemplateEntry::_VkDescriptorUpdateTemplateEntry(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorUpdateTemplateEntry>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "dstBinding");
      Napi::String sAccess1 = Napi::String::New(env, "dstArrayElement");
      Napi::String sAccess2 = Napi::String::New(env, "descriptorCount");
      Napi::String sAccess3 = Napi::String::New(env, "descriptorType");
      Napi::String sAccess4 = Napi::String::New(env, "offset");
      Napi::String sAccess5 = Napi::String::New(env, "stride");
      if (obj.Has(sAccess0)) this->SetdstBinding(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdstArrayElement(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdescriptorCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdescriptorType(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setoffset(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setstride(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkDescriptorUpdateTemplateEntry constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorUpdateTemplateEntry::~_VkDescriptorUpdateTemplateEntry() {
  
  
  
  
  
  
  
}

Napi::Object _VkDescriptorUpdateTemplateEntry::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorUpdateTemplateEntry", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorUpdateTemplateEntry::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorUpdateTemplateEntry::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "dstBinding",
    &_VkDescriptorUpdateTemplateEntry::GetdstBinding,
    &_VkDescriptorUpdateTemplateEntry::SetdstBinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstArrayElement",
    &_VkDescriptorUpdateTemplateEntry::GetdstArrayElement,
    &_VkDescriptorUpdateTemplateEntry::SetdstArrayElement,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorCount",
    &_VkDescriptorUpdateTemplateEntry::GetdescriptorCount,
    &_VkDescriptorUpdateTemplateEntry::SetdescriptorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorType",
    &_VkDescriptorUpdateTemplateEntry::GetdescriptorType,
    &_VkDescriptorUpdateTemplateEntry::SetdescriptorType,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkDescriptorUpdateTemplateEntry::Getoffset,
    &_VkDescriptorUpdateTemplateEntry::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "stride",
    &_VkDescriptorUpdateTemplateEntry::Getstride,
    &_VkDescriptorUpdateTemplateEntry::Setstride,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorUpdateTemplateEntry", func);
  return exports;
}

Napi::Value _VkDescriptorUpdateTemplateEntry::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorUpdateTemplateEntry::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntry *)0)->dstBinding));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntry *)0)->dstBinding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntry *)0)->dstArrayElement));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntry *)0)->dstArrayElement);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntry *)0)->descriptorCount));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntry *)0)->descriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntry *)0)->descriptorType));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntry *)0)->descriptorType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntry *)0)->offset));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntry *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorUpdateTemplateEntry *)0)->stride));
    uint32_t byteLength = sizeof(((VkDescriptorUpdateTemplateEntry *)0)->stride);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorUpdateTemplateEntry::flush() {
  _VkDescriptorUpdateTemplateEntry *self = this;
  
  return true;
}

// dstBinding
Napi::Value _VkDescriptorUpdateTemplateEntry::GetdstBinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstBinding);
}void _VkDescriptorUpdateTemplateEntry::SetdstBinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstBinding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntry.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
Napi::Value _VkDescriptorUpdateTemplateEntry::GetdstArrayElement(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstArrayElement);
}void _VkDescriptorUpdateTemplateEntry::SetdstArrayElement(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstArrayElement = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntry.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
Napi::Value _VkDescriptorUpdateTemplateEntry::GetdescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorCount);
}void _VkDescriptorUpdateTemplateEntry::SetdescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntry.descriptorCount", "Number");
  
    return;
  }
}// descriptorType
Napi::Value _VkDescriptorUpdateTemplateEntry::GetdescriptorType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorType);
}void _VkDescriptorUpdateTemplateEntry::SetdescriptorType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorType = static_cast<VkDescriptorType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntry.descriptorType", "Number");
  
    return;
  }
}// offset
Napi::Value _VkDescriptorUpdateTemplateEntry::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkDescriptorUpdateTemplateEntry::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntry.offset", "Number");
  
    return;
  }
}// stride
Napi::Value _VkDescriptorUpdateTemplateEntry::Getstride(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stride);
}void _VkDescriptorUpdateTemplateEntry::Setstride(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stride = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorUpdateTemplateEntry.stride", "Number");
  
    return;
  }
}
/** ## END VkDescriptorUpdateTemplateEntry ## **/

/** ## BEGIN VkDeviceGroupSwapchainCreateInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupSwapchainCreateInfoKHR::constructor;

_VkDeviceGroupSwapchainCreateInfoKHR::_VkDeviceGroupSwapchainCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupSwapchainCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "modes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmodes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupSwapchainCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupSwapchainCreateInfoKHR::~_VkDeviceGroupSwapchainCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDeviceGroupSwapchainCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupSwapchainCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupSwapchainCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupSwapchainCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupSwapchainCreateInfoKHR::GetsType,
    &_VkDeviceGroupSwapchainCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupSwapchainCreateInfoKHR::GetpNext,
    &_VkDeviceGroupSwapchainCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "modes",
    &_VkDeviceGroupSwapchainCreateInfoKHR::Getmodes,
    &_VkDeviceGroupSwapchainCreateInfoKHR::Setmodes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupSwapchainCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupSwapchainCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupSwapchainCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSwapchainCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupSwapchainCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSwapchainCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupSwapchainCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSwapchainCreateInfoKHR *)0)->modes));
    uint32_t byteLength = sizeof(((VkDeviceGroupSwapchainCreateInfoKHR *)0)->modes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupSwapchainCreateInfoKHR::flush() {
  _VkDeviceGroupSwapchainCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupSwapchainCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupSwapchainCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSwapchainCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupSwapchainCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupSwapchainCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupSwapchainCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSwapchainCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSwapchainCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// modes
Napi::Value _VkDeviceGroupSwapchainCreateInfoKHR::Getmodes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.modes);
}void _VkDeviceGroupSwapchainCreateInfoKHR::Setmodes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.modes = static_cast<VkDeviceGroupPresentModeFlagsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSwapchainCreateInfoKHR.modes", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupSwapchainCreateInfoKHR ## **/

/** ## BEGIN VkDeviceGroupDeviceCreateInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupDeviceCreateInfoKHR::constructor;

_VkDeviceGroupDeviceCreateInfoKHR::_VkDeviceGroupDeviceCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupDeviceCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR;
    vpPhysicalDevices = new std::vector<VkPhysicalDevice>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "physicalDeviceCount");
      Napi::String sAccess3 = Napi::String::New(env, "pPhysicalDevices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetphysicalDeviceCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpPhysicalDevices(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupDeviceCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupDeviceCreateInfoKHR::~_VkDeviceGroupDeviceCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  vpPhysicalDevices->clear();
  delete vpPhysicalDevices;
  
  pPhysicalDevices.Reset();
  
}

Napi::Object _VkDeviceGroupDeviceCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupDeviceCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupDeviceCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupDeviceCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupDeviceCreateInfoKHR::GetsType,
    &_VkDeviceGroupDeviceCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupDeviceCreateInfoKHR::GetpNext,
    &_VkDeviceGroupDeviceCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDeviceCount",
    &_VkDeviceGroupDeviceCreateInfoKHR::GetphysicalDeviceCount,
    &_VkDeviceGroupDeviceCreateInfoKHR::SetphysicalDeviceCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPhysicalDevices",
    &_VkDeviceGroupDeviceCreateInfoKHR::GetpPhysicalDevices,
    &_VkDeviceGroupDeviceCreateInfoKHR::SetpPhysicalDevices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupDeviceCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupDeviceCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupDeviceCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfoKHR *)0)->physicalDeviceCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfoKHR *)0)->physicalDeviceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfoKHR *)0)->pPhysicalDevices));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfoKHR *)0)->pPhysicalDevices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupDeviceCreateInfoKHR::flush() {
  _VkDeviceGroupDeviceCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pPhysicalDevices.IsEmpty())) {
    Napi::Value value = self->pPhysicalDevices.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.physicalDeviceCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPhysicalDevice>* data = this->vpPhysicalDevices;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices", "[object VkPhysicalDevice]");
  
        return false;
      }
      _VkPhysicalDevice* result = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pPhysicalDevices = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupDeviceCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupDeviceCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupDeviceCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupDeviceCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupDeviceCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// physicalDeviceCount
Napi::Value _VkDeviceGroupDeviceCreateInfoKHR::GetphysicalDeviceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.physicalDeviceCount);
}void _VkDeviceGroupDeviceCreateInfoKHR::SetphysicalDeviceCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.physicalDeviceCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.physicalDeviceCount", "Number");
  
    return;
  }
}// pPhysicalDevices
Napi::Value _VkDeviceGroupDeviceCreateInfoKHR::GetpPhysicalDevices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPhysicalDevices.IsEmpty()) return env.Null();
  return this->pPhysicalDevices.Value().As<Napi::Array>();
}void _VkDeviceGroupDeviceCreateInfoKHR::SetpPhysicalDevices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pPhysicalDevices.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pPhysicalDevices.Reset();
      this->instance.pPhysicalDevices = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices", "[object VkPhysicalDevice]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pPhysicalDevices = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices", "[object VkPhysicalDevice]");
  
    return;
  }
}
/** ## END VkDeviceGroupDeviceCreateInfoKHR ## **/

/** ## BEGIN VkDeviceGroupDeviceCreateInfo ## **/

Napi::FunctionReference _VkDeviceGroupDeviceCreateInfo::constructor;

_VkDeviceGroupDeviceCreateInfo::_VkDeviceGroupDeviceCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupDeviceCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
    vpPhysicalDevices = new std::vector<VkPhysicalDevice>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "physicalDeviceCount");
      Napi::String sAccess3 = Napi::String::New(env, "pPhysicalDevices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetphysicalDeviceCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpPhysicalDevices(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupDeviceCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupDeviceCreateInfo::~_VkDeviceGroupDeviceCreateInfo() {
  
  
  pNext.Reset();
  
  
  vpPhysicalDevices->clear();
  delete vpPhysicalDevices;
  
  pPhysicalDevices.Reset();
  
}

Napi::Object _VkDeviceGroupDeviceCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupDeviceCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupDeviceCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupDeviceCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupDeviceCreateInfo::GetsType,
    &_VkDeviceGroupDeviceCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupDeviceCreateInfo::GetpNext,
    &_VkDeviceGroupDeviceCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDeviceCount",
    &_VkDeviceGroupDeviceCreateInfo::GetphysicalDeviceCount,
    &_VkDeviceGroupDeviceCreateInfo::SetphysicalDeviceCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPhysicalDevices",
    &_VkDeviceGroupDeviceCreateInfo::GetpPhysicalDevices,
    &_VkDeviceGroupDeviceCreateInfo::SetpPhysicalDevices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupDeviceCreateInfo", func);
  return exports;
}

Napi::Value _VkDeviceGroupDeviceCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupDeviceCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfo *)0)->physicalDeviceCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfo *)0)->physicalDeviceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupDeviceCreateInfo *)0)->pPhysicalDevices));
    uint32_t byteLength = sizeof(((VkDeviceGroupDeviceCreateInfo *)0)->pPhysicalDevices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupDeviceCreateInfo::flush() {
  _VkDeviceGroupDeviceCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pPhysicalDevices.IsEmpty())) {
    Napi::Value value = self->pPhysicalDevices.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.physicalDeviceCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPhysicalDevice>* data = this->vpPhysicalDevices;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.pPhysicalDevices", "[object VkPhysicalDevice]");
  
        return false;
      }
      _VkPhysicalDevice* result = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pPhysicalDevices = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupDeviceCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupDeviceCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupDeviceCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupDeviceCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupDeviceCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// physicalDeviceCount
Napi::Value _VkDeviceGroupDeviceCreateInfo::GetphysicalDeviceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.physicalDeviceCount);
}void _VkDeviceGroupDeviceCreateInfo::SetphysicalDeviceCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.physicalDeviceCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.physicalDeviceCount", "Number");
  
    return;
  }
}// pPhysicalDevices
Napi::Value _VkDeviceGroupDeviceCreateInfo::GetpPhysicalDevices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPhysicalDevices.IsEmpty()) return env.Null();
  return this->pPhysicalDevices.Value().As<Napi::Array>();
}void _VkDeviceGroupDeviceCreateInfo::SetpPhysicalDevices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pPhysicalDevices.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pPhysicalDevices.Reset();
      this->instance.pPhysicalDevices = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.pPhysicalDevices", "[object VkPhysicalDevice]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pPhysicalDevices = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupDeviceCreateInfo.pPhysicalDevices", "[object VkPhysicalDevice]");
  
    return;
  }
}
/** ## END VkDeviceGroupDeviceCreateInfo ## **/

/** ## BEGIN VkDeviceGroupPresentInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupPresentInfoKHR::constructor;

_VkDeviceGroupPresentInfoKHR::_VkDeviceGroupPresentInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupPresentInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "swapchainCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDeviceMasks");
      Napi::String sAccess4 = Napi::String::New(env, "mode");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetswapchainCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDeviceMasks(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setmode(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupPresentInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupPresentInfoKHR::~_VkDeviceGroupPresentInfoKHR() {
  
  
  pNext.Reset();
  
  
  pDeviceMasks.Reset();
  
  
}

Napi::Object _VkDeviceGroupPresentInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupPresentInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupPresentInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupPresentInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupPresentInfoKHR::GetsType,
    &_VkDeviceGroupPresentInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupPresentInfoKHR::GetpNext,
    &_VkDeviceGroupPresentInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchainCount",
    &_VkDeviceGroupPresentInfoKHR::GetswapchainCount,
    &_VkDeviceGroupPresentInfoKHR::SetswapchainCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceMasks",
    &_VkDeviceGroupPresentInfoKHR::GetpDeviceMasks,
    &_VkDeviceGroupPresentInfoKHR::SetpDeviceMasks,
    napi_enumerable
  ),
  InstanceAccessor(
    "mode",
    &_VkDeviceGroupPresentInfoKHR::Getmode,
    &_VkDeviceGroupPresentInfoKHR::Setmode,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupPresentInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupPresentInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupPresentInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentInfoKHR *)0)->swapchainCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentInfoKHR *)0)->swapchainCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentInfoKHR *)0)->pDeviceMasks));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentInfoKHR *)0)->pDeviceMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentInfoKHR *)0)->mode));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentInfoKHR *)0)->mode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupPresentInfoKHR::flush() {
  _VkDeviceGroupPresentInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupPresentInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupPresentInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupPresentInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupPresentInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupPresentInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// swapchainCount
Napi::Value _VkDeviceGroupPresentInfoKHR::GetswapchainCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.swapchainCount);
}void _VkDeviceGroupPresentInfoKHR::SetswapchainCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.swapchainCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.swapchainCount", "Number");
  
    return;
  }
}// pDeviceMasks
Napi::Value _VkDeviceGroupPresentInfoKHR::GetpDeviceMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceMasks.IsEmpty()) return env.Null();
  return this->pDeviceMasks.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupPresentInfoKHR::SetpDeviceMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pDeviceMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.pDeviceMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDeviceMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.pDeviceMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDeviceMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pDeviceMasks = nullptr;
  }
}// mode
Napi::Value _VkDeviceGroupPresentInfoKHR::Getmode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mode);
}void _VkDeviceGroupPresentInfoKHR::Setmode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mode = static_cast<VkDeviceGroupPresentModeFlagBitsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupPresentInfoKHR.mode", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupPresentInfoKHR ## **/

/** ## BEGIN VkAcquireNextImageInfoKHR ## **/

Napi::FunctionReference _VkAcquireNextImageInfoKHR::constructor;

_VkAcquireNextImageInfoKHR::_VkAcquireNextImageInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAcquireNextImageInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "swapchain");
      Napi::String sAccess3 = Napi::String::New(env, "timeout");
      Napi::String sAccess4 = Napi::String::New(env, "semaphore");
      Napi::String sAccess5 = Napi::String::New(env, "fence");
      Napi::String sAccess6 = Napi::String::New(env, "deviceMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setswapchain(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Settimeout(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setsemaphore(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setfence(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdeviceMask(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkAcquireNextImageInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkAcquireNextImageInfoKHR::~_VkAcquireNextImageInfoKHR() {
  
  
  pNext.Reset();
  
  swapchain.Reset();
  
  
  semaphore.Reset();
  
  fence.Reset();
  
  
}

Napi::Object _VkAcquireNextImageInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAcquireNextImageInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAcquireNextImageInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAcquireNextImageInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkAcquireNextImageInfoKHR::GetsType,
    &_VkAcquireNextImageInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkAcquireNextImageInfoKHR::GetpNext,
    &_VkAcquireNextImageInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchain",
    &_VkAcquireNextImageInfoKHR::Getswapchain,
    &_VkAcquireNextImageInfoKHR::Setswapchain,
    napi_enumerable
  ),
  InstanceAccessor(
    "timeout",
    &_VkAcquireNextImageInfoKHR::Gettimeout,
    &_VkAcquireNextImageInfoKHR::Settimeout,
    napi_enumerable
  ),
  InstanceAccessor(
    "semaphore",
    &_VkAcquireNextImageInfoKHR::Getsemaphore,
    &_VkAcquireNextImageInfoKHR::Setsemaphore,
    napi_enumerable
  ),
  InstanceAccessor(
    "fence",
    &_VkAcquireNextImageInfoKHR::Getfence,
    &_VkAcquireNextImageInfoKHR::Setfence,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkAcquireNextImageInfoKHR::GetdeviceMask,
    &_VkAcquireNextImageInfoKHR::SetdeviceMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAcquireNextImageInfoKHR", func);
  return exports;
}

Napi::Value _VkAcquireNextImageInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAcquireNextImageInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->swapchain));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->swapchain);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->timeout));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->timeout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->semaphore));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->semaphore);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->fence));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->fence);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAcquireNextImageInfoKHR *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkAcquireNextImageInfoKHR *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAcquireNextImageInfoKHR::flush() {
  _VkAcquireNextImageInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkAcquireNextImageInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkAcquireNextImageInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkAcquireNextImageInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkAcquireNextImageInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkAcquireNextImageInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// swapchain
Napi::Value _VkAcquireNextImageInfoKHR::Getswapchain(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->swapchain.IsEmpty()) return env.Null();
  return this->swapchain.Value().As<Napi::Object>();
}void _VkAcquireNextImageInfoKHR::Setswapchain(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSwapchainKHR::constructor.Value())) {
      
      this->swapchain.Reset(value.ToObject(), 1);
      _VkSwapchainKHR* inst = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      ;
      this->instance.swapchain = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->swapchain.Reset();
    this->instance.swapchain = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}// timeout
Napi::Value _VkAcquireNextImageInfoKHR::Gettimeout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.timeout);
}void _VkAcquireNextImageInfoKHR::Settimeout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.timeout = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.timeout", "Number");
  
    return;
  }
}// semaphore
Napi::Value _VkAcquireNextImageInfoKHR::Getsemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->semaphore.IsEmpty()) return env.Null();
  return this->semaphore.Value().As<Napi::Object>();
}void _VkAcquireNextImageInfoKHR::Setsemaphore(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSemaphore::constructor.Value())) {
      
      this->semaphore.Reset(value.ToObject(), 1);
      _VkSemaphore* inst = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      ;
      this->instance.semaphore = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->semaphore.Reset();
    this->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// fence
Napi::Value _VkAcquireNextImageInfoKHR::Getfence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->fence.IsEmpty()) return env.Null();
  return this->fence.Value().As<Napi::Object>();
}void _VkAcquireNextImageInfoKHR::Setfence(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFence::constructor.Value())) {
      
      this->fence.Reset(value.ToObject(), 1);
      _VkFence* inst = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      ;
      this->instance.fence = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->fence.Reset();
    this->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// deviceMask
Napi::Value _VkAcquireNextImageInfoKHR::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkAcquireNextImageInfoKHR::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkAcquireNextImageInfoKHR.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkAcquireNextImageInfoKHR ## **/

/** ## BEGIN VkBindImageMemorySwapchainInfoKHR ## **/

Napi::FunctionReference _VkBindImageMemorySwapchainInfoKHR::constructor;

_VkBindImageMemorySwapchainInfoKHR::_VkBindImageMemorySwapchainInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImageMemorySwapchainInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "swapchain");
      Napi::String sAccess3 = Napi::String::New(env, "imageIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setswapchain(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetimageIndex(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkBindImageMemorySwapchainInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImageMemorySwapchainInfoKHR::~_VkBindImageMemorySwapchainInfoKHR() {
  
  
  pNext.Reset();
  
  swapchain.Reset();
  
  
}

Napi::Object _VkBindImageMemorySwapchainInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImageMemorySwapchainInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImageMemorySwapchainInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImageMemorySwapchainInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImageMemorySwapchainInfoKHR::GetsType,
    &_VkBindImageMemorySwapchainInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImageMemorySwapchainInfoKHR::GetpNext,
    &_VkBindImageMemorySwapchainInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchain",
    &_VkBindImageMemorySwapchainInfoKHR::Getswapchain,
    &_VkBindImageMemorySwapchainInfoKHR::Setswapchain,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageIndex",
    &_VkBindImageMemorySwapchainInfoKHR::GetimageIndex,
    &_VkBindImageMemorySwapchainInfoKHR::SetimageIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImageMemorySwapchainInfoKHR", func);
  return exports;
}

Napi::Value _VkBindImageMemorySwapchainInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImageMemorySwapchainInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemorySwapchainInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImageMemorySwapchainInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemorySwapchainInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImageMemorySwapchainInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemorySwapchainInfoKHR *)0)->swapchain));
    uint32_t byteLength = sizeof(((VkBindImageMemorySwapchainInfoKHR *)0)->swapchain);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemorySwapchainInfoKHR *)0)->imageIndex));
    uint32_t byteLength = sizeof(((VkBindImageMemorySwapchainInfoKHR *)0)->imageIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImageMemorySwapchainInfoKHR::flush() {
  _VkBindImageMemorySwapchainInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBindImageMemorySwapchainInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImageMemorySwapchainInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemorySwapchainInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImageMemorySwapchainInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImageMemorySwapchainInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindImageMemorySwapchainInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemorySwapchainInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemorySwapchainInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// swapchain
Napi::Value _VkBindImageMemorySwapchainInfoKHR::Getswapchain(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->swapchain.IsEmpty()) return env.Null();
  return this->swapchain.Value().As<Napi::Object>();
}void _VkBindImageMemorySwapchainInfoKHR::Setswapchain(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSwapchainKHR::constructor.Value())) {
      
      this->swapchain.Reset(value.ToObject(), 1);
      _VkSwapchainKHR* inst = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      ;
      this->instance.swapchain = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemorySwapchainInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->swapchain.Reset();
    this->instance.swapchain = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemorySwapchainInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}// imageIndex
Napi::Value _VkBindImageMemorySwapchainInfoKHR::GetimageIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageIndex);
}void _VkBindImageMemorySwapchainInfoKHR::SetimageIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemorySwapchainInfoKHR.imageIndex", "Number");
  
    return;
  }
}
/** ## END VkBindImageMemorySwapchainInfoKHR ## **/

/** ## BEGIN VkImageSwapchainCreateInfoKHR ## **/

Napi::FunctionReference _VkImageSwapchainCreateInfoKHR::constructor;

_VkImageSwapchainCreateInfoKHR::_VkImageSwapchainCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageSwapchainCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "swapchain");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setswapchain(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageSwapchainCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageSwapchainCreateInfoKHR::~_VkImageSwapchainCreateInfoKHR() {
  
  
  pNext.Reset();
  
  swapchain.Reset();
  
}

Napi::Object _VkImageSwapchainCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageSwapchainCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageSwapchainCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageSwapchainCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageSwapchainCreateInfoKHR::GetsType,
    &_VkImageSwapchainCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageSwapchainCreateInfoKHR::GetpNext,
    &_VkImageSwapchainCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchain",
    &_VkImageSwapchainCreateInfoKHR::Getswapchain,
    &_VkImageSwapchainCreateInfoKHR::Setswapchain,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageSwapchainCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkImageSwapchainCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageSwapchainCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSwapchainCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageSwapchainCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSwapchainCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageSwapchainCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSwapchainCreateInfoKHR *)0)->swapchain));
    uint32_t byteLength = sizeof(((VkImageSwapchainCreateInfoKHR *)0)->swapchain);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageSwapchainCreateInfoKHR::flush() {
  _VkImageSwapchainCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageSwapchainCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageSwapchainCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSwapchainCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageSwapchainCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageSwapchainCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImageSwapchainCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImageSwapchainCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageSwapchainCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// swapchain
Napi::Value _VkImageSwapchainCreateInfoKHR::Getswapchain(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->swapchain.IsEmpty()) return env.Null();
  return this->swapchain.Value().As<Napi::Object>();
}void _VkImageSwapchainCreateInfoKHR::Setswapchain(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSwapchainKHR::constructor.Value())) {
      
      this->swapchain.Reset(value.ToObject(), 1);
      _VkSwapchainKHR* inst = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      ;
      this->instance.swapchain = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageSwapchainCreateInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->swapchain.Reset();
    this->instance.swapchain = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageSwapchainCreateInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}
/** ## END VkImageSwapchainCreateInfoKHR ## **/

/** ## BEGIN VkDeviceGroupPresentCapabilitiesKHR ## **/

Napi::FunctionReference _VkDeviceGroupPresentCapabilitiesKHR::constructor;

_VkDeviceGroupPresentCapabilitiesKHR::_VkDeviceGroupPresentCapabilitiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupPresentCapabilitiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
    vpresentMask = new std::vector<uint32_t>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupPresentCapabilitiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupPresentCapabilitiesKHR::~_VkDeviceGroupPresentCapabilitiesKHR() {
  
  
  pNext.Reset();
  
  vpresentMask->clear();
  delete vpresentMask;
  
  presentMask.Reset();
  
  
}

Napi::Object _VkDeviceGroupPresentCapabilitiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupPresentCapabilitiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupPresentCapabilitiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupPresentCapabilitiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupPresentCapabilitiesKHR::GetsType,
    &_VkDeviceGroupPresentCapabilitiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupPresentCapabilitiesKHR::GetpNext,
    &_VkDeviceGroupPresentCapabilitiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "presentMask",
    &_VkDeviceGroupPresentCapabilitiesKHR::GetpresentMask,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "modes",
    &_VkDeviceGroupPresentCapabilitiesKHR::Getmodes,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupPresentCapabilitiesKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupPresentCapabilitiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupPresentCapabilitiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentCapabilitiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentCapabilitiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentCapabilitiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentCapabilitiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentCapabilitiesKHR *)0)->presentMask));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentCapabilitiesKHR *)0)->presentMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupPresentCapabilitiesKHR *)0)->modes));
    uint32_t byteLength = sizeof(((VkDeviceGroupPresentCapabilitiesKHR *)0)->modes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupPresentCapabilitiesKHR::flush() {
  _VkDeviceGroupPresentCapabilitiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->presentMask.IsEmpty())) {
    Napi::Value value = self->presentMask.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupPresentCapabilitiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupPresentCapabilitiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupPresentCapabilitiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupPresentCapabilitiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupPresentCapabilitiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupPresentCapabilitiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupPresentCapabilitiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupPresentCapabilitiesKHR.pNext", "[object Object]");
  
    return;
  }
}// presentMask
Napi::Value _VkDeviceGroupPresentCapabilitiesKHR::GetpresentMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->presentMask.IsEmpty()) return env.Null();
  return this->presentMask.Value().As<Napi::Array>();
}// modes
Napi::Value _VkDeviceGroupPresentCapabilitiesKHR::Getmodes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.modes);
}
/** ## END VkDeviceGroupPresentCapabilitiesKHR ## **/

/** ## BEGIN VkDeviceGroupBindSparseInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupBindSparseInfoKHR::constructor;

_VkDeviceGroupBindSparseInfoKHR::_VkDeviceGroupBindSparseInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupBindSparseInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "resourceDeviceIndex");
      Napi::String sAccess3 = Napi::String::New(env, "memoryDeviceIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetresourceDeviceIndex(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmemoryDeviceIndex(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupBindSparseInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupBindSparseInfoKHR::~_VkDeviceGroupBindSparseInfoKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkDeviceGroupBindSparseInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupBindSparseInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupBindSparseInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupBindSparseInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupBindSparseInfoKHR::GetsType,
    &_VkDeviceGroupBindSparseInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupBindSparseInfoKHR::GetpNext,
    &_VkDeviceGroupBindSparseInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "resourceDeviceIndex",
    &_VkDeviceGroupBindSparseInfoKHR::GetresourceDeviceIndex,
    &_VkDeviceGroupBindSparseInfoKHR::SetresourceDeviceIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryDeviceIndex",
    &_VkDeviceGroupBindSparseInfoKHR::GetmemoryDeviceIndex,
    &_VkDeviceGroupBindSparseInfoKHR::SetmemoryDeviceIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupBindSparseInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupBindSparseInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupBindSparseInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfoKHR *)0)->resourceDeviceIndex));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfoKHR *)0)->resourceDeviceIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfoKHR *)0)->memoryDeviceIndex));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfoKHR *)0)->memoryDeviceIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupBindSparseInfoKHR::flush() {
  _VkDeviceGroupBindSparseInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupBindSparseInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupBindSparseInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupBindSparseInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupBindSparseInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupBindSparseInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// resourceDeviceIndex
Napi::Value _VkDeviceGroupBindSparseInfoKHR::GetresourceDeviceIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.resourceDeviceIndex);
}void _VkDeviceGroupBindSparseInfoKHR::SetresourceDeviceIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.resourceDeviceIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfoKHR.resourceDeviceIndex", "Number");
  
    return;
  }
}// memoryDeviceIndex
Napi::Value _VkDeviceGroupBindSparseInfoKHR::GetmemoryDeviceIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryDeviceIndex);
}void _VkDeviceGroupBindSparseInfoKHR::SetmemoryDeviceIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryDeviceIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfoKHR.memoryDeviceIndex", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupBindSparseInfoKHR ## **/

/** ## BEGIN VkDeviceGroupBindSparseInfo ## **/

Napi::FunctionReference _VkDeviceGroupBindSparseInfo::constructor;

_VkDeviceGroupBindSparseInfo::_VkDeviceGroupBindSparseInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupBindSparseInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "resourceDeviceIndex");
      Napi::String sAccess3 = Napi::String::New(env, "memoryDeviceIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetresourceDeviceIndex(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmemoryDeviceIndex(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupBindSparseInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupBindSparseInfo::~_VkDeviceGroupBindSparseInfo() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkDeviceGroupBindSparseInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupBindSparseInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupBindSparseInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupBindSparseInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupBindSparseInfo::GetsType,
    &_VkDeviceGroupBindSparseInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupBindSparseInfo::GetpNext,
    &_VkDeviceGroupBindSparseInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "resourceDeviceIndex",
    &_VkDeviceGroupBindSparseInfo::GetresourceDeviceIndex,
    &_VkDeviceGroupBindSparseInfo::SetresourceDeviceIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryDeviceIndex",
    &_VkDeviceGroupBindSparseInfo::GetmemoryDeviceIndex,
    &_VkDeviceGroupBindSparseInfo::SetmemoryDeviceIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupBindSparseInfo", func);
  return exports;
}

Napi::Value _VkDeviceGroupBindSparseInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupBindSparseInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfo *)0)->resourceDeviceIndex));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfo *)0)->resourceDeviceIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupBindSparseInfo *)0)->memoryDeviceIndex));
    uint32_t byteLength = sizeof(((VkDeviceGroupBindSparseInfo *)0)->memoryDeviceIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupBindSparseInfo::flush() {
  _VkDeviceGroupBindSparseInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupBindSparseInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupBindSparseInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupBindSparseInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupBindSparseInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupBindSparseInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfo.pNext", "[object Object]");
  
    return;
  }
}// resourceDeviceIndex
Napi::Value _VkDeviceGroupBindSparseInfo::GetresourceDeviceIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.resourceDeviceIndex);
}void _VkDeviceGroupBindSparseInfo::SetresourceDeviceIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.resourceDeviceIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfo.resourceDeviceIndex", "Number");
  
    return;
  }
}// memoryDeviceIndex
Napi::Value _VkDeviceGroupBindSparseInfo::GetmemoryDeviceIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryDeviceIndex);
}void _VkDeviceGroupBindSparseInfo::SetmemoryDeviceIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryDeviceIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupBindSparseInfo.memoryDeviceIndex", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupBindSparseInfo ## **/

/** ## BEGIN VkDeviceGroupSubmitInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupSubmitInfoKHR::constructor;

_VkDeviceGroupSubmitInfoKHR::_VkDeviceGroupSubmitInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupSubmitInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "waitSemaphoreCount");
      Napi::String sAccess3 = Napi::String::New(env, "pWaitSemaphoreDeviceIndices");
      Napi::String sAccess4 = Napi::String::New(env, "commandBufferCount");
      Napi::String sAccess5 = Napi::String::New(env, "pCommandBufferDeviceMasks");
      Napi::String sAccess6 = Napi::String::New(env, "signalSemaphoreCount");
      Napi::String sAccess7 = Napi::String::New(env, "pSignalSemaphoreDeviceIndices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetwaitSemaphoreCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpWaitSemaphoreDeviceIndices(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcommandBufferCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpCommandBufferDeviceMasks(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetsignalSemaphoreCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpSignalSemaphoreDeviceIndices(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupSubmitInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupSubmitInfoKHR::~_VkDeviceGroupSubmitInfoKHR() {
  
  
  pNext.Reset();
  
  
  pWaitSemaphoreDeviceIndices.Reset();
  
  
  pCommandBufferDeviceMasks.Reset();
  
  
  pSignalSemaphoreDeviceIndices.Reset();
  
}

Napi::Object _VkDeviceGroupSubmitInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupSubmitInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupSubmitInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupSubmitInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupSubmitInfoKHR::GetsType,
    &_VkDeviceGroupSubmitInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupSubmitInfoKHR::GetpNext,
    &_VkDeviceGroupSubmitInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "waitSemaphoreCount",
    &_VkDeviceGroupSubmitInfoKHR::GetwaitSemaphoreCount,
    &_VkDeviceGroupSubmitInfoKHR::SetwaitSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitSemaphoreDeviceIndices",
    &_VkDeviceGroupSubmitInfoKHR::GetpWaitSemaphoreDeviceIndices,
    &_VkDeviceGroupSubmitInfoKHR::SetpWaitSemaphoreDeviceIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "commandBufferCount",
    &_VkDeviceGroupSubmitInfoKHR::GetcommandBufferCount,
    &_VkDeviceGroupSubmitInfoKHR::SetcommandBufferCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCommandBufferDeviceMasks",
    &_VkDeviceGroupSubmitInfoKHR::GetpCommandBufferDeviceMasks,
    &_VkDeviceGroupSubmitInfoKHR::SetpCommandBufferDeviceMasks,
    napi_enumerable
  ),
  InstanceAccessor(
    "signalSemaphoreCount",
    &_VkDeviceGroupSubmitInfoKHR::GetsignalSemaphoreCount,
    &_VkDeviceGroupSubmitInfoKHR::SetsignalSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSignalSemaphoreDeviceIndices",
    &_VkDeviceGroupSubmitInfoKHR::GetpSignalSemaphoreDeviceIndices,
    &_VkDeviceGroupSubmitInfoKHR::SetpSignalSemaphoreDeviceIndices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupSubmitInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupSubmitInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupSubmitInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->waitSemaphoreCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->waitSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->pWaitSemaphoreDeviceIndices));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->pWaitSemaphoreDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->commandBufferCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->commandBufferCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->pCommandBufferDeviceMasks));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->pCommandBufferDeviceMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->signalSemaphoreCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->signalSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfoKHR *)0)->pSignalSemaphoreDeviceIndices));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfoKHR *)0)->pSignalSemaphoreDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupSubmitInfoKHR::flush() {
  _VkDeviceGroupSubmitInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupSubmitInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupSubmitInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupSubmitInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// waitSemaphoreCount
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetwaitSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.waitSemaphoreCount);
}void _VkDeviceGroupSubmitInfoKHR::SetwaitSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.waitSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphoreDeviceIndices
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetpWaitSemaphoreDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitSemaphoreDeviceIndices.IsEmpty()) return env.Null();
  return this->pWaitSemaphoreDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupSubmitInfoKHR::SetpWaitSemaphoreDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pWaitSemaphoreDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pWaitSemaphoreDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pWaitSemaphoreDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pWaitSemaphoreDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pWaitSemaphoreDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pWaitSemaphoreDeviceIndices = nullptr;
  }
}// commandBufferCount
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetcommandBufferCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.commandBufferCount);
}void _VkDeviceGroupSubmitInfoKHR::SetcommandBufferCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.commandBufferCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.commandBufferCount", "Number");
  
    return;
  }
}// pCommandBufferDeviceMasks
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetpCommandBufferDeviceMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCommandBufferDeviceMasks.IsEmpty()) return env.Null();
  return this->pCommandBufferDeviceMasks.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupSubmitInfoKHR::SetpCommandBufferDeviceMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pCommandBufferDeviceMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pCommandBufferDeviceMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCommandBufferDeviceMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pCommandBufferDeviceMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCommandBufferDeviceMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pCommandBufferDeviceMasks = nullptr;
  }
}// signalSemaphoreCount
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetsignalSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.signalSemaphoreCount);
}void _VkDeviceGroupSubmitInfoKHR::SetsignalSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.signalSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphoreDeviceIndices
Napi::Value _VkDeviceGroupSubmitInfoKHR::GetpSignalSemaphoreDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSignalSemaphoreDeviceIndices.IsEmpty()) return env.Null();
  return this->pSignalSemaphoreDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupSubmitInfoKHR::SetpSignalSemaphoreDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pSignalSemaphoreDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pSignalSemaphoreDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pSignalSemaphoreDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfoKHR.pSignalSemaphoreDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pSignalSemaphoreDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pSignalSemaphoreDeviceIndices = nullptr;
  }
}
/** ## END VkDeviceGroupSubmitInfoKHR ## **/

/** ## BEGIN VkDeviceGroupSubmitInfo ## **/

Napi::FunctionReference _VkDeviceGroupSubmitInfo::constructor;

_VkDeviceGroupSubmitInfo::_VkDeviceGroupSubmitInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupSubmitInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "waitSemaphoreCount");
      Napi::String sAccess3 = Napi::String::New(env, "pWaitSemaphoreDeviceIndices");
      Napi::String sAccess4 = Napi::String::New(env, "commandBufferCount");
      Napi::String sAccess5 = Napi::String::New(env, "pCommandBufferDeviceMasks");
      Napi::String sAccess6 = Napi::String::New(env, "signalSemaphoreCount");
      Napi::String sAccess7 = Napi::String::New(env, "pSignalSemaphoreDeviceIndices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetwaitSemaphoreCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpWaitSemaphoreDeviceIndices(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcommandBufferCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpCommandBufferDeviceMasks(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetsignalSemaphoreCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpSignalSemaphoreDeviceIndices(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupSubmitInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupSubmitInfo::~_VkDeviceGroupSubmitInfo() {
  
  
  pNext.Reset();
  
  
  pWaitSemaphoreDeviceIndices.Reset();
  
  
  pCommandBufferDeviceMasks.Reset();
  
  
  pSignalSemaphoreDeviceIndices.Reset();
  
}

Napi::Object _VkDeviceGroupSubmitInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupSubmitInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupSubmitInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupSubmitInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupSubmitInfo::GetsType,
    &_VkDeviceGroupSubmitInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupSubmitInfo::GetpNext,
    &_VkDeviceGroupSubmitInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "waitSemaphoreCount",
    &_VkDeviceGroupSubmitInfo::GetwaitSemaphoreCount,
    &_VkDeviceGroupSubmitInfo::SetwaitSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitSemaphoreDeviceIndices",
    &_VkDeviceGroupSubmitInfo::GetpWaitSemaphoreDeviceIndices,
    &_VkDeviceGroupSubmitInfo::SetpWaitSemaphoreDeviceIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "commandBufferCount",
    &_VkDeviceGroupSubmitInfo::GetcommandBufferCount,
    &_VkDeviceGroupSubmitInfo::SetcommandBufferCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCommandBufferDeviceMasks",
    &_VkDeviceGroupSubmitInfo::GetpCommandBufferDeviceMasks,
    &_VkDeviceGroupSubmitInfo::SetpCommandBufferDeviceMasks,
    napi_enumerable
  ),
  InstanceAccessor(
    "signalSemaphoreCount",
    &_VkDeviceGroupSubmitInfo::GetsignalSemaphoreCount,
    &_VkDeviceGroupSubmitInfo::SetsignalSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSignalSemaphoreDeviceIndices",
    &_VkDeviceGroupSubmitInfo::GetpSignalSemaphoreDeviceIndices,
    &_VkDeviceGroupSubmitInfo::SetpSignalSemaphoreDeviceIndices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupSubmitInfo", func);
  return exports;
}

Napi::Value _VkDeviceGroupSubmitInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupSubmitInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->waitSemaphoreCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->waitSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->pWaitSemaphoreDeviceIndices));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->pWaitSemaphoreDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->commandBufferCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->commandBufferCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->pCommandBufferDeviceMasks));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->pCommandBufferDeviceMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->signalSemaphoreCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->signalSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupSubmitInfo *)0)->pSignalSemaphoreDeviceIndices));
    uint32_t byteLength = sizeof(((VkDeviceGroupSubmitInfo *)0)->pSignalSemaphoreDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupSubmitInfo::flush() {
  _VkDeviceGroupSubmitInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupSubmitInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupSubmitInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupSubmitInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupSubmitInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupSubmitInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pNext", "[object Object]");
  
    return;
  }
}// waitSemaphoreCount
Napi::Value _VkDeviceGroupSubmitInfo::GetwaitSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.waitSemaphoreCount);
}void _VkDeviceGroupSubmitInfo::SetwaitSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.waitSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphoreDeviceIndices
Napi::Value _VkDeviceGroupSubmitInfo::GetpWaitSemaphoreDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitSemaphoreDeviceIndices.IsEmpty()) return env.Null();
  return this->pWaitSemaphoreDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupSubmitInfo::SetpWaitSemaphoreDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pWaitSemaphoreDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pWaitSemaphoreDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pWaitSemaphoreDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pWaitSemaphoreDeviceIndices = nullptr;
  }
}// commandBufferCount
Napi::Value _VkDeviceGroupSubmitInfo::GetcommandBufferCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.commandBufferCount);
}void _VkDeviceGroupSubmitInfo::SetcommandBufferCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.commandBufferCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.commandBufferCount", "Number");
  
    return;
  }
}// pCommandBufferDeviceMasks
Napi::Value _VkDeviceGroupSubmitInfo::GetpCommandBufferDeviceMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCommandBufferDeviceMasks.IsEmpty()) return env.Null();
  return this->pCommandBufferDeviceMasks.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupSubmitInfo::SetpCommandBufferDeviceMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pCommandBufferDeviceMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCommandBufferDeviceMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCommandBufferDeviceMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pCommandBufferDeviceMasks = nullptr;
  }
}// signalSemaphoreCount
Napi::Value _VkDeviceGroupSubmitInfo::GetsignalSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.signalSemaphoreCount);
}void _VkDeviceGroupSubmitInfo::SetsignalSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.signalSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphoreDeviceIndices
Napi::Value _VkDeviceGroupSubmitInfo::GetpSignalSemaphoreDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSignalSemaphoreDeviceIndices.IsEmpty()) return env.Null();
  return this->pSignalSemaphoreDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkDeviceGroupSubmitInfo::SetpSignalSemaphoreDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pSignalSemaphoreDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pSignalSemaphoreDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pSignalSemaphoreDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pSignalSemaphoreDeviceIndices = nullptr;
  }
}
/** ## END VkDeviceGroupSubmitInfo ## **/

/** ## BEGIN VkDeviceGroupCommandBufferBeginInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupCommandBufferBeginInfoKHR::constructor;

_VkDeviceGroupCommandBufferBeginInfoKHR::_VkDeviceGroupCommandBufferBeginInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupCommandBufferBeginInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceMask(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupCommandBufferBeginInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupCommandBufferBeginInfoKHR::~_VkDeviceGroupCommandBufferBeginInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDeviceGroupCommandBufferBeginInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupCommandBufferBeginInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupCommandBufferBeginInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupCommandBufferBeginInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupCommandBufferBeginInfoKHR::GetsType,
    &_VkDeviceGroupCommandBufferBeginInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupCommandBufferBeginInfoKHR::GetpNext,
    &_VkDeviceGroupCommandBufferBeginInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkDeviceGroupCommandBufferBeginInfoKHR::GetdeviceMask,
    &_VkDeviceGroupCommandBufferBeginInfoKHR::SetdeviceMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupCommandBufferBeginInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupCommandBufferBeginInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupCommandBufferBeginInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupCommandBufferBeginInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupCommandBufferBeginInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupCommandBufferBeginInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupCommandBufferBeginInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupCommandBufferBeginInfoKHR *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkDeviceGroupCommandBufferBeginInfoKHR *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupCommandBufferBeginInfoKHR::flush() {
  _VkDeviceGroupCommandBufferBeginInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupCommandBufferBeginInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupCommandBufferBeginInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupCommandBufferBeginInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupCommandBufferBeginInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupCommandBufferBeginInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// deviceMask
Napi::Value _VkDeviceGroupCommandBufferBeginInfoKHR::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkDeviceGroupCommandBufferBeginInfoKHR::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfoKHR.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupCommandBufferBeginInfoKHR ## **/

/** ## BEGIN VkDeviceGroupCommandBufferBeginInfo ## **/

Napi::FunctionReference _VkDeviceGroupCommandBufferBeginInfo::constructor;

_VkDeviceGroupCommandBufferBeginInfo::_VkDeviceGroupCommandBufferBeginInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupCommandBufferBeginInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceMask(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupCommandBufferBeginInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupCommandBufferBeginInfo::~_VkDeviceGroupCommandBufferBeginInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDeviceGroupCommandBufferBeginInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupCommandBufferBeginInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupCommandBufferBeginInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupCommandBufferBeginInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupCommandBufferBeginInfo::GetsType,
    &_VkDeviceGroupCommandBufferBeginInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupCommandBufferBeginInfo::GetpNext,
    &_VkDeviceGroupCommandBufferBeginInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkDeviceGroupCommandBufferBeginInfo::GetdeviceMask,
    &_VkDeviceGroupCommandBufferBeginInfo::SetdeviceMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupCommandBufferBeginInfo", func);
  return exports;
}

Napi::Value _VkDeviceGroupCommandBufferBeginInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupCommandBufferBeginInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupCommandBufferBeginInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupCommandBufferBeginInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupCommandBufferBeginInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupCommandBufferBeginInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupCommandBufferBeginInfo *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkDeviceGroupCommandBufferBeginInfo *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupCommandBufferBeginInfo::flush() {
  _VkDeviceGroupCommandBufferBeginInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupCommandBufferBeginInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupCommandBufferBeginInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupCommandBufferBeginInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupCommandBufferBeginInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupCommandBufferBeginInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfo.pNext", "[object Object]");
  
    return;
  }
}// deviceMask
Napi::Value _VkDeviceGroupCommandBufferBeginInfo::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkDeviceGroupCommandBufferBeginInfo::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupCommandBufferBeginInfo.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupCommandBufferBeginInfo ## **/

/** ## BEGIN VkDeviceGroupRenderPassBeginInfoKHR ## **/

Napi::FunctionReference _VkDeviceGroupRenderPassBeginInfoKHR::constructor;

_VkDeviceGroupRenderPassBeginInfoKHR::_VkDeviceGroupRenderPassBeginInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupRenderPassBeginInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR;
    vpDeviceRenderAreas = new std::vector<VkRect2D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceMask");
      Napi::String sAccess3 = Napi::String::New(env, "deviceRenderAreaCount");
      Napi::String sAccess4 = Napi::String::New(env, "pDeviceRenderAreas");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceMask(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdeviceRenderAreaCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpDeviceRenderAreas(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupRenderPassBeginInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupRenderPassBeginInfoKHR::~_VkDeviceGroupRenderPassBeginInfoKHR() {
  
  
  pNext.Reset();
  
  
  
  vpDeviceRenderAreas->clear();
  delete vpDeviceRenderAreas;
  
  pDeviceRenderAreas.Reset();
  
}

Napi::Object _VkDeviceGroupRenderPassBeginInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupRenderPassBeginInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupRenderPassBeginInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupRenderPassBeginInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupRenderPassBeginInfoKHR::GetsType,
    &_VkDeviceGroupRenderPassBeginInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupRenderPassBeginInfoKHR::GetpNext,
    &_VkDeviceGroupRenderPassBeginInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkDeviceGroupRenderPassBeginInfoKHR::GetdeviceMask,
    &_VkDeviceGroupRenderPassBeginInfoKHR::SetdeviceMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceRenderAreaCount",
    &_VkDeviceGroupRenderPassBeginInfoKHR::GetdeviceRenderAreaCount,
    &_VkDeviceGroupRenderPassBeginInfoKHR::SetdeviceRenderAreaCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceRenderAreas",
    &_VkDeviceGroupRenderPassBeginInfoKHR::GetpDeviceRenderAreas,
    &_VkDeviceGroupRenderPassBeginInfoKHR::SetpDeviceRenderAreas,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupRenderPassBeginInfoKHR", func);
  return exports;
}

Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->deviceRenderAreaCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->deviceRenderAreaCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->pDeviceRenderAreas));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfoKHR *)0)->pDeviceRenderAreas);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupRenderPassBeginInfoKHR::flush() {
  _VkDeviceGroupRenderPassBeginInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pDeviceRenderAreas.IsEmpty())) {
    Napi::Value value = self->pDeviceRenderAreas.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.deviceRenderAreaCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRect2D>* data = this->vpDeviceRenderAreas;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRect2D::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDeviceRenderAreas = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupRenderPassBeginInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupRenderPassBeginInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupRenderPassBeginInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// deviceMask
Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkDeviceGroupRenderPassBeginInfoKHR::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.deviceMask", "Number");
  
    return;
  }
}// deviceRenderAreaCount
Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetdeviceRenderAreaCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceRenderAreaCount);
}void _VkDeviceGroupRenderPassBeginInfoKHR::SetdeviceRenderAreaCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceRenderAreaCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.deviceRenderAreaCount", "Number");
  
    return;
  }
}// pDeviceRenderAreas
Napi::Value _VkDeviceGroupRenderPassBeginInfoKHR::GetpDeviceRenderAreas(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceRenderAreas.IsEmpty()) return env.Null();
  return this->pDeviceRenderAreas.Value().As<Napi::Array>();
}void _VkDeviceGroupRenderPassBeginInfoKHR::SetpDeviceRenderAreas(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDeviceRenderAreas.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDeviceRenderAreas.Reset();
      this->instance.pDeviceRenderAreas = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDeviceRenderAreas = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkDeviceGroupRenderPassBeginInfoKHR ## **/

/** ## BEGIN VkDeviceGroupRenderPassBeginInfo ## **/

Napi::FunctionReference _VkDeviceGroupRenderPassBeginInfo::constructor;

_VkDeviceGroupRenderPassBeginInfo::_VkDeviceGroupRenderPassBeginInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGroupRenderPassBeginInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    vpDeviceRenderAreas = new std::vector<VkRect2D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceMask");
      Napi::String sAccess3 = Napi::String::New(env, "deviceRenderAreaCount");
      Napi::String sAccess4 = Napi::String::New(env, "pDeviceRenderAreas");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceMask(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdeviceRenderAreaCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpDeviceRenderAreas(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDeviceGroupRenderPassBeginInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGroupRenderPassBeginInfo::~_VkDeviceGroupRenderPassBeginInfo() {
  
  
  pNext.Reset();
  
  
  
  vpDeviceRenderAreas->clear();
  delete vpDeviceRenderAreas;
  
  pDeviceRenderAreas.Reset();
  
}

Napi::Object _VkDeviceGroupRenderPassBeginInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGroupRenderPassBeginInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGroupRenderPassBeginInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGroupRenderPassBeginInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGroupRenderPassBeginInfo::GetsType,
    &_VkDeviceGroupRenderPassBeginInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGroupRenderPassBeginInfo::GetpNext,
    &_VkDeviceGroupRenderPassBeginInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkDeviceGroupRenderPassBeginInfo::GetdeviceMask,
    &_VkDeviceGroupRenderPassBeginInfo::SetdeviceMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceRenderAreaCount",
    &_VkDeviceGroupRenderPassBeginInfo::GetdeviceRenderAreaCount,
    &_VkDeviceGroupRenderPassBeginInfo::SetdeviceRenderAreaCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceRenderAreas",
    &_VkDeviceGroupRenderPassBeginInfo::GetpDeviceRenderAreas,
    &_VkDeviceGroupRenderPassBeginInfo::SetpDeviceRenderAreas,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGroupRenderPassBeginInfo", func);
  return exports;
}

Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfo *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfo *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfo *)0)->deviceRenderAreaCount));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfo *)0)->deviceRenderAreaCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGroupRenderPassBeginInfo *)0)->pDeviceRenderAreas));
    uint32_t byteLength = sizeof(((VkDeviceGroupRenderPassBeginInfo *)0)->pDeviceRenderAreas);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGroupRenderPassBeginInfo::flush() {
  _VkDeviceGroupRenderPassBeginInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pDeviceRenderAreas.IsEmpty())) {
    Napi::Value value = self->pDeviceRenderAreas.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.deviceRenderAreaCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRect2D>* data = this->vpDeviceRenderAreas;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRect2D::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDeviceRenderAreas = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGroupRenderPassBeginInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGroupRenderPassBeginInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGroupRenderPassBeginInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pNext", "[object Object]");
  
    return;
  }
}// deviceMask
Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkDeviceGroupRenderPassBeginInfo::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.deviceMask", "Number");
  
    return;
  }
}// deviceRenderAreaCount
Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetdeviceRenderAreaCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceRenderAreaCount);
}void _VkDeviceGroupRenderPassBeginInfo::SetdeviceRenderAreaCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceRenderAreaCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.deviceRenderAreaCount", "Number");
  
    return;
  }
}// pDeviceRenderAreas
Napi::Value _VkDeviceGroupRenderPassBeginInfo::GetpDeviceRenderAreas(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceRenderAreas.IsEmpty()) return env.Null();
  return this->pDeviceRenderAreas.Value().As<Napi::Array>();
}void _VkDeviceGroupRenderPassBeginInfo::SetpDeviceRenderAreas(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDeviceRenderAreas.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDeviceRenderAreas.Reset();
      this->instance.pDeviceRenderAreas = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDeviceRenderAreas = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkDeviceGroupRenderPassBeginInfo ## **/

/** ## BEGIN VkBindImageMemoryDeviceGroupInfoKHR ## **/

Napi::FunctionReference _VkBindImageMemoryDeviceGroupInfoKHR::constructor;

_VkBindImageMemoryDeviceGroupInfoKHR::_VkBindImageMemoryDeviceGroupInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImageMemoryDeviceGroupInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR;
    vpSplitInstanceBindRegions = new std::vector<VkRect2D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceIndexCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDeviceIndices");
      Napi::String sAccess4 = Napi::String::New(env, "splitInstanceBindRegionCount");
      Napi::String sAccess5 = Napi::String::New(env, "pSplitInstanceBindRegions");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceIndexCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDeviceIndices(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsplitInstanceBindRegionCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpSplitInstanceBindRegions(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkBindImageMemoryDeviceGroupInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImageMemoryDeviceGroupInfoKHR::~_VkBindImageMemoryDeviceGroupInfoKHR() {
  
  
  pNext.Reset();
  
  
  pDeviceIndices.Reset();
  
  
  vpSplitInstanceBindRegions->clear();
  delete vpSplitInstanceBindRegions;
  
  pSplitInstanceBindRegions.Reset();
  
}

Napi::Object _VkBindImageMemoryDeviceGroupInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImageMemoryDeviceGroupInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImageMemoryDeviceGroupInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImageMemoryDeviceGroupInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImageMemoryDeviceGroupInfoKHR::GetsType,
    &_VkBindImageMemoryDeviceGroupInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImageMemoryDeviceGroupInfoKHR::GetpNext,
    &_VkBindImageMemoryDeviceGroupInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceIndexCount",
    &_VkBindImageMemoryDeviceGroupInfoKHR::GetdeviceIndexCount,
    &_VkBindImageMemoryDeviceGroupInfoKHR::SetdeviceIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceIndices",
    &_VkBindImageMemoryDeviceGroupInfoKHR::GetpDeviceIndices,
    &_VkBindImageMemoryDeviceGroupInfoKHR::SetpDeviceIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "splitInstanceBindRegionCount",
    &_VkBindImageMemoryDeviceGroupInfoKHR::GetsplitInstanceBindRegionCount,
    &_VkBindImageMemoryDeviceGroupInfoKHR::SetsplitInstanceBindRegionCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSplitInstanceBindRegions",
    &_VkBindImageMemoryDeviceGroupInfoKHR::GetpSplitInstanceBindRegions,
    &_VkBindImageMemoryDeviceGroupInfoKHR::SetpSplitInstanceBindRegions,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImageMemoryDeviceGroupInfoKHR", func);
  return exports;
}

Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->deviceIndexCount));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->deviceIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->pDeviceIndices));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->pDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->splitInstanceBindRegionCount));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->splitInstanceBindRegionCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->pSplitInstanceBindRegions));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfoKHR *)0)->pSplitInstanceBindRegions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImageMemoryDeviceGroupInfoKHR::flush() {
  _VkBindImageMemoryDeviceGroupInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pSplitInstanceBindRegions.IsEmpty())) {
    Napi::Value value = self->pSplitInstanceBindRegions.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.splitInstanceBindRegionCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRect2D>* data = this->vpSplitInstanceBindRegions;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRect2D::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSplitInstanceBindRegions = data->data();
  }
  return true;
}

// sType
Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImageMemoryDeviceGroupInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImageMemoryDeviceGroupInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindImageMemoryDeviceGroupInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// deviceIndexCount
Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetdeviceIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceIndexCount);
}void _VkBindImageMemoryDeviceGroupInfoKHR::SetdeviceIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetpDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceIndices.IsEmpty()) return env.Null();
  return this->pDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkBindImageMemoryDeviceGroupInfoKHR::SetpDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pDeviceIndices = nullptr;
  }
}// splitInstanceBindRegionCount
Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetsplitInstanceBindRegionCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.splitInstanceBindRegionCount);
}void _VkBindImageMemoryDeviceGroupInfoKHR::SetsplitInstanceBindRegionCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.splitInstanceBindRegionCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.splitInstanceBindRegionCount", "Number");
  
    return;
  }
}// pSplitInstanceBindRegions
Napi::Value _VkBindImageMemoryDeviceGroupInfoKHR::GetpSplitInstanceBindRegions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSplitInstanceBindRegions.IsEmpty()) return env.Null();
  return this->pSplitInstanceBindRegions.Value().As<Napi::Array>();
}void _VkBindImageMemoryDeviceGroupInfoKHR::SetpSplitInstanceBindRegions(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSplitInstanceBindRegions.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSplitInstanceBindRegions.Reset();
      this->instance.pSplitInstanceBindRegions = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSplitInstanceBindRegions = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkBindImageMemoryDeviceGroupInfoKHR ## **/

/** ## BEGIN VkBindImageMemoryDeviceGroupInfo ## **/

Napi::FunctionReference _VkBindImageMemoryDeviceGroupInfo::constructor;

_VkBindImageMemoryDeviceGroupInfo::_VkBindImageMemoryDeviceGroupInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImageMemoryDeviceGroupInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    vpSplitInstanceBindRegions = new std::vector<VkRect2D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceIndexCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDeviceIndices");
      Napi::String sAccess4 = Napi::String::New(env, "splitInstanceBindRegionCount");
      Napi::String sAccess5 = Napi::String::New(env, "pSplitInstanceBindRegions");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceIndexCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDeviceIndices(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsplitInstanceBindRegionCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpSplitInstanceBindRegions(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkBindImageMemoryDeviceGroupInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImageMemoryDeviceGroupInfo::~_VkBindImageMemoryDeviceGroupInfo() {
  
  
  pNext.Reset();
  
  
  pDeviceIndices.Reset();
  
  
  vpSplitInstanceBindRegions->clear();
  delete vpSplitInstanceBindRegions;
  
  pSplitInstanceBindRegions.Reset();
  
}

Napi::Object _VkBindImageMemoryDeviceGroupInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImageMemoryDeviceGroupInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImageMemoryDeviceGroupInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImageMemoryDeviceGroupInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImageMemoryDeviceGroupInfo::GetsType,
    &_VkBindImageMemoryDeviceGroupInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImageMemoryDeviceGroupInfo::GetpNext,
    &_VkBindImageMemoryDeviceGroupInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceIndexCount",
    &_VkBindImageMemoryDeviceGroupInfo::GetdeviceIndexCount,
    &_VkBindImageMemoryDeviceGroupInfo::SetdeviceIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceIndices",
    &_VkBindImageMemoryDeviceGroupInfo::GetpDeviceIndices,
    &_VkBindImageMemoryDeviceGroupInfo::SetpDeviceIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "splitInstanceBindRegionCount",
    &_VkBindImageMemoryDeviceGroupInfo::GetsplitInstanceBindRegionCount,
    &_VkBindImageMemoryDeviceGroupInfo::SetsplitInstanceBindRegionCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSplitInstanceBindRegions",
    &_VkBindImageMemoryDeviceGroupInfo::GetpSplitInstanceBindRegions,
    &_VkBindImageMemoryDeviceGroupInfo::SetpSplitInstanceBindRegions,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImageMemoryDeviceGroupInfo", func);
  return exports;
}

Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfo *)0)->deviceIndexCount));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfo *)0)->deviceIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfo *)0)->pDeviceIndices));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfo *)0)->pDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfo *)0)->splitInstanceBindRegionCount));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfo *)0)->splitInstanceBindRegionCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryDeviceGroupInfo *)0)->pSplitInstanceBindRegions));
    uint32_t byteLength = sizeof(((VkBindImageMemoryDeviceGroupInfo *)0)->pSplitInstanceBindRegions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImageMemoryDeviceGroupInfo::flush() {
  _VkBindImageMemoryDeviceGroupInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pSplitInstanceBindRegions.IsEmpty())) {
    Napi::Value value = self->pSplitInstanceBindRegions.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.splitInstanceBindRegionCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRect2D>* data = this->vpSplitInstanceBindRegions;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRect2D::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSplitInstanceBindRegions = data->data();
  }
  return true;
}

// sType
Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImageMemoryDeviceGroupInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImageMemoryDeviceGroupInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindImageMemoryDeviceGroupInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pNext", "[object Object]");
  
    return;
  }
}// deviceIndexCount
Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetdeviceIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceIndexCount);
}void _VkBindImageMemoryDeviceGroupInfo::SetdeviceIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetpDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceIndices.IsEmpty()) return env.Null();
  return this->pDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkBindImageMemoryDeviceGroupInfo::SetpDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pDeviceIndices = nullptr;
  }
}// splitInstanceBindRegionCount
Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetsplitInstanceBindRegionCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.splitInstanceBindRegionCount);
}void _VkBindImageMemoryDeviceGroupInfo::SetsplitInstanceBindRegionCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.splitInstanceBindRegionCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.splitInstanceBindRegionCount", "Number");
  
    return;
  }
}// pSplitInstanceBindRegions
Napi::Value _VkBindImageMemoryDeviceGroupInfo::GetpSplitInstanceBindRegions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSplitInstanceBindRegions.IsEmpty()) return env.Null();
  return this->pSplitInstanceBindRegions.Value().As<Napi::Array>();
}void _VkBindImageMemoryDeviceGroupInfo::SetpSplitInstanceBindRegions(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSplitInstanceBindRegions.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSplitInstanceBindRegions.Reset();
      this->instance.pSplitInstanceBindRegions = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSplitInstanceBindRegions = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkBindImageMemoryDeviceGroupInfo ## **/

/** ## BEGIN VkBindImageMemoryInfoKHR ## **/

Napi::FunctionReference _VkBindImageMemoryInfoKHR::constructor;

_VkBindImageMemoryInfoKHR::_VkBindImageMemoryInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImageMemoryInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      Napi::String sAccess3 = Napi::String::New(env, "memory");
      Napi::String sAccess4 = Napi::String::New(env, "memoryOffset");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setmemory(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmemoryOffset(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkBindImageMemoryInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImageMemoryInfoKHR::~_VkBindImageMemoryInfoKHR() {
  
  
  pNext.Reset();
  
  image.Reset();
  
  memory.Reset();
  
  
}

Napi::Object _VkBindImageMemoryInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImageMemoryInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImageMemoryInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImageMemoryInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImageMemoryInfoKHR::GetsType,
    &_VkBindImageMemoryInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImageMemoryInfoKHR::GetpNext,
    &_VkBindImageMemoryInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkBindImageMemoryInfoKHR::Getimage,
    &_VkBindImageMemoryInfoKHR::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkBindImageMemoryInfoKHR::Getmemory,
    &_VkBindImageMemoryInfoKHR::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryOffset",
    &_VkBindImageMemoryInfoKHR::GetmemoryOffset,
    &_VkBindImageMemoryInfoKHR::SetmemoryOffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImageMemoryInfoKHR", func);
  return exports;
}

Napi::Value _VkBindImageMemoryInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImageMemoryInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfoKHR *)0)->image));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfoKHR *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfoKHR *)0)->memory));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfoKHR *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfoKHR *)0)->memoryOffset));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfoKHR *)0)->memoryOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImageMemoryInfoKHR::flush() {
  _VkBindImageMemoryInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO) {
      _VkBindImageMemoryDeviceGroupInfo* structExt = Napi::ObjectWrap<_VkBindImageMemoryDeviceGroupInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR) {
      _VkBindImageMemorySwapchainInfoKHR* structExt = Napi::ObjectWrap<_VkBindImageMemorySwapchainInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO) {
      _VkBindImagePlaneMemoryInfo* structExt = Napi::ObjectWrap<_VkBindImagePlaneMemoryInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkBindImageMemoryInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImageMemoryInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImageMemoryInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImageMemoryInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO &&
        sType != VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkBindImageMemoryInfoKHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkBindImageMemoryInfoKHR::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkBindImageMemoryInfoKHR::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.image", "[object VkImage]");
  
    return;
  }
}// memory
Napi::Value _VkBindImageMemoryInfoKHR::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkBindImageMemoryInfoKHR::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
Napi::Value _VkBindImageMemoryInfoKHR::GetmemoryOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryOffset);
}void _VkBindImageMemoryInfoKHR::SetmemoryOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfoKHR.memoryOffset", "Number");
  
    return;
  }
}
/** ## END VkBindImageMemoryInfoKHR ## **/

/** ## BEGIN VkBindImageMemoryInfo ## **/

Napi::FunctionReference _VkBindImageMemoryInfo::constructor;

_VkBindImageMemoryInfo::_VkBindImageMemoryInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindImageMemoryInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      Napi::String sAccess3 = Napi::String::New(env, "memory");
      Napi::String sAccess4 = Napi::String::New(env, "memoryOffset");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setmemory(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmemoryOffset(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkBindImageMemoryInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindImageMemoryInfo::~_VkBindImageMemoryInfo() {
  
  
  pNext.Reset();
  
  image.Reset();
  
  memory.Reset();
  
  
}

Napi::Object _VkBindImageMemoryInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindImageMemoryInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindImageMemoryInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindImageMemoryInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindImageMemoryInfo::GetsType,
    &_VkBindImageMemoryInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindImageMemoryInfo::GetpNext,
    &_VkBindImageMemoryInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkBindImageMemoryInfo::Getimage,
    &_VkBindImageMemoryInfo::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkBindImageMemoryInfo::Getmemory,
    &_VkBindImageMemoryInfo::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryOffset",
    &_VkBindImageMemoryInfo::GetmemoryOffset,
    &_VkBindImageMemoryInfo::SetmemoryOffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindImageMemoryInfo", func);
  return exports;
}

Napi::Value _VkBindImageMemoryInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindImageMemoryInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfo *)0)->image));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfo *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfo *)0)->memory));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfo *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindImageMemoryInfo *)0)->memoryOffset));
    uint32_t byteLength = sizeof(((VkBindImageMemoryInfo *)0)->memoryOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindImageMemoryInfo::flush() {
  _VkBindImageMemoryInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO) {
      _VkBindImageMemoryDeviceGroupInfo* structExt = Napi::ObjectWrap<_VkBindImageMemoryDeviceGroupInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR) {
      _VkBindImageMemorySwapchainInfoKHR* structExt = Napi::ObjectWrap<_VkBindImageMemorySwapchainInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO) {
      _VkBindImagePlaneMemoryInfo* structExt = Napi::ObjectWrap<_VkBindImagePlaneMemoryInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkBindImageMemoryInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindImageMemoryInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindImageMemoryInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindImageMemoryInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO &&
        sType != VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkBindImageMemoryInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkBindImageMemoryInfo::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkBindImageMemoryInfo::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.image", "[object VkImage]");
  
    return;
  }
}// memory
Napi::Value _VkBindImageMemoryInfo::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkBindImageMemoryInfo::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
Napi::Value _VkBindImageMemoryInfo::GetmemoryOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryOffset);
}void _VkBindImageMemoryInfo::SetmemoryOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindImageMemoryInfo.memoryOffset", "Number");
  
    return;
  }
}
/** ## END VkBindImageMemoryInfo ## **/

/** ## BEGIN VkBindBufferMemoryDeviceGroupInfoKHR ## **/

Napi::FunctionReference _VkBindBufferMemoryDeviceGroupInfoKHR::constructor;

_VkBindBufferMemoryDeviceGroupInfoKHR::_VkBindBufferMemoryDeviceGroupInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindBufferMemoryDeviceGroupInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceIndexCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDeviceIndices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceIndexCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDeviceIndices(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkBindBufferMemoryDeviceGroupInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindBufferMemoryDeviceGroupInfoKHR::~_VkBindBufferMemoryDeviceGroupInfoKHR() {
  
  
  pNext.Reset();
  
  
  pDeviceIndices.Reset();
  
}

Napi::Object _VkBindBufferMemoryDeviceGroupInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindBufferMemoryDeviceGroupInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindBufferMemoryDeviceGroupInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindBufferMemoryDeviceGroupInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindBufferMemoryDeviceGroupInfoKHR::GetsType,
    &_VkBindBufferMemoryDeviceGroupInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindBufferMemoryDeviceGroupInfoKHR::GetpNext,
    &_VkBindBufferMemoryDeviceGroupInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceIndexCount",
    &_VkBindBufferMemoryDeviceGroupInfoKHR::GetdeviceIndexCount,
    &_VkBindBufferMemoryDeviceGroupInfoKHR::SetdeviceIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceIndices",
    &_VkBindBufferMemoryDeviceGroupInfoKHR::GetpDeviceIndices,
    &_VkBindBufferMemoryDeviceGroupInfoKHR::SetpDeviceIndices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindBufferMemoryDeviceGroupInfoKHR", func);
  return exports;
}

Napi::Value _VkBindBufferMemoryDeviceGroupInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindBufferMemoryDeviceGroupInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->deviceIndexCount));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->deviceIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->pDeviceIndices));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfoKHR *)0)->pDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindBufferMemoryDeviceGroupInfoKHR::flush() {
  _VkBindBufferMemoryDeviceGroupInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBindBufferMemoryDeviceGroupInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindBufferMemoryDeviceGroupInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindBufferMemoryDeviceGroupInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindBufferMemoryDeviceGroupInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindBufferMemoryDeviceGroupInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// deviceIndexCount
Napi::Value _VkBindBufferMemoryDeviceGroupInfoKHR::GetdeviceIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceIndexCount);
}void _VkBindBufferMemoryDeviceGroupInfoKHR::SetdeviceIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfoKHR.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
Napi::Value _VkBindBufferMemoryDeviceGroupInfoKHR::GetpDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceIndices.IsEmpty()) return env.Null();
  return this->pDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkBindBufferMemoryDeviceGroupInfoKHR::SetpDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfoKHR.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfoKHR.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pDeviceIndices = nullptr;
  }
}
/** ## END VkBindBufferMemoryDeviceGroupInfoKHR ## **/

/** ## BEGIN VkBindBufferMemoryDeviceGroupInfo ## **/

Napi::FunctionReference _VkBindBufferMemoryDeviceGroupInfo::constructor;

_VkBindBufferMemoryDeviceGroupInfo::_VkBindBufferMemoryDeviceGroupInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindBufferMemoryDeviceGroupInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceIndexCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDeviceIndices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceIndexCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDeviceIndices(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkBindBufferMemoryDeviceGroupInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindBufferMemoryDeviceGroupInfo::~_VkBindBufferMemoryDeviceGroupInfo() {
  
  
  pNext.Reset();
  
  
  pDeviceIndices.Reset();
  
}

Napi::Object _VkBindBufferMemoryDeviceGroupInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindBufferMemoryDeviceGroupInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindBufferMemoryDeviceGroupInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindBufferMemoryDeviceGroupInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindBufferMemoryDeviceGroupInfo::GetsType,
    &_VkBindBufferMemoryDeviceGroupInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindBufferMemoryDeviceGroupInfo::GetpNext,
    &_VkBindBufferMemoryDeviceGroupInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceIndexCount",
    &_VkBindBufferMemoryDeviceGroupInfo::GetdeviceIndexCount,
    &_VkBindBufferMemoryDeviceGroupInfo::SetdeviceIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDeviceIndices",
    &_VkBindBufferMemoryDeviceGroupInfo::GetpDeviceIndices,
    &_VkBindBufferMemoryDeviceGroupInfo::SetpDeviceIndices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindBufferMemoryDeviceGroupInfo", func);
  return exports;
}

Napi::Value _VkBindBufferMemoryDeviceGroupInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindBufferMemoryDeviceGroupInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfo *)0)->deviceIndexCount));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfo *)0)->deviceIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryDeviceGroupInfo *)0)->pDeviceIndices));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryDeviceGroupInfo *)0)->pDeviceIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindBufferMemoryDeviceGroupInfo::flush() {
  _VkBindBufferMemoryDeviceGroupInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBindBufferMemoryDeviceGroupInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindBufferMemoryDeviceGroupInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindBufferMemoryDeviceGroupInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindBufferMemoryDeviceGroupInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBindBufferMemoryDeviceGroupInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.pNext", "[object Object]");
  
    return;
  }
}// deviceIndexCount
Napi::Value _VkBindBufferMemoryDeviceGroupInfo::GetdeviceIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceIndexCount);
}void _VkBindBufferMemoryDeviceGroupInfo::SetdeviceIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
Napi::Value _VkBindBufferMemoryDeviceGroupInfo::GetpDeviceIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDeviceIndices.IsEmpty()) return env.Null();
  return this->pDeviceIndices.Value().As<Napi::TypedArray>();
}void _VkBindBufferMemoryDeviceGroupInfo::SetpDeviceIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pDeviceIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDeviceIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDeviceIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pDeviceIndices = nullptr;
  }
}
/** ## END VkBindBufferMemoryDeviceGroupInfo ## **/

/** ## BEGIN VkBindBufferMemoryInfoKHR ## **/

Napi::FunctionReference _VkBindBufferMemoryInfoKHR::constructor;

_VkBindBufferMemoryInfoKHR::_VkBindBufferMemoryInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindBufferMemoryInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      Napi::String sAccess3 = Napi::String::New(env, "memory");
      Napi::String sAccess4 = Napi::String::New(env, "memoryOffset");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setmemory(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmemoryOffset(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkBindBufferMemoryInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindBufferMemoryInfoKHR::~_VkBindBufferMemoryInfoKHR() {
  
  
  pNext.Reset();
  
  buffer.Reset();
  
  memory.Reset();
  
  
}

Napi::Object _VkBindBufferMemoryInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindBufferMemoryInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindBufferMemoryInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindBufferMemoryInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindBufferMemoryInfoKHR::GetsType,
    &_VkBindBufferMemoryInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindBufferMemoryInfoKHR::GetpNext,
    &_VkBindBufferMemoryInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkBindBufferMemoryInfoKHR::Getbuffer,
    &_VkBindBufferMemoryInfoKHR::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkBindBufferMemoryInfoKHR::Getmemory,
    &_VkBindBufferMemoryInfoKHR::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryOffset",
    &_VkBindBufferMemoryInfoKHR::GetmemoryOffset,
    &_VkBindBufferMemoryInfoKHR::SetmemoryOffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindBufferMemoryInfoKHR", func);
  return exports;
}

Napi::Value _VkBindBufferMemoryInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindBufferMemoryInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfoKHR *)0)->buffer));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfoKHR *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfoKHR *)0)->memory));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfoKHR *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfoKHR *)0)->memoryOffset));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfoKHR *)0)->memoryOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindBufferMemoryInfoKHR::flush() {
  _VkBindBufferMemoryInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO) {
      _VkBindBufferMemoryDeviceGroupInfo* structExt = Napi::ObjectWrap<_VkBindBufferMemoryDeviceGroupInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkBindBufferMemoryInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindBufferMemoryInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindBufferMemoryInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindBufferMemoryInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// buffer
Napi::Value _VkBindBufferMemoryInfoKHR::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkBindBufferMemoryInfoKHR::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.buffer", "[object VkBuffer]");
  
    return;
  }
}// memory
Napi::Value _VkBindBufferMemoryInfoKHR::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkBindBufferMemoryInfoKHR::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
Napi::Value _VkBindBufferMemoryInfoKHR::GetmemoryOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryOffset);
}void _VkBindBufferMemoryInfoKHR::SetmemoryOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfoKHR.memoryOffset", "Number");
  
    return;
  }
}
/** ## END VkBindBufferMemoryInfoKHR ## **/

/** ## BEGIN VkBindBufferMemoryInfo ## **/

Napi::FunctionReference _VkBindBufferMemoryInfo::constructor;

_VkBindBufferMemoryInfo::_VkBindBufferMemoryInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindBufferMemoryInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      Napi::String sAccess3 = Napi::String::New(env, "memory");
      Napi::String sAccess4 = Napi::String::New(env, "memoryOffset");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setmemory(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmemoryOffset(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkBindBufferMemoryInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindBufferMemoryInfo::~_VkBindBufferMemoryInfo() {
  
  
  pNext.Reset();
  
  buffer.Reset();
  
  memory.Reset();
  
  
}

Napi::Object _VkBindBufferMemoryInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindBufferMemoryInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindBufferMemoryInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindBufferMemoryInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindBufferMemoryInfo::GetsType,
    &_VkBindBufferMemoryInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindBufferMemoryInfo::GetpNext,
    &_VkBindBufferMemoryInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkBindBufferMemoryInfo::Getbuffer,
    &_VkBindBufferMemoryInfo::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkBindBufferMemoryInfo::Getmemory,
    &_VkBindBufferMemoryInfo::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryOffset",
    &_VkBindBufferMemoryInfo::GetmemoryOffset,
    &_VkBindBufferMemoryInfo::SetmemoryOffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindBufferMemoryInfo", func);
  return exports;
}

Napi::Value _VkBindBufferMemoryInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindBufferMemoryInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfo *)0)->buffer));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfo *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfo *)0)->memory));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfo *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindBufferMemoryInfo *)0)->memoryOffset));
    uint32_t byteLength = sizeof(((VkBindBufferMemoryInfo *)0)->memoryOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindBufferMemoryInfo::flush() {
  _VkBindBufferMemoryInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO) {
      _VkBindBufferMemoryDeviceGroupInfo* structExt = Napi::ObjectWrap<_VkBindBufferMemoryDeviceGroupInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkBindBufferMemoryInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindBufferMemoryInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindBufferMemoryInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindBufferMemoryInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkBindBufferMemoryInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.pNext", "[object Object]");
  
    return;
  }
}// buffer
Napi::Value _VkBindBufferMemoryInfo::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkBindBufferMemoryInfo::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// memory
Napi::Value _VkBindBufferMemoryInfo::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkBindBufferMemoryInfo::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
Napi::Value _VkBindBufferMemoryInfo::GetmemoryOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryOffset);
}void _VkBindBufferMemoryInfo::SetmemoryOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindBufferMemoryInfo.memoryOffset", "Number");
  
    return;
  }
}
/** ## END VkBindBufferMemoryInfo ## **/

/** ## BEGIN VkMemoryAllocateFlagsInfoKHR ## **/

Napi::FunctionReference _VkMemoryAllocateFlagsInfoKHR::constructor;

_VkMemoryAllocateFlagsInfoKHR::_VkMemoryAllocateFlagsInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryAllocateFlagsInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "deviceMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdeviceMask(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryAllocateFlagsInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryAllocateFlagsInfoKHR::~_VkMemoryAllocateFlagsInfoKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkMemoryAllocateFlagsInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryAllocateFlagsInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryAllocateFlagsInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryAllocateFlagsInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryAllocateFlagsInfoKHR::GetsType,
    &_VkMemoryAllocateFlagsInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryAllocateFlagsInfoKHR::GetpNext,
    &_VkMemoryAllocateFlagsInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkMemoryAllocateFlagsInfoKHR::Getflags,
    &_VkMemoryAllocateFlagsInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkMemoryAllocateFlagsInfoKHR::GetdeviceMask,
    &_VkMemoryAllocateFlagsInfoKHR::SetdeviceMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryAllocateFlagsInfoKHR", func);
  return exports;
}

Napi::Value _VkMemoryAllocateFlagsInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryAllocateFlagsInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfoKHR *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfoKHR *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryAllocateFlagsInfoKHR::flush() {
  _VkMemoryAllocateFlagsInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryAllocateFlagsInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryAllocateFlagsInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryAllocateFlagsInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryAllocateFlagsInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryAllocateFlagsInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkMemoryAllocateFlagsInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkMemoryAllocateFlagsInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkMemoryAllocateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfoKHR.flags", "Number");
  
    return;
  }
}// deviceMask
Napi::Value _VkMemoryAllocateFlagsInfoKHR::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkMemoryAllocateFlagsInfoKHR::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfoKHR.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkMemoryAllocateFlagsInfoKHR ## **/

/** ## BEGIN VkMemoryAllocateFlagsInfo ## **/

Napi::FunctionReference _VkMemoryAllocateFlagsInfo::constructor;

_VkMemoryAllocateFlagsInfo::_VkMemoryAllocateFlagsInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryAllocateFlagsInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "deviceMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdeviceMask(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryAllocateFlagsInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryAllocateFlagsInfo::~_VkMemoryAllocateFlagsInfo() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkMemoryAllocateFlagsInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryAllocateFlagsInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryAllocateFlagsInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryAllocateFlagsInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryAllocateFlagsInfo::GetsType,
    &_VkMemoryAllocateFlagsInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryAllocateFlagsInfo::GetpNext,
    &_VkMemoryAllocateFlagsInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkMemoryAllocateFlagsInfo::Getflags,
    &_VkMemoryAllocateFlagsInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceMask",
    &_VkMemoryAllocateFlagsInfo::GetdeviceMask,
    &_VkMemoryAllocateFlagsInfo::SetdeviceMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryAllocateFlagsInfo", func);
  return exports;
}

Napi::Value _VkMemoryAllocateFlagsInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryAllocateFlagsInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateFlagsInfo *)0)->deviceMask));
    uint32_t byteLength = sizeof(((VkMemoryAllocateFlagsInfo *)0)->deviceMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryAllocateFlagsInfo::flush() {
  _VkMemoryAllocateFlagsInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryAllocateFlagsInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryAllocateFlagsInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryAllocateFlagsInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryAllocateFlagsInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryAllocateFlagsInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkMemoryAllocateFlagsInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkMemoryAllocateFlagsInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkMemoryAllocateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfo.flags", "Number");
  
    return;
  }
}// deviceMask
Napi::Value _VkMemoryAllocateFlagsInfo::GetdeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceMask);
}void _VkMemoryAllocateFlagsInfo::SetdeviceMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateFlagsInfo.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkMemoryAllocateFlagsInfo ## **/

/** ## BEGIN VkPhysicalDeviceGroupPropertiesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceGroupPropertiesKHR::constructor;

_VkPhysicalDeviceGroupPropertiesKHR::_VkPhysicalDeviceGroupPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceGroupPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR;
    vphysicalDevices = new std::vector<VkPhysicalDevice>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceGroupPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceGroupPropertiesKHR::~_VkPhysicalDeviceGroupPropertiesKHR() {
  
  
  pNext.Reset();
  
  
  vphysicalDevices->clear();
  delete vphysicalDevices;
  
  physicalDevices.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceGroupPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceGroupPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceGroupPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceGroupPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceGroupPropertiesKHR::GetsType,
    &_VkPhysicalDeviceGroupPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceGroupPropertiesKHR::GetpNext,
    &_VkPhysicalDeviceGroupPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDeviceCount",
    &_VkPhysicalDeviceGroupPropertiesKHR::GetphysicalDeviceCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDevices",
    &_VkPhysicalDeviceGroupPropertiesKHR::GetphysicalDevices,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "subsetAllocation",
    &_VkPhysicalDeviceGroupPropertiesKHR::GetsubsetAllocation,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceGroupPropertiesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupPropertiesKHR *)0)->physicalDeviceCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupPropertiesKHR *)0)->physicalDeviceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupPropertiesKHR *)0)->physicalDevices));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupPropertiesKHR *)0)->physicalDevices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupPropertiesKHR *)0)->subsetAllocation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupPropertiesKHR *)0)->subsetAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceGroupPropertiesKHR::flush() {
  _VkPhysicalDeviceGroupPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->physicalDevices.IsEmpty())) {
    Napi::Value value = self->physicalDevices.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceGroupPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceGroupPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceGroupPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceGroupPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceGroupPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceGroupPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// physicalDeviceCount
Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetphysicalDeviceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.physicalDeviceCount);
}// physicalDevices
Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetphysicalDevices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->physicalDevices.IsEmpty()) return env.Null();
  return this->physicalDevices.Value().As<Napi::Array>();
}// subsetAllocation
Napi::Value _VkPhysicalDeviceGroupPropertiesKHR::GetsubsetAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subsetAllocation);
}
/** ## END VkPhysicalDeviceGroupPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceGroupProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceGroupProperties::constructor;

_VkPhysicalDeviceGroupProperties::_VkPhysicalDeviceGroupProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceGroupProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
    vphysicalDevices = new std::vector<VkPhysicalDevice>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceGroupProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceGroupProperties::~_VkPhysicalDeviceGroupProperties() {
  
  
  pNext.Reset();
  
  
  vphysicalDevices->clear();
  delete vphysicalDevices;
  
  physicalDevices.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceGroupProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceGroupProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceGroupProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceGroupProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceGroupProperties::GetsType,
    &_VkPhysicalDeviceGroupProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceGroupProperties::GetpNext,
    &_VkPhysicalDeviceGroupProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDeviceCount",
    &_VkPhysicalDeviceGroupProperties::GetphysicalDeviceCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDevices",
    &_VkPhysicalDeviceGroupProperties::GetphysicalDevices,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "subsetAllocation",
    &_VkPhysicalDeviceGroupProperties::GetsubsetAllocation,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceGroupProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceGroupProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceGroupProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupProperties *)0)->physicalDeviceCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupProperties *)0)->physicalDeviceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupProperties *)0)->physicalDevices));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupProperties *)0)->physicalDevices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceGroupProperties *)0)->subsetAllocation));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceGroupProperties *)0)->subsetAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceGroupProperties::flush() {
  _VkPhysicalDeviceGroupProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->physicalDevices.IsEmpty())) {
    Napi::Value value = self->physicalDevices.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceGroupProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceGroupProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceGroupProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceGroupProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceGroupProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceGroupProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceGroupProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceGroupProperties.pNext", "[object Object]");
  
    return;
  }
}// physicalDeviceCount
Napi::Value _VkPhysicalDeviceGroupProperties::GetphysicalDeviceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.physicalDeviceCount);
}// physicalDevices
Napi::Value _VkPhysicalDeviceGroupProperties::GetphysicalDevices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->physicalDevices.IsEmpty()) return env.Null();
  return this->physicalDevices.Value().As<Napi::Array>();
}// subsetAllocation
Napi::Value _VkPhysicalDeviceGroupProperties::GetsubsetAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subsetAllocation);
}
/** ## END VkPhysicalDeviceGroupProperties ## **/

/** ## BEGIN VkSwapchainCounterCreateInfoEXT ## **/

Napi::FunctionReference _VkSwapchainCounterCreateInfoEXT::constructor;

_VkSwapchainCounterCreateInfoEXT::_VkSwapchainCounterCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSwapchainCounterCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "surfaceCounters");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsurfaceCounters(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSwapchainCounterCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkSwapchainCounterCreateInfoEXT::~_VkSwapchainCounterCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSwapchainCounterCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSwapchainCounterCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSwapchainCounterCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSwapchainCounterCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSwapchainCounterCreateInfoEXT::GetsType,
    &_VkSwapchainCounterCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSwapchainCounterCreateInfoEXT::GetpNext,
    &_VkSwapchainCounterCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "surfaceCounters",
    &_VkSwapchainCounterCreateInfoEXT::GetsurfaceCounters,
    &_VkSwapchainCounterCreateInfoEXT::SetsurfaceCounters,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSwapchainCounterCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkSwapchainCounterCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSwapchainCounterCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCounterCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkSwapchainCounterCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCounterCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSwapchainCounterCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCounterCreateInfoEXT *)0)->surfaceCounters));
    uint32_t byteLength = sizeof(((VkSwapchainCounterCreateInfoEXT *)0)->surfaceCounters);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSwapchainCounterCreateInfoEXT::flush() {
  _VkSwapchainCounterCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSwapchainCounterCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSwapchainCounterCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCounterCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSwapchainCounterCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSwapchainCounterCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSwapchainCounterCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSwapchainCounterCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCounterCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// surfaceCounters
Napi::Value _VkSwapchainCounterCreateInfoEXT::GetsurfaceCounters(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.surfaceCounters);
}void _VkSwapchainCounterCreateInfoEXT::SetsurfaceCounters(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.surfaceCounters = static_cast<VkSurfaceCounterFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCounterCreateInfoEXT.surfaceCounters", "Number");
  
    return;
  }
}
/** ## END VkSwapchainCounterCreateInfoEXT ## **/

/** ## BEGIN VkDisplayEventInfoEXT ## **/

Napi::FunctionReference _VkDisplayEventInfoEXT::constructor;

_VkDisplayEventInfoEXT::_VkDisplayEventInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayEventInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "displayEvent");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdisplayEvent(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDisplayEventInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayEventInfoEXT::~_VkDisplayEventInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDisplayEventInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayEventInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayEventInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayEventInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayEventInfoEXT::GetsType,
    &_VkDisplayEventInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayEventInfoEXT::GetpNext,
    &_VkDisplayEventInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayEvent",
    &_VkDisplayEventInfoEXT::GetdisplayEvent,
    &_VkDisplayEventInfoEXT::SetdisplayEvent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayEventInfoEXT", func);
  return exports;
}

Napi::Value _VkDisplayEventInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayEventInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayEventInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayEventInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayEventInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayEventInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayEventInfoEXT *)0)->displayEvent));
    uint32_t byteLength = sizeof(((VkDisplayEventInfoEXT *)0)->displayEvent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayEventInfoEXT::flush() {
  _VkDisplayEventInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayEventInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayEventInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayEventInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayEventInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayEventInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayEventInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayEventInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayEventInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// displayEvent
Napi::Value _VkDisplayEventInfoEXT::GetdisplayEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.displayEvent);
}void _VkDisplayEventInfoEXT::SetdisplayEvent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.displayEvent = static_cast<VkDisplayEventTypeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayEventInfoEXT.displayEvent", "Number");
  
    return;
  }
}
/** ## END VkDisplayEventInfoEXT ## **/

/** ## BEGIN VkDeviceEventInfoEXT ## **/

Napi::FunctionReference _VkDeviceEventInfoEXT::constructor;

_VkDeviceEventInfoEXT::_VkDeviceEventInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceEventInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "deviceEvent");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdeviceEvent(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDeviceEventInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceEventInfoEXT::~_VkDeviceEventInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDeviceEventInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceEventInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceEventInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceEventInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceEventInfoEXT::GetsType,
    &_VkDeviceEventInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceEventInfoEXT::GetpNext,
    &_VkDeviceEventInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceEvent",
    &_VkDeviceEventInfoEXT::GetdeviceEvent,
    &_VkDeviceEventInfoEXT::SetdeviceEvent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceEventInfoEXT", func);
  return exports;
}

Napi::Value _VkDeviceEventInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceEventInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceEventInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceEventInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceEventInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceEventInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceEventInfoEXT *)0)->deviceEvent));
    uint32_t byteLength = sizeof(((VkDeviceEventInfoEXT *)0)->deviceEvent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceEventInfoEXT::flush() {
  _VkDeviceEventInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceEventInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceEventInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceEventInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceEventInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceEventInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceEventInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceEventInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceEventInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// deviceEvent
Napi::Value _VkDeviceEventInfoEXT::GetdeviceEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceEvent);
}void _VkDeviceEventInfoEXT::SetdeviceEvent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.deviceEvent = static_cast<VkDeviceEventTypeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceEventInfoEXT.deviceEvent", "Number");
  
    return;
  }
}
/** ## END VkDeviceEventInfoEXT ## **/

/** ## BEGIN VkDisplayPowerInfoEXT ## **/

Napi::FunctionReference _VkDisplayPowerInfoEXT::constructor;

_VkDisplayPowerInfoEXT::_VkDisplayPowerInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPowerInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "powerState");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpowerState(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDisplayPowerInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPowerInfoEXT::~_VkDisplayPowerInfoEXT() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDisplayPowerInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPowerInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPowerInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPowerInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayPowerInfoEXT::GetsType,
    &_VkDisplayPowerInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayPowerInfoEXT::GetpNext,
    &_VkDisplayPowerInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "powerState",
    &_VkDisplayPowerInfoEXT::GetpowerState,
    &_VkDisplayPowerInfoEXT::SetpowerState,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPowerInfoEXT", func);
  return exports;
}

Napi::Value _VkDisplayPowerInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPowerInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPowerInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayPowerInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPowerInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayPowerInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPowerInfoEXT *)0)->powerState));
    uint32_t byteLength = sizeof(((VkDisplayPowerInfoEXT *)0)->powerState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPowerInfoEXT::flush() {
  _VkDisplayPowerInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDisplayPowerInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayPowerInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPowerInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayPowerInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayPowerInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayPowerInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPowerInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPowerInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// powerState
Napi::Value _VkDisplayPowerInfoEXT::GetpowerState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.powerState);
}void _VkDisplayPowerInfoEXT::SetpowerState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.powerState = static_cast<VkDisplayPowerStateEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPowerInfoEXT.powerState", "Number");
  
    return;
  }
}
/** ## END VkDisplayPowerInfoEXT ## **/

/** ## BEGIN VkSurfaceCapabilities2EXT ## **/

Napi::FunctionReference _VkSurfaceCapabilities2EXT::constructor;

_VkSurfaceCapabilities2EXT::_VkSurfaceCapabilities2EXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSurfaceCapabilities2EXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSurfaceCapabilities2EXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkSurfaceCapabilities2EXT::~_VkSurfaceCapabilities2EXT() {
  
  
  pNext.Reset();
  
  
  
  currentExtent.Reset();
  
  minImageExtent.Reset();
  
  maxImageExtent.Reset();
  
  
  
  
  
  
  
}

Napi::Object _VkSurfaceCapabilities2EXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSurfaceCapabilities2EXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSurfaceCapabilities2EXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSurfaceCapabilities2EXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSurfaceCapabilities2EXT::GetsType,
    &_VkSurfaceCapabilities2EXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSurfaceCapabilities2EXT::GetpNext,
    &_VkSurfaceCapabilities2EXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "minImageCount",
    &_VkSurfaceCapabilities2EXT::GetminImageCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageCount",
    &_VkSurfaceCapabilities2EXT::GetmaxImageCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "currentExtent",
    &_VkSurfaceCapabilities2EXT::GetcurrentExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minImageExtent",
    &_VkSurfaceCapabilities2EXT::GetminImageExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageExtent",
    &_VkSurfaceCapabilities2EXT::GetmaxImageExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageArrayLayers",
    &_VkSurfaceCapabilities2EXT::GetmaxImageArrayLayers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedTransforms",
    &_VkSurfaceCapabilities2EXT::GetsupportedTransforms,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "currentTransform",
    &_VkSurfaceCapabilities2EXT::GetcurrentTransform,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedCompositeAlpha",
    &_VkSurfaceCapabilities2EXT::GetsupportedCompositeAlpha,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedUsageFlags",
    &_VkSurfaceCapabilities2EXT::GetsupportedUsageFlags,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedSurfaceCounters",
    &_VkSurfaceCapabilities2EXT::GetsupportedSurfaceCounters,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSurfaceCapabilities2EXT", func);
  return exports;
}

Napi::Value _VkSurfaceCapabilities2EXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSurfaceCapabilities2EXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->minImageCount));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->minImageCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->maxImageCount));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->maxImageCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->currentExtent));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->currentExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->minImageExtent));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->minImageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->maxImageExtent));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->maxImageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->maxImageArrayLayers));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->maxImageArrayLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->supportedTransforms));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->supportedTransforms);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->currentTransform));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->currentTransform);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->supportedCompositeAlpha));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->supportedCompositeAlpha);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->supportedUsageFlags));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->supportedUsageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilities2EXT *)0)->supportedSurfaceCounters));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilities2EXT *)0)->supportedSurfaceCounters);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSurfaceCapabilities2EXT::flush() {
  _VkSurfaceCapabilities2EXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->currentExtent.IsEmpty())) {
    Napi::Value value = self->currentExtent.Value();
    
  }if (!(self->minImageExtent.IsEmpty())) {
    Napi::Value value = self->minImageExtent.Value();
    
  }if (!(self->maxImageExtent.IsEmpty())) {
    Napi::Value value = self->maxImageExtent.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSurfaceCapabilities2EXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSurfaceCapabilities2EXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSurfaceCapabilities2EXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSurfaceCapabilities2EXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSurfaceCapabilities2EXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSurfaceCapabilities2EXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSurfaceCapabilities2EXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSurfaceCapabilities2EXT.pNext", "[object Object]");
  
    return;
  }
}// minImageCount
Napi::Value _VkSurfaceCapabilities2EXT::GetminImageCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minImageCount);
}// maxImageCount
Napi::Value _VkSurfaceCapabilities2EXT::GetmaxImageCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageCount);
}// currentExtent
Napi::Value _VkSurfaceCapabilities2EXT::GetcurrentExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->currentExtent.IsEmpty()) return env.Null();
  return this->currentExtent.Value().As<Napi::Object>();
}// minImageExtent
Napi::Value _VkSurfaceCapabilities2EXT::GetminImageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minImageExtent.IsEmpty()) return env.Null();
  return this->minImageExtent.Value().As<Napi::Object>();
}// maxImageExtent
Napi::Value _VkSurfaceCapabilities2EXT::GetmaxImageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxImageExtent.IsEmpty()) return env.Null();
  return this->maxImageExtent.Value().As<Napi::Object>();
}// maxImageArrayLayers
Napi::Value _VkSurfaceCapabilities2EXT::GetmaxImageArrayLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageArrayLayers);
}// supportedTransforms
Napi::Value _VkSurfaceCapabilities2EXT::GetsupportedTransforms(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedTransforms);
}// currentTransform
Napi::Value _VkSurfaceCapabilities2EXT::GetcurrentTransform(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.currentTransform);
}// supportedCompositeAlpha
Napi::Value _VkSurfaceCapabilities2EXT::GetsupportedCompositeAlpha(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedCompositeAlpha);
}// supportedUsageFlags
Napi::Value _VkSurfaceCapabilities2EXT::GetsupportedUsageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedUsageFlags);
}// supportedSurfaceCounters
Napi::Value _VkSurfaceCapabilities2EXT::GetsupportedSurfaceCounters(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedSurfaceCounters);
}
/** ## END VkSurfaceCapabilities2EXT ## **/

/** ## BEGIN VkRenderPassMultiviewCreateInfoKHR ## **/

Napi::FunctionReference _VkRenderPassMultiviewCreateInfoKHR::constructor;

_VkRenderPassMultiviewCreateInfoKHR::_VkRenderPassMultiviewCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassMultiviewCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "subpassCount");
      Napi::String sAccess3 = Napi::String::New(env, "pViewMasks");
      Napi::String sAccess4 = Napi::String::New(env, "dependencyCount");
      Napi::String sAccess5 = Napi::String::New(env, "pViewOffsets");
      Napi::String sAccess6 = Napi::String::New(env, "correlationMaskCount");
      Napi::String sAccess7 = Napi::String::New(env, "pCorrelationMasks");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsubpassCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpViewMasks(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetdependencyCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpViewOffsets(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetcorrelationMaskCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpCorrelationMasks(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkRenderPassMultiviewCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassMultiviewCreateInfoKHR::~_VkRenderPassMultiviewCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  pViewMasks.Reset();
  
  
  pViewOffsets.Reset();
  
  
  pCorrelationMasks.Reset();
  
}

Napi::Object _VkRenderPassMultiviewCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassMultiviewCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassMultiviewCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassMultiviewCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassMultiviewCreateInfoKHR::GetsType,
    &_VkRenderPassMultiviewCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassMultiviewCreateInfoKHR::GetpNext,
    &_VkRenderPassMultiviewCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "subpassCount",
    &_VkRenderPassMultiviewCreateInfoKHR::GetsubpassCount,
    &_VkRenderPassMultiviewCreateInfoKHR::SetsubpassCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewMasks",
    &_VkRenderPassMultiviewCreateInfoKHR::GetpViewMasks,
    &_VkRenderPassMultiviewCreateInfoKHR::SetpViewMasks,
    napi_enumerable
  ),
  InstanceAccessor(
    "dependencyCount",
    &_VkRenderPassMultiviewCreateInfoKHR::GetdependencyCount,
    &_VkRenderPassMultiviewCreateInfoKHR::SetdependencyCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewOffsets",
    &_VkRenderPassMultiviewCreateInfoKHR::GetpViewOffsets,
    &_VkRenderPassMultiviewCreateInfoKHR::SetpViewOffsets,
    napi_enumerable
  ),
  InstanceAccessor(
    "correlationMaskCount",
    &_VkRenderPassMultiviewCreateInfoKHR::GetcorrelationMaskCount,
    &_VkRenderPassMultiviewCreateInfoKHR::SetcorrelationMaskCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCorrelationMasks",
    &_VkRenderPassMultiviewCreateInfoKHR::GetpCorrelationMasks,
    &_VkRenderPassMultiviewCreateInfoKHR::SetpCorrelationMasks,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassMultiviewCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->subpassCount));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->subpassCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->pViewMasks));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->pViewMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->dependencyCount));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->dependencyCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->pViewOffsets));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->pViewOffsets);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->correlationMaskCount));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->correlationMaskCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfoKHR *)0)->pCorrelationMasks));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfoKHR *)0)->pCorrelationMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassMultiviewCreateInfoKHR::flush() {
  _VkRenderPassMultiviewCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassMultiviewCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassMultiviewCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkRenderPassMultiviewCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// subpassCount
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetsubpassCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpassCount);
}void _VkRenderPassMultiviewCreateInfoKHR::SetsubpassCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpassCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.subpassCount", "Number");
  
    return;
  }
}// pViewMasks
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetpViewMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewMasks.IsEmpty()) return env.Null();
  return this->pViewMasks.Value().As<Napi::TypedArray>();
}void _VkRenderPassMultiviewCreateInfoKHR::SetpViewMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pViewMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pViewMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pViewMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pViewMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pViewMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pViewMasks = nullptr;
  }
}// dependencyCount
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetdependencyCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dependencyCount);
}void _VkRenderPassMultiviewCreateInfoKHR::SetdependencyCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dependencyCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.dependencyCount", "Number");
  
    return;
  }
}// pViewOffsets
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetpViewOffsets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewOffsets.IsEmpty()) return env.Null();
  return this->pViewOffsets.Value().As<Napi::TypedArray>();
}void _VkRenderPassMultiviewCreateInfoKHR::SetpViewOffsets(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pViewOffsets.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pViewOffsets", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pViewOffsets.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pViewOffsets", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pViewOffsets = getTypedArrayData<int32_t>(value, nullptr);
  } else {
    this->instance.pViewOffsets = nullptr;
  }
}// correlationMaskCount
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetcorrelationMaskCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.correlationMaskCount);
}void _VkRenderPassMultiviewCreateInfoKHR::SetcorrelationMaskCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.correlationMaskCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.correlationMaskCount", "Number");
  
    return;
  }
}// pCorrelationMasks
Napi::Value _VkRenderPassMultiviewCreateInfoKHR::GetpCorrelationMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCorrelationMasks.IsEmpty()) return env.Null();
  return this->pCorrelationMasks.Value().As<Napi::TypedArray>();
}void _VkRenderPassMultiviewCreateInfoKHR::SetpCorrelationMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pCorrelationMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pCorrelationMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCorrelationMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfoKHR.pCorrelationMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCorrelationMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pCorrelationMasks = nullptr;
  }
}
/** ## END VkRenderPassMultiviewCreateInfoKHR ## **/

/** ## BEGIN VkRenderPassMultiviewCreateInfo ## **/

Napi::FunctionReference _VkRenderPassMultiviewCreateInfo::constructor;

_VkRenderPassMultiviewCreateInfo::_VkRenderPassMultiviewCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassMultiviewCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "subpassCount");
      Napi::String sAccess3 = Napi::String::New(env, "pViewMasks");
      Napi::String sAccess4 = Napi::String::New(env, "dependencyCount");
      Napi::String sAccess5 = Napi::String::New(env, "pViewOffsets");
      Napi::String sAccess6 = Napi::String::New(env, "correlationMaskCount");
      Napi::String sAccess7 = Napi::String::New(env, "pCorrelationMasks");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsubpassCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpViewMasks(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetdependencyCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpViewOffsets(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetcorrelationMaskCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpCorrelationMasks(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkRenderPassMultiviewCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassMultiviewCreateInfo::~_VkRenderPassMultiviewCreateInfo() {
  
  
  pNext.Reset();
  
  
  pViewMasks.Reset();
  
  
  pViewOffsets.Reset();
  
  
  pCorrelationMasks.Reset();
  
}

Napi::Object _VkRenderPassMultiviewCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassMultiviewCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassMultiviewCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassMultiviewCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassMultiviewCreateInfo::GetsType,
    &_VkRenderPassMultiviewCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassMultiviewCreateInfo::GetpNext,
    &_VkRenderPassMultiviewCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "subpassCount",
    &_VkRenderPassMultiviewCreateInfo::GetsubpassCount,
    &_VkRenderPassMultiviewCreateInfo::SetsubpassCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewMasks",
    &_VkRenderPassMultiviewCreateInfo::GetpViewMasks,
    &_VkRenderPassMultiviewCreateInfo::SetpViewMasks,
    napi_enumerable
  ),
  InstanceAccessor(
    "dependencyCount",
    &_VkRenderPassMultiviewCreateInfo::GetdependencyCount,
    &_VkRenderPassMultiviewCreateInfo::SetdependencyCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewOffsets",
    &_VkRenderPassMultiviewCreateInfo::GetpViewOffsets,
    &_VkRenderPassMultiviewCreateInfo::SetpViewOffsets,
    napi_enumerable
  ),
  InstanceAccessor(
    "correlationMaskCount",
    &_VkRenderPassMultiviewCreateInfo::GetcorrelationMaskCount,
    &_VkRenderPassMultiviewCreateInfo::SetcorrelationMaskCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCorrelationMasks",
    &_VkRenderPassMultiviewCreateInfo::GetpCorrelationMasks,
    &_VkRenderPassMultiviewCreateInfo::SetpCorrelationMasks,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassMultiviewCreateInfo", func);
  return exports;
}

Napi::Value _VkRenderPassMultiviewCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassMultiviewCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->subpassCount));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->subpassCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->pViewMasks));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->pViewMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->dependencyCount));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->dependencyCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->pViewOffsets));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->pViewOffsets);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->correlationMaskCount));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->correlationMaskCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassMultiviewCreateInfo *)0)->pCorrelationMasks));
    uint32_t byteLength = sizeof(((VkRenderPassMultiviewCreateInfo *)0)->pCorrelationMasks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassMultiviewCreateInfo::flush() {
  _VkRenderPassMultiviewCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkRenderPassMultiviewCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassMultiviewCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassMultiviewCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassMultiviewCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkRenderPassMultiviewCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// subpassCount
Napi::Value _VkRenderPassMultiviewCreateInfo::GetsubpassCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpassCount);
}void _VkRenderPassMultiviewCreateInfo::SetsubpassCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpassCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.subpassCount", "Number");
  
    return;
  }
}// pViewMasks
Napi::Value _VkRenderPassMultiviewCreateInfo::GetpViewMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewMasks.IsEmpty()) return env.Null();
  return this->pViewMasks.Value().As<Napi::TypedArray>();
}void _VkRenderPassMultiviewCreateInfo::SetpViewMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pViewMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pViewMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pViewMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pViewMasks = nullptr;
  }
}// dependencyCount
Napi::Value _VkRenderPassMultiviewCreateInfo::GetdependencyCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dependencyCount);
}void _VkRenderPassMultiviewCreateInfo::SetdependencyCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dependencyCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.dependencyCount", "Number");
  
    return;
  }
}// pViewOffsets
Napi::Value _VkRenderPassMultiviewCreateInfo::GetpViewOffsets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewOffsets.IsEmpty()) return env.Null();
  return this->pViewOffsets.Value().As<Napi::TypedArray>();
}void _VkRenderPassMultiviewCreateInfo::SetpViewOffsets(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pViewOffsets.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewOffsets", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pViewOffsets.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewOffsets", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pViewOffsets = getTypedArrayData<int32_t>(value, nullptr);
  } else {
    this->instance.pViewOffsets = nullptr;
  }
}// correlationMaskCount
Napi::Value _VkRenderPassMultiviewCreateInfo::GetcorrelationMaskCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.correlationMaskCount);
}void _VkRenderPassMultiviewCreateInfo::SetcorrelationMaskCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.correlationMaskCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.correlationMaskCount", "Number");
  
    return;
  }
}// pCorrelationMasks
Napi::Value _VkRenderPassMultiviewCreateInfo::GetpCorrelationMasks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCorrelationMasks.IsEmpty()) return env.Null();
  return this->pCorrelationMasks.Value().As<Napi::TypedArray>();
}void _VkRenderPassMultiviewCreateInfo::SetpCorrelationMasks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pCorrelationMasks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pCorrelationMasks", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCorrelationMasks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassMultiviewCreateInfo.pCorrelationMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCorrelationMasks = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pCorrelationMasks = nullptr;
  }
}
/** ## END VkRenderPassMultiviewCreateInfo ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewPropertiesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceMultiviewPropertiesKHR::constructor;

_VkPhysicalDeviceMultiviewPropertiesKHR::_VkPhysicalDeviceMultiviewPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMultiviewPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMultiviewPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMultiviewPropertiesKHR::~_VkPhysicalDeviceMultiviewPropertiesKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceMultiviewPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMultiviewPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMultiviewPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMultiviewPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMultiviewPropertiesKHR::GetsType,
    &_VkPhysicalDeviceMultiviewPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMultiviewPropertiesKHR::GetpNext,
    &_VkPhysicalDeviceMultiviewPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMultiviewViewCount",
    &_VkPhysicalDeviceMultiviewPropertiesKHR::GetmaxMultiviewViewCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMultiviewInstanceIndex",
    &_VkPhysicalDeviceMultiviewPropertiesKHR::GetmaxMultiviewInstanceIndex,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMultiviewPropertiesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMultiviewPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMultiviewPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->maxMultiviewViewCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->maxMultiviewViewCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->maxMultiviewInstanceIndex));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewPropertiesKHR *)0)->maxMultiviewInstanceIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMultiviewPropertiesKHR::flush() {
  _VkPhysicalDeviceMultiviewPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMultiviewPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMultiviewPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMultiviewPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMultiviewPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMultiviewPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// maxMultiviewViewCount
Napi::Value _VkPhysicalDeviceMultiviewPropertiesKHR::GetmaxMultiviewViewCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMultiviewViewCount);
}// maxMultiviewInstanceIndex
Napi::Value _VkPhysicalDeviceMultiviewPropertiesKHR::GetmaxMultiviewInstanceIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMultiviewInstanceIndex);
}
/** ## END VkPhysicalDeviceMultiviewPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceMultiviewProperties::constructor;

_VkPhysicalDeviceMultiviewProperties::_VkPhysicalDeviceMultiviewProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMultiviewProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMultiviewProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMultiviewProperties::~_VkPhysicalDeviceMultiviewProperties() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceMultiviewProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMultiviewProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMultiviewProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMultiviewProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMultiviewProperties::GetsType,
    &_VkPhysicalDeviceMultiviewProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMultiviewProperties::GetpNext,
    &_VkPhysicalDeviceMultiviewProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMultiviewViewCount",
    &_VkPhysicalDeviceMultiviewProperties::GetmaxMultiviewViewCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMultiviewInstanceIndex",
    &_VkPhysicalDeviceMultiviewProperties::GetmaxMultiviewInstanceIndex,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMultiviewProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMultiviewProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMultiviewProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewProperties *)0)->maxMultiviewViewCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewProperties *)0)->maxMultiviewViewCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewProperties *)0)->maxMultiviewInstanceIndex));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewProperties *)0)->maxMultiviewInstanceIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMultiviewProperties::flush() {
  _VkPhysicalDeviceMultiviewProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMultiviewProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMultiviewProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMultiviewProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMultiviewProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMultiviewProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewProperties.pNext", "[object Object]");
  
    return;
  }
}// maxMultiviewViewCount
Napi::Value _VkPhysicalDeviceMultiviewProperties::GetmaxMultiviewViewCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMultiviewViewCount);
}// maxMultiviewInstanceIndex
Napi::Value _VkPhysicalDeviceMultiviewProperties::GetmaxMultiviewInstanceIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMultiviewInstanceIndex);
}
/** ## END VkPhysicalDeviceMultiviewProperties ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewFeaturesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceMultiviewFeaturesKHR::constructor;

_VkPhysicalDeviceMultiviewFeaturesKHR::_VkPhysicalDeviceMultiviewFeaturesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMultiviewFeaturesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "multiview");
      Napi::String sAccess3 = Napi::String::New(env, "multiviewGeometryShader");
      Napi::String sAccess4 = Napi::String::New(env, "multiviewTessellationShader");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmultiview(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmultiviewGeometryShader(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmultiviewTessellationShader(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMultiviewFeaturesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMultiviewFeaturesKHR::~_VkPhysicalDeviceMultiviewFeaturesKHR() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPhysicalDeviceMultiviewFeaturesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMultiviewFeaturesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMultiviewFeaturesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMultiviewFeaturesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMultiviewFeaturesKHR::GetsType,
    &_VkPhysicalDeviceMultiviewFeaturesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMultiviewFeaturesKHR::GetpNext,
    &_VkPhysicalDeviceMultiviewFeaturesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiview",
    &_VkPhysicalDeviceMultiviewFeaturesKHR::Getmultiview,
    &_VkPhysicalDeviceMultiviewFeaturesKHR::Setmultiview,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiviewGeometryShader",
    &_VkPhysicalDeviceMultiviewFeaturesKHR::GetmultiviewGeometryShader,
    &_VkPhysicalDeviceMultiviewFeaturesKHR::SetmultiviewGeometryShader,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiviewTessellationShader",
    &_VkPhysicalDeviceMultiviewFeaturesKHR::GetmultiviewTessellationShader,
    &_VkPhysicalDeviceMultiviewFeaturesKHR::SetmultiviewTessellationShader,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMultiviewFeaturesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->multiview));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->multiview);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->multiviewGeometryShader));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->multiviewGeometryShader);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->multiviewTessellationShader));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeaturesKHR *)0)->multiviewTessellationShader);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMultiviewFeaturesKHR::flush() {
  _VkPhysicalDeviceMultiviewFeaturesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMultiviewFeaturesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeaturesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMultiviewFeaturesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMultiviewFeaturesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeaturesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeaturesKHR.pNext", "[object Object]");
  
    return;
  }
}// multiview
Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::Getmultiview(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiview);
}void _VkPhysicalDeviceMultiviewFeaturesKHR::Setmultiview(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiview = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiview = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeaturesKHR.multiview", "Number");
  
    return;
  }
}// multiviewGeometryShader
Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::GetmultiviewGeometryShader(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiviewGeometryShader);
}void _VkPhysicalDeviceMultiviewFeaturesKHR::SetmultiviewGeometryShader(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiviewGeometryShader = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiviewGeometryShader = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeaturesKHR.multiviewGeometryShader", "Number");
  
    return;
  }
}// multiviewTessellationShader
Napi::Value _VkPhysicalDeviceMultiviewFeaturesKHR::GetmultiviewTessellationShader(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiviewTessellationShader);
}void _VkPhysicalDeviceMultiviewFeaturesKHR::SetmultiviewTessellationShader(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiviewTessellationShader = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiviewTessellationShader = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeaturesKHR.multiviewTessellationShader", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceMultiviewFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewFeatures ## **/

Napi::FunctionReference _VkPhysicalDeviceMultiviewFeatures::constructor;

_VkPhysicalDeviceMultiviewFeatures::_VkPhysicalDeviceMultiviewFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMultiviewFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "multiview");
      Napi::String sAccess3 = Napi::String::New(env, "multiviewGeometryShader");
      Napi::String sAccess4 = Napi::String::New(env, "multiviewTessellationShader");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmultiview(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmultiviewGeometryShader(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmultiviewTessellationShader(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMultiviewFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMultiviewFeatures::~_VkPhysicalDeviceMultiviewFeatures() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPhysicalDeviceMultiviewFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMultiviewFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMultiviewFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMultiviewFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMultiviewFeatures::GetsType,
    &_VkPhysicalDeviceMultiviewFeatures::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMultiviewFeatures::GetpNext,
    &_VkPhysicalDeviceMultiviewFeatures::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiview",
    &_VkPhysicalDeviceMultiviewFeatures::Getmultiview,
    &_VkPhysicalDeviceMultiviewFeatures::Setmultiview,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiviewGeometryShader",
    &_VkPhysicalDeviceMultiviewFeatures::GetmultiviewGeometryShader,
    &_VkPhysicalDeviceMultiviewFeatures::SetmultiviewGeometryShader,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiviewTessellationShader",
    &_VkPhysicalDeviceMultiviewFeatures::GetmultiviewTessellationShader,
    &_VkPhysicalDeviceMultiviewFeatures::SetmultiviewTessellationShader,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMultiviewFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMultiviewFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMultiviewFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeatures *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeatures *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeatures *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeatures *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeatures *)0)->multiview));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeatures *)0)->multiview);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeatures *)0)->multiviewGeometryShader));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeatures *)0)->multiviewGeometryShader);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMultiviewFeatures *)0)->multiviewTessellationShader));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMultiviewFeatures *)0)->multiviewTessellationShader);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMultiviewFeatures::flush() {
  _VkPhysicalDeviceMultiviewFeatures *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMultiviewFeatures::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMultiviewFeatures::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeatures.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMultiviewFeatures::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMultiviewFeatures::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMultiviewFeatures.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeatures.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeatures.pNext", "[object Object]");
  
    return;
  }
}// multiview
Napi::Value _VkPhysicalDeviceMultiviewFeatures::Getmultiview(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiview);
}void _VkPhysicalDeviceMultiviewFeatures::Setmultiview(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiview = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiview = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeatures.multiview", "Number");
  
    return;
  }
}// multiviewGeometryShader
Napi::Value _VkPhysicalDeviceMultiviewFeatures::GetmultiviewGeometryShader(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiviewGeometryShader);
}void _VkPhysicalDeviceMultiviewFeatures::SetmultiviewGeometryShader(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiviewGeometryShader = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiviewGeometryShader = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeatures.multiviewGeometryShader", "Number");
  
    return;
  }
}// multiviewTessellationShader
Napi::Value _VkPhysicalDeviceMultiviewFeatures::GetmultiviewTessellationShader(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiviewTessellationShader);
}void _VkPhysicalDeviceMultiviewFeatures::SetmultiviewTessellationShader(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiviewTessellationShader = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiviewTessellationShader = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMultiviewFeatures.multiviewTessellationShader", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceMultiviewFeatures ## **/

/** ## BEGIN VkFenceGetFdInfoKHR ## **/

Napi::FunctionReference _VkFenceGetFdInfoKHR::constructor;

_VkFenceGetFdInfoKHR::_VkFenceGetFdInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFenceGetFdInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "fence");
      Napi::String sAccess3 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setfence(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SethandleType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkFenceGetFdInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkFenceGetFdInfoKHR::~_VkFenceGetFdInfoKHR() {
  
  
  pNext.Reset();
  
  fence.Reset();
  
  
}

Napi::Object _VkFenceGetFdInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFenceGetFdInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFenceGetFdInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFenceGetFdInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkFenceGetFdInfoKHR::GetsType,
    &_VkFenceGetFdInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkFenceGetFdInfoKHR::GetpNext,
    &_VkFenceGetFdInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "fence",
    &_VkFenceGetFdInfoKHR::Getfence,
    &_VkFenceGetFdInfoKHR::Setfence,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkFenceGetFdInfoKHR::GethandleType,
    &_VkFenceGetFdInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFenceGetFdInfoKHR", func);
  return exports;
}

Napi::Value _VkFenceGetFdInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFenceGetFdInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetFdInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkFenceGetFdInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetFdInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkFenceGetFdInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetFdInfoKHR *)0)->fence));
    uint32_t byteLength = sizeof(((VkFenceGetFdInfoKHR *)0)->fence);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetFdInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkFenceGetFdInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFenceGetFdInfoKHR::flush() {
  _VkFenceGetFdInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkFenceGetFdInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkFenceGetFdInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetFdInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkFenceGetFdInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkFenceGetFdInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkFenceGetFdInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkFenceGetFdInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetFdInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// fence
Napi::Value _VkFenceGetFdInfoKHR::Getfence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->fence.IsEmpty()) return env.Null();
  return this->fence.Value().As<Napi::Object>();
}void _VkFenceGetFdInfoKHR::Setfence(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFence::constructor.Value())) {
      
      this->fence.Reset(value.ToObject(), 1);
      _VkFence* inst = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      ;
      this->instance.fence = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkFenceGetFdInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->fence.Reset();
    this->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetFdInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// handleType
Napi::Value _VkFenceGetFdInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkFenceGetFdInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetFdInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkFenceGetFdInfoKHR ## **/

/** ## BEGIN VkImportFenceFdInfoKHR ## **/

Napi::FunctionReference _VkImportFenceFdInfoKHR::constructor;

_VkImportFenceFdInfoKHR::_VkImportFenceFdInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportFenceFdInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "fence");
      Napi::String sAccess3 = Napi::String::New(env, "flags");
      Napi::String sAccess4 = Napi::String::New(env, "handleType");
      Napi::String sAccess5 = Napi::String::New(env, "fd");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setfence(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setflags(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SethandleType(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setfd(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkImportFenceFdInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportFenceFdInfoKHR::~_VkImportFenceFdInfoKHR() {
  
  
  pNext.Reset();
  
  fence.Reset();
  
  
  
  
}

Napi::Object _VkImportFenceFdInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportFenceFdInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportFenceFdInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportFenceFdInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportFenceFdInfoKHR::GetsType,
    &_VkImportFenceFdInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportFenceFdInfoKHR::GetpNext,
    &_VkImportFenceFdInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "fence",
    &_VkImportFenceFdInfoKHR::Getfence,
    &_VkImportFenceFdInfoKHR::Setfence,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkImportFenceFdInfoKHR::Getflags,
    &_VkImportFenceFdInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportFenceFdInfoKHR::GethandleType,
    &_VkImportFenceFdInfoKHR::SethandleType,
    napi_enumerable
  ),
  InstanceAccessor(
    "fd",
    &_VkImportFenceFdInfoKHR::Getfd,
    &_VkImportFenceFdInfoKHR::Setfd,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportFenceFdInfoKHR", func);
  return exports;
}

Napi::Value _VkImportFenceFdInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportFenceFdInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceFdInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportFenceFdInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceFdInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportFenceFdInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceFdInfoKHR *)0)->fence));
    uint32_t byteLength = sizeof(((VkImportFenceFdInfoKHR *)0)->fence);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceFdInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkImportFenceFdInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceFdInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportFenceFdInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceFdInfoKHR *)0)->fd));
    uint32_t byteLength = sizeof(((VkImportFenceFdInfoKHR *)0)->fd);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportFenceFdInfoKHR::flush() {
  _VkImportFenceFdInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportFenceFdInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportFenceFdInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportFenceFdInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportFenceFdInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportFenceFdInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// fence
Napi::Value _VkImportFenceFdInfoKHR::Getfence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->fence.IsEmpty()) return env.Null();
  return this->fence.Value().As<Napi::Object>();
}void _VkImportFenceFdInfoKHR::Setfence(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFence::constructor.Value())) {
      
      this->fence.Reset(value.ToObject(), 1);
      _VkFence* inst = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      ;
      this->instance.fence = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->fence.Reset();
    this->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// flags
Napi::Value _VkImportFenceFdInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkImportFenceFdInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkFenceImportFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
Napi::Value _VkImportFenceFdInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportFenceFdInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.handleType", "Number");
  
    return;
  }
}// fd
Napi::Value _VkImportFenceFdInfoKHR::Getfd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fd);
}void _VkImportFenceFdInfoKHR::Setfd(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.fd = static_cast<int>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceFdInfoKHR.fd", "Number");
  
    return;
  }
}
/** ## END VkImportFenceFdInfoKHR ## **/

/** ## BEGIN VkFenceGetWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkFenceGetWin32HandleInfoKHR::constructor;

_VkFenceGetWin32HandleInfoKHR::_VkFenceGetWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFenceGetWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "fence");
      Napi::String sAccess3 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setfence(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SethandleType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkFenceGetWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkFenceGetWin32HandleInfoKHR::~_VkFenceGetWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
  fence.Reset();
  
  
}

Napi::Object _VkFenceGetWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFenceGetWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFenceGetWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFenceGetWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkFenceGetWin32HandleInfoKHR::GetsType,
    &_VkFenceGetWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkFenceGetWin32HandleInfoKHR::GetpNext,
    &_VkFenceGetWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "fence",
    &_VkFenceGetWin32HandleInfoKHR::Getfence,
    &_VkFenceGetWin32HandleInfoKHR::Setfence,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkFenceGetWin32HandleInfoKHR::GethandleType,
    &_VkFenceGetWin32HandleInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFenceGetWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkFenceGetWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFenceGetWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkFenceGetWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkFenceGetWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetWin32HandleInfoKHR *)0)->fence));
    uint32_t byteLength = sizeof(((VkFenceGetWin32HandleInfoKHR *)0)->fence);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceGetWin32HandleInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkFenceGetWin32HandleInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFenceGetWin32HandleInfoKHR::flush() {
  _VkFenceGetWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkFenceGetWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkFenceGetWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkFenceGetWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkFenceGetWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkFenceGetWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkFenceGetWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// fence
Napi::Value _VkFenceGetWin32HandleInfoKHR::Getfence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->fence.IsEmpty()) return env.Null();
  return this->fence.Value().As<Napi::Object>();
}void _VkFenceGetWin32HandleInfoKHR::Setfence(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFence::constructor.Value())) {
      
      this->fence.Reset(value.ToObject(), 1);
      _VkFence* inst = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      ;
      this->instance.fence = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkFenceGetWin32HandleInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->fence.Reset();
    this->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetWin32HandleInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// handleType
Napi::Value _VkFenceGetWin32HandleInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkFenceGetWin32HandleInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFenceGetWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkFenceGetWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportFenceWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkExportFenceWin32HandleInfoKHR::constructor;

_VkExportFenceWin32HandleInfoKHR::_VkExportFenceWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportFenceWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExportFenceWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportFenceWin32HandleInfoKHR::~_VkExportFenceWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkExportFenceWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportFenceWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportFenceWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportFenceWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportFenceWin32HandleInfoKHR::GetsType,
    &_VkExportFenceWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportFenceWin32HandleInfoKHR::GetpNext,
    &_VkExportFenceWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportFenceWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkExportFenceWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportFenceWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportFenceWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportFenceWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportFenceWin32HandleInfoKHR::flush() {
  _VkExportFenceWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportFenceWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportFenceWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportFenceWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportFenceWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportFenceWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportFenceWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}
/** ## END VkExportFenceWin32HandleInfoKHR ## **/

/** ## BEGIN VkImportFenceWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkImportFenceWin32HandleInfoKHR::constructor;

_VkImportFenceWin32HandleInfoKHR::_VkImportFenceWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportFenceWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "fence");
      Napi::String sAccess3 = Napi::String::New(env, "flags");
      Napi::String sAccess4 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setfence(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setflags(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SethandleType(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkImportFenceWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportFenceWin32HandleInfoKHR::~_VkImportFenceWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
  fence.Reset();
  
  
  
}

Napi::Object _VkImportFenceWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportFenceWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportFenceWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportFenceWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportFenceWin32HandleInfoKHR::GetsType,
    &_VkImportFenceWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportFenceWin32HandleInfoKHR::GetpNext,
    &_VkImportFenceWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "fence",
    &_VkImportFenceWin32HandleInfoKHR::Getfence,
    &_VkImportFenceWin32HandleInfoKHR::Setfence,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkImportFenceWin32HandleInfoKHR::Getflags,
    &_VkImportFenceWin32HandleInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportFenceWin32HandleInfoKHR::GethandleType,
    &_VkImportFenceWin32HandleInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportFenceWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkImportFenceWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportFenceWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportFenceWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportFenceWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceWin32HandleInfoKHR *)0)->fence));
    uint32_t byteLength = sizeof(((VkImportFenceWin32HandleInfoKHR *)0)->fence);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceWin32HandleInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkImportFenceWin32HandleInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportFenceWin32HandleInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportFenceWin32HandleInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportFenceWin32HandleInfoKHR::flush() {
  _VkImportFenceWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportFenceWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportFenceWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportFenceWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportFenceWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportFenceWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// fence
Napi::Value _VkImportFenceWin32HandleInfoKHR::Getfence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->fence.IsEmpty()) return env.Null();
  return this->fence.Value().As<Napi::Object>();
}void _VkImportFenceWin32HandleInfoKHR::Setfence(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFence::constructor.Value())) {
      
      this->fence.Reset(value.ToObject(), 1);
      _VkFence* inst = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      ;
      this->instance.fence = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->fence.Reset();
    this->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// flags
Napi::Value _VkImportFenceWin32HandleInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkImportFenceWin32HandleInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkFenceImportFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
Napi::Value _VkImportFenceWin32HandleInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportFenceWin32HandleInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportFenceWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportFenceWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportFenceCreateInfoKHR ## **/

Napi::FunctionReference _VkExportFenceCreateInfoKHR::constructor;

_VkExportFenceCreateInfoKHR::_VkExportFenceCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportFenceCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportFenceCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportFenceCreateInfoKHR::~_VkExportFenceCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportFenceCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportFenceCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportFenceCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportFenceCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportFenceCreateInfoKHR::GetsType,
    &_VkExportFenceCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportFenceCreateInfoKHR::GetpNext,
    &_VkExportFenceCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportFenceCreateInfoKHR::GethandleTypes,
    &_VkExportFenceCreateInfoKHR::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportFenceCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkExportFenceCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportFenceCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportFenceCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportFenceCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceCreateInfoKHR *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportFenceCreateInfoKHR *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportFenceCreateInfoKHR::flush() {
  _VkExportFenceCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportFenceCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportFenceCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportFenceCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportFenceCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportFenceCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportFenceCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportFenceCreateInfoKHR::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportFenceCreateInfoKHR::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalFenceHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceCreateInfoKHR.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportFenceCreateInfoKHR ## **/

/** ## BEGIN VkExportFenceCreateInfo ## **/

Napi::FunctionReference _VkExportFenceCreateInfo::constructor;

_VkExportFenceCreateInfo::_VkExportFenceCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportFenceCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportFenceCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportFenceCreateInfo::~_VkExportFenceCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportFenceCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportFenceCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportFenceCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportFenceCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportFenceCreateInfo::GetsType,
    &_VkExportFenceCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportFenceCreateInfo::GetpNext,
    &_VkExportFenceCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportFenceCreateInfo::GethandleTypes,
    &_VkExportFenceCreateInfo::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportFenceCreateInfo", func);
  return exports;
}

Napi::Value _VkExportFenceCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportFenceCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportFenceCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportFenceCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportFenceCreateInfo *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportFenceCreateInfo *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportFenceCreateInfo::flush() {
  _VkExportFenceCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportFenceCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportFenceCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportFenceCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportFenceCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportFenceCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportFenceCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportFenceCreateInfo::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportFenceCreateInfo::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalFenceHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportFenceCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportFenceCreateInfo ## **/

/** ## BEGIN VkExternalFencePropertiesKHR ## **/

Napi::FunctionReference _VkExternalFencePropertiesKHR::constructor;

_VkExternalFencePropertiesKHR::_VkExternalFencePropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalFencePropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalFencePropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalFencePropertiesKHR::~_VkExternalFencePropertiesKHR() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkExternalFencePropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalFencePropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalFencePropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalFencePropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalFencePropertiesKHR::GetsType,
    &_VkExternalFencePropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalFencePropertiesKHR::GetpNext,
    &_VkExternalFencePropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalFencePropertiesKHR::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalFencePropertiesKHR::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalFenceFeatures",
    &_VkExternalFencePropertiesKHR::GetexternalFenceFeatures,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalFencePropertiesKHR", func);
  return exports;
}

Napi::Value _VkExternalFencePropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalFencePropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFencePropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalFencePropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFencePropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalFencePropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFencePropertiesKHR *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalFencePropertiesKHR *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFencePropertiesKHR *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalFencePropertiesKHR *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFencePropertiesKHR *)0)->externalFenceFeatures));
    uint32_t byteLength = sizeof(((VkExternalFencePropertiesKHR *)0)->externalFenceFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalFencePropertiesKHR::flush() {
  _VkExternalFencePropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalFencePropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalFencePropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalFencePropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalFencePropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalFencePropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalFencePropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalFencePropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalFencePropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// exportFromImportedHandleTypes
Napi::Value _VkExternalFencePropertiesKHR::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalFencePropertiesKHR::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}// externalFenceFeatures
Napi::Value _VkExternalFencePropertiesKHR::GetexternalFenceFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalFenceFeatures);
}
/** ## END VkExternalFencePropertiesKHR ## **/

/** ## BEGIN VkExternalFenceProperties ## **/

Napi::FunctionReference _VkExternalFenceProperties::constructor;

_VkExternalFenceProperties::_VkExternalFenceProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalFenceProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalFenceProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalFenceProperties::~_VkExternalFenceProperties() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkExternalFenceProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalFenceProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalFenceProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalFenceProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalFenceProperties::GetsType,
    &_VkExternalFenceProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalFenceProperties::GetpNext,
    &_VkExternalFenceProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalFenceProperties::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalFenceProperties::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalFenceFeatures",
    &_VkExternalFenceProperties::GetexternalFenceFeatures,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalFenceProperties", func);
  return exports;
}

Napi::Value _VkExternalFenceProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalFenceProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFenceProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalFenceProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFenceProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalFenceProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFenceProperties *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalFenceProperties *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFenceProperties *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalFenceProperties *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalFenceProperties *)0)->externalFenceFeatures));
    uint32_t byteLength = sizeof(((VkExternalFenceProperties *)0)->externalFenceFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalFenceProperties::flush() {
  _VkExternalFenceProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalFenceProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalFenceProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalFenceProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalFenceProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalFenceProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalFenceProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalFenceProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalFenceProperties.pNext", "[object Object]");
  
    return;
  }
}// exportFromImportedHandleTypes
Napi::Value _VkExternalFenceProperties::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalFenceProperties::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}// externalFenceFeatures
Napi::Value _VkExternalFenceProperties::GetexternalFenceFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalFenceFeatures);
}
/** ## END VkExternalFenceProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalFenceInfoKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalFenceInfoKHR::constructor;

_VkPhysicalDeviceExternalFenceInfoKHR::_VkPhysicalDeviceExternalFenceInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalFenceInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalFenceInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalFenceInfoKHR::~_VkPhysicalDeviceExternalFenceInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalFenceInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalFenceInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalFenceInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalFenceInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalFenceInfoKHR::GetsType,
    &_VkPhysicalDeviceExternalFenceInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalFenceInfoKHR::GetpNext,
    &_VkPhysicalDeviceExternalFenceInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalFenceInfoKHR::GethandleType,
    &_VkPhysicalDeviceExternalFenceInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalFenceInfoKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalFenceInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalFenceInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalFenceInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalFenceInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalFenceInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalFenceInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalFenceInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalFenceInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalFenceInfoKHR::flush() {
  _VkPhysicalDeviceExternalFenceInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalFenceInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalFenceInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalFenceInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalFenceInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalFenceInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalFenceInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalFenceInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalFenceInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalFenceInfo ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalFenceInfo::constructor;

_VkPhysicalDeviceExternalFenceInfo::_VkPhysicalDeviceExternalFenceInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalFenceInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalFenceInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalFenceInfo::~_VkPhysicalDeviceExternalFenceInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalFenceInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalFenceInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalFenceInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalFenceInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalFenceInfo::GetsType,
    &_VkPhysicalDeviceExternalFenceInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalFenceInfo::GetpNext,
    &_VkPhysicalDeviceExternalFenceInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalFenceInfo::GethandleType,
    &_VkPhysicalDeviceExternalFenceInfo::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalFenceInfo", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalFenceInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalFenceInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalFenceInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalFenceInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalFenceInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalFenceInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalFenceInfo *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalFenceInfo *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalFenceInfo::flush() {
  _VkPhysicalDeviceExternalFenceInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalFenceInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalFenceInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalFenceInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalFenceInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalFenceInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfo.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalFenceInfo::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalFenceInfo::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalFenceInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalFenceInfo ## **/

/** ## BEGIN VkSemaphoreGetFdInfoKHR ## **/

Napi::FunctionReference _VkSemaphoreGetFdInfoKHR::constructor;

_VkSemaphoreGetFdInfoKHR::_VkSemaphoreGetFdInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSemaphoreGetFdInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "semaphore");
      Napi::String sAccess3 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsemaphore(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SethandleType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkSemaphoreGetFdInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSemaphoreGetFdInfoKHR::~_VkSemaphoreGetFdInfoKHR() {
  
  
  pNext.Reset();
  
  semaphore.Reset();
  
  
}

Napi::Object _VkSemaphoreGetFdInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSemaphoreGetFdInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSemaphoreGetFdInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSemaphoreGetFdInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSemaphoreGetFdInfoKHR::GetsType,
    &_VkSemaphoreGetFdInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSemaphoreGetFdInfoKHR::GetpNext,
    &_VkSemaphoreGetFdInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "semaphore",
    &_VkSemaphoreGetFdInfoKHR::Getsemaphore,
    &_VkSemaphoreGetFdInfoKHR::Setsemaphore,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkSemaphoreGetFdInfoKHR::GethandleType,
    &_VkSemaphoreGetFdInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSemaphoreGetFdInfoKHR", func);
  return exports;
}

Napi::Value _VkSemaphoreGetFdInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSemaphoreGetFdInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetFdInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSemaphoreGetFdInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetFdInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSemaphoreGetFdInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetFdInfoKHR *)0)->semaphore));
    uint32_t byteLength = sizeof(((VkSemaphoreGetFdInfoKHR *)0)->semaphore);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetFdInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkSemaphoreGetFdInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSemaphoreGetFdInfoKHR::flush() {
  _VkSemaphoreGetFdInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSemaphoreGetFdInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSemaphoreGetFdInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetFdInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSemaphoreGetFdInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSemaphoreGetFdInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSemaphoreGetFdInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSemaphoreGetFdInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetFdInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// semaphore
Napi::Value _VkSemaphoreGetFdInfoKHR::Getsemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->semaphore.IsEmpty()) return env.Null();
  return this->semaphore.Value().As<Napi::Object>();
}void _VkSemaphoreGetFdInfoKHR::Setsemaphore(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSemaphore::constructor.Value())) {
      
      this->semaphore.Reset(value.ToObject(), 1);
      _VkSemaphore* inst = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      ;
      this->instance.semaphore = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSemaphoreGetFdInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->semaphore.Reset();
    this->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetFdInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// handleType
Napi::Value _VkSemaphoreGetFdInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkSemaphoreGetFdInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetFdInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkSemaphoreGetFdInfoKHR ## **/

/** ## BEGIN VkImportSemaphoreFdInfoKHR ## **/

Napi::FunctionReference _VkImportSemaphoreFdInfoKHR::constructor;

_VkImportSemaphoreFdInfoKHR::_VkImportSemaphoreFdInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportSemaphoreFdInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "semaphore");
      Napi::String sAccess3 = Napi::String::New(env, "flags");
      Napi::String sAccess4 = Napi::String::New(env, "handleType");
      Napi::String sAccess5 = Napi::String::New(env, "fd");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsemaphore(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setflags(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SethandleType(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setfd(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkImportSemaphoreFdInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportSemaphoreFdInfoKHR::~_VkImportSemaphoreFdInfoKHR() {
  
  
  pNext.Reset();
  
  semaphore.Reset();
  
  
  
  
}

Napi::Object _VkImportSemaphoreFdInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportSemaphoreFdInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportSemaphoreFdInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportSemaphoreFdInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportSemaphoreFdInfoKHR::GetsType,
    &_VkImportSemaphoreFdInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportSemaphoreFdInfoKHR::GetpNext,
    &_VkImportSemaphoreFdInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "semaphore",
    &_VkImportSemaphoreFdInfoKHR::Getsemaphore,
    &_VkImportSemaphoreFdInfoKHR::Setsemaphore,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkImportSemaphoreFdInfoKHR::Getflags,
    &_VkImportSemaphoreFdInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportSemaphoreFdInfoKHR::GethandleType,
    &_VkImportSemaphoreFdInfoKHR::SethandleType,
    napi_enumerable
  ),
  InstanceAccessor(
    "fd",
    &_VkImportSemaphoreFdInfoKHR::Getfd,
    &_VkImportSemaphoreFdInfoKHR::Setfd,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportSemaphoreFdInfoKHR", func);
  return exports;
}

Napi::Value _VkImportSemaphoreFdInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportSemaphoreFdInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreFdInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportSemaphoreFdInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreFdInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportSemaphoreFdInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreFdInfoKHR *)0)->semaphore));
    uint32_t byteLength = sizeof(((VkImportSemaphoreFdInfoKHR *)0)->semaphore);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreFdInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkImportSemaphoreFdInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreFdInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportSemaphoreFdInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreFdInfoKHR *)0)->fd));
    uint32_t byteLength = sizeof(((VkImportSemaphoreFdInfoKHR *)0)->fd);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportSemaphoreFdInfoKHR::flush() {
  _VkImportSemaphoreFdInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportSemaphoreFdInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportSemaphoreFdInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportSemaphoreFdInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportSemaphoreFdInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportSemaphoreFdInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// semaphore
Napi::Value _VkImportSemaphoreFdInfoKHR::Getsemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->semaphore.IsEmpty()) return env.Null();
  return this->semaphore.Value().As<Napi::Object>();
}void _VkImportSemaphoreFdInfoKHR::Setsemaphore(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSemaphore::constructor.Value())) {
      
      this->semaphore.Reset(value.ToObject(), 1);
      _VkSemaphore* inst = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      ;
      this->instance.semaphore = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->semaphore.Reset();
    this->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// flags
Napi::Value _VkImportSemaphoreFdInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkImportSemaphoreFdInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSemaphoreImportFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
Napi::Value _VkImportSemaphoreFdInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportSemaphoreFdInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.handleType", "Number");
  
    return;
  }
}// fd
Napi::Value _VkImportSemaphoreFdInfoKHR::Getfd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fd);
}void _VkImportSemaphoreFdInfoKHR::Setfd(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.fd = static_cast<int>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreFdInfoKHR.fd", "Number");
  
    return;
  }
}
/** ## END VkImportSemaphoreFdInfoKHR ## **/

/** ## BEGIN VkSemaphoreGetWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkSemaphoreGetWin32HandleInfoKHR::constructor;

_VkSemaphoreGetWin32HandleInfoKHR::_VkSemaphoreGetWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSemaphoreGetWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "semaphore");
      Napi::String sAccess3 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsemaphore(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SethandleType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkSemaphoreGetWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSemaphoreGetWin32HandleInfoKHR::~_VkSemaphoreGetWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
  semaphore.Reset();
  
  
}

Napi::Object _VkSemaphoreGetWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSemaphoreGetWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSemaphoreGetWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSemaphoreGetWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSemaphoreGetWin32HandleInfoKHR::GetsType,
    &_VkSemaphoreGetWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSemaphoreGetWin32HandleInfoKHR::GetpNext,
    &_VkSemaphoreGetWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "semaphore",
    &_VkSemaphoreGetWin32HandleInfoKHR::Getsemaphore,
    &_VkSemaphoreGetWin32HandleInfoKHR::Setsemaphore,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkSemaphoreGetWin32HandleInfoKHR::GethandleType,
    &_VkSemaphoreGetWin32HandleInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSemaphoreGetWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkSemaphoreGetWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSemaphoreGetWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSemaphoreGetWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSemaphoreGetWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetWin32HandleInfoKHR *)0)->semaphore));
    uint32_t byteLength = sizeof(((VkSemaphoreGetWin32HandleInfoKHR *)0)->semaphore);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreGetWin32HandleInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkSemaphoreGetWin32HandleInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSemaphoreGetWin32HandleInfoKHR::flush() {
  _VkSemaphoreGetWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSemaphoreGetWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSemaphoreGetWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSemaphoreGetWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSemaphoreGetWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSemaphoreGetWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// semaphore
Napi::Value _VkSemaphoreGetWin32HandleInfoKHR::Getsemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->semaphore.IsEmpty()) return env.Null();
  return this->semaphore.Value().As<Napi::Object>();
}void _VkSemaphoreGetWin32HandleInfoKHR::Setsemaphore(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSemaphore::constructor.Value())) {
      
      this->semaphore.Reset(value.ToObject(), 1);
      _VkSemaphore* inst = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      ;
      this->instance.semaphore = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->semaphore.Reset();
    this->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// handleType
Napi::Value _VkSemaphoreGetWin32HandleInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkSemaphoreGetWin32HandleInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkSemaphoreGetWin32HandleInfoKHR ## **/

/** ## BEGIN VkD3D12FenceSubmitInfoKHR ## **/

Napi::FunctionReference _VkD3D12FenceSubmitInfoKHR::constructor;

_VkD3D12FenceSubmitInfoKHR::_VkD3D12FenceSubmitInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkD3D12FenceSubmitInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "waitSemaphoreValuesCount");
      Napi::String sAccess3 = Napi::String::New(env, "pWaitSemaphoreValues");
      Napi::String sAccess4 = Napi::String::New(env, "signalSemaphoreValuesCount");
      Napi::String sAccess5 = Napi::String::New(env, "pSignalSemaphoreValues");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetwaitSemaphoreValuesCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpWaitSemaphoreValues(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsignalSemaphoreValuesCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpSignalSemaphoreValues(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkD3D12FenceSubmitInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkD3D12FenceSubmitInfoKHR::~_VkD3D12FenceSubmitInfoKHR() {
  
  
  pNext.Reset();
  
  
  pWaitSemaphoreValues.Reset();
  
  
  pSignalSemaphoreValues.Reset();
  
}

Napi::Object _VkD3D12FenceSubmitInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkD3D12FenceSubmitInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkD3D12FenceSubmitInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkD3D12FenceSubmitInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkD3D12FenceSubmitInfoKHR::GetsType,
    &_VkD3D12FenceSubmitInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkD3D12FenceSubmitInfoKHR::GetpNext,
    &_VkD3D12FenceSubmitInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "waitSemaphoreValuesCount",
    &_VkD3D12FenceSubmitInfoKHR::GetwaitSemaphoreValuesCount,
    &_VkD3D12FenceSubmitInfoKHR::SetwaitSemaphoreValuesCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitSemaphoreValues",
    &_VkD3D12FenceSubmitInfoKHR::GetpWaitSemaphoreValues,
    &_VkD3D12FenceSubmitInfoKHR::SetpWaitSemaphoreValues,
    napi_enumerable
  ),
  InstanceAccessor(
    "signalSemaphoreValuesCount",
    &_VkD3D12FenceSubmitInfoKHR::GetsignalSemaphoreValuesCount,
    &_VkD3D12FenceSubmitInfoKHR::SetsignalSemaphoreValuesCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSignalSemaphoreValues",
    &_VkD3D12FenceSubmitInfoKHR::GetpSignalSemaphoreValues,
    &_VkD3D12FenceSubmitInfoKHR::SetpSignalSemaphoreValues,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkD3D12FenceSubmitInfoKHR", func);
  return exports;
}

Napi::Value _VkD3D12FenceSubmitInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkD3D12FenceSubmitInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkD3D12FenceSubmitInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkD3D12FenceSubmitInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkD3D12FenceSubmitInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkD3D12FenceSubmitInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkD3D12FenceSubmitInfoKHR *)0)->waitSemaphoreValuesCount));
    uint32_t byteLength = sizeof(((VkD3D12FenceSubmitInfoKHR *)0)->waitSemaphoreValuesCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkD3D12FenceSubmitInfoKHR *)0)->pWaitSemaphoreValues));
    uint32_t byteLength = sizeof(((VkD3D12FenceSubmitInfoKHR *)0)->pWaitSemaphoreValues);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkD3D12FenceSubmitInfoKHR *)0)->signalSemaphoreValuesCount));
    uint32_t byteLength = sizeof(((VkD3D12FenceSubmitInfoKHR *)0)->signalSemaphoreValuesCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkD3D12FenceSubmitInfoKHR *)0)->pSignalSemaphoreValues));
    uint32_t byteLength = sizeof(((VkD3D12FenceSubmitInfoKHR *)0)->pSignalSemaphoreValues);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkD3D12FenceSubmitInfoKHR::flush() {
  _VkD3D12FenceSubmitInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkD3D12FenceSubmitInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkD3D12FenceSubmitInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkD3D12FenceSubmitInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkD3D12FenceSubmitInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkD3D12FenceSubmitInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// waitSemaphoreValuesCount
Napi::Value _VkD3D12FenceSubmitInfoKHR::GetwaitSemaphoreValuesCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.waitSemaphoreValuesCount);
}void _VkD3D12FenceSubmitInfoKHR::SetwaitSemaphoreValuesCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.waitSemaphoreValuesCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.waitSemaphoreValuesCount", "Number");
  
    return;
  }
}// pWaitSemaphoreValues
Napi::Value _VkD3D12FenceSubmitInfoKHR::GetpWaitSemaphoreValues(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitSemaphoreValues.IsEmpty()) return env.Null();
  return this->pWaitSemaphoreValues.Value().As<Napi::TypedArray>();
}void _VkD3D12FenceSubmitInfoKHR::SetpWaitSemaphoreValues(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_biguint64_array) {
        this->pWaitSemaphoreValues.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues", "BigUint64Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pWaitSemaphoreValues.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pWaitSemaphoreValues = getTypedArrayData<uint64_t>(value, nullptr);
  } else {
    this->instance.pWaitSemaphoreValues = nullptr;
  }
}// signalSemaphoreValuesCount
Napi::Value _VkD3D12FenceSubmitInfoKHR::GetsignalSemaphoreValuesCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.signalSemaphoreValuesCount);
}void _VkD3D12FenceSubmitInfoKHR::SetsignalSemaphoreValuesCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.signalSemaphoreValuesCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.signalSemaphoreValuesCount", "Number");
  
    return;
  }
}// pSignalSemaphoreValues
Napi::Value _VkD3D12FenceSubmitInfoKHR::GetpSignalSemaphoreValues(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSignalSemaphoreValues.IsEmpty()) return env.Null();
  return this->pSignalSemaphoreValues.Value().As<Napi::TypedArray>();
}void _VkD3D12FenceSubmitInfoKHR::SetpSignalSemaphoreValues(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_biguint64_array) {
        this->pSignalSemaphoreValues.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues", "BigUint64Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pSignalSemaphoreValues.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pSignalSemaphoreValues = getTypedArrayData<uint64_t>(value, nullptr);
  } else {
    this->instance.pSignalSemaphoreValues = nullptr;
  }
}
/** ## END VkD3D12FenceSubmitInfoKHR ## **/

/** ## BEGIN VkExportSemaphoreWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkExportSemaphoreWin32HandleInfoKHR::constructor;

_VkExportSemaphoreWin32HandleInfoKHR::_VkExportSemaphoreWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportSemaphoreWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExportSemaphoreWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportSemaphoreWin32HandleInfoKHR::~_VkExportSemaphoreWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkExportSemaphoreWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportSemaphoreWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportSemaphoreWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportSemaphoreWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportSemaphoreWin32HandleInfoKHR::GetsType,
    &_VkExportSemaphoreWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportSemaphoreWin32HandleInfoKHR::GetpNext,
    &_VkExportSemaphoreWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportSemaphoreWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkExportSemaphoreWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportSemaphoreWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportSemaphoreWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportSemaphoreWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportSemaphoreWin32HandleInfoKHR::flush() {
  _VkExportSemaphoreWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportSemaphoreWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportSemaphoreWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportSemaphoreWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportSemaphoreWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportSemaphoreWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportSemaphoreWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}
/** ## END VkExportSemaphoreWin32HandleInfoKHR ## **/

/** ## BEGIN VkImportSemaphoreWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkImportSemaphoreWin32HandleInfoKHR::constructor;

_VkImportSemaphoreWin32HandleInfoKHR::_VkImportSemaphoreWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportSemaphoreWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "semaphore");
      Napi::String sAccess3 = Napi::String::New(env, "flags");
      Napi::String sAccess4 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsemaphore(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setflags(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SethandleType(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkImportSemaphoreWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportSemaphoreWin32HandleInfoKHR::~_VkImportSemaphoreWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
  semaphore.Reset();
  
  
  
}

Napi::Object _VkImportSemaphoreWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportSemaphoreWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportSemaphoreWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportSemaphoreWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportSemaphoreWin32HandleInfoKHR::GetsType,
    &_VkImportSemaphoreWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportSemaphoreWin32HandleInfoKHR::GetpNext,
    &_VkImportSemaphoreWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "semaphore",
    &_VkImportSemaphoreWin32HandleInfoKHR::Getsemaphore,
    &_VkImportSemaphoreWin32HandleInfoKHR::Setsemaphore,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkImportSemaphoreWin32HandleInfoKHR::Getflags,
    &_VkImportSemaphoreWin32HandleInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportSemaphoreWin32HandleInfoKHR::GethandleType,
    &_VkImportSemaphoreWin32HandleInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportSemaphoreWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportSemaphoreWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportSemaphoreWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreWin32HandleInfoKHR *)0)->semaphore));
    uint32_t byteLength = sizeof(((VkImportSemaphoreWin32HandleInfoKHR *)0)->semaphore);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreWin32HandleInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkImportSemaphoreWin32HandleInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportSemaphoreWin32HandleInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportSemaphoreWin32HandleInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportSemaphoreWin32HandleInfoKHR::flush() {
  _VkImportSemaphoreWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportSemaphoreWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportSemaphoreWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportSemaphoreWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// semaphore
Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::Getsemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->semaphore.IsEmpty()) return env.Null();
  return this->semaphore.Value().As<Napi::Object>();
}void _VkImportSemaphoreWin32HandleInfoKHR::Setsemaphore(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSemaphore::constructor.Value())) {
      
      this->semaphore.Reset(value.ToObject(), 1);
      _VkSemaphore* inst = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      ;
      this->instance.semaphore = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->semaphore.Reset();
    this->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// flags
Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkImportSemaphoreWin32HandleInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSemaphoreImportFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
Napi::Value _VkImportSemaphoreWin32HandleInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportSemaphoreWin32HandleInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportSemaphoreWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportSemaphoreCreateInfoKHR ## **/

Napi::FunctionReference _VkExportSemaphoreCreateInfoKHR::constructor;

_VkExportSemaphoreCreateInfoKHR::_VkExportSemaphoreCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportSemaphoreCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportSemaphoreCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportSemaphoreCreateInfoKHR::~_VkExportSemaphoreCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportSemaphoreCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportSemaphoreCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportSemaphoreCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportSemaphoreCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportSemaphoreCreateInfoKHR::GetsType,
    &_VkExportSemaphoreCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportSemaphoreCreateInfoKHR::GetpNext,
    &_VkExportSemaphoreCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportSemaphoreCreateInfoKHR::GethandleTypes,
    &_VkExportSemaphoreCreateInfoKHR::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportSemaphoreCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkExportSemaphoreCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportSemaphoreCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportSemaphoreCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportSemaphoreCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreCreateInfoKHR *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportSemaphoreCreateInfoKHR *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportSemaphoreCreateInfoKHR::flush() {
  _VkExportSemaphoreCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportSemaphoreCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportSemaphoreCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportSemaphoreCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportSemaphoreCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportSemaphoreCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportSemaphoreCreateInfoKHR::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportSemaphoreCreateInfoKHR::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalSemaphoreHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfoKHR.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportSemaphoreCreateInfoKHR ## **/

/** ## BEGIN VkExportSemaphoreCreateInfo ## **/

Napi::FunctionReference _VkExportSemaphoreCreateInfo::constructor;

_VkExportSemaphoreCreateInfo::_VkExportSemaphoreCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportSemaphoreCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportSemaphoreCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportSemaphoreCreateInfo::~_VkExportSemaphoreCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportSemaphoreCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportSemaphoreCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportSemaphoreCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportSemaphoreCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportSemaphoreCreateInfo::GetsType,
    &_VkExportSemaphoreCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportSemaphoreCreateInfo::GetpNext,
    &_VkExportSemaphoreCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportSemaphoreCreateInfo::GethandleTypes,
    &_VkExportSemaphoreCreateInfo::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportSemaphoreCreateInfo", func);
  return exports;
}

Napi::Value _VkExportSemaphoreCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportSemaphoreCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportSemaphoreCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportSemaphoreCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportSemaphoreCreateInfo *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportSemaphoreCreateInfo *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportSemaphoreCreateInfo::flush() {
  _VkExportSemaphoreCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportSemaphoreCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportSemaphoreCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportSemaphoreCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportSemaphoreCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportSemaphoreCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportSemaphoreCreateInfo::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportSemaphoreCreateInfo::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalSemaphoreHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportSemaphoreCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportSemaphoreCreateInfo ## **/

/** ## BEGIN VkExternalSemaphorePropertiesKHR ## **/

Napi::FunctionReference _VkExternalSemaphorePropertiesKHR::constructor;

_VkExternalSemaphorePropertiesKHR::_VkExternalSemaphorePropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalSemaphorePropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalSemaphorePropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalSemaphorePropertiesKHR::~_VkExternalSemaphorePropertiesKHR() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkExternalSemaphorePropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalSemaphorePropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalSemaphorePropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalSemaphorePropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalSemaphorePropertiesKHR::GetsType,
    &_VkExternalSemaphorePropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalSemaphorePropertiesKHR::GetpNext,
    &_VkExternalSemaphorePropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalSemaphorePropertiesKHR::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalSemaphorePropertiesKHR::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalSemaphoreFeatures",
    &_VkExternalSemaphorePropertiesKHR::GetexternalSemaphoreFeatures,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalSemaphorePropertiesKHR", func);
  return exports;
}

Napi::Value _VkExternalSemaphorePropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalSemaphorePropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphorePropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalSemaphorePropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphorePropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalSemaphorePropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphorePropertiesKHR *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalSemaphorePropertiesKHR *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphorePropertiesKHR *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalSemaphorePropertiesKHR *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphorePropertiesKHR *)0)->externalSemaphoreFeatures));
    uint32_t byteLength = sizeof(((VkExternalSemaphorePropertiesKHR *)0)->externalSemaphoreFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalSemaphorePropertiesKHR::flush() {
  _VkExternalSemaphorePropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalSemaphorePropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalSemaphorePropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalSemaphorePropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalSemaphorePropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalSemaphorePropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalSemaphorePropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalSemaphorePropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalSemaphorePropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// exportFromImportedHandleTypes
Napi::Value _VkExternalSemaphorePropertiesKHR::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalSemaphorePropertiesKHR::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}// externalSemaphoreFeatures
Napi::Value _VkExternalSemaphorePropertiesKHR::GetexternalSemaphoreFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalSemaphoreFeatures);
}
/** ## END VkExternalSemaphorePropertiesKHR ## **/

/** ## BEGIN VkExternalSemaphoreProperties ## **/

Napi::FunctionReference _VkExternalSemaphoreProperties::constructor;

_VkExternalSemaphoreProperties::_VkExternalSemaphoreProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalSemaphoreProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalSemaphoreProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalSemaphoreProperties::~_VkExternalSemaphoreProperties() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkExternalSemaphoreProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalSemaphoreProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalSemaphoreProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalSemaphoreProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalSemaphoreProperties::GetsType,
    &_VkExternalSemaphoreProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalSemaphoreProperties::GetpNext,
    &_VkExternalSemaphoreProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalSemaphoreProperties::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalSemaphoreProperties::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalSemaphoreFeatures",
    &_VkExternalSemaphoreProperties::GetexternalSemaphoreFeatures,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalSemaphoreProperties", func);
  return exports;
}

Napi::Value _VkExternalSemaphoreProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalSemaphoreProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphoreProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalSemaphoreProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphoreProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalSemaphoreProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphoreProperties *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalSemaphoreProperties *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphoreProperties *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalSemaphoreProperties *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalSemaphoreProperties *)0)->externalSemaphoreFeatures));
    uint32_t byteLength = sizeof(((VkExternalSemaphoreProperties *)0)->externalSemaphoreFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalSemaphoreProperties::flush() {
  _VkExternalSemaphoreProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalSemaphoreProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalSemaphoreProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalSemaphoreProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalSemaphoreProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalSemaphoreProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalSemaphoreProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalSemaphoreProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalSemaphoreProperties.pNext", "[object Object]");
  
    return;
  }
}// exportFromImportedHandleTypes
Napi::Value _VkExternalSemaphoreProperties::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalSemaphoreProperties::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}// externalSemaphoreFeatures
Napi::Value _VkExternalSemaphoreProperties::GetexternalSemaphoreFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalSemaphoreFeatures);
}
/** ## END VkExternalSemaphoreProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalSemaphoreInfoKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalSemaphoreInfoKHR::constructor;

_VkPhysicalDeviceExternalSemaphoreInfoKHR::_VkPhysicalDeviceExternalSemaphoreInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalSemaphoreInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalSemaphoreInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalSemaphoreInfoKHR::~_VkPhysicalDeviceExternalSemaphoreInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalSemaphoreInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalSemaphoreInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalSemaphoreInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalSemaphoreInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalSemaphoreInfoKHR::GetsType,
    &_VkPhysicalDeviceExternalSemaphoreInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalSemaphoreInfoKHR::GetpNext,
    &_VkPhysicalDeviceExternalSemaphoreInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalSemaphoreInfoKHR::GethandleType,
    &_VkPhysicalDeviceExternalSemaphoreInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalSemaphoreInfoKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalSemaphoreInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalSemaphoreInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalSemaphoreInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalSemaphoreInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalSemaphoreInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalSemaphoreInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalSemaphoreInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalSemaphoreInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalSemaphoreInfoKHR::flush() {
  _VkPhysicalDeviceExternalSemaphoreInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalSemaphoreInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalSemaphoreInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalSemaphoreInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalSemaphoreInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalSemaphoreInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalSemaphoreInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalSemaphoreInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalSemaphoreInfo ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalSemaphoreInfo::constructor;

_VkPhysicalDeviceExternalSemaphoreInfo::_VkPhysicalDeviceExternalSemaphoreInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalSemaphoreInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalSemaphoreInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalSemaphoreInfo::~_VkPhysicalDeviceExternalSemaphoreInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalSemaphoreInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalSemaphoreInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalSemaphoreInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalSemaphoreInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalSemaphoreInfo::GetsType,
    &_VkPhysicalDeviceExternalSemaphoreInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalSemaphoreInfo::GetpNext,
    &_VkPhysicalDeviceExternalSemaphoreInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalSemaphoreInfo::GethandleType,
    &_VkPhysicalDeviceExternalSemaphoreInfo::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalSemaphoreInfo", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalSemaphoreInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalSemaphoreInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalSemaphoreInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalSemaphoreInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalSemaphoreInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalSemaphoreInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalSemaphoreInfo *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalSemaphoreInfo *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalSemaphoreInfo::flush() {
  _VkPhysicalDeviceExternalSemaphoreInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalSemaphoreInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalSemaphoreInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalSemaphoreInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalSemaphoreInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalSemaphoreInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfo.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalSemaphoreInfo::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalSemaphoreInfo::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalSemaphoreInfo ## **/

/** ## BEGIN VkWin32KeyedMutexAcquireReleaseInfoKHR ## **/

Napi::FunctionReference _VkWin32KeyedMutexAcquireReleaseInfoKHR::constructor;

_VkWin32KeyedMutexAcquireReleaseInfoKHR::_VkWin32KeyedMutexAcquireReleaseInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
    vpAcquireSyncs = new std::vector<VkDeviceMemory>;
    vpReleaseSyncs = new std::vector<VkDeviceMemory>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "acquireCount");
      Napi::String sAccess3 = Napi::String::New(env, "pAcquireSyncs");
      Napi::String sAccess4 = Napi::String::New(env, "pAcquireKeys");
      Napi::String sAccess5 = Napi::String::New(env, "pAcquireTimeouts");
      Napi::String sAccess6 = Napi::String::New(env, "releaseCount");
      Napi::String sAccess7 = Napi::String::New(env, "pReleaseSyncs");
      Napi::String sAccess8 = Napi::String::New(env, "pReleaseKeys");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetacquireCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpAcquireSyncs(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpAcquireKeys(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpAcquireTimeouts(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetreleaseCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpReleaseSyncs(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpReleaseKeys(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkWin32KeyedMutexAcquireReleaseInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkWin32KeyedMutexAcquireReleaseInfoKHR::~_VkWin32KeyedMutexAcquireReleaseInfoKHR() {
  
  
  pNext.Reset();
  
  
  vpAcquireSyncs->clear();
  delete vpAcquireSyncs;
  
  pAcquireSyncs.Reset();
  
  pAcquireKeys.Reset();
  
  pAcquireTimeouts.Reset();
  
  
  vpReleaseSyncs->clear();
  delete vpReleaseSyncs;
  
  pReleaseSyncs.Reset();
  
  pReleaseKeys.Reset();
  
}

Napi::Object _VkWin32KeyedMutexAcquireReleaseInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkWin32KeyedMutexAcquireReleaseInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetsType,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpNext,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "acquireCount",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetacquireCount,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetacquireCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAcquireSyncs",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireSyncs,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireSyncs,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAcquireKeys",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireKeys,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireKeys,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAcquireTimeouts",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireTimeouts,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireTimeouts,
    napi_enumerable
  ),
  InstanceAccessor(
    "releaseCount",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetreleaseCount,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetreleaseCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pReleaseSyncs",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpReleaseSyncs,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpReleaseSyncs,
    napi_enumerable
  ),
  InstanceAccessor(
    "pReleaseKeys",
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpReleaseKeys,
    &_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpReleaseKeys,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkWin32KeyedMutexAcquireReleaseInfoKHR", func);
  return exports;
}

Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->acquireCount));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->acquireCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pAcquireSyncs));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pAcquireSyncs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pAcquireKeys));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pAcquireKeys);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pAcquireTimeouts));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pAcquireTimeouts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->releaseCount));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->releaseCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pReleaseSyncs));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pReleaseSyncs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pReleaseKeys));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoKHR *)0)->pReleaseKeys);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkWin32KeyedMutexAcquireReleaseInfoKHR::flush() {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAcquireSyncs.IsEmpty())) {
    Napi::Value value = self->pAcquireSyncs.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.acquireCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDeviceMemory>* data = this->vpAcquireSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAcquireSyncs = data->data();
  }if (!(self->pReleaseSyncs.IsEmpty())) {
    Napi::Value value = self->pReleaseSyncs.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.releaseCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDeviceMemory>* data = this->vpReleaseSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pReleaseSyncs = data->data();
  }
  return true;
}

// sType
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// acquireCount
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetacquireCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.acquireCount);
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetacquireCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.acquireCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.acquireCount", "Number");
  
    return;
  }
}// pAcquireSyncs
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireSyncs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAcquireSyncs.IsEmpty()) return env.Null();
  return this->pAcquireSyncs.Value().As<Napi::Array>();
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireSyncs(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAcquireSyncs.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAcquireSyncs.Reset();
      this->instance.pAcquireSyncs = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAcquireSyncs = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pAcquireKeys
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireKeys(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAcquireKeys.IsEmpty()) return env.Null();
  return this->pAcquireKeys.Value().As<Napi::TypedArray>();
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireKeys(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_biguint64_array) {
        this->pAcquireKeys.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys", "BigUint64Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pAcquireKeys.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pAcquireKeys = getTypedArrayData<uint64_t>(value, nullptr);
  } else {
    this->instance.pAcquireKeys = nullptr;
  }
}// pAcquireTimeouts
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireTimeouts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAcquireTimeouts.IsEmpty()) return env.Null();
  return this->pAcquireTimeouts.Value().As<Napi::TypedArray>();
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireTimeouts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pAcquireTimeouts.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pAcquireTimeouts.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pAcquireTimeouts = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pAcquireTimeouts = nullptr;
  }
}// releaseCount
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetreleaseCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.releaseCount);
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetreleaseCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.releaseCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.releaseCount", "Number");
  
    return;
  }
}// pReleaseSyncs
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpReleaseSyncs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pReleaseSyncs.IsEmpty()) return env.Null();
  return this->pReleaseSyncs.Value().As<Napi::Array>();
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpReleaseSyncs(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pReleaseSyncs.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pReleaseSyncs.Reset();
      this->instance.pReleaseSyncs = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pReleaseSyncs = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pReleaseKeys
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpReleaseKeys(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pReleaseKeys.IsEmpty()) return env.Null();
  return this->pReleaseKeys.Value().As<Napi::TypedArray>();
}void _VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpReleaseKeys(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_biguint64_array) {
        this->pReleaseKeys.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys", "BigUint64Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pReleaseKeys.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pReleaseKeys = getTypedArrayData<uint64_t>(value, nullptr);
  } else {
    this->instance.pReleaseKeys = nullptr;
  }
}
/** ## END VkWin32KeyedMutexAcquireReleaseInfoKHR ## **/

/** ## BEGIN VkMemoryGetFdInfoKHR ## **/

Napi::FunctionReference _VkMemoryGetFdInfoKHR::constructor;

_VkMemoryGetFdInfoKHR::_VkMemoryGetFdInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryGetFdInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "memory");
      Napi::String sAccess3 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmemory(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SethandleType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryGetFdInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryGetFdInfoKHR::~_VkMemoryGetFdInfoKHR() {
  
  
  pNext.Reset();
  
  memory.Reset();
  
  
}

Napi::Object _VkMemoryGetFdInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryGetFdInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryGetFdInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryGetFdInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryGetFdInfoKHR::GetsType,
    &_VkMemoryGetFdInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryGetFdInfoKHR::GetpNext,
    &_VkMemoryGetFdInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkMemoryGetFdInfoKHR::Getmemory,
    &_VkMemoryGetFdInfoKHR::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkMemoryGetFdInfoKHR::GethandleType,
    &_VkMemoryGetFdInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryGetFdInfoKHR", func);
  return exports;
}

Napi::Value _VkMemoryGetFdInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryGetFdInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetFdInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryGetFdInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetFdInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryGetFdInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetFdInfoKHR *)0)->memory));
    uint32_t byteLength = sizeof(((VkMemoryGetFdInfoKHR *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetFdInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkMemoryGetFdInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryGetFdInfoKHR::flush() {
  _VkMemoryGetFdInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryGetFdInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryGetFdInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetFdInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryGetFdInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryGetFdInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryGetFdInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryGetFdInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetFdInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// memory
Napi::Value _VkMemoryGetFdInfoKHR::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkMemoryGetFdInfoKHR::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMemoryGetFdInfoKHR.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetFdInfoKHR.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// handleType
Napi::Value _VkMemoryGetFdInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkMemoryGetFdInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetFdInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkMemoryGetFdInfoKHR ## **/

/** ## BEGIN VkMemoryFdPropertiesKHR ## **/

Napi::FunctionReference _VkMemoryFdPropertiesKHR::constructor;

_VkMemoryFdPropertiesKHR::_VkMemoryFdPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryFdPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMemoryFdPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryFdPropertiesKHR::~_VkMemoryFdPropertiesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkMemoryFdPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryFdPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryFdPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryFdPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryFdPropertiesKHR::GetsType,
    &_VkMemoryFdPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryFdPropertiesKHR::GetpNext,
    &_VkMemoryFdPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryTypeBits",
    &_VkMemoryFdPropertiesKHR::GetmemoryTypeBits,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryFdPropertiesKHR", func);
  return exports;
}

Napi::Value _VkMemoryFdPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryFdPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryFdPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryFdPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryFdPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryFdPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryFdPropertiesKHR *)0)->memoryTypeBits));
    uint32_t byteLength = sizeof(((VkMemoryFdPropertiesKHR *)0)->memoryTypeBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryFdPropertiesKHR::flush() {
  _VkMemoryFdPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryFdPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryFdPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryFdPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryFdPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryFdPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryFdPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryFdPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryFdPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// memoryTypeBits
Napi::Value _VkMemoryFdPropertiesKHR::GetmemoryTypeBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryTypeBits);
}
/** ## END VkMemoryFdPropertiesKHR ## **/

/** ## BEGIN VkImportMemoryFdInfoKHR ## **/

Napi::FunctionReference _VkImportMemoryFdInfoKHR::constructor;

_VkImportMemoryFdInfoKHR::_VkImportMemoryFdInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportMemoryFdInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      Napi::String sAccess3 = Napi::String::New(env, "fd");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setfd(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkImportMemoryFdInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportMemoryFdInfoKHR::~_VkImportMemoryFdInfoKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkImportMemoryFdInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportMemoryFdInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportMemoryFdInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportMemoryFdInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportMemoryFdInfoKHR::GetsType,
    &_VkImportMemoryFdInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportMemoryFdInfoKHR::GetpNext,
    &_VkImportMemoryFdInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportMemoryFdInfoKHR::GethandleType,
    &_VkImportMemoryFdInfoKHR::SethandleType,
    napi_enumerable
  ),
  InstanceAccessor(
    "fd",
    &_VkImportMemoryFdInfoKHR::Getfd,
    &_VkImportMemoryFdInfoKHR::Setfd,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportMemoryFdInfoKHR", func);
  return exports;
}

Napi::Value _VkImportMemoryFdInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportMemoryFdInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryFdInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportMemoryFdInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryFdInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportMemoryFdInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryFdInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportMemoryFdInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryFdInfoKHR *)0)->fd));
    uint32_t byteLength = sizeof(((VkImportMemoryFdInfoKHR *)0)->fd);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportMemoryFdInfoKHR::flush() {
  _VkImportMemoryFdInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportMemoryFdInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportMemoryFdInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryFdInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportMemoryFdInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportMemoryFdInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportMemoryFdInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportMemoryFdInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryFdInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkImportMemoryFdInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportMemoryFdInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryFdInfoKHR.handleType", "Number");
  
    return;
  }
}// fd
Napi::Value _VkImportMemoryFdInfoKHR::Getfd(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fd);
}void _VkImportMemoryFdInfoKHR::Setfd(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.fd = static_cast<int>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryFdInfoKHR.fd", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryFdInfoKHR ## **/

/** ## BEGIN VkMemoryGetWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkMemoryGetWin32HandleInfoKHR::constructor;

_VkMemoryGetWin32HandleInfoKHR::_VkMemoryGetWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryGetWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "memory");
      Napi::String sAccess3 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmemory(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SethandleType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryGetWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryGetWin32HandleInfoKHR::~_VkMemoryGetWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
  memory.Reset();
  
  
}

Napi::Object _VkMemoryGetWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryGetWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryGetWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryGetWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryGetWin32HandleInfoKHR::GetsType,
    &_VkMemoryGetWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryGetWin32HandleInfoKHR::GetpNext,
    &_VkMemoryGetWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkMemoryGetWin32HandleInfoKHR::Getmemory,
    &_VkMemoryGetWin32HandleInfoKHR::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkMemoryGetWin32HandleInfoKHR::GethandleType,
    &_VkMemoryGetWin32HandleInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryGetWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkMemoryGetWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryGetWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryGetWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryGetWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetWin32HandleInfoKHR *)0)->memory));
    uint32_t byteLength = sizeof(((VkMemoryGetWin32HandleInfoKHR *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryGetWin32HandleInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkMemoryGetWin32HandleInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryGetWin32HandleInfoKHR::flush() {
  _VkMemoryGetWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryGetWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryGetWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryGetWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryGetWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryGetWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryGetWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// memory
Napi::Value _VkMemoryGetWin32HandleInfoKHR::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkMemoryGetWin32HandleInfoKHR::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMemoryGetWin32HandleInfoKHR.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetWin32HandleInfoKHR.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// handleType
Napi::Value _VkMemoryGetWin32HandleInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkMemoryGetWin32HandleInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryGetWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkMemoryGetWin32HandleInfoKHR ## **/

/** ## BEGIN VkMemoryWin32HandlePropertiesKHR ## **/

Napi::FunctionReference _VkMemoryWin32HandlePropertiesKHR::constructor;

_VkMemoryWin32HandlePropertiesKHR::_VkMemoryWin32HandlePropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryWin32HandlePropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkMemoryWin32HandlePropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryWin32HandlePropertiesKHR::~_VkMemoryWin32HandlePropertiesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkMemoryWin32HandlePropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryWin32HandlePropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryWin32HandlePropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryWin32HandlePropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryWin32HandlePropertiesKHR::GetsType,
    &_VkMemoryWin32HandlePropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryWin32HandlePropertiesKHR::GetpNext,
    &_VkMemoryWin32HandlePropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryTypeBits",
    &_VkMemoryWin32HandlePropertiesKHR::GetmemoryTypeBits,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryWin32HandlePropertiesKHR", func);
  return exports;
}

Napi::Value _VkMemoryWin32HandlePropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryWin32HandlePropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryWin32HandlePropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryWin32HandlePropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryWin32HandlePropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryWin32HandlePropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryWin32HandlePropertiesKHR *)0)->memoryTypeBits));
    uint32_t byteLength = sizeof(((VkMemoryWin32HandlePropertiesKHR *)0)->memoryTypeBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryWin32HandlePropertiesKHR::flush() {
  _VkMemoryWin32HandlePropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryWin32HandlePropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryWin32HandlePropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryWin32HandlePropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryWin32HandlePropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryWin32HandlePropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryWin32HandlePropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryWin32HandlePropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryWin32HandlePropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// memoryTypeBits
Napi::Value _VkMemoryWin32HandlePropertiesKHR::GetmemoryTypeBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryTypeBits);
}
/** ## END VkMemoryWin32HandlePropertiesKHR ## **/

/** ## BEGIN VkExportMemoryWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkExportMemoryWin32HandleInfoKHR::constructor;

_VkExportMemoryWin32HandleInfoKHR::_VkExportMemoryWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportMemoryWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExportMemoryWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportMemoryWin32HandleInfoKHR::~_VkExportMemoryWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkExportMemoryWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportMemoryWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportMemoryWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportMemoryWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportMemoryWin32HandleInfoKHR::GetsType,
    &_VkExportMemoryWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportMemoryWin32HandleInfoKHR::GetpNext,
    &_VkExportMemoryWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportMemoryWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkExportMemoryWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportMemoryWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportMemoryWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportMemoryWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportMemoryWin32HandleInfoKHR::flush() {
  _VkExportMemoryWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportMemoryWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportMemoryWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportMemoryWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportMemoryWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportMemoryWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportMemoryWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}
/** ## END VkExportMemoryWin32HandleInfoKHR ## **/

/** ## BEGIN VkImportMemoryWin32HandleInfoKHR ## **/

Napi::FunctionReference _VkImportMemoryWin32HandleInfoKHR::constructor;

_VkImportMemoryWin32HandleInfoKHR::_VkImportMemoryWin32HandleInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportMemoryWin32HandleInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImportMemoryWin32HandleInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportMemoryWin32HandleInfoKHR::~_VkImportMemoryWin32HandleInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkImportMemoryWin32HandleInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportMemoryWin32HandleInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportMemoryWin32HandleInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportMemoryWin32HandleInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportMemoryWin32HandleInfoKHR::GetsType,
    &_VkImportMemoryWin32HandleInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportMemoryWin32HandleInfoKHR::GetpNext,
    &_VkImportMemoryWin32HandleInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportMemoryWin32HandleInfoKHR::GethandleType,
    &_VkImportMemoryWin32HandleInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportMemoryWin32HandleInfoKHR", func);
  return exports;
}

Napi::Value _VkImportMemoryWin32HandleInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportMemoryWin32HandleInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryWin32HandleInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportMemoryWin32HandleInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryWin32HandleInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportMemoryWin32HandleInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryWin32HandleInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportMemoryWin32HandleInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportMemoryWin32HandleInfoKHR::flush() {
  _VkImportMemoryWin32HandleInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportMemoryWin32HandleInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportMemoryWin32HandleInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportMemoryWin32HandleInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportMemoryWin32HandleInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportMemoryWin32HandleInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkImportMemoryWin32HandleInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportMemoryWin32HandleInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportMemoryAllocateInfoKHR ## **/

Napi::FunctionReference _VkExportMemoryAllocateInfoKHR::constructor;

_VkExportMemoryAllocateInfoKHR::_VkExportMemoryAllocateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportMemoryAllocateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportMemoryAllocateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportMemoryAllocateInfoKHR::~_VkExportMemoryAllocateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportMemoryAllocateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportMemoryAllocateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportMemoryAllocateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportMemoryAllocateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportMemoryAllocateInfoKHR::GetsType,
    &_VkExportMemoryAllocateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportMemoryAllocateInfoKHR::GetpNext,
    &_VkExportMemoryAllocateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportMemoryAllocateInfoKHR::GethandleTypes,
    &_VkExportMemoryAllocateInfoKHR::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportMemoryAllocateInfoKHR", func);
  return exports;
}

Napi::Value _VkExportMemoryAllocateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportMemoryAllocateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfoKHR *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfoKHR *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportMemoryAllocateInfoKHR::flush() {
  _VkExportMemoryAllocateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportMemoryAllocateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportMemoryAllocateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportMemoryAllocateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportMemoryAllocateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportMemoryAllocateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportMemoryAllocateInfoKHR::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportMemoryAllocateInfoKHR::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoKHR.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryAllocateInfoKHR ## **/

/** ## BEGIN VkExportMemoryAllocateInfo ## **/

Napi::FunctionReference _VkExportMemoryAllocateInfo::constructor;

_VkExportMemoryAllocateInfo::_VkExportMemoryAllocateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportMemoryAllocateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportMemoryAllocateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportMemoryAllocateInfo::~_VkExportMemoryAllocateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportMemoryAllocateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportMemoryAllocateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportMemoryAllocateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportMemoryAllocateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportMemoryAllocateInfo::GetsType,
    &_VkExportMemoryAllocateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportMemoryAllocateInfo::GetpNext,
    &_VkExportMemoryAllocateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportMemoryAllocateInfo::GethandleTypes,
    &_VkExportMemoryAllocateInfo::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportMemoryAllocateInfo", func);
  return exports;
}

Napi::Value _VkExportMemoryAllocateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportMemoryAllocateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfo *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfo *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportMemoryAllocateInfo::flush() {
  _VkExportMemoryAllocateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportMemoryAllocateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportMemoryAllocateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportMemoryAllocateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportMemoryAllocateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportMemoryAllocateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfo.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportMemoryAllocateInfo::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportMemoryAllocateInfo::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryAllocateInfo ## **/

/** ## BEGIN VkExternalMemoryBufferCreateInfoKHR ## **/

Napi::FunctionReference _VkExternalMemoryBufferCreateInfoKHR::constructor;

_VkExternalMemoryBufferCreateInfoKHR::_VkExternalMemoryBufferCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryBufferCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryBufferCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryBufferCreateInfoKHR::~_VkExternalMemoryBufferCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExternalMemoryBufferCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryBufferCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryBufferCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryBufferCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalMemoryBufferCreateInfoKHR::GetsType,
    &_VkExternalMemoryBufferCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalMemoryBufferCreateInfoKHR::GetpNext,
    &_VkExternalMemoryBufferCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExternalMemoryBufferCreateInfoKHR::GethandleTypes,
    &_VkExternalMemoryBufferCreateInfoKHR::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryBufferCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkExternalMemoryBufferCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryBufferCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryBufferCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalMemoryBufferCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryBufferCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalMemoryBufferCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryBufferCreateInfoKHR *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryBufferCreateInfoKHR *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryBufferCreateInfoKHR::flush() {
  _VkExternalMemoryBufferCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalMemoryBufferCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalMemoryBufferCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalMemoryBufferCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalMemoryBufferCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalMemoryBufferCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExternalMemoryBufferCreateInfoKHR::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExternalMemoryBufferCreateInfoKHR::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfoKHR.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryBufferCreateInfoKHR ## **/

/** ## BEGIN VkExternalMemoryBufferCreateInfo ## **/

Napi::FunctionReference _VkExternalMemoryBufferCreateInfo::constructor;

_VkExternalMemoryBufferCreateInfo::_VkExternalMemoryBufferCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryBufferCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryBufferCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryBufferCreateInfo::~_VkExternalMemoryBufferCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExternalMemoryBufferCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryBufferCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryBufferCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryBufferCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalMemoryBufferCreateInfo::GetsType,
    &_VkExternalMemoryBufferCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalMemoryBufferCreateInfo::GetpNext,
    &_VkExternalMemoryBufferCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExternalMemoryBufferCreateInfo::GethandleTypes,
    &_VkExternalMemoryBufferCreateInfo::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryBufferCreateInfo", func);
  return exports;
}

Napi::Value _VkExternalMemoryBufferCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryBufferCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryBufferCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalMemoryBufferCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryBufferCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalMemoryBufferCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryBufferCreateInfo *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryBufferCreateInfo *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryBufferCreateInfo::flush() {
  _VkExternalMemoryBufferCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalMemoryBufferCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalMemoryBufferCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalMemoryBufferCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalMemoryBufferCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalMemoryBufferCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExternalMemoryBufferCreateInfo::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExternalMemoryBufferCreateInfo::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryBufferCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryBufferCreateInfo ## **/

/** ## BEGIN VkExternalMemoryImageCreateInfoKHR ## **/

Napi::FunctionReference _VkExternalMemoryImageCreateInfoKHR::constructor;

_VkExternalMemoryImageCreateInfoKHR::_VkExternalMemoryImageCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryImageCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryImageCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryImageCreateInfoKHR::~_VkExternalMemoryImageCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExternalMemoryImageCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryImageCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryImageCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryImageCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalMemoryImageCreateInfoKHR::GetsType,
    &_VkExternalMemoryImageCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalMemoryImageCreateInfoKHR::GetpNext,
    &_VkExternalMemoryImageCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExternalMemoryImageCreateInfoKHR::GethandleTypes,
    &_VkExternalMemoryImageCreateInfoKHR::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryImageCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkExternalMemoryImageCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryImageCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfoKHR *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfoKHR *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryImageCreateInfoKHR::flush() {
  _VkExternalMemoryImageCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalMemoryImageCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalMemoryImageCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalMemoryImageCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalMemoryImageCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalMemoryImageCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExternalMemoryImageCreateInfoKHR::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExternalMemoryImageCreateInfoKHR::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoKHR.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryImageCreateInfoKHR ## **/

/** ## BEGIN VkExternalMemoryImageCreateInfo ## **/

Napi::FunctionReference _VkExternalMemoryImageCreateInfo::constructor;

_VkExternalMemoryImageCreateInfo::_VkExternalMemoryImageCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryImageCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryImageCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryImageCreateInfo::~_VkExternalMemoryImageCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExternalMemoryImageCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryImageCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryImageCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryImageCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalMemoryImageCreateInfo::GetsType,
    &_VkExternalMemoryImageCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalMemoryImageCreateInfo::GetpNext,
    &_VkExternalMemoryImageCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExternalMemoryImageCreateInfo::GethandleTypes,
    &_VkExternalMemoryImageCreateInfo::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryImageCreateInfo", func);
  return exports;
}

Napi::Value _VkExternalMemoryImageCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryImageCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfo *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfo *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryImageCreateInfo::flush() {
  _VkExternalMemoryImageCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalMemoryImageCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalMemoryImageCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalMemoryImageCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalMemoryImageCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalMemoryImageCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExternalMemoryImageCreateInfo::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExternalMemoryImageCreateInfo::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryImageCreateInfo ## **/

/** ## BEGIN VkPhysicalDeviceIDPropertiesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceIDPropertiesKHR::constructor;

_VkPhysicalDeviceIDPropertiesKHR::_VkPhysicalDeviceIDPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceIDPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR;
    vdeviceUUID = new std::vector<uint8_t>;
    vdriverUUID = new std::vector<uint8_t>;
    vdeviceLUID = new std::vector<uint8_t>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceIDPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceIDPropertiesKHR::~_VkPhysicalDeviceIDPropertiesKHR() {
  
  
  pNext.Reset();
  
  vdeviceUUID->clear();
  delete vdeviceUUID;
  
  deviceUUID.Reset();
  
  vdriverUUID->clear();
  delete vdriverUUID;
  
  driverUUID.Reset();
  
  vdeviceLUID->clear();
  delete vdeviceLUID;
  
  deviceLUID.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceIDPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceIDPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceIDPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceIDPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceIDPropertiesKHR::GetsType,
    &_VkPhysicalDeviceIDPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceIDPropertiesKHR::GetpNext,
    &_VkPhysicalDeviceIDPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceUUID",
    &_VkPhysicalDeviceIDPropertiesKHR::GetdeviceUUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "driverUUID",
    &_VkPhysicalDeviceIDPropertiesKHR::GetdriverUUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceLUID",
    &_VkPhysicalDeviceIDPropertiesKHR::GetdeviceLUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceNodeMask",
    &_VkPhysicalDeviceIDPropertiesKHR::GetdeviceNodeMask,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceLUIDValid",
    &_VkPhysicalDeviceIDPropertiesKHR::GetdeviceLUIDValid,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceIDPropertiesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceUUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceUUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->driverUUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->driverUUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceLUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceLUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceNodeMask));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceNodeMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceLUIDValid));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDPropertiesKHR *)0)->deviceLUIDValid);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceIDPropertiesKHR::flush() {
  _VkPhysicalDeviceIDPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->deviceUUID.IsEmpty())) {
    Napi::Value value = self->deviceUUID.Value();
    
  }if (!(self->driverUUID.IsEmpty())) {
    Napi::Value value = self->driverUUID.Value();
    
  }if (!(self->deviceLUID.IsEmpty())) {
    Napi::Value value = self->deviceLUID.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceIDPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceIDPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceIDPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceIDPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceIDPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceIDPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// deviceUUID
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetdeviceUUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->deviceUUID.IsEmpty()) return env.Null();
  return this->deviceUUID.Value().As<Napi::Array>();
}// driverUUID
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetdriverUUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->driverUUID.IsEmpty()) return env.Null();
  return this->driverUUID.Value().As<Napi::Array>();
}// deviceLUID
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetdeviceLUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->deviceLUID.IsEmpty()) return env.Null();
  return this->deviceLUID.Value().As<Napi::Array>();
}// deviceNodeMask
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetdeviceNodeMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceNodeMask);
}// deviceLUIDValid
Napi::Value _VkPhysicalDeviceIDPropertiesKHR::GetdeviceLUIDValid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceLUIDValid);
}
/** ## END VkPhysicalDeviceIDPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceIDProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceIDProperties::constructor;

_VkPhysicalDeviceIDProperties::_VkPhysicalDeviceIDProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceIDProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
    vdeviceUUID = new std::vector<uint8_t>;
    vdriverUUID = new std::vector<uint8_t>;
    vdeviceLUID = new std::vector<uint8_t>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceIDProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceIDProperties::~_VkPhysicalDeviceIDProperties() {
  
  
  pNext.Reset();
  
  vdeviceUUID->clear();
  delete vdeviceUUID;
  
  deviceUUID.Reset();
  
  vdriverUUID->clear();
  delete vdriverUUID;
  
  driverUUID.Reset();
  
  vdeviceLUID->clear();
  delete vdeviceLUID;
  
  deviceLUID.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceIDProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceIDProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceIDProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceIDProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceIDProperties::GetsType,
    &_VkPhysicalDeviceIDProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceIDProperties::GetpNext,
    &_VkPhysicalDeviceIDProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceUUID",
    &_VkPhysicalDeviceIDProperties::GetdeviceUUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "driverUUID",
    &_VkPhysicalDeviceIDProperties::GetdriverUUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceLUID",
    &_VkPhysicalDeviceIDProperties::GetdeviceLUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceNodeMask",
    &_VkPhysicalDeviceIDProperties::GetdeviceNodeMask,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceLUIDValid",
    &_VkPhysicalDeviceIDProperties::GetdeviceLUIDValid,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceIDProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceIDProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceIDProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->deviceUUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->deviceUUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->driverUUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->driverUUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->deviceLUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->deviceLUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->deviceNodeMask));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->deviceNodeMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceIDProperties *)0)->deviceLUIDValid));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceIDProperties *)0)->deviceLUIDValid);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceIDProperties::flush() {
  _VkPhysicalDeviceIDProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->deviceUUID.IsEmpty())) {
    Napi::Value value = self->deviceUUID.Value();
    
  }if (!(self->driverUUID.IsEmpty())) {
    Napi::Value value = self->driverUUID.Value();
    
  }if (!(self->deviceLUID.IsEmpty())) {
    Napi::Value value = self->deviceLUID.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceIDProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceIDProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceIDProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceIDProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceIDProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceIDProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceIDProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceIDProperties.pNext", "[object Object]");
  
    return;
  }
}// deviceUUID
Napi::Value _VkPhysicalDeviceIDProperties::GetdeviceUUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->deviceUUID.IsEmpty()) return env.Null();
  return this->deviceUUID.Value().As<Napi::Array>();
}// driverUUID
Napi::Value _VkPhysicalDeviceIDProperties::GetdriverUUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->driverUUID.IsEmpty()) return env.Null();
  return this->driverUUID.Value().As<Napi::Array>();
}// deviceLUID
Napi::Value _VkPhysicalDeviceIDProperties::GetdeviceLUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->deviceLUID.IsEmpty()) return env.Null();
  return this->deviceLUID.Value().As<Napi::Array>();
}// deviceNodeMask
Napi::Value _VkPhysicalDeviceIDProperties::GetdeviceNodeMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceNodeMask);
}// deviceLUIDValid
Napi::Value _VkPhysicalDeviceIDProperties::GetdeviceLUIDValid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceLUIDValid);
}
/** ## END VkPhysicalDeviceIDProperties ## **/

/** ## BEGIN VkExternalBufferPropertiesKHR ## **/

Napi::FunctionReference _VkExternalBufferPropertiesKHR::constructor;

_VkExternalBufferPropertiesKHR::_VkExternalBufferPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalBufferPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalBufferPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalBufferPropertiesKHR::~_VkExternalBufferPropertiesKHR() {
  
  
  pNext.Reset();
  
  externalMemoryProperties.Reset();
  
}

Napi::Object _VkExternalBufferPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalBufferPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalBufferPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalBufferPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalBufferPropertiesKHR::GetsType,
    &_VkExternalBufferPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalBufferPropertiesKHR::GetpNext,
    &_VkExternalBufferPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalMemoryProperties",
    &_VkExternalBufferPropertiesKHR::GetexternalMemoryProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalBufferPropertiesKHR", func);
  return exports;
}

Napi::Value _VkExternalBufferPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalBufferPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalBufferPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalBufferPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalBufferPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalBufferPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalBufferPropertiesKHR *)0)->externalMemoryProperties));
    uint32_t byteLength = sizeof(((VkExternalBufferPropertiesKHR *)0)->externalMemoryProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalBufferPropertiesKHR::flush() {
  _VkExternalBufferPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->externalMemoryProperties.IsEmpty())) {
    Napi::Value value = self->externalMemoryProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalBufferPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalBufferPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalBufferPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalBufferPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalBufferPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalBufferPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalBufferPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalBufferPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// externalMemoryProperties
Napi::Value _VkExternalBufferPropertiesKHR::GetexternalMemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->externalMemoryProperties.IsEmpty()) return env.Null();
  return this->externalMemoryProperties.Value().As<Napi::Object>();
}
/** ## END VkExternalBufferPropertiesKHR ## **/

/** ## BEGIN VkExternalBufferProperties ## **/

Napi::FunctionReference _VkExternalBufferProperties::constructor;

_VkExternalBufferProperties::_VkExternalBufferProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalBufferProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalBufferProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalBufferProperties::~_VkExternalBufferProperties() {
  
  
  pNext.Reset();
  
  externalMemoryProperties.Reset();
  
}

Napi::Object _VkExternalBufferProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalBufferProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalBufferProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalBufferProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalBufferProperties::GetsType,
    &_VkExternalBufferProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalBufferProperties::GetpNext,
    &_VkExternalBufferProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalMemoryProperties",
    &_VkExternalBufferProperties::GetexternalMemoryProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalBufferProperties", func);
  return exports;
}

Napi::Value _VkExternalBufferProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalBufferProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalBufferProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalBufferProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalBufferProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalBufferProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalBufferProperties *)0)->externalMemoryProperties));
    uint32_t byteLength = sizeof(((VkExternalBufferProperties *)0)->externalMemoryProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalBufferProperties::flush() {
  _VkExternalBufferProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->externalMemoryProperties.IsEmpty())) {
    Napi::Value value = self->externalMemoryProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalBufferProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalBufferProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalBufferProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalBufferProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalBufferProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalBufferProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalBufferProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalBufferProperties.pNext", "[object Object]");
  
    return;
  }
}// externalMemoryProperties
Napi::Value _VkExternalBufferProperties::GetexternalMemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->externalMemoryProperties.IsEmpty()) return env.Null();
  return this->externalMemoryProperties.Value().As<Napi::Object>();
}
/** ## END VkExternalBufferProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalBufferInfoKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalBufferInfoKHR::constructor;

_VkPhysicalDeviceExternalBufferInfoKHR::_VkPhysicalDeviceExternalBufferInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalBufferInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "usage");
      Napi::String sAccess4 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setusage(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SethandleType(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalBufferInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalBufferInfoKHR::~_VkPhysicalDeviceExternalBufferInfoKHR() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPhysicalDeviceExternalBufferInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalBufferInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalBufferInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalBufferInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalBufferInfoKHR::GetsType,
    &_VkPhysicalDeviceExternalBufferInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalBufferInfoKHR::GetpNext,
    &_VkPhysicalDeviceExternalBufferInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPhysicalDeviceExternalBufferInfoKHR::Getflags,
    &_VkPhysicalDeviceExternalBufferInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkPhysicalDeviceExternalBufferInfoKHR::Getusage,
    &_VkPhysicalDeviceExternalBufferInfoKHR::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalBufferInfoKHR::GethandleType,
    &_VkPhysicalDeviceExternalBufferInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalBufferInfoKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->usage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalBufferInfoKHR::flush() {
  _VkPhysicalDeviceExternalBufferInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalBufferInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalBufferInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalBufferInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPhysicalDeviceExternalBufferInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkBufferCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfoKHR.flags", "Number");
  
    return;
  }
}// usage
Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkPhysicalDeviceExternalBufferInfoKHR::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkBufferUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfoKHR.usage", "Number");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalBufferInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalBufferInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalBufferInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalBufferInfo ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalBufferInfo::constructor;

_VkPhysicalDeviceExternalBufferInfo::_VkPhysicalDeviceExternalBufferInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalBufferInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "usage");
      Napi::String sAccess4 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setusage(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SethandleType(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalBufferInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalBufferInfo::~_VkPhysicalDeviceExternalBufferInfo() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPhysicalDeviceExternalBufferInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalBufferInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalBufferInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalBufferInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalBufferInfo::GetsType,
    &_VkPhysicalDeviceExternalBufferInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalBufferInfo::GetpNext,
    &_VkPhysicalDeviceExternalBufferInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPhysicalDeviceExternalBufferInfo::Getflags,
    &_VkPhysicalDeviceExternalBufferInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkPhysicalDeviceExternalBufferInfo::Getusage,
    &_VkPhysicalDeviceExternalBufferInfo::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalBufferInfo::GethandleType,
    &_VkPhysicalDeviceExternalBufferInfo::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalBufferInfo", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalBufferInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalBufferInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfo *)0)->usage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfo *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalBufferInfo *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalBufferInfo *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalBufferInfo::flush() {
  _VkPhysicalDeviceExternalBufferInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalBufferInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalBufferInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalBufferInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalBufferInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalBufferInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPhysicalDeviceExternalBufferInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPhysicalDeviceExternalBufferInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkBufferCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfo.flags", "Number");
  
    return;
  }
}// usage
Napi::Value _VkPhysicalDeviceExternalBufferInfo::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkPhysicalDeviceExternalBufferInfo::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkBufferUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfo.usage", "Number");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalBufferInfo::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalBufferInfo::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalBufferInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalBufferInfo ## **/

/** ## BEGIN VkExternalImageFormatPropertiesKHR ## **/

Napi::FunctionReference _VkExternalImageFormatPropertiesKHR::constructor;

_VkExternalImageFormatPropertiesKHR::_VkExternalImageFormatPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalImageFormatPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalImageFormatPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalImageFormatPropertiesKHR::~_VkExternalImageFormatPropertiesKHR() {
  
  
  pNext.Reset();
  
  externalMemoryProperties.Reset();
  
}

Napi::Object _VkExternalImageFormatPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalImageFormatPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalImageFormatPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalImageFormatPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalImageFormatPropertiesKHR::GetsType,
    &_VkExternalImageFormatPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalImageFormatPropertiesKHR::GetpNext,
    &_VkExternalImageFormatPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalMemoryProperties",
    &_VkExternalImageFormatPropertiesKHR::GetexternalMemoryProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalImageFormatPropertiesKHR", func);
  return exports;
}

Napi::Value _VkExternalImageFormatPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalImageFormatPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesKHR *)0)->externalMemoryProperties));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesKHR *)0)->externalMemoryProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalImageFormatPropertiesKHR::flush() {
  _VkExternalImageFormatPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->externalMemoryProperties.IsEmpty())) {
    Napi::Value value = self->externalMemoryProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalImageFormatPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalImageFormatPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalImageFormatPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalImageFormatPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalImageFormatPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalImageFormatPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalImageFormatPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalImageFormatPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// externalMemoryProperties
Napi::Value _VkExternalImageFormatPropertiesKHR::GetexternalMemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->externalMemoryProperties.IsEmpty()) return env.Null();
  return this->externalMemoryProperties.Value().As<Napi::Object>();
}
/** ## END VkExternalImageFormatPropertiesKHR ## **/

/** ## BEGIN VkExternalImageFormatProperties ## **/

Napi::FunctionReference _VkExternalImageFormatProperties::constructor;

_VkExternalImageFormatProperties::_VkExternalImageFormatProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalImageFormatProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExternalImageFormatProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalImageFormatProperties::~_VkExternalImageFormatProperties() {
  
  
  pNext.Reset();
  
  externalMemoryProperties.Reset();
  
}

Napi::Object _VkExternalImageFormatProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalImageFormatProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalImageFormatProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalImageFormatProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalImageFormatProperties::GetsType,
    &_VkExternalImageFormatProperties::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalImageFormatProperties::GetpNext,
    &_VkExternalImageFormatProperties::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalMemoryProperties",
    &_VkExternalImageFormatProperties::GetexternalMemoryProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalImageFormatProperties", func);
  return exports;
}

Napi::Value _VkExternalImageFormatProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalImageFormatProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatProperties *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalImageFormatProperties *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatProperties *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalImageFormatProperties *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatProperties *)0)->externalMemoryProperties));
    uint32_t byteLength = sizeof(((VkExternalImageFormatProperties *)0)->externalMemoryProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalImageFormatProperties::flush() {
  _VkExternalImageFormatProperties *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->externalMemoryProperties.IsEmpty())) {
    Napi::Value value = self->externalMemoryProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalImageFormatProperties::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalImageFormatProperties::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalImageFormatProperties.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalImageFormatProperties::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalImageFormatProperties::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalImageFormatProperties.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalImageFormatProperties.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalImageFormatProperties.pNext", "[object Object]");
  
    return;
  }
}// externalMemoryProperties
Napi::Value _VkExternalImageFormatProperties::GetexternalMemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->externalMemoryProperties.IsEmpty()) return env.Null();
  return this->externalMemoryProperties.Value().As<Napi::Object>();
}
/** ## END VkExternalImageFormatProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalImageFormatInfoKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalImageFormatInfoKHR::constructor;

_VkPhysicalDeviceExternalImageFormatInfoKHR::_VkPhysicalDeviceExternalImageFormatInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalImageFormatInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalImageFormatInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalImageFormatInfoKHR::~_VkPhysicalDeviceExternalImageFormatInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalImageFormatInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalImageFormatInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalImageFormatInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalImageFormatInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalImageFormatInfoKHR::GetsType,
    &_VkPhysicalDeviceExternalImageFormatInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalImageFormatInfoKHR::GetpNext,
    &_VkPhysicalDeviceExternalImageFormatInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalImageFormatInfoKHR::GethandleType,
    &_VkPhysicalDeviceExternalImageFormatInfoKHR::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalImageFormatInfoKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalImageFormatInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalImageFormatInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalImageFormatInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalImageFormatInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalImageFormatInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalImageFormatInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalImageFormatInfoKHR *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalImageFormatInfoKHR *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalImageFormatInfoKHR::flush() {
  _VkPhysicalDeviceExternalImageFormatInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalImageFormatInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalImageFormatInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalImageFormatInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalImageFormatInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalImageFormatInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalImageFormatInfoKHR::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalImageFormatInfoKHR::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalImageFormatInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalImageFormatInfo ## **/

Napi::FunctionReference _VkPhysicalDeviceExternalImageFormatInfo::constructor;

_VkPhysicalDeviceExternalImageFormatInfo::_VkPhysicalDeviceExternalImageFormatInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceExternalImageFormatInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceExternalImageFormatInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceExternalImageFormatInfo::~_VkPhysicalDeviceExternalImageFormatInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDeviceExternalImageFormatInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceExternalImageFormatInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceExternalImageFormatInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceExternalImageFormatInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceExternalImageFormatInfo::GetsType,
    &_VkPhysicalDeviceExternalImageFormatInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceExternalImageFormatInfo::GetpNext,
    &_VkPhysicalDeviceExternalImageFormatInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkPhysicalDeviceExternalImageFormatInfo::GethandleType,
    &_VkPhysicalDeviceExternalImageFormatInfo::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceExternalImageFormatInfo", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceExternalImageFormatInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceExternalImageFormatInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalImageFormatInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalImageFormatInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalImageFormatInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalImageFormatInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceExternalImageFormatInfo *)0)->handleType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceExternalImageFormatInfo *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceExternalImageFormatInfo::flush() {
  _VkPhysicalDeviceExternalImageFormatInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceExternalImageFormatInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceExternalImageFormatInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceExternalImageFormatInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceExternalImageFormatInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceExternalImageFormatInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfo.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkPhysicalDeviceExternalImageFormatInfo::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkPhysicalDeviceExternalImageFormatInfo::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceExternalImageFormatInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalImageFormatInfo ## **/

/** ## BEGIN VkExternalMemoryPropertiesKHR ## **/

Napi::FunctionReference _VkExternalMemoryPropertiesKHR::constructor;

_VkExternalMemoryPropertiesKHR::_VkExternalMemoryPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryPropertiesKHR::~_VkExternalMemoryPropertiesKHR() {
  
  
  
  
}

Napi::Object _VkExternalMemoryPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "externalMemoryFeatures",
    &_VkExternalMemoryPropertiesKHR::GetexternalMemoryFeatures,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalMemoryPropertiesKHR::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalMemoryPropertiesKHR::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryPropertiesKHR", func);
  return exports;
}

Napi::Value _VkExternalMemoryPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryPropertiesKHR *)0)->externalMemoryFeatures));
    uint32_t byteLength = sizeof(((VkExternalMemoryPropertiesKHR *)0)->externalMemoryFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryPropertiesKHR *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryPropertiesKHR *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryPropertiesKHR *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryPropertiesKHR *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryPropertiesKHR::flush() {
  _VkExternalMemoryPropertiesKHR *self = this;
  
  return true;
}

// externalMemoryFeatures
Napi::Value _VkExternalMemoryPropertiesKHR::GetexternalMemoryFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalMemoryFeatures);
}// exportFromImportedHandleTypes
Napi::Value _VkExternalMemoryPropertiesKHR::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalMemoryPropertiesKHR::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}
/** ## END VkExternalMemoryPropertiesKHR ## **/

/** ## BEGIN VkExternalMemoryProperties ## **/

Napi::FunctionReference _VkExternalMemoryProperties::constructor;

_VkExternalMemoryProperties::_VkExternalMemoryProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryProperties::~_VkExternalMemoryProperties() {
  
  
  
  
}

Napi::Object _VkExternalMemoryProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "externalMemoryFeatures",
    &_VkExternalMemoryProperties::GetexternalMemoryFeatures,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalMemoryProperties::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalMemoryProperties::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryProperties", func);
  return exports;
}

Napi::Value _VkExternalMemoryProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryProperties *)0)->externalMemoryFeatures));
    uint32_t byteLength = sizeof(((VkExternalMemoryProperties *)0)->externalMemoryFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryProperties *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryProperties *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryProperties *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryProperties *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryProperties::flush() {
  _VkExternalMemoryProperties *self = this;
  
  return true;
}

// externalMemoryFeatures
Napi::Value _VkExternalMemoryProperties::GetexternalMemoryFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalMemoryFeatures);
}// exportFromImportedHandleTypes
Napi::Value _VkExternalMemoryProperties::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalMemoryProperties::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}
/** ## END VkExternalMemoryProperties ## **/

/** ## BEGIN VkPhysicalDeviceVariablePointerFeaturesKHR ## **/

Napi::FunctionReference _VkPhysicalDeviceVariablePointerFeaturesKHR::constructor;

_VkPhysicalDeviceVariablePointerFeaturesKHR::_VkPhysicalDeviceVariablePointerFeaturesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceVariablePointerFeaturesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "variablePointersStorageBuffer");
      Napi::String sAccess3 = Napi::String::New(env, "variablePointers");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetvariablePointersStorageBuffer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetvariablePointers(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceVariablePointerFeaturesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceVariablePointerFeaturesKHR::~_VkPhysicalDeviceVariablePointerFeaturesKHR() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceVariablePointerFeaturesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceVariablePointerFeaturesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceVariablePointerFeaturesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceVariablePointerFeaturesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::GetsType,
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::GetpNext,
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "variablePointersStorageBuffer",
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::GetvariablePointersStorageBuffer,
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::SetvariablePointersStorageBuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "variablePointers",
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::GetvariablePointers,
    &_VkPhysicalDeviceVariablePointerFeaturesKHR::SetvariablePointers,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceVariablePointerFeaturesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceVariablePointerFeaturesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceVariablePointerFeaturesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->variablePointersStorageBuffer));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->variablePointersStorageBuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->variablePointers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeaturesKHR *)0)->variablePointers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceVariablePointerFeaturesKHR::flush() {
  _VkPhysicalDeviceVariablePointerFeaturesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceVariablePointerFeaturesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceVariablePointerFeaturesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeaturesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceVariablePointerFeaturesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceVariablePointerFeaturesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceVariablePointerFeaturesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeaturesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeaturesKHR.pNext", "[object Object]");
  
    return;
  }
}// variablePointersStorageBuffer
Napi::Value _VkPhysicalDeviceVariablePointerFeaturesKHR::GetvariablePointersStorageBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.variablePointersStorageBuffer);
}void _VkPhysicalDeviceVariablePointerFeaturesKHR::SetvariablePointersStorageBuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.variablePointersStorageBuffer = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.variablePointersStorageBuffer = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeaturesKHR.variablePointersStorageBuffer", "Number");
  
    return;
  }
}// variablePointers
Napi::Value _VkPhysicalDeviceVariablePointerFeaturesKHR::GetvariablePointers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.variablePointers);
}void _VkPhysicalDeviceVariablePointerFeaturesKHR::SetvariablePointers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.variablePointers = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.variablePointers = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeaturesKHR.variablePointers", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceVariablePointerFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceVariablePointerFeatures ## **/

Napi::FunctionReference _VkPhysicalDeviceVariablePointerFeatures::constructor;

_VkPhysicalDeviceVariablePointerFeatures::_VkPhysicalDeviceVariablePointerFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceVariablePointerFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "variablePointersStorageBuffer");
      Napi::String sAccess3 = Napi::String::New(env, "variablePointers");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetvariablePointersStorageBuffer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetvariablePointers(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceVariablePointerFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceVariablePointerFeatures::~_VkPhysicalDeviceVariablePointerFeatures() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPhysicalDeviceVariablePointerFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceVariablePointerFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceVariablePointerFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceVariablePointerFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceVariablePointerFeatures::GetsType,
    &_VkPhysicalDeviceVariablePointerFeatures::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceVariablePointerFeatures::GetpNext,
    &_VkPhysicalDeviceVariablePointerFeatures::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "variablePointersStorageBuffer",
    &_VkPhysicalDeviceVariablePointerFeatures::GetvariablePointersStorageBuffer,
    &_VkPhysicalDeviceVariablePointerFeatures::SetvariablePointersStorageBuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "variablePointers",
    &_VkPhysicalDeviceVariablePointerFeatures::GetvariablePointers,
    &_VkPhysicalDeviceVariablePointerFeatures::SetvariablePointers,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceVariablePointerFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceVariablePointerFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceVariablePointerFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeatures *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeatures *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeatures *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeatures *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeatures *)0)->variablePointersStorageBuffer));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeatures *)0)->variablePointersStorageBuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceVariablePointerFeatures *)0)->variablePointers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceVariablePointerFeatures *)0)->variablePointers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceVariablePointerFeatures::flush() {
  _VkPhysicalDeviceVariablePointerFeatures *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceVariablePointerFeatures::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceVariablePointerFeatures::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceVariablePointerFeatures::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceVariablePointerFeatures::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceVariablePointerFeatures.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.pNext", "[object Object]");
  
    return;
  }
}// variablePointersStorageBuffer
Napi::Value _VkPhysicalDeviceVariablePointerFeatures::GetvariablePointersStorageBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.variablePointersStorageBuffer);
}void _VkPhysicalDeviceVariablePointerFeatures::SetvariablePointersStorageBuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.variablePointersStorageBuffer = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.variablePointersStorageBuffer = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.variablePointersStorageBuffer", "Number");
  
    return;
  }
}// variablePointers
Napi::Value _VkPhysicalDeviceVariablePointerFeatures::GetvariablePointers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.variablePointers);
}void _VkPhysicalDeviceVariablePointerFeatures::SetvariablePointers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.variablePointers = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.variablePointers = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.variablePointers", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceVariablePointerFeatures ## **/

/** ## BEGIN VkRectLayerKHR ## **/

Napi::FunctionReference _VkRectLayerKHR::constructor;

_VkRectLayerKHR::_VkRectLayerKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRectLayerKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "offset");
      Napi::String sAccess1 = Napi::String::New(env, "extent");
      Napi::String sAccess2 = Napi::String::New(env, "layer");
      if (obj.Has(sAccess0)) this->Setoffset(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setextent(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setlayer(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkRectLayerKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkRectLayerKHR::~_VkRectLayerKHR() {
  
  offset.Reset();
  
  extent.Reset();
  
  
}

Napi::Object _VkRectLayerKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRectLayerKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRectLayerKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRectLayerKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "offset",
    &_VkRectLayerKHR::Getoffset,
    &_VkRectLayerKHR::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "extent",
    &_VkRectLayerKHR::Getextent,
    &_VkRectLayerKHR::Setextent,
    napi_enumerable
  ),
  InstanceAccessor(
    "layer",
    &_VkRectLayerKHR::Getlayer,
    &_VkRectLayerKHR::Setlayer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRectLayerKHR", func);
  return exports;
}

Napi::Value _VkRectLayerKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRectLayerKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRectLayerKHR *)0)->offset));
    uint32_t byteLength = sizeof(((VkRectLayerKHR *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRectLayerKHR *)0)->extent));
    uint32_t byteLength = sizeof(((VkRectLayerKHR *)0)->extent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRectLayerKHR *)0)->layer));
    uint32_t byteLength = sizeof(((VkRectLayerKHR *)0)->layer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRectLayerKHR::flush() {
  _VkRectLayerKHR *self = this;
  if (!(self->offset.IsEmpty())) {
    Napi::Value value = self->offset.Value();
    
    _VkOffset2D* result = Napi::ObjectWrap<_VkOffset2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.offset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    Napi::Value value = self->extent.Value();
    
    _VkExtent2D* result = Napi::ObjectWrap<_VkExtent2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

// offset
Napi::Value _VkRectLayerKHR::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->offset.IsEmpty()) return env.Null();
  return this->offset.Value().As<Napi::Object>();
}void _VkRectLayerKHR::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset2D::constructor.Value())) {
      
      this->offset.Reset(value.ToObject(), 1);
      _VkOffset2D* inst = Napi::ObjectWrap<_VkOffset2D>::Unwrap(obj);
      inst->flush();
      this->instance.offset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRectLayerKHR.offset", "[object VkOffset2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->offset.Reset();
    memset(&this->instance.offset, 0, sizeof(VkOffset2D));
  } else {
    
    NapiObjectTypeError(value, "VkRectLayerKHR.offset", "[object VkOffset2D]");
  
    return;
  }
}// extent
Napi::Value _VkRectLayerKHR::Getextent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extent.IsEmpty()) return env.Null();
  return this->extent.Value().As<Napi::Object>();
}void _VkRectLayerKHR::Setextent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent2D::constructor.Value())) {
      
      this->extent.Reset(value.ToObject(), 1);
      _VkExtent2D* inst = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
      inst->flush();
      this->instance.extent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRectLayerKHR.extent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->extent.Reset();
    memset(&this->instance.extent, 0, sizeof(VkExtent2D));
  } else {
    
    NapiObjectTypeError(value, "VkRectLayerKHR.extent", "[object VkExtent2D]");
  
    return;
  }
}// layer
Napi::Value _VkRectLayerKHR::Getlayer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layer);
}void _VkRectLayerKHR::Setlayer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layer = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRectLayerKHR.layer", "Number");
  
    return;
  }
}
/** ## END VkRectLayerKHR ## **/

/** ## BEGIN VkPresentRegionKHR ## **/

Napi::FunctionReference _VkPresentRegionKHR::constructor;

_VkPresentRegionKHR::_VkPresentRegionKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPresentRegionKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpRectangles = new std::vector<VkRectLayerKHR>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "rectangleCount");
      Napi::String sAccess1 = Napi::String::New(env, "pRectangles");
      if (obj.Has(sAccess0)) this->SetrectangleCount(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpRectangles(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPresentRegionKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPresentRegionKHR::~_VkPresentRegionKHR() {
  
  
  vpRectangles->clear();
  delete vpRectangles;
  
  pRectangles.Reset();
  
}

Napi::Object _VkPresentRegionKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPresentRegionKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPresentRegionKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPresentRegionKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "rectangleCount",
    &_VkPresentRegionKHR::GetrectangleCount,
    &_VkPresentRegionKHR::SetrectangleCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pRectangles",
    &_VkPresentRegionKHR::GetpRectangles,
    &_VkPresentRegionKHR::SetpRectangles,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPresentRegionKHR", func);
  return exports;
}

Napi::Value _VkPresentRegionKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPresentRegionKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentRegionKHR *)0)->rectangleCount));
    uint32_t byteLength = sizeof(((VkPresentRegionKHR *)0)->rectangleCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentRegionKHR *)0)->pRectangles));
    uint32_t byteLength = sizeof(((VkPresentRegionKHR *)0)->pRectangles);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPresentRegionKHR::flush() {
  _VkPresentRegionKHR *self = this;
  if (!(self->pRectangles.IsEmpty())) {
    Napi::Value value = self->pRectangles.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.rectangleCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'rectangleCount' for 'VkPresentRegionKHR.pRectangles'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRectLayerKHR>* data = this->vpRectangles;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRectLayerKHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPresentRegionKHR.pRectangles", "[object VkRectLayerKHR]");
  
        return false;
      }
      _VkRectLayerKHR* result = Napi::ObjectWrap<_VkRectLayerKHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pRectangles = data->data();
  }
  return true;
}

// rectangleCount
Napi::Value _VkPresentRegionKHR::GetrectangleCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.rectangleCount);
}void _VkPresentRegionKHR::SetrectangleCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.rectangleCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentRegionKHR.rectangleCount", "Number");
  
    return;
  }
}// pRectangles
Napi::Value _VkPresentRegionKHR::GetpRectangles(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pRectangles.IsEmpty()) return env.Null();
  return this->pRectangles.Value().As<Napi::Array>();
}void _VkPresentRegionKHR::SetpRectangles(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pRectangles.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pRectangles.Reset();
      this->instance.pRectangles = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPresentRegionKHR.pRectangles", "[object VkRectLayerKHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pRectangles = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPresentRegionKHR.pRectangles", "[object VkRectLayerKHR]");
  
    return;
  }
}
/** ## END VkPresentRegionKHR ## **/

/** ## BEGIN VkPresentRegionsKHR ## **/

Napi::FunctionReference _VkPresentRegionsKHR::constructor;

_VkPresentRegionsKHR::_VkPresentRegionsKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPresentRegionsKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
    vpRegions = new std::vector<VkPresentRegionKHR>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "swapchainCount");
      Napi::String sAccess3 = Napi::String::New(env, "pRegions");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetswapchainCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpRegions(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPresentRegionsKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPresentRegionsKHR::~_VkPresentRegionsKHR() {
  
  
  pNext.Reset();
  
  
  vpRegions->clear();
  delete vpRegions;
  
  pRegions.Reset();
  
}

Napi::Object _VkPresentRegionsKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPresentRegionsKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPresentRegionsKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPresentRegionsKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPresentRegionsKHR::GetsType,
    &_VkPresentRegionsKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPresentRegionsKHR::GetpNext,
    &_VkPresentRegionsKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchainCount",
    &_VkPresentRegionsKHR::GetswapchainCount,
    &_VkPresentRegionsKHR::SetswapchainCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pRegions",
    &_VkPresentRegionsKHR::GetpRegions,
    &_VkPresentRegionsKHR::SetpRegions,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPresentRegionsKHR", func);
  return exports;
}

Napi::Value _VkPresentRegionsKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPresentRegionsKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentRegionsKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPresentRegionsKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentRegionsKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPresentRegionsKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentRegionsKHR *)0)->swapchainCount));
    uint32_t byteLength = sizeof(((VkPresentRegionsKHR *)0)->swapchainCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentRegionsKHR *)0)->pRegions));
    uint32_t byteLength = sizeof(((VkPresentRegionsKHR *)0)->pRegions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPresentRegionsKHR::flush() {
  _VkPresentRegionsKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pRegions.IsEmpty())) {
    Napi::Value value = self->pRegions.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.swapchainCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'swapchainCount' for 'VkPresentRegionsKHR.pRegions'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPresentRegionKHR>* data = this->vpRegions;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPresentRegionKHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPresentRegionsKHR.pRegions", "[object VkPresentRegionKHR]");
  
        return false;
      }
      _VkPresentRegionKHR* result = Napi::ObjectWrap<_VkPresentRegionKHR>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pRegions = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPresentRegionsKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPresentRegionsKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentRegionsKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPresentRegionsKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPresentRegionsKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPresentRegionsKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPresentRegionsKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPresentRegionsKHR.pNext", "[object Object]");
  
    return;
  }
}// swapchainCount
Napi::Value _VkPresentRegionsKHR::GetswapchainCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.swapchainCount);
}void _VkPresentRegionsKHR::SetswapchainCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.swapchainCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentRegionsKHR.swapchainCount", "Number");
  
    return;
  }
}// pRegions
Napi::Value _VkPresentRegionsKHR::GetpRegions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pRegions.IsEmpty()) return env.Null();
  return this->pRegions.Value().As<Napi::Array>();
}void _VkPresentRegionsKHR::SetpRegions(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pRegions.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pRegions.Reset();
      this->instance.pRegions = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPresentRegionsKHR.pRegions", "[object VkPresentRegionKHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pRegions = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPresentRegionsKHR.pRegions", "[object VkPresentRegionKHR]");
  
    return;
  }
}
/** ## END VkPresentRegionsKHR ## **/

/** ## BEGIN VkPhysicalDevicePushDescriptorPropertiesKHR ## **/

Napi::FunctionReference _VkPhysicalDevicePushDescriptorPropertiesKHR::constructor;

_VkPhysicalDevicePushDescriptorPropertiesKHR::_VkPhysicalDevicePushDescriptorPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDevicePushDescriptorPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "maxPushDescriptors");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetmaxPushDescriptors(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDevicePushDescriptorPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDevicePushDescriptorPropertiesKHR::~_VkPhysicalDevicePushDescriptorPropertiesKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPhysicalDevicePushDescriptorPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDevicePushDescriptorPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDevicePushDescriptorPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDevicePushDescriptorPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDevicePushDescriptorPropertiesKHR::GetsType,
    &_VkPhysicalDevicePushDescriptorPropertiesKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDevicePushDescriptorPropertiesKHR::GetpNext,
    &_VkPhysicalDevicePushDescriptorPropertiesKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPushDescriptors",
    &_VkPhysicalDevicePushDescriptorPropertiesKHR::GetmaxPushDescriptors,
    &_VkPhysicalDevicePushDescriptorPropertiesKHR::SetmaxPushDescriptors,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDevicePushDescriptorPropertiesKHR", func);
  return exports;
}

Napi::Value _VkPhysicalDevicePushDescriptorPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDevicePushDescriptorPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePushDescriptorPropertiesKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePushDescriptorPropertiesKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePushDescriptorPropertiesKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePushDescriptorPropertiesKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDevicePushDescriptorPropertiesKHR *)0)->maxPushDescriptors));
    uint32_t byteLength = sizeof(((VkPhysicalDevicePushDescriptorPropertiesKHR *)0)->maxPushDescriptors);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDevicePushDescriptorPropertiesKHR::flush() {
  _VkPhysicalDevicePushDescriptorPropertiesKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDevicePushDescriptorPropertiesKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDevicePushDescriptorPropertiesKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePushDescriptorPropertiesKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDevicePushDescriptorPropertiesKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDevicePushDescriptorPropertiesKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDevicePushDescriptorPropertiesKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDevicePushDescriptorPropertiesKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePushDescriptorPropertiesKHR.pNext", "[object Object]");
  
    return;
  }
}// maxPushDescriptors
Napi::Value _VkPhysicalDevicePushDescriptorPropertiesKHR::GetmaxPushDescriptors(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPushDescriptors);
}void _VkPhysicalDevicePushDescriptorPropertiesKHR::SetmaxPushDescriptors(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxPushDescriptors = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDevicePushDescriptorPropertiesKHR.maxPushDescriptors", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDevicePushDescriptorPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceSparseImageFormatInfo2KHR ## **/

Napi::FunctionReference _VkPhysicalDeviceSparseImageFormatInfo2KHR::constructor;

_VkPhysicalDeviceSparseImageFormatInfo2KHR::_VkPhysicalDeviceSparseImageFormatInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSparseImageFormatInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "type");
      Napi::String sAccess4 = Napi::String::New(env, "samples");
      Napi::String sAccess5 = Napi::String::New(env, "usage");
      Napi::String sAccess6 = Napi::String::New(env, "tiling");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Settype(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setsamples(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setusage(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Settiling(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSparseImageFormatInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSparseImageFormatInfo2KHR::~_VkPhysicalDeviceSparseImageFormatInfo2KHR() {
  
  
  pNext.Reset();
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceSparseImageFormatInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSparseImageFormatInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSparseImageFormatInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSparseImageFormatInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::GetsType,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::GetpNext,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Getformat,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "type",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Gettype,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "samples",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Getsamples,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Setsamples,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Getusage,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "tiling",
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Gettiling,
    &_VkPhysicalDeviceSparseImageFormatInfo2KHR::Settiling,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSparseImageFormatInfo2KHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->format));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->type));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->samples));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->usage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->tiling));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2KHR *)0)->tiling);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSparseImageFormatInfo2KHR::flush() {
  _VkPhysicalDeviceSparseImageFormatInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// format
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.format", "Number");
  
    return;
  }
}// type
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkImageType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.type", "Number");
  
    return;
  }
}// samples
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::Getsamples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samples);
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::Setsamples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.samples = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.samples", "Number");
  
    return;
  }
}// usage
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.usage", "Number");
  
    return;
  }
}// tiling
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2KHR::Gettiling(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tiling);
}void _VkPhysicalDeviceSparseImageFormatInfo2KHR::Settiling(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tiling = static_cast<VkImageTiling>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSparseImageFormatInfo2KHR ## **/

/** ## BEGIN VkPhysicalDeviceSparseImageFormatInfo2 ## **/

Napi::FunctionReference _VkPhysicalDeviceSparseImageFormatInfo2::constructor;

_VkPhysicalDeviceSparseImageFormatInfo2::_VkPhysicalDeviceSparseImageFormatInfo2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "type");
      Napi::String sAccess4 = Napi::String::New(env, "samples");
      Napi::String sAccess5 = Napi::String::New(env, "usage");
      Napi::String sAccess6 = Napi::String::New(env, "tiling");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Settype(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setsamples(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setusage(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Settiling(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSparseImageFormatInfo2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSparseImageFormatInfo2::~_VkPhysicalDeviceSparseImageFormatInfo2() {
  
  
  pNext.Reset();
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceSparseImageFormatInfo2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSparseImageFormatInfo2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSparseImageFormatInfo2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSparseImageFormatInfo2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceSparseImageFormatInfo2::GetsType,
    &_VkPhysicalDeviceSparseImageFormatInfo2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceSparseImageFormatInfo2::GetpNext,
    &_VkPhysicalDeviceSparseImageFormatInfo2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkPhysicalDeviceSparseImageFormatInfo2::Getformat,
    &_VkPhysicalDeviceSparseImageFormatInfo2::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "type",
    &_VkPhysicalDeviceSparseImageFormatInfo2::Gettype,
    &_VkPhysicalDeviceSparseImageFormatInfo2::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "samples",
    &_VkPhysicalDeviceSparseImageFormatInfo2::Getsamples,
    &_VkPhysicalDeviceSparseImageFormatInfo2::Setsamples,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkPhysicalDeviceSparseImageFormatInfo2::Getusage,
    &_VkPhysicalDeviceSparseImageFormatInfo2::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "tiling",
    &_VkPhysicalDeviceSparseImageFormatInfo2::Gettiling,
    &_VkPhysicalDeviceSparseImageFormatInfo2::Settiling,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSparseImageFormatInfo2", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->format));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->type));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->samples));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->usage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->tiling));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseImageFormatInfo2 *)0)->tiling);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSparseImageFormatInfo2::flush() {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceSparseImageFormatInfo2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceSparseImageFormatInfo2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceSparseImageFormatInfo2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.pNext", "[object Object]");
  
    return;
  }
}// format
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkPhysicalDeviceSparseImageFormatInfo2::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.format", "Number");
  
    return;
  }
}// type
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkPhysicalDeviceSparseImageFormatInfo2::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkImageType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.type", "Number");
  
    return;
  }
}// samples
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::Getsamples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samples);
}void _VkPhysicalDeviceSparseImageFormatInfo2::Setsamples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.samples = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.samples", "Number");
  
    return;
  }
}// usage
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkPhysicalDeviceSparseImageFormatInfo2::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.usage", "Number");
  
    return;
  }
}// tiling
Napi::Value _VkPhysicalDeviceSparseImageFormatInfo2::Gettiling(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tiling);
}void _VkPhysicalDeviceSparseImageFormatInfo2::Settiling(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tiling = static_cast<VkImageTiling>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.tiling", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSparseImageFormatInfo2 ## **/

/** ## BEGIN VkSparseImageFormatProperties2KHR ## **/

Napi::FunctionReference _VkSparseImageFormatProperties2KHR::constructor;

_VkSparseImageFormatProperties2KHR::_VkSparseImageFormatProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageFormatProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSparseImageFormatProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageFormatProperties2KHR::~_VkSparseImageFormatProperties2KHR() {
  
  
  pNext.Reset();
  
  properties.Reset();
  
}

Napi::Object _VkSparseImageFormatProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageFormatProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageFormatProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageFormatProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSparseImageFormatProperties2KHR::GetsType,
    &_VkSparseImageFormatProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSparseImageFormatProperties2KHR::GetpNext,
    &_VkSparseImageFormatProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "properties",
    &_VkSparseImageFormatProperties2KHR::Getproperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageFormatProperties2KHR", func);
  return exports;
}

Napi::Value _VkSparseImageFormatProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageFormatProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties2KHR *)0)->properties));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties2KHR *)0)->properties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageFormatProperties2KHR::flush() {
  _VkSparseImageFormatProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->properties.IsEmpty())) {
    Napi::Value value = self->properties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSparseImageFormatProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSparseImageFormatProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageFormatProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSparseImageFormatProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSparseImageFormatProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSparseImageFormatProperties2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageFormatProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageFormatProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// properties
Napi::Value _VkSparseImageFormatProperties2KHR::Getproperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->properties.IsEmpty()) return env.Null();
  return this->properties.Value().As<Napi::Object>();
}
/** ## END VkSparseImageFormatProperties2KHR ## **/

/** ## BEGIN VkSparseImageFormatProperties2 ## **/

Napi::FunctionReference _VkSparseImageFormatProperties2::constructor;

_VkSparseImageFormatProperties2::_VkSparseImageFormatProperties2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageFormatProperties2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkSparseImageFormatProperties2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageFormatProperties2::~_VkSparseImageFormatProperties2() {
  
  
  pNext.Reset();
  
  properties.Reset();
  
}

Napi::Object _VkSparseImageFormatProperties2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageFormatProperties2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageFormatProperties2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageFormatProperties2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSparseImageFormatProperties2::GetsType,
    &_VkSparseImageFormatProperties2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSparseImageFormatProperties2::GetpNext,
    &_VkSparseImageFormatProperties2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "properties",
    &_VkSparseImageFormatProperties2::Getproperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageFormatProperties2", func);
  return exports;
}

Napi::Value _VkSparseImageFormatProperties2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageFormatProperties2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties2 *)0)->properties));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties2 *)0)->properties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageFormatProperties2::flush() {
  _VkSparseImageFormatProperties2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->properties.IsEmpty())) {
    Napi::Value value = self->properties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkSparseImageFormatProperties2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSparseImageFormatProperties2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageFormatProperties2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSparseImageFormatProperties2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSparseImageFormatProperties2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkSparseImageFormatProperties2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageFormatProperties2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageFormatProperties2.pNext", "[object Object]");
  
    return;
  }
}// properties
Napi::Value _VkSparseImageFormatProperties2::Getproperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->properties.IsEmpty()) return env.Null();
  return this->properties.Value().As<Napi::Object>();
}
/** ## END VkSparseImageFormatProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceMemoryProperties2KHR ## **/

Napi::FunctionReference _VkPhysicalDeviceMemoryProperties2KHR::constructor;

_VkPhysicalDeviceMemoryProperties2KHR::_VkPhysicalDeviceMemoryProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMemoryProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMemoryProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMemoryProperties2KHR::~_VkPhysicalDeviceMemoryProperties2KHR() {
  
  
  pNext.Reset();
  
  memoryProperties.Reset();
  
}

Napi::Object _VkPhysicalDeviceMemoryProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMemoryProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMemoryProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMemoryProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMemoryProperties2KHR::GetsType,
    &_VkPhysicalDeviceMemoryProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMemoryProperties2KHR::GetpNext,
    &_VkPhysicalDeviceMemoryProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryProperties",
    &_VkPhysicalDeviceMemoryProperties2KHR::GetmemoryProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMemoryProperties2KHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMemoryProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMemoryProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties2KHR *)0)->memoryProperties));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties2KHR *)0)->memoryProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMemoryProperties2KHR::flush() {
  _VkPhysicalDeviceMemoryProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->memoryProperties.IsEmpty())) {
    Napi::Value value = self->memoryProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMemoryProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMemoryProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMemoryProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMemoryProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMemoryProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMemoryProperties2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMemoryProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMemoryProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// memoryProperties
Napi::Value _VkPhysicalDeviceMemoryProperties2KHR::GetmemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryProperties.IsEmpty()) return env.Null();
  return this->memoryProperties.Value().As<Napi::Object>();
}
/** ## END VkPhysicalDeviceMemoryProperties2KHR ## **/

/** ## BEGIN VkPhysicalDeviceMemoryProperties2 ## **/

Napi::FunctionReference _VkPhysicalDeviceMemoryProperties2::constructor;

_VkPhysicalDeviceMemoryProperties2::_VkPhysicalDeviceMemoryProperties2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMemoryProperties2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMemoryProperties2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMemoryProperties2::~_VkPhysicalDeviceMemoryProperties2() {
  
  
  pNext.Reset();
  
  memoryProperties.Reset();
  
}

Napi::Object _VkPhysicalDeviceMemoryProperties2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMemoryProperties2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMemoryProperties2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMemoryProperties2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceMemoryProperties2::GetsType,
    &_VkPhysicalDeviceMemoryProperties2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceMemoryProperties2::GetpNext,
    &_VkPhysicalDeviceMemoryProperties2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryProperties",
    &_VkPhysicalDeviceMemoryProperties2::GetmemoryProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMemoryProperties2", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMemoryProperties2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMemoryProperties2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties2 *)0)->memoryProperties));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties2 *)0)->memoryProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMemoryProperties2::flush() {
  _VkPhysicalDeviceMemoryProperties2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->memoryProperties.IsEmpty())) {
    Napi::Value value = self->memoryProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceMemoryProperties2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceMemoryProperties2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMemoryProperties2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceMemoryProperties2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceMemoryProperties2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPhysicalDeviceMemoryProperties2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceMemoryProperties2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceMemoryProperties2.pNext", "[object Object]");
  
    return;
  }
}// memoryProperties
Napi::Value _VkPhysicalDeviceMemoryProperties2::GetmemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryProperties.IsEmpty()) return env.Null();
  return this->memoryProperties.Value().As<Napi::Object>();
}
/** ## END VkPhysicalDeviceMemoryProperties2 ## **/

/** ## BEGIN VkQueueFamilyProperties2KHR ## **/

Napi::FunctionReference _VkQueueFamilyProperties2KHR::constructor;

_VkQueueFamilyProperties2KHR::_VkQueueFamilyProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueueFamilyProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkQueueFamilyProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkQueueFamilyProperties2KHR::~_VkQueueFamilyProperties2KHR() {
  
  
  pNext.Reset();
  
  queueFamilyProperties.Reset();
  
}

Napi::Object _VkQueueFamilyProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueueFamilyProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkQueueFamilyProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkQueueFamilyProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkQueueFamilyProperties2KHR::GetsType,
    &_VkQueueFamilyProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkQueueFamilyProperties2KHR::GetpNext,
    &_VkQueueFamilyProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyProperties",
    &_VkQueueFamilyProperties2KHR::GetqueueFamilyProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueueFamilyProperties2KHR", func);
  return exports;
}

Napi::Value _VkQueueFamilyProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkQueueFamilyProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties2KHR *)0)->queueFamilyProperties));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties2KHR *)0)->queueFamilyProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkQueueFamilyProperties2KHR::flush() {
  _VkQueueFamilyProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->queueFamilyProperties.IsEmpty())) {
    Napi::Value value = self->queueFamilyProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkQueueFamilyProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkQueueFamilyProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueueFamilyProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkQueueFamilyProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkQueueFamilyProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkQueueFamilyProperties2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkQueueFamilyProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkQueueFamilyProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// queueFamilyProperties
Napi::Value _VkQueueFamilyProperties2KHR::GetqueueFamilyProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->queueFamilyProperties.IsEmpty()) return env.Null();
  return this->queueFamilyProperties.Value().As<Napi::Object>();
}
/** ## END VkQueueFamilyProperties2KHR ## **/

/** ## BEGIN VkQueueFamilyProperties2 ## **/

Napi::FunctionReference _VkQueueFamilyProperties2::constructor;

_VkQueueFamilyProperties2::_VkQueueFamilyProperties2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueueFamilyProperties2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkQueueFamilyProperties2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkQueueFamilyProperties2::~_VkQueueFamilyProperties2() {
  
  
  pNext.Reset();
  
  queueFamilyProperties.Reset();
  
}

Napi::Object _VkQueueFamilyProperties2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueueFamilyProperties2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkQueueFamilyProperties2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkQueueFamilyProperties2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkQueueFamilyProperties2::GetsType,
    &_VkQueueFamilyProperties2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkQueueFamilyProperties2::GetpNext,
    &_VkQueueFamilyProperties2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyProperties",
    &_VkQueueFamilyProperties2::GetqueueFamilyProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueueFamilyProperties2", func);
  return exports;
}

Napi::Value _VkQueueFamilyProperties2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkQueueFamilyProperties2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties2 *)0)->queueFamilyProperties));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties2 *)0)->queueFamilyProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkQueueFamilyProperties2::flush() {
  _VkQueueFamilyProperties2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->queueFamilyProperties.IsEmpty())) {
    Napi::Value value = self->queueFamilyProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkQueueFamilyProperties2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkQueueFamilyProperties2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueueFamilyProperties2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkQueueFamilyProperties2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkQueueFamilyProperties2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkQueueFamilyProperties2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkQueueFamilyProperties2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkQueueFamilyProperties2.pNext", "[object Object]");
  
    return;
  }
}// queueFamilyProperties
Napi::Value _VkQueueFamilyProperties2::GetqueueFamilyProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->queueFamilyProperties.IsEmpty()) return env.Null();
  return this->queueFamilyProperties.Value().As<Napi::Object>();
}
/** ## END VkQueueFamilyProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceImageFormatInfo2KHR ## **/

Napi::FunctionReference _VkPhysicalDeviceImageFormatInfo2KHR::constructor;

_VkPhysicalDeviceImageFormatInfo2KHR::_VkPhysicalDeviceImageFormatInfo2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceImageFormatInfo2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "type");
      Napi::String sAccess4 = Napi::String::New(env, "tiling");
      Napi::String sAccess5 = Napi::String::New(env, "usage");
      Napi::String sAccess6 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Settype(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Settiling(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setusage(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setflags(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceImageFormatInfo2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceImageFormatInfo2KHR::~_VkPhysicalDeviceImageFormatInfo2KHR() {
  
  
  pNext.Reset();
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceImageFormatInfo2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceImageFormatInfo2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceImageFormatInfo2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceImageFormatInfo2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceImageFormatInfo2KHR::GetsType,
    &_VkPhysicalDeviceImageFormatInfo2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceImageFormatInfo2KHR::GetpNext,
    &_VkPhysicalDeviceImageFormatInfo2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkPhysicalDeviceImageFormatInfo2KHR::Getformat,
    &_VkPhysicalDeviceImageFormatInfo2KHR::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "type",
    &_VkPhysicalDeviceImageFormatInfo2KHR::Gettype,
    &_VkPhysicalDeviceImageFormatInfo2KHR::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "tiling",
    &_VkPhysicalDeviceImageFormatInfo2KHR::Gettiling,
    &_VkPhysicalDeviceImageFormatInfo2KHR::Settiling,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkPhysicalDeviceImageFormatInfo2KHR::Getusage,
    &_VkPhysicalDeviceImageFormatInfo2KHR::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPhysicalDeviceImageFormatInfo2KHR::Getflags,
    &_VkPhysicalDeviceImageFormatInfo2KHR::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceImageFormatInfo2KHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->format));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->type));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->tiling));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->tiling);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->usage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2KHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceImageFormatInfo2KHR::flush() {
  _VkPhysicalDeviceImageFormatInfo2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO) {
      _VkPhysicalDeviceExternalImageFormatInfo* structExt = Napi::ObjectWrap<_VkPhysicalDeviceExternalImageFormatInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceImageFormatInfo2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceImageFormatInfo2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.pNext", "[object Object]");
  
    return;
  }
}// format
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkPhysicalDeviceImageFormatInfo2KHR::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.format", "Number");
  
    return;
  }
}// type
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkPhysicalDeviceImageFormatInfo2KHR::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkImageType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.type", "Number");
  
    return;
  }
}// tiling
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::Gettiling(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tiling);
}void _VkPhysicalDeviceImageFormatInfo2KHR::Settiling(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tiling = static_cast<VkImageTiling>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.tiling", "Number");
  
    return;
  }
}// usage
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkPhysicalDeviceImageFormatInfo2KHR::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.usage", "Number");
  
    return;
  }
}// flags
Napi::Value _VkPhysicalDeviceImageFormatInfo2KHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPhysicalDeviceImageFormatInfo2KHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkImageCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2KHR.flags", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceImageFormatInfo2KHR ## **/

/** ## BEGIN VkPhysicalDeviceImageFormatInfo2 ## **/

Napi::FunctionReference _VkPhysicalDeviceImageFormatInfo2::constructor;

_VkPhysicalDeviceImageFormatInfo2::_VkPhysicalDeviceImageFormatInfo2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceImageFormatInfo2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "type");
      Napi::String sAccess4 = Napi::String::New(env, "tiling");
      Napi::String sAccess5 = Napi::String::New(env, "usage");
      Napi::String sAccess6 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Settype(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Settiling(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setusage(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setflags(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceImageFormatInfo2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceImageFormatInfo2::~_VkPhysicalDeviceImageFormatInfo2() {
  
  
  pNext.Reset();
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceImageFormatInfo2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceImageFormatInfo2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceImageFormatInfo2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceImageFormatInfo2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceImageFormatInfo2::GetsType,
    &_VkPhysicalDeviceImageFormatInfo2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceImageFormatInfo2::GetpNext,
    &_VkPhysicalDeviceImageFormatInfo2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkPhysicalDeviceImageFormatInfo2::Getformat,
    &_VkPhysicalDeviceImageFormatInfo2::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "type",
    &_VkPhysicalDeviceImageFormatInfo2::Gettype,
    &_VkPhysicalDeviceImageFormatInfo2::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "tiling",
    &_VkPhysicalDeviceImageFormatInfo2::Gettiling,
    &_VkPhysicalDeviceImageFormatInfo2::Settiling,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkPhysicalDeviceImageFormatInfo2::Getusage,
    &_VkPhysicalDeviceImageFormatInfo2::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPhysicalDeviceImageFormatInfo2::Getflags,
    &_VkPhysicalDeviceImageFormatInfo2::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceImageFormatInfo2", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceImageFormatInfo2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceImageFormatInfo2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->format));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->type));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->tiling));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->tiling);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->usage));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceImageFormatInfo2 *)0)->flags));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceImageFormatInfo2 *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceImageFormatInfo2::flush() {
  _VkPhysicalDeviceImageFormatInfo2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO) {
      _VkPhysicalDeviceExternalImageFormatInfo* structExt = Napi::ObjectWrap<_VkPhysicalDeviceExternalImageFormatInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceImageFormatInfo2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceImageFormatInfo2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceImageFormatInfo2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceImageFormatInfo2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.pNext", "[object Object]");
  
    return;
  }
}// format
Napi::Value _VkPhysicalDeviceImageFormatInfo2::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkPhysicalDeviceImageFormatInfo2::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.format", "Number");
  
    return;
  }
}// type
Napi::Value _VkPhysicalDeviceImageFormatInfo2::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkPhysicalDeviceImageFormatInfo2::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkImageType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.type", "Number");
  
    return;
  }
}// tiling
Napi::Value _VkPhysicalDeviceImageFormatInfo2::Gettiling(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tiling);
}void _VkPhysicalDeviceImageFormatInfo2::Settiling(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tiling = static_cast<VkImageTiling>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.tiling", "Number");
  
    return;
  }
}// usage
Napi::Value _VkPhysicalDeviceImageFormatInfo2::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkPhysicalDeviceImageFormatInfo2::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.usage", "Number");
  
    return;
  }
}// flags
Napi::Value _VkPhysicalDeviceImageFormatInfo2::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPhysicalDeviceImageFormatInfo2::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkImageCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceImageFormatInfo2.flags", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceImageFormatInfo2 ## **/

/** ## BEGIN VkImageFormatProperties2KHR ## **/

Napi::FunctionReference _VkImageFormatProperties2KHR::constructor;

_VkImageFormatProperties2KHR::_VkImageFormatProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageFormatProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkImageFormatProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageFormatProperties2KHR::~_VkImageFormatProperties2KHR() {
  
  
  pNext.Reset();
  
  imageFormatProperties.Reset();
  
}

Napi::Object _VkImageFormatProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageFormatProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageFormatProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageFormatProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageFormatProperties2KHR::GetsType,
    &_VkImageFormatProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageFormatProperties2KHR::GetpNext,
    &_VkImageFormatProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageFormatProperties",
    &_VkImageFormatProperties2KHR::GetimageFormatProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageFormatProperties2KHR", func);
  return exports;
}

Napi::Value _VkImageFormatProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageFormatProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageFormatProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageFormatProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties2KHR *)0)->imageFormatProperties));
    uint32_t byteLength = sizeof(((VkImageFormatProperties2KHR *)0)->imageFormatProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageFormatProperties2KHR::flush() {
  _VkImageFormatProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->imageFormatProperties.IsEmpty())) {
    Napi::Value value = self->imageFormatProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageFormatProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageFormatProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageFormatProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageFormatProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD &&
        sType != VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageFormatProperties2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageFormatProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// imageFormatProperties
Napi::Value _VkImageFormatProperties2KHR::GetimageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageFormatProperties.IsEmpty()) return env.Null();
  return this->imageFormatProperties.Value().As<Napi::Object>();
}
/** ## END VkImageFormatProperties2KHR ## **/

/** ## BEGIN VkImageFormatProperties2 ## **/

Napi::FunctionReference _VkImageFormatProperties2::constructor;

_VkImageFormatProperties2::_VkImageFormatProperties2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageFormatProperties2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkImageFormatProperties2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageFormatProperties2::~_VkImageFormatProperties2() {
  
  
  pNext.Reset();
  
  imageFormatProperties.Reset();
  
}

Napi::Object _VkImageFormatProperties2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageFormatProperties2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageFormatProperties2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageFormatProperties2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageFormatProperties2::GetsType,
    &_VkImageFormatProperties2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageFormatProperties2::GetpNext,
    &_VkImageFormatProperties2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageFormatProperties",
    &_VkImageFormatProperties2::GetimageFormatProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageFormatProperties2", func);
  return exports;
}

Napi::Value _VkImageFormatProperties2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageFormatProperties2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageFormatProperties2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageFormatProperties2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties2 *)0)->imageFormatProperties));
    uint32_t byteLength = sizeof(((VkImageFormatProperties2 *)0)->imageFormatProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageFormatProperties2::flush() {
  _VkImageFormatProperties2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->imageFormatProperties.IsEmpty())) {
    Napi::Value value = self->imageFormatProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImageFormatProperties2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageFormatProperties2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatProperties2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageFormatProperties2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageFormatProperties2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD &&
        sType != VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageFormatProperties2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageFormatProperties2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageFormatProperties2.pNext", "[object Object]");
  
    return;
  }
}// imageFormatProperties
Napi::Value _VkImageFormatProperties2::GetimageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageFormatProperties.IsEmpty()) return env.Null();
  return this->imageFormatProperties.Value().As<Napi::Object>();
}
/** ## END VkImageFormatProperties2 ## **/

/** ## BEGIN VkFormatProperties2KHR ## **/

Napi::FunctionReference _VkFormatProperties2KHR::constructor;

_VkFormatProperties2KHR::_VkFormatProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFormatProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkFormatProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkFormatProperties2KHR::~_VkFormatProperties2KHR() {
  
  
  pNext.Reset();
  
  formatProperties.Reset();
  
}

Napi::Object _VkFormatProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFormatProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFormatProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFormatProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkFormatProperties2KHR::GetsType,
    &_VkFormatProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkFormatProperties2KHR::GetpNext,
    &_VkFormatProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "formatProperties",
    &_VkFormatProperties2KHR::GetformatProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFormatProperties2KHR", func);
  return exports;
}

Napi::Value _VkFormatProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFormatProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkFormatProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkFormatProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties2KHR *)0)->formatProperties));
    uint32_t byteLength = sizeof(((VkFormatProperties2KHR *)0)->formatProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFormatProperties2KHR::flush() {
  _VkFormatProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->formatProperties.IsEmpty())) {
    Napi::Value value = self->formatProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkFormatProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkFormatProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFormatProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkFormatProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkFormatProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkFormatProperties2KHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkFormatProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkFormatProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// formatProperties
Napi::Value _VkFormatProperties2KHR::GetformatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->formatProperties.IsEmpty()) return env.Null();
  return this->formatProperties.Value().As<Napi::Object>();
}
/** ## END VkFormatProperties2KHR ## **/

/** ## BEGIN VkFormatProperties2 ## **/

Napi::FunctionReference _VkFormatProperties2::constructor;

_VkFormatProperties2::_VkFormatProperties2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFormatProperties2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkFormatProperties2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkFormatProperties2::~_VkFormatProperties2() {
  
  
  pNext.Reset();
  
  formatProperties.Reset();
  
}

Napi::Object _VkFormatProperties2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFormatProperties2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFormatProperties2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFormatProperties2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkFormatProperties2::GetsType,
    &_VkFormatProperties2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkFormatProperties2::GetpNext,
    &_VkFormatProperties2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "formatProperties",
    &_VkFormatProperties2::GetformatProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFormatProperties2", func);
  return exports;
}

Napi::Value _VkFormatProperties2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFormatProperties2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkFormatProperties2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkFormatProperties2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties2 *)0)->formatProperties));
    uint32_t byteLength = sizeof(((VkFormatProperties2 *)0)->formatProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFormatProperties2::flush() {
  _VkFormatProperties2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->formatProperties.IsEmpty())) {
    Napi::Value value = self->formatProperties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkFormatProperties2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkFormatProperties2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFormatProperties2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkFormatProperties2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkFormatProperties2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkFormatProperties2.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkFormatProperties2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkFormatProperties2.pNext", "[object Object]");
  
    return;
  }
}// formatProperties
Napi::Value _VkFormatProperties2::GetformatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->formatProperties.IsEmpty()) return env.Null();
  return this->formatProperties.Value().As<Napi::Object>();
}
/** ## END VkFormatProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceProperties2KHR ## **/

Napi::FunctionReference _VkPhysicalDeviceProperties2KHR::constructor;

_VkPhysicalDeviceProperties2KHR::_VkPhysicalDeviceProperties2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceProperties2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceProperties2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceProperties2KHR::~_VkPhysicalDeviceProperties2KHR() {
  
  
  pNext.Reset();
  
  properties.Reset();
  
}

Napi::Object _VkPhysicalDeviceProperties2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceProperties2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceProperties2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceProperties2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceProperties2KHR::GetsType,
    &_VkPhysicalDeviceProperties2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceProperties2KHR::GetpNext,
    &_VkPhysicalDeviceProperties2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "properties",
    &_VkPhysicalDeviceProperties2KHR::Getproperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceProperties2KHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceProperties2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceProperties2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties2KHR *)0)->properties));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties2KHR *)0)->properties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceProperties2KHR::flush() {
  _VkPhysicalDeviceProperties2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->properties.IsEmpty())) {
    Napi::Value value = self->properties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceProperties2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceProperties2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProperties2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceProperties2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceProperties2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceProperties2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProperties2KHR.pNext", "[object Object]");
  
    return;
  }
}// properties
Napi::Value _VkPhysicalDeviceProperties2KHR::Getproperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->properties.IsEmpty()) return env.Null();
  return this->properties.Value().As<Napi::Object>();
}
/** ## END VkPhysicalDeviceProperties2KHR ## **/

/** ## BEGIN VkPhysicalDeviceProperties2 ## **/

Napi::FunctionReference _VkPhysicalDeviceProperties2::constructor;

_VkPhysicalDeviceProperties2::_VkPhysicalDeviceProperties2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceProperties2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceProperties2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceProperties2::~_VkPhysicalDeviceProperties2() {
  
  
  pNext.Reset();
  
  properties.Reset();
  
}

Napi::Object _VkPhysicalDeviceProperties2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceProperties2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceProperties2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceProperties2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceProperties2::GetsType,
    &_VkPhysicalDeviceProperties2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceProperties2::GetpNext,
    &_VkPhysicalDeviceProperties2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "properties",
    &_VkPhysicalDeviceProperties2::Getproperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceProperties2", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceProperties2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceProperties2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties2 *)0)->properties));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties2 *)0)->properties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceProperties2::flush() {
  _VkPhysicalDeviceProperties2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->properties.IsEmpty())) {
    Napi::Value value = self->properties.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceProperties2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceProperties2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProperties2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceProperties2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceProperties2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPhysicalDeviceProperties2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceProperties2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceProperties2.pNext", "[object Object]");
  
    return;
  }
}// properties
Napi::Value _VkPhysicalDeviceProperties2::Getproperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->properties.IsEmpty()) return env.Null();
  return this->properties.Value().As<Napi::Object>();
}
/** ## END VkPhysicalDeviceProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceFeatures2KHR ## **/

Napi::FunctionReference _VkPhysicalDeviceFeatures2KHR::constructor;

_VkPhysicalDeviceFeatures2KHR::_VkPhysicalDeviceFeatures2KHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceFeatures2KHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "features");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setfeatures(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceFeatures2KHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceFeatures2KHR::~_VkPhysicalDeviceFeatures2KHR() {
  
  
  pNext.Reset();
  
  features.Reset();
  
}

Napi::Object _VkPhysicalDeviceFeatures2KHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceFeatures2KHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceFeatures2KHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceFeatures2KHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceFeatures2KHR::GetsType,
    &_VkPhysicalDeviceFeatures2KHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceFeatures2KHR::GetpNext,
    &_VkPhysicalDeviceFeatures2KHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "features",
    &_VkPhysicalDeviceFeatures2KHR::Getfeatures,
    &_VkPhysicalDeviceFeatures2KHR::Setfeatures,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceFeatures2KHR", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceFeatures2KHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceFeatures2KHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures2KHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures2KHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures2KHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures2KHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures2KHR *)0)->features));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures2KHR *)0)->features);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceFeatures2KHR::flush() {
  _VkPhysicalDeviceFeatures2KHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES) {
      _VkPhysicalDeviceVariablePointerFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceVariablePointerFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES) {
      _VkPhysicalDeviceMultiviewFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceMultiviewFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES) {
      _VkPhysicalDevice16BitStorageFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDevice16BitStorageFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES) {
      _VkPhysicalDeviceSamplerYcbcrConversionFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES) {
      _VkPhysicalDeviceProtectedMemoryFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceProtectedMemoryFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT) {
      _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES) {
      _VkPhysicalDeviceShaderDrawParameterFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceShaderDrawParameterFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT) {
      _VkPhysicalDeviceDescriptorIndexingFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR) {
      _VkPhysicalDevice8BitStorageFeaturesKHR* structExt = Napi::ObjectWrap<_VkPhysicalDevice8BitStorageFeaturesKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT) {
      _VkPhysicalDeviceConditionalRenderingFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->features.IsEmpty())) {
    Napi::Value value = self->features.Value();
    
    _VkPhysicalDeviceFeatures* result = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.features = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceFeatures2KHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceFeatures2KHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2KHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceFeatures2KHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceFeatures2KHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2KHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2KHR.pNext", "[object Object]");
  
    return;
  }
}// features
Napi::Value _VkPhysicalDeviceFeatures2KHR::Getfeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->features.IsEmpty()) return env.Null();
  return this->features.Value().As<Napi::Object>();
}void _VkPhysicalDeviceFeatures2KHR::Setfeatures(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPhysicalDeviceFeatures::constructor.Value())) {
      
      this->features.Reset(value.ToObject(), 1);
      _VkPhysicalDeviceFeatures* inst = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(obj);
      inst->flush();
      this->instance.features = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2KHR.features", "[object VkPhysicalDeviceFeatures]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->features.Reset();
    memset(&this->instance.features, 0, sizeof(VkPhysicalDeviceFeatures));
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2KHR.features", "[object VkPhysicalDeviceFeatures]");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFeatures2KHR ## **/

/** ## BEGIN VkPhysicalDeviceFeatures2 ## **/

Napi::FunctionReference _VkPhysicalDeviceFeatures2::constructor;

_VkPhysicalDeviceFeatures2::_VkPhysicalDeviceFeatures2(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceFeatures2>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "features");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setfeatures(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceFeatures2 constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceFeatures2::~_VkPhysicalDeviceFeatures2() {
  
  
  pNext.Reset();
  
  features.Reset();
  
}

Napi::Object _VkPhysicalDeviceFeatures2::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceFeatures2", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceFeatures2::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceFeatures2::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPhysicalDeviceFeatures2::GetsType,
    &_VkPhysicalDeviceFeatures2::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPhysicalDeviceFeatures2::GetpNext,
    &_VkPhysicalDeviceFeatures2::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "features",
    &_VkPhysicalDeviceFeatures2::Getfeatures,
    &_VkPhysicalDeviceFeatures2::Setfeatures,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceFeatures2", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceFeatures2::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceFeatures2::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures2 *)0)->sType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures2 *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures2 *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures2 *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures2 *)0)->features));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures2 *)0)->features);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceFeatures2::flush() {
  _VkPhysicalDeviceFeatures2 *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES) {
      _VkPhysicalDeviceVariablePointerFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceVariablePointerFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES) {
      _VkPhysicalDeviceMultiviewFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceMultiviewFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES) {
      _VkPhysicalDevice16BitStorageFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDevice16BitStorageFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES) {
      _VkPhysicalDeviceSamplerYcbcrConversionFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES) {
      _VkPhysicalDeviceProtectedMemoryFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceProtectedMemoryFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT) {
      _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES) {
      _VkPhysicalDeviceShaderDrawParameterFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceShaderDrawParameterFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT) {
      _VkPhysicalDeviceDescriptorIndexingFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR) {
      _VkPhysicalDevice8BitStorageFeaturesKHR* structExt = Napi::ObjectWrap<_VkPhysicalDevice8BitStorageFeaturesKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT) {
      _VkPhysicalDeviceConditionalRenderingFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->features.IsEmpty())) {
    Napi::Value value = self->features.Value();
    
    _VkPhysicalDeviceFeatures* result = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.features = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkPhysicalDeviceFeatures2::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPhysicalDeviceFeatures2::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPhysicalDeviceFeatures2::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPhysicalDeviceFeatures2::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPhysicalDeviceFeatures2.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2.pNext", "[object Object]");
  
    return;
  }
}// features
Napi::Value _VkPhysicalDeviceFeatures2::Getfeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->features.IsEmpty()) return env.Null();
  return this->features.Value().As<Napi::Object>();
}void _VkPhysicalDeviceFeatures2::Setfeatures(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPhysicalDeviceFeatures::constructor.Value())) {
      
      this->features.Reset(value.ToObject(), 1);
      _VkPhysicalDeviceFeatures* inst = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(obj);
      inst->flush();
      this->instance.features = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2.features", "[object VkPhysicalDeviceFeatures]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->features.Reset();
    memset(&this->instance.features, 0, sizeof(VkPhysicalDeviceFeatures));
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures2.features", "[object VkPhysicalDeviceFeatures]");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFeatures2 ## **/

/** ## BEGIN VkObjectTablePushConstantEntryNVX ## **/

Napi::FunctionReference _VkObjectTablePushConstantEntryNVX::constructor;

_VkObjectTablePushConstantEntryNVX::_VkObjectTablePushConstantEntryNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTablePushConstantEntryNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "flags");
      Napi::String sAccess2 = Napi::String::New(env, "pipelineLayout");
      Napi::String sAccess3 = Napi::String::New(env, "stageFlags");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setflags(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpipelineLayout(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetstageFlags(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkObjectTablePushConstantEntryNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTablePushConstantEntryNVX::~_VkObjectTablePushConstantEntryNVX() {
  
  
  
  pipelineLayout.Reset();
  
  
}

Napi::Object _VkObjectTablePushConstantEntryNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTablePushConstantEntryNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTablePushConstantEntryNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTablePushConstantEntryNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkObjectTablePushConstantEntryNVX::Gettype,
    &_VkObjectTablePushConstantEntryNVX::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkObjectTablePushConstantEntryNVX::Getflags,
    &_VkObjectTablePushConstantEntryNVX::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineLayout",
    &_VkObjectTablePushConstantEntryNVX::GetpipelineLayout,
    &_VkObjectTablePushConstantEntryNVX::SetpipelineLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "stageFlags",
    &_VkObjectTablePushConstantEntryNVX::GetstageFlags,
    &_VkObjectTablePushConstantEntryNVX::SetstageFlags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTablePushConstantEntryNVX", func);
  return exports;
}

Napi::Value _VkObjectTablePushConstantEntryNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTablePushConstantEntryNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePushConstantEntryNVX *)0)->type));
    uint32_t byteLength = sizeof(((VkObjectTablePushConstantEntryNVX *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePushConstantEntryNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkObjectTablePushConstantEntryNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePushConstantEntryNVX *)0)->pipelineLayout));
    uint32_t byteLength = sizeof(((VkObjectTablePushConstantEntryNVX *)0)->pipelineLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePushConstantEntryNVX *)0)->stageFlags));
    uint32_t byteLength = sizeof(((VkObjectTablePushConstantEntryNVX *)0)->stageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTablePushConstantEntryNVX::flush() {
  _VkObjectTablePushConstantEntryNVX *self = this;
  
  return true;
}

// type
Napi::Value _VkObjectTablePushConstantEntryNVX::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkObjectTablePushConstantEntryNVX::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkObjectEntryTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePushConstantEntryNVX.type", "Number");
  
    return;
  }
}// flags
Napi::Value _VkObjectTablePushConstantEntryNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkObjectTablePushConstantEntryNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePushConstantEntryNVX.flags", "Number");
  
    return;
  }
}// pipelineLayout
Napi::Value _VkObjectTablePushConstantEntryNVX::GetpipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pipelineLayout.IsEmpty()) return env.Null();
  return this->pipelineLayout.Value().As<Napi::Object>();
}void _VkObjectTablePushConstantEntryNVX::SetpipelineLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineLayout::constructor.Value())) {
      
      this->pipelineLayout.Reset(value.ToObject(), 1);
      _VkPipelineLayout* inst = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
      ;
      this->instance.pipelineLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkObjectTablePushConstantEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pipelineLayout.Reset();
    this->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePushConstantEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// stageFlags
Napi::Value _VkObjectTablePushConstantEntryNVX::GetstageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stageFlags);
}void _VkObjectTablePushConstantEntryNVX::SetstageFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stageFlags = static_cast<VkShaderStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePushConstantEntryNVX.stageFlags", "Number");
  
    return;
  }
}
/** ## END VkObjectTablePushConstantEntryNVX ## **/

/** ## BEGIN VkObjectTableIndexBufferEntryNVX ## **/

Napi::FunctionReference _VkObjectTableIndexBufferEntryNVX::constructor;

_VkObjectTableIndexBufferEntryNVX::_VkObjectTableIndexBufferEntryNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTableIndexBufferEntryNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "flags");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      Napi::String sAccess3 = Napi::String::New(env, "indexType");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setflags(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetindexType(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkObjectTableIndexBufferEntryNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTableIndexBufferEntryNVX::~_VkObjectTableIndexBufferEntryNVX() {
  
  
  
  buffer.Reset();
  
  
}

Napi::Object _VkObjectTableIndexBufferEntryNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTableIndexBufferEntryNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTableIndexBufferEntryNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTableIndexBufferEntryNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkObjectTableIndexBufferEntryNVX::Gettype,
    &_VkObjectTableIndexBufferEntryNVX::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkObjectTableIndexBufferEntryNVX::Getflags,
    &_VkObjectTableIndexBufferEntryNVX::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkObjectTableIndexBufferEntryNVX::Getbuffer,
    &_VkObjectTableIndexBufferEntryNVX::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "indexType",
    &_VkObjectTableIndexBufferEntryNVX::GetindexType,
    &_VkObjectTableIndexBufferEntryNVX::SetindexType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTableIndexBufferEntryNVX", func);
  return exports;
}

Napi::Value _VkObjectTableIndexBufferEntryNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTableIndexBufferEntryNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableIndexBufferEntryNVX *)0)->type));
    uint32_t byteLength = sizeof(((VkObjectTableIndexBufferEntryNVX *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableIndexBufferEntryNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkObjectTableIndexBufferEntryNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableIndexBufferEntryNVX *)0)->buffer));
    uint32_t byteLength = sizeof(((VkObjectTableIndexBufferEntryNVX *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableIndexBufferEntryNVX *)0)->indexType));
    uint32_t byteLength = sizeof(((VkObjectTableIndexBufferEntryNVX *)0)->indexType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTableIndexBufferEntryNVX::flush() {
  _VkObjectTableIndexBufferEntryNVX *self = this;
  
  return true;
}

// type
Napi::Value _VkObjectTableIndexBufferEntryNVX::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkObjectTableIndexBufferEntryNVX::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkObjectEntryTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableIndexBufferEntryNVX.type", "Number");
  
    return;
  }
}// flags
Napi::Value _VkObjectTableIndexBufferEntryNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkObjectTableIndexBufferEntryNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableIndexBufferEntryNVX.flags", "Number");
  
    return;
  }
}// buffer
Napi::Value _VkObjectTableIndexBufferEntryNVX::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkObjectTableIndexBufferEntryNVX::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableIndexBufferEntryNVX.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableIndexBufferEntryNVX.buffer", "[object VkBuffer]");
  
    return;
  }
}// indexType
Napi::Value _VkObjectTableIndexBufferEntryNVX::GetindexType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.indexType);
}void _VkObjectTableIndexBufferEntryNVX::SetindexType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.indexType = static_cast<VkIndexType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableIndexBufferEntryNVX.indexType", "Number");
  
    return;
  }
}
/** ## END VkObjectTableIndexBufferEntryNVX ## **/

/** ## BEGIN VkObjectTableVertexBufferEntryNVX ## **/

Napi::FunctionReference _VkObjectTableVertexBufferEntryNVX::constructor;

_VkObjectTableVertexBufferEntryNVX::_VkObjectTableVertexBufferEntryNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTableVertexBufferEntryNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "flags");
      Napi::String sAccess2 = Napi::String::New(env, "buffer");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setflags(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setbuffer(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkObjectTableVertexBufferEntryNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTableVertexBufferEntryNVX::~_VkObjectTableVertexBufferEntryNVX() {
  
  
  
  buffer.Reset();
  
}

Napi::Object _VkObjectTableVertexBufferEntryNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTableVertexBufferEntryNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTableVertexBufferEntryNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTableVertexBufferEntryNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkObjectTableVertexBufferEntryNVX::Gettype,
    &_VkObjectTableVertexBufferEntryNVX::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkObjectTableVertexBufferEntryNVX::Getflags,
    &_VkObjectTableVertexBufferEntryNVX::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkObjectTableVertexBufferEntryNVX::Getbuffer,
    &_VkObjectTableVertexBufferEntryNVX::Setbuffer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTableVertexBufferEntryNVX", func);
  return exports;
}

Napi::Value _VkObjectTableVertexBufferEntryNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTableVertexBufferEntryNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableVertexBufferEntryNVX *)0)->type));
    uint32_t byteLength = sizeof(((VkObjectTableVertexBufferEntryNVX *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableVertexBufferEntryNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkObjectTableVertexBufferEntryNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableVertexBufferEntryNVX *)0)->buffer));
    uint32_t byteLength = sizeof(((VkObjectTableVertexBufferEntryNVX *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTableVertexBufferEntryNVX::flush() {
  _VkObjectTableVertexBufferEntryNVX *self = this;
  
  return true;
}

// type
Napi::Value _VkObjectTableVertexBufferEntryNVX::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkObjectTableVertexBufferEntryNVX::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkObjectEntryTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableVertexBufferEntryNVX.type", "Number");
  
    return;
  }
}// flags
Napi::Value _VkObjectTableVertexBufferEntryNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkObjectTableVertexBufferEntryNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableVertexBufferEntryNVX.flags", "Number");
  
    return;
  }
}// buffer
Napi::Value _VkObjectTableVertexBufferEntryNVX::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkObjectTableVertexBufferEntryNVX::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableVertexBufferEntryNVX.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableVertexBufferEntryNVX.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkObjectTableVertexBufferEntryNVX ## **/

/** ## BEGIN VkObjectTableDescriptorSetEntryNVX ## **/

Napi::FunctionReference _VkObjectTableDescriptorSetEntryNVX::constructor;

_VkObjectTableDescriptorSetEntryNVX::_VkObjectTableDescriptorSetEntryNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTableDescriptorSetEntryNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "flags");
      Napi::String sAccess2 = Napi::String::New(env, "pipelineLayout");
      Napi::String sAccess3 = Napi::String::New(env, "descriptorSet");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setflags(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpipelineLayout(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdescriptorSet(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkObjectTableDescriptorSetEntryNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTableDescriptorSetEntryNVX::~_VkObjectTableDescriptorSetEntryNVX() {
  
  
  
  pipelineLayout.Reset();
  
  descriptorSet.Reset();
  
}

Napi::Object _VkObjectTableDescriptorSetEntryNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTableDescriptorSetEntryNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTableDescriptorSetEntryNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTableDescriptorSetEntryNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkObjectTableDescriptorSetEntryNVX::Gettype,
    &_VkObjectTableDescriptorSetEntryNVX::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkObjectTableDescriptorSetEntryNVX::Getflags,
    &_VkObjectTableDescriptorSetEntryNVX::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineLayout",
    &_VkObjectTableDescriptorSetEntryNVX::GetpipelineLayout,
    &_VkObjectTableDescriptorSetEntryNVX::SetpipelineLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorSet",
    &_VkObjectTableDescriptorSetEntryNVX::GetdescriptorSet,
    &_VkObjectTableDescriptorSetEntryNVX::SetdescriptorSet,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTableDescriptorSetEntryNVX", func);
  return exports;
}

Napi::Value _VkObjectTableDescriptorSetEntryNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTableDescriptorSetEntryNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableDescriptorSetEntryNVX *)0)->type));
    uint32_t byteLength = sizeof(((VkObjectTableDescriptorSetEntryNVX *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableDescriptorSetEntryNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkObjectTableDescriptorSetEntryNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableDescriptorSetEntryNVX *)0)->pipelineLayout));
    uint32_t byteLength = sizeof(((VkObjectTableDescriptorSetEntryNVX *)0)->pipelineLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableDescriptorSetEntryNVX *)0)->descriptorSet));
    uint32_t byteLength = sizeof(((VkObjectTableDescriptorSetEntryNVX *)0)->descriptorSet);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTableDescriptorSetEntryNVX::flush() {
  _VkObjectTableDescriptorSetEntryNVX *self = this;
  
  return true;
}

// type
Napi::Value _VkObjectTableDescriptorSetEntryNVX::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkObjectTableDescriptorSetEntryNVX::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkObjectEntryTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableDescriptorSetEntryNVX.type", "Number");
  
    return;
  }
}// flags
Napi::Value _VkObjectTableDescriptorSetEntryNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkObjectTableDescriptorSetEntryNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableDescriptorSetEntryNVX.flags", "Number");
  
    return;
  }
}// pipelineLayout
Napi::Value _VkObjectTableDescriptorSetEntryNVX::GetpipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pipelineLayout.IsEmpty()) return env.Null();
  return this->pipelineLayout.Value().As<Napi::Object>();
}void _VkObjectTableDescriptorSetEntryNVX::SetpipelineLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineLayout::constructor.Value())) {
      
      this->pipelineLayout.Reset(value.ToObject(), 1);
      _VkPipelineLayout* inst = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
      ;
      this->instance.pipelineLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableDescriptorSetEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pipelineLayout.Reset();
    this->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableDescriptorSetEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// descriptorSet
Napi::Value _VkObjectTableDescriptorSetEntryNVX::GetdescriptorSet(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->descriptorSet.IsEmpty()) return env.Null();
  return this->descriptorSet.Value().As<Napi::Object>();
}void _VkObjectTableDescriptorSetEntryNVX::SetdescriptorSet(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorSet::constructor.Value())) {
      
      this->descriptorSet.Reset(value.ToObject(), 1);
      _VkDescriptorSet* inst = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      ;
      this->instance.descriptorSet = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableDescriptorSetEntryNVX.descriptorSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->descriptorSet.Reset();
    this->instance.descriptorSet = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableDescriptorSetEntryNVX.descriptorSet", "[object VkDescriptorSet]");
  
    return;
  }
}
/** ## END VkObjectTableDescriptorSetEntryNVX ## **/

/** ## BEGIN VkObjectTablePipelineEntryNVX ## **/

Napi::FunctionReference _VkObjectTablePipelineEntryNVX::constructor;

_VkObjectTablePipelineEntryNVX::_VkObjectTablePipelineEntryNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTablePipelineEntryNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "flags");
      Napi::String sAccess2 = Napi::String::New(env, "pipeline");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setflags(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setpipeline(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkObjectTablePipelineEntryNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTablePipelineEntryNVX::~_VkObjectTablePipelineEntryNVX() {
  
  
  
  pipeline.Reset();
  
}

Napi::Object _VkObjectTablePipelineEntryNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTablePipelineEntryNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTablePipelineEntryNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTablePipelineEntryNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkObjectTablePipelineEntryNVX::Gettype,
    &_VkObjectTablePipelineEntryNVX::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkObjectTablePipelineEntryNVX::Getflags,
    &_VkObjectTablePipelineEntryNVX::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipeline",
    &_VkObjectTablePipelineEntryNVX::Getpipeline,
    &_VkObjectTablePipelineEntryNVX::Setpipeline,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTablePipelineEntryNVX", func);
  return exports;
}

Napi::Value _VkObjectTablePipelineEntryNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTablePipelineEntryNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePipelineEntryNVX *)0)->type));
    uint32_t byteLength = sizeof(((VkObjectTablePipelineEntryNVX *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePipelineEntryNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkObjectTablePipelineEntryNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTablePipelineEntryNVX *)0)->pipeline));
    uint32_t byteLength = sizeof(((VkObjectTablePipelineEntryNVX *)0)->pipeline);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTablePipelineEntryNVX::flush() {
  _VkObjectTablePipelineEntryNVX *self = this;
  
  return true;
}

// type
Napi::Value _VkObjectTablePipelineEntryNVX::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkObjectTablePipelineEntryNVX::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkObjectEntryTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePipelineEntryNVX.type", "Number");
  
    return;
  }
}// flags
Napi::Value _VkObjectTablePipelineEntryNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkObjectTablePipelineEntryNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePipelineEntryNVX.flags", "Number");
  
    return;
  }
}// pipeline
Napi::Value _VkObjectTablePipelineEntryNVX::Getpipeline(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pipeline.IsEmpty()) return env.Null();
  return this->pipeline.Value().As<Napi::Object>();
}void _VkObjectTablePipelineEntryNVX::Setpipeline(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipeline::constructor.Value())) {
      
      this->pipeline.Reset(value.ToObject(), 1);
      _VkPipeline* inst = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      ;
      this->instance.pipeline = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkObjectTablePipelineEntryNVX.pipeline", "[object VkPipeline]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pipeline.Reset();
    this->instance.pipeline = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTablePipelineEntryNVX.pipeline", "[object VkPipeline]");
  
    return;
  }
}
/** ## END VkObjectTablePipelineEntryNVX ## **/

/** ## BEGIN VkObjectTableEntryNVX ## **/

Napi::FunctionReference _VkObjectTableEntryNVX::constructor;

_VkObjectTableEntryNVX::_VkObjectTableEntryNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTableEntryNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setflags(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkObjectTableEntryNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTableEntryNVX::~_VkObjectTableEntryNVX() {
  
  
  
}

Napi::Object _VkObjectTableEntryNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTableEntryNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTableEntryNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTableEntryNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkObjectTableEntryNVX::Gettype,
    &_VkObjectTableEntryNVX::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkObjectTableEntryNVX::Getflags,
    &_VkObjectTableEntryNVX::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTableEntryNVX", func);
  return exports;
}

Napi::Value _VkObjectTableEntryNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTableEntryNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableEntryNVX *)0)->type));
    uint32_t byteLength = sizeof(((VkObjectTableEntryNVX *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableEntryNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkObjectTableEntryNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTableEntryNVX::flush() {
  _VkObjectTableEntryNVX *self = this;
  
  return true;
}

// type
Napi::Value _VkObjectTableEntryNVX::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkObjectTableEntryNVX::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkObjectEntryTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableEntryNVX.type", "Number");
  
    return;
  }
}// flags
Napi::Value _VkObjectTableEntryNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkObjectTableEntryNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableEntryNVX.flags", "Number");
  
    return;
  }
}
/** ## END VkObjectTableEntryNVX ## **/

/** ## BEGIN VkObjectTableCreateInfoNVX ## **/

Napi::FunctionReference _VkObjectTableCreateInfoNVX::constructor;

_VkObjectTableCreateInfoNVX::_VkObjectTableCreateInfoNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkObjectTableCreateInfoNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectCount");
      Napi::String sAccess3 = Napi::String::New(env, "pObjectEntryTypes");
      Napi::String sAccess4 = Napi::String::New(env, "pObjectEntryCounts");
      Napi::String sAccess5 = Napi::String::New(env, "pObjectEntryUsageFlags");
      Napi::String sAccess6 = Napi::String::New(env, "maxUniformBuffersPerDescriptor");
      Napi::String sAccess7 = Napi::String::New(env, "maxStorageBuffersPerDescriptor");
      Napi::String sAccess8 = Napi::String::New(env, "maxStorageImagesPerDescriptor");
      Napi::String sAccess9 = Napi::String::New(env, "maxSampledImagesPerDescriptor");
      Napi::String sAccess10 = Napi::String::New(env, "maxPipelineLayouts");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpObjectEntryTypes(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpObjectEntryCounts(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpObjectEntryUsageFlags(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetmaxUniformBuffersPerDescriptor(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetmaxStorageBuffersPerDescriptor(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetmaxStorageImagesPerDescriptor(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetmaxSampledImagesPerDescriptor(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetmaxPipelineLayouts(info, obj.Get(sAccess10));
      
    } else {
      Napi::Error::New(env, "VkObjectTableCreateInfoNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkObjectTableCreateInfoNVX::~_VkObjectTableCreateInfoNVX() {
  
  
  pNext.Reset();
  
  
  pObjectEntryTypes.Reset();
  
  pObjectEntryCounts.Reset();
  
  pObjectEntryUsageFlags.Reset();
  
  
  
  
  
  
}

Napi::Object _VkObjectTableCreateInfoNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkObjectTableCreateInfoNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkObjectTableCreateInfoNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkObjectTableCreateInfoNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkObjectTableCreateInfoNVX::GetsType,
    &_VkObjectTableCreateInfoNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkObjectTableCreateInfoNVX::GetpNext,
    &_VkObjectTableCreateInfoNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectCount",
    &_VkObjectTableCreateInfoNVX::GetobjectCount,
    &_VkObjectTableCreateInfoNVX::SetobjectCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pObjectEntryTypes",
    &_VkObjectTableCreateInfoNVX::GetpObjectEntryTypes,
    &_VkObjectTableCreateInfoNVX::SetpObjectEntryTypes,
    napi_enumerable
  ),
  InstanceAccessor(
    "pObjectEntryCounts",
    &_VkObjectTableCreateInfoNVX::GetpObjectEntryCounts,
    &_VkObjectTableCreateInfoNVX::SetpObjectEntryCounts,
    napi_enumerable
  ),
  InstanceAccessor(
    "pObjectEntryUsageFlags",
    &_VkObjectTableCreateInfoNVX::GetpObjectEntryUsageFlags,
    &_VkObjectTableCreateInfoNVX::SetpObjectEntryUsageFlags,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxUniformBuffersPerDescriptor",
    &_VkObjectTableCreateInfoNVX::GetmaxUniformBuffersPerDescriptor,
    &_VkObjectTableCreateInfoNVX::SetmaxUniformBuffersPerDescriptor,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxStorageBuffersPerDescriptor",
    &_VkObjectTableCreateInfoNVX::GetmaxStorageBuffersPerDescriptor,
    &_VkObjectTableCreateInfoNVX::SetmaxStorageBuffersPerDescriptor,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxStorageImagesPerDescriptor",
    &_VkObjectTableCreateInfoNVX::GetmaxStorageImagesPerDescriptor,
    &_VkObjectTableCreateInfoNVX::SetmaxStorageImagesPerDescriptor,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSampledImagesPerDescriptor",
    &_VkObjectTableCreateInfoNVX::GetmaxSampledImagesPerDescriptor,
    &_VkObjectTableCreateInfoNVX::SetmaxSampledImagesPerDescriptor,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPipelineLayouts",
    &_VkObjectTableCreateInfoNVX::GetmaxPipelineLayouts,
    &_VkObjectTableCreateInfoNVX::SetmaxPipelineLayouts,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkObjectTableCreateInfoNVX", func);
  return exports;
}

Napi::Value _VkObjectTableCreateInfoNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkObjectTableCreateInfoNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->objectCount));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->objectCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->pObjectEntryTypes));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->pObjectEntryTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->pObjectEntryCounts));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->pObjectEntryCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->pObjectEntryUsageFlags));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->pObjectEntryUsageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->maxUniformBuffersPerDescriptor));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->maxUniformBuffersPerDescriptor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->maxStorageBuffersPerDescriptor));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->maxStorageBuffersPerDescriptor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->maxStorageImagesPerDescriptor));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->maxStorageImagesPerDescriptor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->maxSampledImagesPerDescriptor));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->maxSampledImagesPerDescriptor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkObjectTableCreateInfoNVX *)0)->maxPipelineLayouts));
    uint32_t byteLength = sizeof(((VkObjectTableCreateInfoNVX *)0)->maxPipelineLayouts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkObjectTableCreateInfoNVX::flush() {
  _VkObjectTableCreateInfoNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkObjectTableCreateInfoNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkObjectTableCreateInfoNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkObjectTableCreateInfoNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkObjectTableCreateInfoNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkObjectTableCreateInfoNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pNext", "[object Object]");
  
    return;
  }
}// objectCount
Napi::Value _VkObjectTableCreateInfoNVX::GetobjectCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectCount);
}void _VkObjectTableCreateInfoNVX::SetobjectCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.objectCount", "Number");
  
    return;
  }
}// pObjectEntryTypes
Napi::Value _VkObjectTableCreateInfoNVX::GetpObjectEntryTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pObjectEntryTypes.IsEmpty()) return env.Null();
  return this->pObjectEntryTypes.Value().As<Napi::TypedArray>();
}void _VkObjectTableCreateInfoNVX::SetpObjectEntryTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pObjectEntryTypes.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryTypes", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pObjectEntryTypes.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryTypes", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pObjectEntryTypes = reinterpret_cast<const VkObjectEntryTypeNVX *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pObjectEntryTypes = nullptr;
  }
}// pObjectEntryCounts
Napi::Value _VkObjectTableCreateInfoNVX::GetpObjectEntryCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pObjectEntryCounts.IsEmpty()) return env.Null();
  return this->pObjectEntryCounts.Value().As<Napi::TypedArray>();
}void _VkObjectTableCreateInfoNVX::SetpObjectEntryCounts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pObjectEntryCounts.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryCounts", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pObjectEntryCounts.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryCounts", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pObjectEntryCounts = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pObjectEntryCounts = nullptr;
  }
}// pObjectEntryUsageFlags
Napi::Value _VkObjectTableCreateInfoNVX::GetpObjectEntryUsageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pObjectEntryUsageFlags.IsEmpty()) return env.Null();
  return this->pObjectEntryUsageFlags.Value().As<Napi::TypedArray>();
}void _VkObjectTableCreateInfoNVX::SetpObjectEntryUsageFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pObjectEntryUsageFlags.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pObjectEntryUsageFlags.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pObjectEntryUsageFlags = reinterpret_cast<const VkObjectEntryUsageFlagsNVX *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pObjectEntryUsageFlags = nullptr;
  }
}// maxUniformBuffersPerDescriptor
Napi::Value _VkObjectTableCreateInfoNVX::GetmaxUniformBuffersPerDescriptor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxUniformBuffersPerDescriptor);
}void _VkObjectTableCreateInfoNVX::SetmaxUniformBuffersPerDescriptor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxUniformBuffersPerDescriptor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.maxUniformBuffersPerDescriptor", "Number");
  
    return;
  }
}// maxStorageBuffersPerDescriptor
Napi::Value _VkObjectTableCreateInfoNVX::GetmaxStorageBuffersPerDescriptor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxStorageBuffersPerDescriptor);
}void _VkObjectTableCreateInfoNVX::SetmaxStorageBuffersPerDescriptor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxStorageBuffersPerDescriptor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.maxStorageBuffersPerDescriptor", "Number");
  
    return;
  }
}// maxStorageImagesPerDescriptor
Napi::Value _VkObjectTableCreateInfoNVX::GetmaxStorageImagesPerDescriptor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxStorageImagesPerDescriptor);
}void _VkObjectTableCreateInfoNVX::SetmaxStorageImagesPerDescriptor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxStorageImagesPerDescriptor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.maxStorageImagesPerDescriptor", "Number");
  
    return;
  }
}// maxSampledImagesPerDescriptor
Napi::Value _VkObjectTableCreateInfoNVX::GetmaxSampledImagesPerDescriptor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSampledImagesPerDescriptor);
}void _VkObjectTableCreateInfoNVX::SetmaxSampledImagesPerDescriptor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxSampledImagesPerDescriptor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.maxSampledImagesPerDescriptor", "Number");
  
    return;
  }
}// maxPipelineLayouts
Napi::Value _VkObjectTableCreateInfoNVX::GetmaxPipelineLayouts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPipelineLayouts);
}void _VkObjectTableCreateInfoNVX::SetmaxPipelineLayouts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxPipelineLayouts = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkObjectTableCreateInfoNVX.maxPipelineLayouts", "Number");
  
    return;
  }
}
/** ## END VkObjectTableCreateInfoNVX ## **/

/** ## BEGIN VkCmdReserveSpaceForCommandsInfoNVX ## **/

Napi::FunctionReference _VkCmdReserveSpaceForCommandsInfoNVX::constructor;

_VkCmdReserveSpaceForCommandsInfoNVX::_VkCmdReserveSpaceForCommandsInfoNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectTable");
      Napi::String sAccess3 = Napi::String::New(env, "indirectCommandsLayout");
      Napi::String sAccess4 = Napi::String::New(env, "maxSequencesCount");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectTable(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetindirectCommandsLayout(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmaxSequencesCount(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkCmdReserveSpaceForCommandsInfoNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkCmdReserveSpaceForCommandsInfoNVX::~_VkCmdReserveSpaceForCommandsInfoNVX() {
  
  
  pNext.Reset();
  
  objectTable.Reset();
  
  indirectCommandsLayout.Reset();
  
  
}

Napi::Object _VkCmdReserveSpaceForCommandsInfoNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCmdReserveSpaceForCommandsInfoNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCmdReserveSpaceForCommandsInfoNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCmdReserveSpaceForCommandsInfoNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCmdReserveSpaceForCommandsInfoNVX::GetsType,
    &_VkCmdReserveSpaceForCommandsInfoNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCmdReserveSpaceForCommandsInfoNVX::GetpNext,
    &_VkCmdReserveSpaceForCommandsInfoNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectTable",
    &_VkCmdReserveSpaceForCommandsInfoNVX::GetobjectTable,
    &_VkCmdReserveSpaceForCommandsInfoNVX::SetobjectTable,
    napi_enumerable
  ),
  InstanceAccessor(
    "indirectCommandsLayout",
    &_VkCmdReserveSpaceForCommandsInfoNVX::GetindirectCommandsLayout,
    &_VkCmdReserveSpaceForCommandsInfoNVX::SetindirectCommandsLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSequencesCount",
    &_VkCmdReserveSpaceForCommandsInfoNVX::GetmaxSequencesCount,
    &_VkCmdReserveSpaceForCommandsInfoNVX::SetmaxSequencesCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCmdReserveSpaceForCommandsInfoNVX", func);
  return exports;
}

Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->objectTable));
    uint32_t byteLength = sizeof(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->objectTable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->indirectCommandsLayout));
    uint32_t byteLength = sizeof(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->indirectCommandsLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->maxSequencesCount));
    uint32_t byteLength = sizeof(((VkCmdReserveSpaceForCommandsInfoNVX *)0)->maxSequencesCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCmdReserveSpaceForCommandsInfoNVX::flush() {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCmdReserveSpaceForCommandsInfoNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCmdReserveSpaceForCommandsInfoNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCmdReserveSpaceForCommandsInfoNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.pNext", "[object Object]");
  
    return;
  }
}// objectTable
Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetobjectTable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->objectTable.IsEmpty()) return env.Null();
  return this->objectTable.Value().As<Napi::Object>();
}void _VkCmdReserveSpaceForCommandsInfoNVX::SetobjectTable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkObjectTableNVX::constructor.Value())) {
      
      this->objectTable.Reset(value.ToObject(), 1);
      _VkObjectTableNVX* inst = Napi::ObjectWrap<_VkObjectTableNVX>::Unwrap(obj);
      ;
      this->instance.objectTable = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->objectTable.Reset();
    this->instance.objectTable = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
    return;
  }
}// indirectCommandsLayout
Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetindirectCommandsLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->indirectCommandsLayout.IsEmpty()) return env.Null();
  return this->indirectCommandsLayout.Value().As<Napi::Object>();
}void _VkCmdReserveSpaceForCommandsInfoNVX::SetindirectCommandsLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkIndirectCommandsLayoutNVX::constructor.Value())) {
      
      this->indirectCommandsLayout.Reset(value.ToObject(), 1);
      _VkIndirectCommandsLayoutNVX* inst = Napi::ObjectWrap<_VkIndirectCommandsLayoutNVX>::Unwrap(obj);
      ;
      this->instance.indirectCommandsLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->indirectCommandsLayout.Reset();
    this->instance.indirectCommandsLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
    return;
  }
}// maxSequencesCount
Napi::Value _VkCmdReserveSpaceForCommandsInfoNVX::GetmaxSequencesCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSequencesCount);
}void _VkCmdReserveSpaceForCommandsInfoNVX::SetmaxSequencesCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxSequencesCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.maxSequencesCount", "Number");
  
    return;
  }
}
/** ## END VkCmdReserveSpaceForCommandsInfoNVX ## **/

/** ## BEGIN VkCmdProcessCommandsInfoNVX ## **/

Napi::FunctionReference _VkCmdProcessCommandsInfoNVX::constructor;

_VkCmdProcessCommandsInfoNVX::_VkCmdProcessCommandsInfoNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCmdProcessCommandsInfoNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX;
    vpIndirectCommandsTokens = new std::vector<VkIndirectCommandsTokenNVX>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectTable");
      Napi::String sAccess3 = Napi::String::New(env, "indirectCommandsLayout");
      Napi::String sAccess4 = Napi::String::New(env, "indirectCommandsTokenCount");
      Napi::String sAccess5 = Napi::String::New(env, "pIndirectCommandsTokens");
      Napi::String sAccess6 = Napi::String::New(env, "maxSequencesCount");
      Napi::String sAccess7 = Napi::String::New(env, "targetCommandBuffer");
      Napi::String sAccess8 = Napi::String::New(env, "sequencesCountBuffer");
      Napi::String sAccess9 = Napi::String::New(env, "sequencesCountOffset");
      Napi::String sAccess10 = Napi::String::New(env, "sequencesIndexBuffer");
      Napi::String sAccess11 = Napi::String::New(env, "sequencesIndexOffset");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectTable(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetindirectCommandsLayout(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetindirectCommandsTokenCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpIndirectCommandsTokens(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetmaxSequencesCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SettargetCommandBuffer(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetsequencesCountBuffer(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetsequencesCountOffset(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetsequencesIndexBuffer(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetsequencesIndexOffset(info, obj.Get(sAccess11));
      
    } else {
      Napi::Error::New(env, "VkCmdProcessCommandsInfoNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkCmdProcessCommandsInfoNVX::~_VkCmdProcessCommandsInfoNVX() {
  
  
  pNext.Reset();
  
  objectTable.Reset();
  
  indirectCommandsLayout.Reset();
  
  
  vpIndirectCommandsTokens->clear();
  delete vpIndirectCommandsTokens;
  
  pIndirectCommandsTokens.Reset();
  
  
  targetCommandBuffer.Reset();
  
  sequencesCountBuffer.Reset();
  
  
  sequencesIndexBuffer.Reset();
  
  
}

Napi::Object _VkCmdProcessCommandsInfoNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCmdProcessCommandsInfoNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCmdProcessCommandsInfoNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCmdProcessCommandsInfoNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCmdProcessCommandsInfoNVX::GetsType,
    &_VkCmdProcessCommandsInfoNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCmdProcessCommandsInfoNVX::GetpNext,
    &_VkCmdProcessCommandsInfoNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectTable",
    &_VkCmdProcessCommandsInfoNVX::GetobjectTable,
    &_VkCmdProcessCommandsInfoNVX::SetobjectTable,
    napi_enumerable
  ),
  InstanceAccessor(
    "indirectCommandsLayout",
    &_VkCmdProcessCommandsInfoNVX::GetindirectCommandsLayout,
    &_VkCmdProcessCommandsInfoNVX::SetindirectCommandsLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "indirectCommandsTokenCount",
    &_VkCmdProcessCommandsInfoNVX::GetindirectCommandsTokenCount,
    &_VkCmdProcessCommandsInfoNVX::SetindirectCommandsTokenCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pIndirectCommandsTokens",
    &_VkCmdProcessCommandsInfoNVX::GetpIndirectCommandsTokens,
    &_VkCmdProcessCommandsInfoNVX::SetpIndirectCommandsTokens,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSequencesCount",
    &_VkCmdProcessCommandsInfoNVX::GetmaxSequencesCount,
    &_VkCmdProcessCommandsInfoNVX::SetmaxSequencesCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "targetCommandBuffer",
    &_VkCmdProcessCommandsInfoNVX::GettargetCommandBuffer,
    &_VkCmdProcessCommandsInfoNVX::SettargetCommandBuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "sequencesCountBuffer",
    &_VkCmdProcessCommandsInfoNVX::GetsequencesCountBuffer,
    &_VkCmdProcessCommandsInfoNVX::SetsequencesCountBuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "sequencesCountOffset",
    &_VkCmdProcessCommandsInfoNVX::GetsequencesCountOffset,
    &_VkCmdProcessCommandsInfoNVX::SetsequencesCountOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "sequencesIndexBuffer",
    &_VkCmdProcessCommandsInfoNVX::GetsequencesIndexBuffer,
    &_VkCmdProcessCommandsInfoNVX::SetsequencesIndexBuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "sequencesIndexOffset",
    &_VkCmdProcessCommandsInfoNVX::GetsequencesIndexOffset,
    &_VkCmdProcessCommandsInfoNVX::SetsequencesIndexOffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCmdProcessCommandsInfoNVX", func);
  return exports;
}

Napi::Value _VkCmdProcessCommandsInfoNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCmdProcessCommandsInfoNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->objectTable));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->objectTable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->indirectCommandsLayout));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->indirectCommandsLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->indirectCommandsTokenCount));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->indirectCommandsTokenCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->pIndirectCommandsTokens));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->pIndirectCommandsTokens);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->maxSequencesCount));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->maxSequencesCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->targetCommandBuffer));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->targetCommandBuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->sequencesCountBuffer));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->sequencesCountBuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->sequencesCountOffset));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->sequencesCountOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->sequencesIndexBuffer));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->sequencesIndexBuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCmdProcessCommandsInfoNVX *)0)->sequencesIndexOffset));
    uint32_t byteLength = sizeof(((VkCmdProcessCommandsInfoNVX *)0)->sequencesIndexOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCmdProcessCommandsInfoNVX::flush() {
  _VkCmdProcessCommandsInfoNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pIndirectCommandsTokens.IsEmpty())) {
    Napi::Value value = self->pIndirectCommandsTokens.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.indirectCommandsTokenCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'indirectCommandsTokenCount' for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkIndirectCommandsTokenNVX>* data = this->vpIndirectCommandsTokens;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkIndirectCommandsTokenNVX::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens", "[object VkIndirectCommandsTokenNVX]");
  
        return false;
      }
      _VkIndirectCommandsTokenNVX* result = Napi::ObjectWrap<_VkIndirectCommandsTokenNVX>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pIndirectCommandsTokens = data->data();
  }
  return true;
}

// sType
Napi::Value _VkCmdProcessCommandsInfoNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCmdProcessCommandsInfoNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCmdProcessCommandsInfoNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCmdProcessCommandsInfoNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCmdProcessCommandsInfoNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.pNext", "[object Object]");
  
    return;
  }
}// objectTable
Napi::Value _VkCmdProcessCommandsInfoNVX::GetobjectTable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->objectTable.IsEmpty()) return env.Null();
  return this->objectTable.Value().As<Napi::Object>();
}void _VkCmdProcessCommandsInfoNVX::SetobjectTable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkObjectTableNVX::constructor.Value())) {
      
      this->objectTable.Reset(value.ToObject(), 1);
      _VkObjectTableNVX* inst = Napi::ObjectWrap<_VkObjectTableNVX>::Unwrap(obj);
      ;
      this->instance.objectTable = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->objectTable.Reset();
    this->instance.objectTable = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
    return;
  }
}// indirectCommandsLayout
Napi::Value _VkCmdProcessCommandsInfoNVX::GetindirectCommandsLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->indirectCommandsLayout.IsEmpty()) return env.Null();
  return this->indirectCommandsLayout.Value().As<Napi::Object>();
}void _VkCmdProcessCommandsInfoNVX::SetindirectCommandsLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkIndirectCommandsLayoutNVX::constructor.Value())) {
      
      this->indirectCommandsLayout.Reset(value.ToObject(), 1);
      _VkIndirectCommandsLayoutNVX* inst = Napi::ObjectWrap<_VkIndirectCommandsLayoutNVX>::Unwrap(obj);
      ;
      this->instance.indirectCommandsLayout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->indirectCommandsLayout.Reset();
    this->instance.indirectCommandsLayout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
    return;
  }
}// indirectCommandsTokenCount
Napi::Value _VkCmdProcessCommandsInfoNVX::GetindirectCommandsTokenCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.indirectCommandsTokenCount);
}void _VkCmdProcessCommandsInfoNVX::SetindirectCommandsTokenCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.indirectCommandsTokenCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.indirectCommandsTokenCount", "Number");
  
    return;
  }
}// pIndirectCommandsTokens
Napi::Value _VkCmdProcessCommandsInfoNVX::GetpIndirectCommandsTokens(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pIndirectCommandsTokens.IsEmpty()) return env.Null();
  return this->pIndirectCommandsTokens.Value().As<Napi::Array>();
}void _VkCmdProcessCommandsInfoNVX::SetpIndirectCommandsTokens(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pIndirectCommandsTokens.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pIndirectCommandsTokens.Reset();
      this->instance.pIndirectCommandsTokens = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens", "[object VkIndirectCommandsTokenNVX]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pIndirectCommandsTokens = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens", "[object VkIndirectCommandsTokenNVX]");
  
    return;
  }
}// maxSequencesCount
Napi::Value _VkCmdProcessCommandsInfoNVX::GetmaxSequencesCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSequencesCount);
}void _VkCmdProcessCommandsInfoNVX::SetmaxSequencesCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxSequencesCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.maxSequencesCount", "Number");
  
    return;
  }
}// targetCommandBuffer
Napi::Value _VkCmdProcessCommandsInfoNVX::GettargetCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->targetCommandBuffer.IsEmpty()) return env.Null();
  return this->targetCommandBuffer.Value().As<Napi::Object>();
}void _VkCmdProcessCommandsInfoNVX::SettargetCommandBuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkCommandBuffer::constructor.Value())) {
      
      this->targetCommandBuffer.Reset(value.ToObject(), 1);
      _VkCommandBuffer* inst = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
      ;
      this->instance.targetCommandBuffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.targetCommandBuffer", "[object VkCommandBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->targetCommandBuffer.Reset();
    this->instance.targetCommandBuffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.targetCommandBuffer", "[object VkCommandBuffer]");
  
    return;
  }
}// sequencesCountBuffer
Napi::Value _VkCmdProcessCommandsInfoNVX::GetsequencesCountBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sequencesCountBuffer.IsEmpty()) return env.Null();
  return this->sequencesCountBuffer.Value().As<Napi::Object>();
}void _VkCmdProcessCommandsInfoNVX::SetsequencesCountBuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->sequencesCountBuffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.sequencesCountBuffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesCountBuffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sequencesCountBuffer.Reset();
    this->instance.sequencesCountBuffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesCountBuffer", "[object VkBuffer]");
  
    return;
  }
}// sequencesCountOffset
Napi::Value _VkCmdProcessCommandsInfoNVX::GetsequencesCountOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sequencesCountOffset);
}void _VkCmdProcessCommandsInfoNVX::SetsequencesCountOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sequencesCountOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesCountOffset", "Number");
  
    return;
  }
}// sequencesIndexBuffer
Napi::Value _VkCmdProcessCommandsInfoNVX::GetsequencesIndexBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sequencesIndexBuffer.IsEmpty()) return env.Null();
  return this->sequencesIndexBuffer.Value().As<Napi::Object>();
}void _VkCmdProcessCommandsInfoNVX::SetsequencesIndexBuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->sequencesIndexBuffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.sequencesIndexBuffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sequencesIndexBuffer.Reset();
    this->instance.sequencesIndexBuffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer", "[object VkBuffer]");
  
    return;
  }
}// sequencesIndexOffset
Napi::Value _VkCmdProcessCommandsInfoNVX::GetsequencesIndexOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sequencesIndexOffset);
}void _VkCmdProcessCommandsInfoNVX::SetsequencesIndexOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sequencesIndexOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesIndexOffset", "Number");
  
    return;
  }
}
/** ## END VkCmdProcessCommandsInfoNVX ## **/

/** ## BEGIN VkIndirectCommandsLayoutCreateInfoNVX ## **/

Napi::FunctionReference _VkIndirectCommandsLayoutCreateInfoNVX::constructor;

_VkIndirectCommandsLayoutCreateInfoNVX::_VkIndirectCommandsLayoutCreateInfoNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX;
    vpTokens = new std::vector<VkIndirectCommandsLayoutTokenNVX>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "pipelineBindPoint");
      Napi::String sAccess3 = Napi::String::New(env, "flags");
      Napi::String sAccess4 = Napi::String::New(env, "tokenCount");
      Napi::String sAccess5 = Napi::String::New(env, "pTokens");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpipelineBindPoint(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setflags(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SettokenCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpTokens(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkIndirectCommandsLayoutCreateInfoNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkIndirectCommandsLayoutCreateInfoNVX::~_VkIndirectCommandsLayoutCreateInfoNVX() {
  
  
  pNext.Reset();
  
  
  
  
  vpTokens->clear();
  delete vpTokens;
  
  pTokens.Reset();
  
}

Napi::Object _VkIndirectCommandsLayoutCreateInfoNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkIndirectCommandsLayoutCreateInfoNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkIndirectCommandsLayoutCreateInfoNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkIndirectCommandsLayoutCreateInfoNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkIndirectCommandsLayoutCreateInfoNVX::GetsType,
    &_VkIndirectCommandsLayoutCreateInfoNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkIndirectCommandsLayoutCreateInfoNVX::GetpNext,
    &_VkIndirectCommandsLayoutCreateInfoNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineBindPoint",
    &_VkIndirectCommandsLayoutCreateInfoNVX::GetpipelineBindPoint,
    &_VkIndirectCommandsLayoutCreateInfoNVX::SetpipelineBindPoint,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkIndirectCommandsLayoutCreateInfoNVX::Getflags,
    &_VkIndirectCommandsLayoutCreateInfoNVX::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "tokenCount",
    &_VkIndirectCommandsLayoutCreateInfoNVX::GettokenCount,
    &_VkIndirectCommandsLayoutCreateInfoNVX::SettokenCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pTokens",
    &_VkIndirectCommandsLayoutCreateInfoNVX::GetpTokens,
    &_VkIndirectCommandsLayoutCreateInfoNVX::SetpTokens,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkIndirectCommandsLayoutCreateInfoNVX", func);
  return exports;
}

Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->pipelineBindPoint));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->pipelineBindPoint);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->flags));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->tokenCount));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->tokenCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->pTokens));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutCreateInfoNVX *)0)->pTokens);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkIndirectCommandsLayoutCreateInfoNVX::flush() {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pTokens.IsEmpty())) {
    Napi::Value value = self->pTokens.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.tokenCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'tokenCount' for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkIndirectCommandsLayoutTokenNVX>* data = this->vpTokens;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkIndirectCommandsLayoutTokenNVX::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pTokens", "[object VkIndirectCommandsLayoutTokenNVX]");
  
        return false;
      }
      _VkIndirectCommandsLayoutTokenNVX* result = Napi::ObjectWrap<_VkIndirectCommandsLayoutTokenNVX>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pTokens = data->data();
  }
  return true;
}

// sType
Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkIndirectCommandsLayoutCreateInfoNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkIndirectCommandsLayoutCreateInfoNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkIndirectCommandsLayoutCreateInfoNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pNext", "[object Object]");
  
    return;
  }
}// pipelineBindPoint
Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GetpipelineBindPoint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineBindPoint);
}void _VkIndirectCommandsLayoutCreateInfoNVX::SetpipelineBindPoint(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint", "Number");
  
    return;
  }
}// flags
Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkIndirectCommandsLayoutCreateInfoNVX::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkIndirectCommandsLayoutUsageFlagsNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.flags", "Number");
  
    return;
  }
}// tokenCount
Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GettokenCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tokenCount);
}void _VkIndirectCommandsLayoutCreateInfoNVX::SettokenCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tokenCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.tokenCount", "Number");
  
    return;
  }
}// pTokens
Napi::Value _VkIndirectCommandsLayoutCreateInfoNVX::GetpTokens(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pTokens.IsEmpty()) return env.Null();
  return this->pTokens.Value().As<Napi::Array>();
}void _VkIndirectCommandsLayoutCreateInfoNVX::SetpTokens(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pTokens.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pTokens.Reset();
      this->instance.pTokens = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pTokens", "[object VkIndirectCommandsLayoutTokenNVX]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pTokens = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pTokens", "[object VkIndirectCommandsLayoutTokenNVX]");
  
    return;
  }
}
/** ## END VkIndirectCommandsLayoutCreateInfoNVX ## **/

/** ## BEGIN VkIndirectCommandsLayoutTokenNVX ## **/

Napi::FunctionReference _VkIndirectCommandsLayoutTokenNVX::constructor;

_VkIndirectCommandsLayoutTokenNVX::_VkIndirectCommandsLayoutTokenNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkIndirectCommandsLayoutTokenNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "tokenType");
      Napi::String sAccess1 = Napi::String::New(env, "bindingUnit");
      Napi::String sAccess2 = Napi::String::New(env, "dynamicCount");
      Napi::String sAccess3 = Napi::String::New(env, "divisor");
      if (obj.Has(sAccess0)) this->SettokenType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbindingUnit(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdynamicCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setdivisor(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkIndirectCommandsLayoutTokenNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkIndirectCommandsLayoutTokenNVX::~_VkIndirectCommandsLayoutTokenNVX() {
  
  
  
  
  
}

Napi::Object _VkIndirectCommandsLayoutTokenNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkIndirectCommandsLayoutTokenNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkIndirectCommandsLayoutTokenNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkIndirectCommandsLayoutTokenNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "tokenType",
    &_VkIndirectCommandsLayoutTokenNVX::GettokenType,
    &_VkIndirectCommandsLayoutTokenNVX::SettokenType,
    napi_enumerable
  ),
  InstanceAccessor(
    "bindingUnit",
    &_VkIndirectCommandsLayoutTokenNVX::GetbindingUnit,
    &_VkIndirectCommandsLayoutTokenNVX::SetbindingUnit,
    napi_enumerable
  ),
  InstanceAccessor(
    "dynamicCount",
    &_VkIndirectCommandsLayoutTokenNVX::GetdynamicCount,
    &_VkIndirectCommandsLayoutTokenNVX::SetdynamicCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "divisor",
    &_VkIndirectCommandsLayoutTokenNVX::Getdivisor,
    &_VkIndirectCommandsLayoutTokenNVX::Setdivisor,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkIndirectCommandsLayoutTokenNVX", func);
  return exports;
}

Napi::Value _VkIndirectCommandsLayoutTokenNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkIndirectCommandsLayoutTokenNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutTokenNVX *)0)->tokenType));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutTokenNVX *)0)->tokenType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutTokenNVX *)0)->bindingUnit));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutTokenNVX *)0)->bindingUnit);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutTokenNVX *)0)->dynamicCount));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutTokenNVX *)0)->dynamicCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsLayoutTokenNVX *)0)->divisor));
    uint32_t byteLength = sizeof(((VkIndirectCommandsLayoutTokenNVX *)0)->divisor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkIndirectCommandsLayoutTokenNVX::flush() {
  _VkIndirectCommandsLayoutTokenNVX *self = this;
  
  return true;
}

// tokenType
Napi::Value _VkIndirectCommandsLayoutTokenNVX::GettokenType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tokenType);
}void _VkIndirectCommandsLayoutTokenNVX::SettokenType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tokenType = static_cast<VkIndirectCommandsTokenTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutTokenNVX.tokenType", "Number");
  
    return;
  }
}// bindingUnit
Napi::Value _VkIndirectCommandsLayoutTokenNVX::GetbindingUnit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bindingUnit);
}void _VkIndirectCommandsLayoutTokenNVX::SetbindingUnit(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bindingUnit = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutTokenNVX.bindingUnit", "Number");
  
    return;
  }
}// dynamicCount
Napi::Value _VkIndirectCommandsLayoutTokenNVX::GetdynamicCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dynamicCount);
}void _VkIndirectCommandsLayoutTokenNVX::SetdynamicCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dynamicCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutTokenNVX.dynamicCount", "Number");
  
    return;
  }
}// divisor
Napi::Value _VkIndirectCommandsLayoutTokenNVX::Getdivisor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.divisor);
}void _VkIndirectCommandsLayoutTokenNVX::Setdivisor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.divisor = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsLayoutTokenNVX.divisor", "Number");
  
    return;
  }
}
/** ## END VkIndirectCommandsLayoutTokenNVX ## **/

/** ## BEGIN VkIndirectCommandsTokenNVX ## **/

Napi::FunctionReference _VkIndirectCommandsTokenNVX::constructor;

_VkIndirectCommandsTokenNVX::_VkIndirectCommandsTokenNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkIndirectCommandsTokenNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "tokenType");
      Napi::String sAccess1 = Napi::String::New(env, "buffer");
      Napi::String sAccess2 = Napi::String::New(env, "offset");
      if (obj.Has(sAccess0)) this->SettokenType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setbuffer(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setoffset(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkIndirectCommandsTokenNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkIndirectCommandsTokenNVX::~_VkIndirectCommandsTokenNVX() {
  
  
  buffer.Reset();
  
  
}

Napi::Object _VkIndirectCommandsTokenNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkIndirectCommandsTokenNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkIndirectCommandsTokenNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkIndirectCommandsTokenNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "tokenType",
    &_VkIndirectCommandsTokenNVX::GettokenType,
    &_VkIndirectCommandsTokenNVX::SettokenType,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkIndirectCommandsTokenNVX::Getbuffer,
    &_VkIndirectCommandsTokenNVX::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkIndirectCommandsTokenNVX::Getoffset,
    &_VkIndirectCommandsTokenNVX::Setoffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkIndirectCommandsTokenNVX", func);
  return exports;
}

Napi::Value _VkIndirectCommandsTokenNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkIndirectCommandsTokenNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsTokenNVX *)0)->tokenType));
    uint32_t byteLength = sizeof(((VkIndirectCommandsTokenNVX *)0)->tokenType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsTokenNVX *)0)->buffer));
    uint32_t byteLength = sizeof(((VkIndirectCommandsTokenNVX *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkIndirectCommandsTokenNVX *)0)->offset));
    uint32_t byteLength = sizeof(((VkIndirectCommandsTokenNVX *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkIndirectCommandsTokenNVX::flush() {
  _VkIndirectCommandsTokenNVX *self = this;
  
  return true;
}

// tokenType
Napi::Value _VkIndirectCommandsTokenNVX::GettokenType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tokenType);
}void _VkIndirectCommandsTokenNVX::SettokenType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tokenType = static_cast<VkIndirectCommandsTokenTypeNVX>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsTokenNVX.tokenType", "Number");
  
    return;
  }
}// buffer
Napi::Value _VkIndirectCommandsTokenNVX::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkIndirectCommandsTokenNVX::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkIndirectCommandsTokenNVX.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsTokenNVX.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
Napi::Value _VkIndirectCommandsTokenNVX::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkIndirectCommandsTokenNVX::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkIndirectCommandsTokenNVX.offset", "Number");
  
    return;
  }
}
/** ## END VkIndirectCommandsTokenNVX ## **/

/** ## BEGIN VkDeviceGeneratedCommandsLimitsNVX ## **/

Napi::FunctionReference _VkDeviceGeneratedCommandsLimitsNVX::constructor;

_VkDeviceGeneratedCommandsLimitsNVX::_VkDeviceGeneratedCommandsLimitsNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGeneratedCommandsLimitsNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "maxIndirectCommandsLayoutTokenCount");
      Napi::String sAccess3 = Napi::String::New(env, "maxObjectEntryCounts");
      Napi::String sAccess4 = Napi::String::New(env, "minSequenceCountBufferOffsetAlignment");
      Napi::String sAccess5 = Napi::String::New(env, "minSequenceIndexBufferOffsetAlignment");
      Napi::String sAccess6 = Napi::String::New(env, "minCommandsTokenBufferOffsetAlignment");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetmaxIndirectCommandsLayoutTokenCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmaxObjectEntryCounts(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetminSequenceCountBufferOffsetAlignment(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetminSequenceIndexBufferOffsetAlignment(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetminCommandsTokenBufferOffsetAlignment(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkDeviceGeneratedCommandsLimitsNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGeneratedCommandsLimitsNVX::~_VkDeviceGeneratedCommandsLimitsNVX() {
  
  
  pNext.Reset();
  
  
  
  
  
  
}

Napi::Object _VkDeviceGeneratedCommandsLimitsNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGeneratedCommandsLimitsNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGeneratedCommandsLimitsNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGeneratedCommandsLimitsNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetsType,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetpNext,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxIndirectCommandsLayoutTokenCount",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetmaxIndirectCommandsLayoutTokenCount,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetmaxIndirectCommandsLayoutTokenCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxObjectEntryCounts",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetmaxObjectEntryCounts,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetmaxObjectEntryCounts,
    napi_enumerable
  ),
  InstanceAccessor(
    "minSequenceCountBufferOffsetAlignment",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetminSequenceCountBufferOffsetAlignment,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetminSequenceCountBufferOffsetAlignment,
    napi_enumerable
  ),
  InstanceAccessor(
    "minSequenceIndexBufferOffsetAlignment",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetminSequenceIndexBufferOffsetAlignment,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetminSequenceIndexBufferOffsetAlignment,
    napi_enumerable
  ),
  InstanceAccessor(
    "minCommandsTokenBufferOffsetAlignment",
    &_VkDeviceGeneratedCommandsLimitsNVX::GetminCommandsTokenBufferOffsetAlignment,
    &_VkDeviceGeneratedCommandsLimitsNVX::SetminCommandsTokenBufferOffsetAlignment,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGeneratedCommandsLimitsNVX", func);
  return exports;
}

Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->maxIndirectCommandsLayoutTokenCount));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->maxIndirectCommandsLayoutTokenCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->maxObjectEntryCounts));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->maxObjectEntryCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->minSequenceCountBufferOffsetAlignment));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->minSequenceCountBufferOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->minSequenceIndexBufferOffsetAlignment));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->minSequenceIndexBufferOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsLimitsNVX *)0)->minCommandsTokenBufferOffsetAlignment));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsLimitsNVX *)0)->minCommandsTokenBufferOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGeneratedCommandsLimitsNVX::flush() {
  _VkDeviceGeneratedCommandsLimitsNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGeneratedCommandsLimitsNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGeneratedCommandsLimitsNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGeneratedCommandsLimitsNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.pNext", "[object Object]");
  
    return;
  }
}// maxIndirectCommandsLayoutTokenCount
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetmaxIndirectCommandsLayoutTokenCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxIndirectCommandsLayoutTokenCount);
}void _VkDeviceGeneratedCommandsLimitsNVX::SetmaxIndirectCommandsLayoutTokenCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxIndirectCommandsLayoutTokenCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.maxIndirectCommandsLayoutTokenCount", "Number");
  
    return;
  }
}// maxObjectEntryCounts
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetmaxObjectEntryCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxObjectEntryCounts);
}void _VkDeviceGeneratedCommandsLimitsNVX::SetmaxObjectEntryCounts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxObjectEntryCounts = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.maxObjectEntryCounts", "Number");
  
    return;
  }
}// minSequenceCountBufferOffsetAlignment
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetminSequenceCountBufferOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minSequenceCountBufferOffsetAlignment);
}void _VkDeviceGeneratedCommandsLimitsNVX::SetminSequenceCountBufferOffsetAlignment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minSequenceCountBufferOffsetAlignment = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.minSequenceCountBufferOffsetAlignment", "Number");
  
    return;
  }
}// minSequenceIndexBufferOffsetAlignment
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetminSequenceIndexBufferOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minSequenceIndexBufferOffsetAlignment);
}void _VkDeviceGeneratedCommandsLimitsNVX::SetminSequenceIndexBufferOffsetAlignment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minSequenceIndexBufferOffsetAlignment = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.minSequenceIndexBufferOffsetAlignment", "Number");
  
    return;
  }
}// minCommandsTokenBufferOffsetAlignment
Napi::Value _VkDeviceGeneratedCommandsLimitsNVX::GetminCommandsTokenBufferOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minCommandsTokenBufferOffsetAlignment);
}void _VkDeviceGeneratedCommandsLimitsNVX::SetminCommandsTokenBufferOffsetAlignment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minCommandsTokenBufferOffsetAlignment = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.minCommandsTokenBufferOffsetAlignment", "Number");
  
    return;
  }
}
/** ## END VkDeviceGeneratedCommandsLimitsNVX ## **/

/** ## BEGIN VkDeviceGeneratedCommandsFeaturesNVX ## **/

Napi::FunctionReference _VkDeviceGeneratedCommandsFeaturesNVX::constructor;

_VkDeviceGeneratedCommandsFeaturesNVX::_VkDeviceGeneratedCommandsFeaturesNVX(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceGeneratedCommandsFeaturesNVX>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "computeBindingPointSupport");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetcomputeBindingPointSupport(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDeviceGeneratedCommandsFeaturesNVX constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceGeneratedCommandsFeaturesNVX::~_VkDeviceGeneratedCommandsFeaturesNVX() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDeviceGeneratedCommandsFeaturesNVX::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceGeneratedCommandsFeaturesNVX", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceGeneratedCommandsFeaturesNVX::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceGeneratedCommandsFeaturesNVX::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceGeneratedCommandsFeaturesNVX::GetsType,
    &_VkDeviceGeneratedCommandsFeaturesNVX::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceGeneratedCommandsFeaturesNVX::GetpNext,
    &_VkDeviceGeneratedCommandsFeaturesNVX::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "computeBindingPointSupport",
    &_VkDeviceGeneratedCommandsFeaturesNVX::GetcomputeBindingPointSupport,
    &_VkDeviceGeneratedCommandsFeaturesNVX::SetcomputeBindingPointSupport,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceGeneratedCommandsFeaturesNVX", func);
  return exports;
}

Napi::Value _VkDeviceGeneratedCommandsFeaturesNVX::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceGeneratedCommandsFeaturesNVX::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsFeaturesNVX *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsFeaturesNVX *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsFeaturesNVX *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsFeaturesNVX *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceGeneratedCommandsFeaturesNVX *)0)->computeBindingPointSupport));
    uint32_t byteLength = sizeof(((VkDeviceGeneratedCommandsFeaturesNVX *)0)->computeBindingPointSupport);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceGeneratedCommandsFeaturesNVX::flush() {
  _VkDeviceGeneratedCommandsFeaturesNVX *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDeviceGeneratedCommandsFeaturesNVX::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceGeneratedCommandsFeaturesNVX::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsFeaturesNVX.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceGeneratedCommandsFeaturesNVX::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceGeneratedCommandsFeaturesNVX::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDeviceGeneratedCommandsFeaturesNVX.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsFeaturesNVX.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsFeaturesNVX.pNext", "[object Object]");
  
    return;
  }
}// computeBindingPointSupport
Napi::Value _VkDeviceGeneratedCommandsFeaturesNVX::GetcomputeBindingPointSupport(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.computeBindingPointSupport);
}void _VkDeviceGeneratedCommandsFeaturesNVX::SetcomputeBindingPointSupport(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.computeBindingPointSupport = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.computeBindingPointSupport = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkDeviceGeneratedCommandsFeaturesNVX.computeBindingPointSupport", "Number");
  
    return;
  }
}
/** ## END VkDeviceGeneratedCommandsFeaturesNVX ## **/

/** ## BEGIN VkWin32KeyedMutexAcquireReleaseInfoNV ## **/

Napi::FunctionReference _VkWin32KeyedMutexAcquireReleaseInfoNV::constructor;

_VkWin32KeyedMutexAcquireReleaseInfoNV::_VkWin32KeyedMutexAcquireReleaseInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
    vpAcquireSyncs = new std::vector<VkDeviceMemory>;
    vpReleaseSyncs = new std::vector<VkDeviceMemory>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "acquireCount");
      Napi::String sAccess3 = Napi::String::New(env, "pAcquireSyncs");
      Napi::String sAccess4 = Napi::String::New(env, "pAcquireKeys");
      Napi::String sAccess5 = Napi::String::New(env, "pAcquireTimeoutMilliseconds");
      Napi::String sAccess6 = Napi::String::New(env, "releaseCount");
      Napi::String sAccess7 = Napi::String::New(env, "pReleaseSyncs");
      Napi::String sAccess8 = Napi::String::New(env, "pReleaseKeys");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetacquireCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpAcquireSyncs(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpAcquireKeys(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpAcquireTimeoutMilliseconds(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetreleaseCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpReleaseSyncs(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpReleaseKeys(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkWin32KeyedMutexAcquireReleaseInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkWin32KeyedMutexAcquireReleaseInfoNV::~_VkWin32KeyedMutexAcquireReleaseInfoNV() {
  
  
  pNext.Reset();
  
  
  vpAcquireSyncs->clear();
  delete vpAcquireSyncs;
  
  pAcquireSyncs.Reset();
  
  pAcquireKeys.Reset();
  
  pAcquireTimeoutMilliseconds.Reset();
  
  
  vpReleaseSyncs->clear();
  delete vpReleaseSyncs;
  
  pReleaseSyncs.Reset();
  
  pReleaseKeys.Reset();
  
}

Napi::Object _VkWin32KeyedMutexAcquireReleaseInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkWin32KeyedMutexAcquireReleaseInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetsType,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpNext,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "acquireCount",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetacquireCount,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetacquireCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAcquireSyncs",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireSyncs,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireSyncs,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAcquireKeys",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireKeys,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireKeys,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAcquireTimeoutMilliseconds",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireTimeoutMilliseconds,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireTimeoutMilliseconds,
    napi_enumerable
  ),
  InstanceAccessor(
    "releaseCount",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetreleaseCount,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetreleaseCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pReleaseSyncs",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpReleaseSyncs,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpReleaseSyncs,
    napi_enumerable
  ),
  InstanceAccessor(
    "pReleaseKeys",
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpReleaseKeys,
    &_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpReleaseKeys,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkWin32KeyedMutexAcquireReleaseInfoNV", func);
  return exports;
}

Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->acquireCount));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->acquireCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pAcquireSyncs));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pAcquireSyncs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pAcquireKeys));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pAcquireKeys);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pAcquireTimeoutMilliseconds));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pAcquireTimeoutMilliseconds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->releaseCount));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->releaseCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pReleaseSyncs));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pReleaseSyncs);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pReleaseKeys));
    uint32_t byteLength = sizeof(((VkWin32KeyedMutexAcquireReleaseInfoNV *)0)->pReleaseKeys);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkWin32KeyedMutexAcquireReleaseInfoNV::flush() {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAcquireSyncs.IsEmpty())) {
    Napi::Value value = self->pAcquireSyncs.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.acquireCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDeviceMemory>* data = this->vpAcquireSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAcquireSyncs = data->data();
  }if (!(self->pReleaseSyncs.IsEmpty())) {
    Napi::Value value = self->pReleaseSyncs.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.releaseCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDeviceMemory>* data = this->vpReleaseSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pReleaseSyncs = data->data();
  }
  return true;
}

// sType
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkWin32KeyedMutexAcquireReleaseInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pNext", "[object Object]");
  
    return;
  }
}// acquireCount
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetacquireCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.acquireCount);
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetacquireCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.acquireCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.acquireCount", "Number");
  
    return;
  }
}// pAcquireSyncs
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireSyncs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAcquireSyncs.IsEmpty()) return env.Null();
  return this->pAcquireSyncs.Value().As<Napi::Array>();
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireSyncs(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAcquireSyncs.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAcquireSyncs.Reset();
      this->instance.pAcquireSyncs = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAcquireSyncs = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pAcquireKeys
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireKeys(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAcquireKeys.IsEmpty()) return env.Null();
  return this->pAcquireKeys.Value().As<Napi::TypedArray>();
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireKeys(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_biguint64_array) {
        this->pAcquireKeys.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys", "BigUint64Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pAcquireKeys.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pAcquireKeys = getTypedArrayData<uint64_t>(value, nullptr);
  } else {
    this->instance.pAcquireKeys = nullptr;
  }
}// pAcquireTimeoutMilliseconds
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireTimeoutMilliseconds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAcquireTimeoutMilliseconds.IsEmpty()) return env.Null();
  return this->pAcquireTimeoutMilliseconds.Value().As<Napi::TypedArray>();
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireTimeoutMilliseconds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pAcquireTimeoutMilliseconds.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pAcquireTimeoutMilliseconds.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pAcquireTimeoutMilliseconds = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pAcquireTimeoutMilliseconds = nullptr;
  }
}// releaseCount
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetreleaseCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.releaseCount);
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetreleaseCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.releaseCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.releaseCount", "Number");
  
    return;
  }
}// pReleaseSyncs
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetpReleaseSyncs(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pReleaseSyncs.IsEmpty()) return env.Null();
  return this->pReleaseSyncs.Value().As<Napi::Array>();
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetpReleaseSyncs(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pReleaseSyncs.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pReleaseSyncs.Reset();
      this->instance.pReleaseSyncs = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pReleaseSyncs = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pReleaseKeys
Napi::Value _VkWin32KeyedMutexAcquireReleaseInfoNV::GetpReleaseKeys(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pReleaseKeys.IsEmpty()) return env.Null();
  return this->pReleaseKeys.Value().As<Napi::TypedArray>();
}void _VkWin32KeyedMutexAcquireReleaseInfoNV::SetpReleaseKeys(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_biguint64_array) {
        this->pReleaseKeys.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys", "BigUint64Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pReleaseKeys.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pReleaseKeys = getTypedArrayData<uint64_t>(value, nullptr);
  } else {
    this->instance.pReleaseKeys = nullptr;
  }
}
/** ## END VkWin32KeyedMutexAcquireReleaseInfoNV ## **/

/** ## BEGIN VkExportMemoryWin32HandleInfoNV ## **/

Napi::FunctionReference _VkExportMemoryWin32HandleInfoNV::constructor;

_VkExportMemoryWin32HandleInfoNV::_VkExportMemoryWin32HandleInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportMemoryWin32HandleInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExportMemoryWin32HandleInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportMemoryWin32HandleInfoNV::~_VkExportMemoryWin32HandleInfoNV() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkExportMemoryWin32HandleInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportMemoryWin32HandleInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportMemoryWin32HandleInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportMemoryWin32HandleInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportMemoryWin32HandleInfoNV::GetsType,
    &_VkExportMemoryWin32HandleInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportMemoryWin32HandleInfoNV::GetpNext,
    &_VkExportMemoryWin32HandleInfoNV::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportMemoryWin32HandleInfoNV", func);
  return exports;
}

Napi::Value _VkExportMemoryWin32HandleInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportMemoryWin32HandleInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryWin32HandleInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportMemoryWin32HandleInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryWin32HandleInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportMemoryWin32HandleInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportMemoryWin32HandleInfoNV::flush() {
  _VkExportMemoryWin32HandleInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportMemoryWin32HandleInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportMemoryWin32HandleInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryWin32HandleInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportMemoryWin32HandleInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportMemoryWin32HandleInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportMemoryWin32HandleInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportMemoryWin32HandleInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryWin32HandleInfoNV.pNext", "[object Object]");
  
    return;
  }
}
/** ## END VkExportMemoryWin32HandleInfoNV ## **/

/** ## BEGIN VkImportMemoryWin32HandleInfoNV ## **/

Napi::FunctionReference _VkImportMemoryWin32HandleInfoNV::constructor;

_VkImportMemoryWin32HandleInfoNV::_VkImportMemoryWin32HandleInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImportMemoryWin32HandleInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleType");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleType(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImportMemoryWin32HandleInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkImportMemoryWin32HandleInfoNV::~_VkImportMemoryWin32HandleInfoNV() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkImportMemoryWin32HandleInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImportMemoryWin32HandleInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImportMemoryWin32HandleInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImportMemoryWin32HandleInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImportMemoryWin32HandleInfoNV::GetsType,
    &_VkImportMemoryWin32HandleInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImportMemoryWin32HandleInfoNV::GetpNext,
    &_VkImportMemoryWin32HandleInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleType",
    &_VkImportMemoryWin32HandleInfoNV::GethandleType,
    &_VkImportMemoryWin32HandleInfoNV::SethandleType,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImportMemoryWin32HandleInfoNV", func);
  return exports;
}

Napi::Value _VkImportMemoryWin32HandleInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImportMemoryWin32HandleInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryWin32HandleInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkImportMemoryWin32HandleInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryWin32HandleInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImportMemoryWin32HandleInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImportMemoryWin32HandleInfoNV *)0)->handleType));
    uint32_t byteLength = sizeof(((VkImportMemoryWin32HandleInfoNV *)0)->handleType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImportMemoryWin32HandleInfoNV::flush() {
  _VkImportMemoryWin32HandleInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkImportMemoryWin32HandleInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImportMemoryWin32HandleInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImportMemoryWin32HandleInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImportMemoryWin32HandleInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkImportMemoryWin32HandleInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoNV.pNext", "[object Object]");
  
    return;
  }
}// handleType
Napi::Value _VkImportMemoryWin32HandleInfoNV::GethandleType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleType);
}void _VkImportMemoryWin32HandleInfoNV::SethandleType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagsNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImportMemoryWin32HandleInfoNV.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryWin32HandleInfoNV ## **/

/** ## BEGIN VkExportMemoryAllocateInfoNV ## **/

Napi::FunctionReference _VkExportMemoryAllocateInfoNV::constructor;

_VkExportMemoryAllocateInfoNV::_VkExportMemoryAllocateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExportMemoryAllocateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExportMemoryAllocateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkExportMemoryAllocateInfoNV::~_VkExportMemoryAllocateInfoNV() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExportMemoryAllocateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExportMemoryAllocateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExportMemoryAllocateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExportMemoryAllocateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExportMemoryAllocateInfoNV::GetsType,
    &_VkExportMemoryAllocateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExportMemoryAllocateInfoNV::GetpNext,
    &_VkExportMemoryAllocateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExportMemoryAllocateInfoNV::GethandleTypes,
    &_VkExportMemoryAllocateInfoNV::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExportMemoryAllocateInfoNV", func);
  return exports;
}

Napi::Value _VkExportMemoryAllocateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExportMemoryAllocateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExportMemoryAllocateInfoNV *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExportMemoryAllocateInfoNV *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExportMemoryAllocateInfoNV::flush() {
  _VkExportMemoryAllocateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExportMemoryAllocateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExportMemoryAllocateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExportMemoryAllocateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExportMemoryAllocateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExportMemoryAllocateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExportMemoryAllocateInfoNV::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExportMemoryAllocateInfoNV::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlagsNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExportMemoryAllocateInfoNV.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryAllocateInfoNV ## **/

/** ## BEGIN VkExternalMemoryImageCreateInfoNV ## **/

Napi::FunctionReference _VkExternalMemoryImageCreateInfoNV::constructor;

_VkExternalMemoryImageCreateInfoNV::_VkExternalMemoryImageCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalMemoryImageCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "handleTypes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SethandleTypes(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExternalMemoryImageCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalMemoryImageCreateInfoNV::~_VkExternalMemoryImageCreateInfoNV() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkExternalMemoryImageCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalMemoryImageCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalMemoryImageCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalMemoryImageCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkExternalMemoryImageCreateInfoNV::GetsType,
    &_VkExternalMemoryImageCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkExternalMemoryImageCreateInfoNV::GetpNext,
    &_VkExternalMemoryImageCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "handleTypes",
    &_VkExternalMemoryImageCreateInfoNV::GethandleTypes,
    &_VkExternalMemoryImageCreateInfoNV::SethandleTypes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalMemoryImageCreateInfoNV", func);
  return exports;
}

Napi::Value _VkExternalMemoryImageCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalMemoryImageCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalMemoryImageCreateInfoNV *)0)->handleTypes));
    uint32_t byteLength = sizeof(((VkExternalMemoryImageCreateInfoNV *)0)->handleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalMemoryImageCreateInfoNV::flush() {
  _VkExternalMemoryImageCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkExternalMemoryImageCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkExternalMemoryImageCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkExternalMemoryImageCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkExternalMemoryImageCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkExternalMemoryImageCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// handleTypes
Napi::Value _VkExternalMemoryImageCreateInfoNV::GethandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.handleTypes);
}void _VkExternalMemoryImageCreateInfoNV::SethandleTypes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlagsNV>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkExternalMemoryImageCreateInfoNV.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryImageCreateInfoNV ## **/

/** ## BEGIN VkExternalImageFormatPropertiesNV ## **/

Napi::FunctionReference _VkExternalImageFormatPropertiesNV::constructor;

_VkExternalImageFormatPropertiesNV::_VkExternalImageFormatPropertiesNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExternalImageFormatPropertiesNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkExternalImageFormatPropertiesNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkExternalImageFormatPropertiesNV::~_VkExternalImageFormatPropertiesNV() {
  
  imageFormatProperties.Reset();
  
  
  
  
}

Napi::Object _VkExternalImageFormatPropertiesNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExternalImageFormatPropertiesNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExternalImageFormatPropertiesNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExternalImageFormatPropertiesNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "imageFormatProperties",
    &_VkExternalImageFormatPropertiesNV::GetimageFormatProperties,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "externalMemoryFeatures",
    &_VkExternalImageFormatPropertiesNV::GetexternalMemoryFeatures,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "exportFromImportedHandleTypes",
    &_VkExternalImageFormatPropertiesNV::GetexportFromImportedHandleTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "compatibleHandleTypes",
    &_VkExternalImageFormatPropertiesNV::GetcompatibleHandleTypes,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExternalImageFormatPropertiesNV", func);
  return exports;
}

Napi::Value _VkExternalImageFormatPropertiesNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExternalImageFormatPropertiesNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesNV *)0)->imageFormatProperties));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesNV *)0)->imageFormatProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesNV *)0)->externalMemoryFeatures));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesNV *)0)->externalMemoryFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesNV *)0)->exportFromImportedHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesNV *)0)->exportFromImportedHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExternalImageFormatPropertiesNV *)0)->compatibleHandleTypes));
    uint32_t byteLength = sizeof(((VkExternalImageFormatPropertiesNV *)0)->compatibleHandleTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExternalImageFormatPropertiesNV::flush() {
  _VkExternalImageFormatPropertiesNV *self = this;
  if (!(self->imageFormatProperties.IsEmpty())) {
    Napi::Value value = self->imageFormatProperties.Value();
    
  }
  return true;
}

// imageFormatProperties
Napi::Value _VkExternalImageFormatPropertiesNV::GetimageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageFormatProperties.IsEmpty()) return env.Null();
  return this->imageFormatProperties.Value().As<Napi::Object>();
}// externalMemoryFeatures
Napi::Value _VkExternalImageFormatPropertiesNV::GetexternalMemoryFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.externalMemoryFeatures);
}// exportFromImportedHandleTypes
Napi::Value _VkExternalImageFormatPropertiesNV::GetexportFromImportedHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.exportFromImportedHandleTypes);
}// compatibleHandleTypes
Napi::Value _VkExternalImageFormatPropertiesNV::GetcompatibleHandleTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compatibleHandleTypes);
}
/** ## END VkExternalImageFormatPropertiesNV ## **/

/** ## BEGIN VkDedicatedAllocationMemoryAllocateInfoNV ## **/

Napi::FunctionReference _VkDedicatedAllocationMemoryAllocateInfoNV::constructor;

_VkDedicatedAllocationMemoryAllocateInfoNV::_VkDedicatedAllocationMemoryAllocateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "image");
      Napi::String sAccess3 = Napi::String::New(env, "buffer");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setimage(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setbuffer(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDedicatedAllocationMemoryAllocateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkDedicatedAllocationMemoryAllocateInfoNV::~_VkDedicatedAllocationMemoryAllocateInfoNV() {
  
  
  pNext.Reset();
  
  image.Reset();
  
  buffer.Reset();
  
}

Napi::Object _VkDedicatedAllocationMemoryAllocateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDedicatedAllocationMemoryAllocateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDedicatedAllocationMemoryAllocateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDedicatedAllocationMemoryAllocateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDedicatedAllocationMemoryAllocateInfoNV::GetsType,
    &_VkDedicatedAllocationMemoryAllocateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDedicatedAllocationMemoryAllocateInfoNV::GetpNext,
    &_VkDedicatedAllocationMemoryAllocateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkDedicatedAllocationMemoryAllocateInfoNV::Getimage,
    &_VkDedicatedAllocationMemoryAllocateInfoNV::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkDedicatedAllocationMemoryAllocateInfoNV::Getbuffer,
    &_VkDedicatedAllocationMemoryAllocateInfoNV::Setbuffer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDedicatedAllocationMemoryAllocateInfoNV", func);
  return exports;
}

Napi::Value _VkDedicatedAllocationMemoryAllocateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDedicatedAllocationMemoryAllocateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->image));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->buffer));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationMemoryAllocateInfoNV *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDedicatedAllocationMemoryAllocateInfoNV::flush() {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDedicatedAllocationMemoryAllocateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDedicatedAllocationMemoryAllocateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDedicatedAllocationMemoryAllocateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDedicatedAllocationMemoryAllocateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDedicatedAllocationMemoryAllocateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// image
Napi::Value _VkDedicatedAllocationMemoryAllocateInfoNV::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkDedicatedAllocationMemoryAllocateInfoNV::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.image", "[object VkImage]");
  
    return;
  }
}// buffer
Napi::Value _VkDedicatedAllocationMemoryAllocateInfoNV::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkDedicatedAllocationMemoryAllocateInfoNV::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkDedicatedAllocationMemoryAllocateInfoNV ## **/

/** ## BEGIN VkDedicatedAllocationBufferCreateInfoNV ## **/

Napi::FunctionReference _VkDedicatedAllocationBufferCreateInfoNV::constructor;

_VkDedicatedAllocationBufferCreateInfoNV::_VkDedicatedAllocationBufferCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDedicatedAllocationBufferCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "dedicatedAllocation");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdedicatedAllocation(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDedicatedAllocationBufferCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkDedicatedAllocationBufferCreateInfoNV::~_VkDedicatedAllocationBufferCreateInfoNV() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDedicatedAllocationBufferCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDedicatedAllocationBufferCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDedicatedAllocationBufferCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDedicatedAllocationBufferCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDedicatedAllocationBufferCreateInfoNV::GetsType,
    &_VkDedicatedAllocationBufferCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDedicatedAllocationBufferCreateInfoNV::GetpNext,
    &_VkDedicatedAllocationBufferCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "dedicatedAllocation",
    &_VkDedicatedAllocationBufferCreateInfoNV::GetdedicatedAllocation,
    &_VkDedicatedAllocationBufferCreateInfoNV::SetdedicatedAllocation,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDedicatedAllocationBufferCreateInfoNV", func);
  return exports;
}

Napi::Value _VkDedicatedAllocationBufferCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDedicatedAllocationBufferCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationBufferCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationBufferCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationBufferCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationBufferCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationBufferCreateInfoNV *)0)->dedicatedAllocation));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationBufferCreateInfoNV *)0)->dedicatedAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDedicatedAllocationBufferCreateInfoNV::flush() {
  _VkDedicatedAllocationBufferCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDedicatedAllocationBufferCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDedicatedAllocationBufferCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationBufferCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDedicatedAllocationBufferCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDedicatedAllocationBufferCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDedicatedAllocationBufferCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDedicatedAllocationBufferCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationBufferCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// dedicatedAllocation
Napi::Value _VkDedicatedAllocationBufferCreateInfoNV::GetdedicatedAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dedicatedAllocation);
}void _VkDedicatedAllocationBufferCreateInfoNV::SetdedicatedAllocation(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.dedicatedAllocation = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.dedicatedAllocation = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationBufferCreateInfoNV.dedicatedAllocation", "Number");
  
    return;
  }
}
/** ## END VkDedicatedAllocationBufferCreateInfoNV ## **/

/** ## BEGIN VkDedicatedAllocationImageCreateInfoNV ## **/

Napi::FunctionReference _VkDedicatedAllocationImageCreateInfoNV::constructor;

_VkDedicatedAllocationImageCreateInfoNV::_VkDedicatedAllocationImageCreateInfoNV(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDedicatedAllocationImageCreateInfoNV>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "dedicatedAllocation");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdedicatedAllocation(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDedicatedAllocationImageCreateInfoNV constructor cannot be invoked without 'new'");
    }
  }
}

_VkDedicatedAllocationImageCreateInfoNV::~_VkDedicatedAllocationImageCreateInfoNV() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkDedicatedAllocationImageCreateInfoNV::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDedicatedAllocationImageCreateInfoNV", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDedicatedAllocationImageCreateInfoNV::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDedicatedAllocationImageCreateInfoNV::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDedicatedAllocationImageCreateInfoNV::GetsType,
    &_VkDedicatedAllocationImageCreateInfoNV::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDedicatedAllocationImageCreateInfoNV::GetpNext,
    &_VkDedicatedAllocationImageCreateInfoNV::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "dedicatedAllocation",
    &_VkDedicatedAllocationImageCreateInfoNV::GetdedicatedAllocation,
    &_VkDedicatedAllocationImageCreateInfoNV::SetdedicatedAllocation,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDedicatedAllocationImageCreateInfoNV", func);
  return exports;
}

Napi::Value _VkDedicatedAllocationImageCreateInfoNV::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDedicatedAllocationImageCreateInfoNV::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationImageCreateInfoNV *)0)->sType));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationImageCreateInfoNV *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationImageCreateInfoNV *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationImageCreateInfoNV *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDedicatedAllocationImageCreateInfoNV *)0)->dedicatedAllocation));
    uint32_t byteLength = sizeof(((VkDedicatedAllocationImageCreateInfoNV *)0)->dedicatedAllocation);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDedicatedAllocationImageCreateInfoNV::flush() {
  _VkDedicatedAllocationImageCreateInfoNV *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDedicatedAllocationImageCreateInfoNV::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDedicatedAllocationImageCreateInfoNV::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationImageCreateInfoNV.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDedicatedAllocationImageCreateInfoNV::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDedicatedAllocationImageCreateInfoNV::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDedicatedAllocationImageCreateInfoNV.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDedicatedAllocationImageCreateInfoNV.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationImageCreateInfoNV.pNext", "[object Object]");
  
    return;
  }
}// dedicatedAllocation
Napi::Value _VkDedicatedAllocationImageCreateInfoNV::GetdedicatedAllocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dedicatedAllocation);
}void _VkDedicatedAllocationImageCreateInfoNV::SetdedicatedAllocation(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.dedicatedAllocation = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.dedicatedAllocation = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkDedicatedAllocationImageCreateInfoNV.dedicatedAllocation", "Number");
  
    return;
  }
}
/** ## END VkDedicatedAllocationImageCreateInfoNV ## **/

/** ## BEGIN VkDebugMarkerMarkerInfoEXT ## **/

Napi::FunctionReference _VkDebugMarkerMarkerInfoEXT::constructor;

_VkDebugMarkerMarkerInfoEXT::_VkDebugMarkerMarkerInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugMarkerMarkerInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
    vcolor = new std::vector<float>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "pMarkerName");
      Napi::String sAccess3 = Napi::String::New(env, "color");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpMarkerName(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setcolor(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDebugMarkerMarkerInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugMarkerMarkerInfoEXT::~_VkDebugMarkerMarkerInfoEXT() {
  
  
  pNext.Reset();
  
  pMarkerName.Reset();
  
  vcolor->clear();
  delete vcolor;
  
  color.Reset();
  
}

Napi::Object _VkDebugMarkerMarkerInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugMarkerMarkerInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugMarkerMarkerInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugMarkerMarkerInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugMarkerMarkerInfoEXT::GetsType,
    &_VkDebugMarkerMarkerInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugMarkerMarkerInfoEXT::GetpNext,
    &_VkDebugMarkerMarkerInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "pMarkerName",
    &_VkDebugMarkerMarkerInfoEXT::GetpMarkerName,
    &_VkDebugMarkerMarkerInfoEXT::SetpMarkerName,
    napi_enumerable
  ),
  InstanceAccessor(
    "color",
    &_VkDebugMarkerMarkerInfoEXT::Getcolor,
    &_VkDebugMarkerMarkerInfoEXT::Setcolor,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugMarkerMarkerInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugMarkerMarkerInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugMarkerMarkerInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerMarkerInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugMarkerMarkerInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerMarkerInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugMarkerMarkerInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerMarkerInfoEXT *)0)->pMarkerName));
    uint32_t byteLength = sizeof(((VkDebugMarkerMarkerInfoEXT *)0)->pMarkerName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerMarkerInfoEXT *)0)->color));
    uint32_t byteLength = sizeof(((VkDebugMarkerMarkerInfoEXT *)0)->color);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugMarkerMarkerInfoEXT::flush() {
  _VkDebugMarkerMarkerInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->color.IsEmpty())) {
    Napi::Value value = self->color.Value();
    
    if (value.IsArray()) {
      // validate length
      if (value.As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '4' for 'VkDebugMarkerMarkerInfoEXT.color'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(this->instance.color, array.data(), sizeof(float) * 4);
    } else if (value.IsNull()) {
      memset(&this->instance.color, 0, sizeof(float));
    } else {
      
    NapiObjectTypeError(value, "VkDebugMarkerMarkerInfoEXT.color", "Array");
  
      return false;
    }
  }
  return true;
}

// sType
Napi::Value _VkDebugMarkerMarkerInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugMarkerMarkerInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerMarkerInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugMarkerMarkerInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugMarkerMarkerInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugMarkerMarkerInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugMarkerMarkerInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerMarkerInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// pMarkerName
Napi::Value _VkDebugMarkerMarkerInfoEXT::GetpMarkerName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pMarkerName.IsEmpty()) return env.Null();
  return this->pMarkerName.Value().ToString();
}void _VkDebugMarkerMarkerInfoEXT::SetpMarkerName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pMarkerName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pMarkerName) delete[] this->instance.pMarkerName;
    this->instance.pMarkerName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pMarkerName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerMarkerInfoEXT.pMarkerName", "String");
  
    return;
  }
}// color
Napi::Value _VkDebugMarkerMarkerInfoEXT::Getcolor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->color.IsEmpty()) return env.Null();
  return this->color.Value().As<Napi::Array>();
}void _VkDebugMarkerMarkerInfoEXT::Setcolor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->color.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->color.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerMarkerInfoEXT.color", "Array");
  
    return;
  }
}
/** ## END VkDebugMarkerMarkerInfoEXT ## **/

/** ## BEGIN VkDebugMarkerObjectTagInfoEXT ## **/

Napi::FunctionReference _VkDebugMarkerObjectTagInfoEXT::constructor;

_VkDebugMarkerObjectTagInfoEXT::_VkDebugMarkerObjectTagInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugMarkerObjectTagInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectType");
      Napi::String sAccess3 = Napi::String::New(env, "object");
      Napi::String sAccess4 = Napi::String::New(env, "tagName");
      Napi::String sAccess5 = Napi::String::New(env, "tagSize");
      Napi::String sAccess6 = Napi::String::New(env, "pTag");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectType(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setobject(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SettagName(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SettagSize(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpTag(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkDebugMarkerObjectTagInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugMarkerObjectTagInfoEXT::~_VkDebugMarkerObjectTagInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  
  
  pTag.Reset();
  
}

Napi::Object _VkDebugMarkerObjectTagInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugMarkerObjectTagInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugMarkerObjectTagInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugMarkerObjectTagInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugMarkerObjectTagInfoEXT::GetsType,
    &_VkDebugMarkerObjectTagInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugMarkerObjectTagInfoEXT::GetpNext,
    &_VkDebugMarkerObjectTagInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectType",
    &_VkDebugMarkerObjectTagInfoEXT::GetobjectType,
    &_VkDebugMarkerObjectTagInfoEXT::SetobjectType,
    napi_enumerable
  ),
  InstanceAccessor(
    "object",
    &_VkDebugMarkerObjectTagInfoEXT::Getobject,
    &_VkDebugMarkerObjectTagInfoEXT::Setobject,
    napi_enumerable
  ),
  InstanceAccessor(
    "tagName",
    &_VkDebugMarkerObjectTagInfoEXT::GettagName,
    &_VkDebugMarkerObjectTagInfoEXT::SettagName,
    napi_enumerable
  ),
  InstanceAccessor(
    "tagSize",
    &_VkDebugMarkerObjectTagInfoEXT::GettagSize,
    &_VkDebugMarkerObjectTagInfoEXT::SettagSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "pTag",
    &_VkDebugMarkerObjectTagInfoEXT::GetpTag,
    &_VkDebugMarkerObjectTagInfoEXT::SetpTag,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugMarkerObjectTagInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugMarkerObjectTagInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugMarkerObjectTagInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->objectType));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->objectType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->object));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->object);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->tagName));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->tagName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->tagSize));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->tagSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectTagInfoEXT *)0)->pTag));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectTagInfoEXT *)0)->pTag);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugMarkerObjectTagInfoEXT::flush() {
  _VkDebugMarkerObjectTagInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDebugMarkerObjectTagInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugMarkerObjectTagInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugMarkerObjectTagInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugMarkerObjectTagInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugMarkerObjectTagInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// objectType
Napi::Value _VkDebugMarkerObjectTagInfoEXT::GetobjectType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectType);
}void _VkDebugMarkerObjectTagInfoEXT::SetobjectType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectType = static_cast<VkDebugReportObjectTypeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.objectType", "Number");
  
    return;
  }
}// object
Napi::Value _VkDebugMarkerObjectTagInfoEXT::Getobject(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.object);
}void _VkDebugMarkerObjectTagInfoEXT::Setobject(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.object = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.object", "Number");
  
    return;
  }
}// tagName
Napi::Value _VkDebugMarkerObjectTagInfoEXT::GettagName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tagName);
}void _VkDebugMarkerObjectTagInfoEXT::SettagName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tagName = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.tagName", "Number");
  
    return;
  }
}// tagSize
Napi::Value _VkDebugMarkerObjectTagInfoEXT::GettagSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tagSize);
}void _VkDebugMarkerObjectTagInfoEXT::SettagSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tagSize = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.tagSize", "Number");
  
    return;
  }
}// pTag
Napi::Value _VkDebugMarkerObjectTagInfoEXT::GetpTag(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pTag.IsEmpty()) return env.Null();
  return this->pTag.Value().As<Napi::Object>();
}void _VkDebugMarkerObjectTagInfoEXT::SetpTag(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pTag = buffer.Data();
    this->pTag.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pTag = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectTagInfoEXT.pTag", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkDebugMarkerObjectTagInfoEXT ## **/

/** ## BEGIN VkDebugMarkerObjectNameInfoEXT ## **/

Napi::FunctionReference _VkDebugMarkerObjectNameInfoEXT::constructor;

_VkDebugMarkerObjectNameInfoEXT::_VkDebugMarkerObjectNameInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugMarkerObjectNameInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "objectType");
      Napi::String sAccess3 = Napi::String::New(env, "object");
      Napi::String sAccess4 = Napi::String::New(env, "pObjectName");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetobjectType(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setobject(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpObjectName(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDebugMarkerObjectNameInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugMarkerObjectNameInfoEXT::~_VkDebugMarkerObjectNameInfoEXT() {
  
  
  pNext.Reset();
  
  
  
  pObjectName.Reset();
  
}

Napi::Object _VkDebugMarkerObjectNameInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugMarkerObjectNameInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugMarkerObjectNameInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugMarkerObjectNameInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugMarkerObjectNameInfoEXT::GetsType,
    &_VkDebugMarkerObjectNameInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugMarkerObjectNameInfoEXT::GetpNext,
    &_VkDebugMarkerObjectNameInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "objectType",
    &_VkDebugMarkerObjectNameInfoEXT::GetobjectType,
    &_VkDebugMarkerObjectNameInfoEXT::SetobjectType,
    napi_enumerable
  ),
  InstanceAccessor(
    "object",
    &_VkDebugMarkerObjectNameInfoEXT::Getobject,
    &_VkDebugMarkerObjectNameInfoEXT::Setobject,
    napi_enumerable
  ),
  InstanceAccessor(
    "pObjectName",
    &_VkDebugMarkerObjectNameInfoEXT::GetpObjectName,
    &_VkDebugMarkerObjectNameInfoEXT::SetpObjectName,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugMarkerObjectNameInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugMarkerObjectNameInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugMarkerObjectNameInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectNameInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectNameInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectNameInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectNameInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectNameInfoEXT *)0)->objectType));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectNameInfoEXT *)0)->objectType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectNameInfoEXT *)0)->object));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectNameInfoEXT *)0)->object);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugMarkerObjectNameInfoEXT *)0)->pObjectName));
    uint32_t byteLength = sizeof(((VkDebugMarkerObjectNameInfoEXT *)0)->pObjectName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugMarkerObjectNameInfoEXT::flush() {
  _VkDebugMarkerObjectNameInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDebugMarkerObjectNameInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugMarkerObjectNameInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectNameInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugMarkerObjectNameInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugMarkerObjectNameInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugMarkerObjectNameInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugMarkerObjectNameInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectNameInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// objectType
Napi::Value _VkDebugMarkerObjectNameInfoEXT::GetobjectType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.objectType);
}void _VkDebugMarkerObjectNameInfoEXT::SetobjectType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.objectType = static_cast<VkDebugReportObjectTypeEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectNameInfoEXT.objectType", "Number");
  
    return;
  }
}// object
Napi::Value _VkDebugMarkerObjectNameInfoEXT::Getobject(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.object);
}void _VkDebugMarkerObjectNameInfoEXT::Setobject(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.object = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectNameInfoEXT.object", "Number");
  
    return;
  }
}// pObjectName
Napi::Value _VkDebugMarkerObjectNameInfoEXT::GetpObjectName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pObjectName.IsEmpty()) return env.Null();
  return this->pObjectName.Value().ToString();
}void _VkDebugMarkerObjectNameInfoEXT::SetpObjectName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pObjectName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pObjectName) delete[] this->instance.pObjectName;
    this->instance.pObjectName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pObjectName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugMarkerObjectNameInfoEXT.pObjectName", "String");
  
    return;
  }
}
/** ## END VkDebugMarkerObjectNameInfoEXT ## **/

/** ## BEGIN VkPipelineRasterizationStateRasterizationOrderAMD ## **/

Napi::FunctionReference _VkPipelineRasterizationStateRasterizationOrderAMD::constructor;

_VkPipelineRasterizationStateRasterizationOrderAMD::_VkPipelineRasterizationStateRasterizationOrderAMD(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineRasterizationStateRasterizationOrderAMD>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "rasterizationOrder");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetrasterizationOrder(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPipelineRasterizationStateRasterizationOrderAMD constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineRasterizationStateRasterizationOrderAMD::~_VkPipelineRasterizationStateRasterizationOrderAMD() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkPipelineRasterizationStateRasterizationOrderAMD::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineRasterizationStateRasterizationOrderAMD", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineRasterizationStateRasterizationOrderAMD::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineRasterizationStateRasterizationOrderAMD::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineRasterizationStateRasterizationOrderAMD::GetsType,
    &_VkPipelineRasterizationStateRasterizationOrderAMD::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineRasterizationStateRasterizationOrderAMD::GetpNext,
    &_VkPipelineRasterizationStateRasterizationOrderAMD::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "rasterizationOrder",
    &_VkPipelineRasterizationStateRasterizationOrderAMD::GetrasterizationOrder,
    &_VkPipelineRasterizationStateRasterizationOrderAMD::SetrasterizationOrder,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineRasterizationStateRasterizationOrderAMD", func);
  return exports;
}

Napi::Value _VkPipelineRasterizationStateRasterizationOrderAMD::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineRasterizationStateRasterizationOrderAMD::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateRasterizationOrderAMD *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateRasterizationOrderAMD *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateRasterizationOrderAMD *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateRasterizationOrderAMD *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateRasterizationOrderAMD *)0)->rasterizationOrder));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateRasterizationOrderAMD *)0)->rasterizationOrder);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineRasterizationStateRasterizationOrderAMD::flush() {
  _VkPipelineRasterizationStateRasterizationOrderAMD *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineRasterizationStateRasterizationOrderAMD::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineRasterizationStateRasterizationOrderAMD::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateRasterizationOrderAMD.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineRasterizationStateRasterizationOrderAMD::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineRasterizationStateRasterizationOrderAMD::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineRasterizationStateRasterizationOrderAMD.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineRasterizationStateRasterizationOrderAMD.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateRasterizationOrderAMD.pNext", "[object Object]");
  
    return;
  }
}// rasterizationOrder
Napi::Value _VkPipelineRasterizationStateRasterizationOrderAMD::GetrasterizationOrder(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.rasterizationOrder);
}void _VkPipelineRasterizationStateRasterizationOrderAMD::SetrasterizationOrder(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.rasterizationOrder = static_cast<VkRasterizationOrderAMD>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationStateRasterizationOrderAMD ## **/

/** ## BEGIN VkValidationFlagsEXT ## **/

Napi::FunctionReference _VkValidationFlagsEXT::constructor;

_VkValidationFlagsEXT::_VkValidationFlagsEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkValidationFlagsEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "disabledValidationCheckCount");
      Napi::String sAccess3 = Napi::String::New(env, "pDisabledValidationChecks");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdisabledValidationCheckCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpDisabledValidationChecks(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkValidationFlagsEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkValidationFlagsEXT::~_VkValidationFlagsEXT() {
  
  
  pNext.Reset();
  
  
  pDisabledValidationChecks.Reset();
  
}

Napi::Object _VkValidationFlagsEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkValidationFlagsEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkValidationFlagsEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkValidationFlagsEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkValidationFlagsEXT::GetsType,
    &_VkValidationFlagsEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkValidationFlagsEXT::GetpNext,
    &_VkValidationFlagsEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "disabledValidationCheckCount",
    &_VkValidationFlagsEXT::GetdisabledValidationCheckCount,
    &_VkValidationFlagsEXT::SetdisabledValidationCheckCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDisabledValidationChecks",
    &_VkValidationFlagsEXT::GetpDisabledValidationChecks,
    &_VkValidationFlagsEXT::SetpDisabledValidationChecks,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkValidationFlagsEXT", func);
  return exports;
}

Napi::Value _VkValidationFlagsEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkValidationFlagsEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationFlagsEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkValidationFlagsEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationFlagsEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkValidationFlagsEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationFlagsEXT *)0)->disabledValidationCheckCount));
    uint32_t byteLength = sizeof(((VkValidationFlagsEXT *)0)->disabledValidationCheckCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkValidationFlagsEXT *)0)->pDisabledValidationChecks));
    uint32_t byteLength = sizeof(((VkValidationFlagsEXT *)0)->pDisabledValidationChecks);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkValidationFlagsEXT::flush() {
  _VkValidationFlagsEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkValidationFlagsEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkValidationFlagsEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkValidationFlagsEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkValidationFlagsEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkValidationFlagsEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkValidationFlagsEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkValidationFlagsEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkValidationFlagsEXT.pNext", "[object Object]");
  
    return;
  }
}// disabledValidationCheckCount
Napi::Value _VkValidationFlagsEXT::GetdisabledValidationCheckCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.disabledValidationCheckCount);
}void _VkValidationFlagsEXT::SetdisabledValidationCheckCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.disabledValidationCheckCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkValidationFlagsEXT.disabledValidationCheckCount", "Number");
  
    return;
  }
}// pDisabledValidationChecks
Napi::Value _VkValidationFlagsEXT::GetpDisabledValidationChecks(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDisabledValidationChecks.IsEmpty()) return env.Null();
  return this->pDisabledValidationChecks.Value().As<Napi::TypedArray>();
}void _VkValidationFlagsEXT::SetpDisabledValidationChecks(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pDisabledValidationChecks.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkValidationFlagsEXT.pDisabledValidationChecks", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDisabledValidationChecks.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkValidationFlagsEXT.pDisabledValidationChecks", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDisabledValidationChecks = reinterpret_cast<const VkValidationCheckEXT *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pDisabledValidationChecks = nullptr;
  }
}
/** ## END VkValidationFlagsEXT ## **/

/** ## BEGIN VkDebugReportCallbackCreateInfoEXT ## **/

Napi::FunctionReference _VkDebugReportCallbackCreateInfoEXT::constructor;

_VkDebugReportCallbackCreateInfoEXT::_VkDebugReportCallbackCreateInfoEXT(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDebugReportCallbackCreateInfoEXT>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess4 = Napi::String::New(env, "pUserData");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess4)) this->SetpUserData(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDebugReportCallbackCreateInfoEXT constructor cannot be invoked without 'new'");
    }
  }
}

_VkDebugReportCallbackCreateInfoEXT::~_VkDebugReportCallbackCreateInfoEXT() {
  
  
  pNext.Reset();
  
  
  pUserData.Reset();
  
}

Napi::Object _VkDebugReportCallbackCreateInfoEXT::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDebugReportCallbackCreateInfoEXT", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDebugReportCallbackCreateInfoEXT::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDebugReportCallbackCreateInfoEXT::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDebugReportCallbackCreateInfoEXT::GetsType,
    &_VkDebugReportCallbackCreateInfoEXT::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDebugReportCallbackCreateInfoEXT::GetpNext,
    &_VkDebugReportCallbackCreateInfoEXT::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDebugReportCallbackCreateInfoEXT::Getflags,
    &_VkDebugReportCallbackCreateInfoEXT::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pUserData",
    &_VkDebugReportCallbackCreateInfoEXT::GetpUserData,
    &_VkDebugReportCallbackCreateInfoEXT::SetpUserData,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDebugReportCallbackCreateInfoEXT", func);
  return exports;
}

Napi::Value _VkDebugReportCallbackCreateInfoEXT::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDebugReportCallbackCreateInfoEXT::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugReportCallbackCreateInfoEXT *)0)->sType));
    uint32_t byteLength = sizeof(((VkDebugReportCallbackCreateInfoEXT *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugReportCallbackCreateInfoEXT *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDebugReportCallbackCreateInfoEXT *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugReportCallbackCreateInfoEXT *)0)->flags));
    uint32_t byteLength = sizeof(((VkDebugReportCallbackCreateInfoEXT *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDebugReportCallbackCreateInfoEXT *)0)->pUserData));
    uint32_t byteLength = sizeof(((VkDebugReportCallbackCreateInfoEXT *)0)->pUserData);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDebugReportCallbackCreateInfoEXT::flush() {
  _VkDebugReportCallbackCreateInfoEXT *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkDebugReportCallbackCreateInfoEXT::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDebugReportCallbackCreateInfoEXT::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugReportCallbackCreateInfoEXT.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDebugReportCallbackCreateInfoEXT::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDebugReportCallbackCreateInfoEXT::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDebugReportCallbackCreateInfoEXT.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDebugReportCallbackCreateInfoEXT.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugReportCallbackCreateInfoEXT.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDebugReportCallbackCreateInfoEXT::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDebugReportCallbackCreateInfoEXT::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDebugReportFlagsEXT>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDebugReportCallbackCreateInfoEXT.flags", "Number");
  
    return;
  }
}// pUserData
Napi::Value _VkDebugReportCallbackCreateInfoEXT::GetpUserData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pUserData.IsEmpty()) return env.Null();
  return this->pUserData.Value().As<Napi::Object>();
}void _VkDebugReportCallbackCreateInfoEXT::SetpUserData(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pUserData = buffer.Data();
    this->pUserData.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pUserData = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDebugReportCallbackCreateInfoEXT.pUserData", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkDebugReportCallbackCreateInfoEXT ## **/

/** ## BEGIN VkPresentInfoKHR ## **/

Napi::FunctionReference _VkPresentInfoKHR::constructor;

_VkPresentInfoKHR::_VkPresentInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPresentInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    vpWaitSemaphores = new std::vector<VkSemaphore>;
    vpSwapchains = new std::vector<VkSwapchainKHR>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "waitSemaphoreCount");
      Napi::String sAccess3 = Napi::String::New(env, "pWaitSemaphores");
      Napi::String sAccess4 = Napi::String::New(env, "swapchainCount");
      Napi::String sAccess5 = Napi::String::New(env, "pSwapchains");
      Napi::String sAccess6 = Napi::String::New(env, "pImageIndices");
      Napi::String sAccess7 = Napi::String::New(env, "pResults");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetwaitSemaphoreCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpWaitSemaphores(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetswapchainCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpSwapchains(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpImageIndices(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpResults(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkPresentInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkPresentInfoKHR::~_VkPresentInfoKHR() {
  
  
  pNext.Reset();
  
  
  vpWaitSemaphores->clear();
  delete vpWaitSemaphores;
  
  pWaitSemaphores.Reset();
  
  
  vpSwapchains->clear();
  delete vpSwapchains;
  
  pSwapchains.Reset();
  
  pImageIndices.Reset();
  
  pResults.Reset();
  
}

Napi::Object _VkPresentInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPresentInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPresentInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPresentInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPresentInfoKHR::GetsType,
    &_VkPresentInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPresentInfoKHR::GetpNext,
    &_VkPresentInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "waitSemaphoreCount",
    &_VkPresentInfoKHR::GetwaitSemaphoreCount,
    &_VkPresentInfoKHR::SetwaitSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitSemaphores",
    &_VkPresentInfoKHR::GetpWaitSemaphores,
    &_VkPresentInfoKHR::SetpWaitSemaphores,
    napi_enumerable
  ),
  InstanceAccessor(
    "swapchainCount",
    &_VkPresentInfoKHR::GetswapchainCount,
    &_VkPresentInfoKHR::SetswapchainCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSwapchains",
    &_VkPresentInfoKHR::GetpSwapchains,
    &_VkPresentInfoKHR::SetpSwapchains,
    napi_enumerable
  ),
  InstanceAccessor(
    "pImageIndices",
    &_VkPresentInfoKHR::GetpImageIndices,
    &_VkPresentInfoKHR::SetpImageIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "pResults",
    &_VkPresentInfoKHR::GetpResults,
    &_VkPresentInfoKHR::SetpResults,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPresentInfoKHR", func);
  return exports;
}

Napi::Value _VkPresentInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPresentInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->waitSemaphoreCount));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->waitSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->pWaitSemaphores));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->pWaitSemaphores);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->swapchainCount));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->swapchainCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->pSwapchains));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->pSwapchains);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->pImageIndices));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->pImageIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPresentInfoKHR *)0)->pResults));
    uint32_t byteLength = sizeof(((VkPresentInfoKHR *)0)->pResults);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPresentInfoKHR::flush() {
  _VkPresentInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR) {
      _VkDisplayPresentInfoKHR* structExt = Napi::ObjectWrap<_VkDisplayPresentInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR) {
      _VkPresentRegionsKHR* structExt = Napi::ObjectWrap<_VkPresentRegionsKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR) {
      _VkDeviceGroupPresentInfoKHR* structExt = Napi::ObjectWrap<_VkDeviceGroupPresentInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE) {
      _VkPresentTimesInfoGOOGLE* structExt = Napi::ObjectWrap<_VkPresentTimesInfoGOOGLE>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pWaitSemaphores.IsEmpty())) {
    Napi::Value value = self->pWaitSemaphores.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.waitSemaphoreCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'waitSemaphoreCount' for 'VkPresentInfoKHR.pWaitSemaphores'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSemaphore>* data = this->vpWaitSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPresentInfoKHR.pWaitSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pWaitSemaphores = data->data();
  }if (!(self->pSwapchains.IsEmpty())) {
    Napi::Value value = self->pSwapchains.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.swapchainCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'swapchainCount' for 'VkPresentInfoKHR.pSwapchains'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSwapchainKHR>* data = this->vpSwapchains;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPresentInfoKHR.pSwapchains", "[object VkSwapchainKHR]");
  
        return false;
      }
      _VkSwapchainKHR* result = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSwapchains = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPresentInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPresentInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPresentInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPresentInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR &&
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPresentInfoKHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPresentInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPresentInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// waitSemaphoreCount
Napi::Value _VkPresentInfoKHR::GetwaitSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.waitSemaphoreCount);
}void _VkPresentInfoKHR::SetwaitSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.waitSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentInfoKHR.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphores
Napi::Value _VkPresentInfoKHR::GetpWaitSemaphores(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitSemaphores.IsEmpty()) return env.Null();
  return this->pWaitSemaphores.Value().As<Napi::Array>();
}void _VkPresentInfoKHR::SetpWaitSemaphores(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pWaitSemaphores.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pWaitSemaphores.Reset();
      this->instance.pWaitSemaphores = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPresentInfoKHR.pWaitSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pWaitSemaphores = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkPresentInfoKHR.pWaitSemaphores", "[object VkSemaphore]");
  
    return;
  }
}// swapchainCount
Napi::Value _VkPresentInfoKHR::GetswapchainCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.swapchainCount);
}void _VkPresentInfoKHR::SetswapchainCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.swapchainCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPresentInfoKHR.swapchainCount", "Number");
  
    return;
  }
}// pSwapchains
Napi::Value _VkPresentInfoKHR::GetpSwapchains(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSwapchains.IsEmpty()) return env.Null();
  return this->pSwapchains.Value().As<Napi::Array>();
}void _VkPresentInfoKHR::SetpSwapchains(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSwapchains.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSwapchains.Reset();
      this->instance.pSwapchains = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPresentInfoKHR.pSwapchains", "[object VkSwapchainKHR]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSwapchains = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkPresentInfoKHR.pSwapchains", "[object VkSwapchainKHR]");
  
    return;
  }
}// pImageIndices
Napi::Value _VkPresentInfoKHR::GetpImageIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pImageIndices.IsEmpty()) return env.Null();
  return this->pImageIndices.Value().As<Napi::TypedArray>();
}void _VkPresentInfoKHR::SetpImageIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pImageIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkPresentInfoKHR.pImageIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pImageIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkPresentInfoKHR.pImageIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pImageIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pImageIndices = nullptr;
  }
}// pResults
Napi::Value _VkPresentInfoKHR::GetpResults(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pResults.IsEmpty()) return env.Null();
  return this->pResults.Value().As<Napi::TypedArray>();
}void _VkPresentInfoKHR::SetpResults(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pResults.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkPresentInfoKHR.pResults", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pResults.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkPresentInfoKHR.pResults", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pResults = reinterpret_cast<VkResult *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pResults = nullptr;
  }
}
/** ## END VkPresentInfoKHR ## **/

/** ## BEGIN VkSwapchainCreateInfoKHR ## **/

Napi::FunctionReference _VkSwapchainCreateInfoKHR::constructor;

_VkSwapchainCreateInfoKHR::_VkSwapchainCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSwapchainCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "surface");
      Napi::String sAccess4 = Napi::String::New(env, "minImageCount");
      Napi::String sAccess5 = Napi::String::New(env, "imageFormat");
      Napi::String sAccess6 = Napi::String::New(env, "imageColorSpace");
      Napi::String sAccess7 = Napi::String::New(env, "imageExtent");
      Napi::String sAccess8 = Napi::String::New(env, "imageArrayLayers");
      Napi::String sAccess9 = Napi::String::New(env, "imageUsage");
      Napi::String sAccess10 = Napi::String::New(env, "imageSharingMode");
      Napi::String sAccess11 = Napi::String::New(env, "queueFamilyIndexCount");
      Napi::String sAccess12 = Napi::String::New(env, "pQueueFamilyIndices");
      Napi::String sAccess13 = Napi::String::New(env, "preTransform");
      Napi::String sAccess14 = Napi::String::New(env, "compositeAlpha");
      Napi::String sAccess15 = Napi::String::New(env, "presentMode");
      Napi::String sAccess16 = Napi::String::New(env, "clipped");
      Napi::String sAccess17 = Napi::String::New(env, "oldSwapchain");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setsurface(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetminImageCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetimageFormat(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetimageColorSpace(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetimageExtent(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetimageArrayLayers(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetimageUsage(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetimageSharingMode(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetqueueFamilyIndexCount(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetpQueueFamilyIndices(info, obj.Get(sAccess12));
      if (obj.Has(sAccess13)) this->SetpreTransform(info, obj.Get(sAccess13));
      if (obj.Has(sAccess14)) this->SetcompositeAlpha(info, obj.Get(sAccess14));
      if (obj.Has(sAccess15)) this->SetpresentMode(info, obj.Get(sAccess15));
      if (obj.Has(sAccess16)) this->Setclipped(info, obj.Get(sAccess16));
      if (obj.Has(sAccess17)) this->SetoldSwapchain(info, obj.Get(sAccess17));
      
    } else {
      Napi::Error::New(env, "VkSwapchainCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSwapchainCreateInfoKHR::~_VkSwapchainCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  surface.Reset();
  
  
  
  
  imageExtent.Reset();
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
  
  
  
  
  oldSwapchain.Reset();
  
}

Napi::Object _VkSwapchainCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSwapchainCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSwapchainCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSwapchainCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSwapchainCreateInfoKHR::GetsType,
    &_VkSwapchainCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSwapchainCreateInfoKHR::GetpNext,
    &_VkSwapchainCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSwapchainCreateInfoKHR::Getflags,
    &_VkSwapchainCreateInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "surface",
    &_VkSwapchainCreateInfoKHR::Getsurface,
    &_VkSwapchainCreateInfoKHR::Setsurface,
    napi_enumerable
  ),
  InstanceAccessor(
    "minImageCount",
    &_VkSwapchainCreateInfoKHR::GetminImageCount,
    &_VkSwapchainCreateInfoKHR::SetminImageCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageFormat",
    &_VkSwapchainCreateInfoKHR::GetimageFormat,
    &_VkSwapchainCreateInfoKHR::SetimageFormat,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageColorSpace",
    &_VkSwapchainCreateInfoKHR::GetimageColorSpace,
    &_VkSwapchainCreateInfoKHR::SetimageColorSpace,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageExtent",
    &_VkSwapchainCreateInfoKHR::GetimageExtent,
    &_VkSwapchainCreateInfoKHR::SetimageExtent,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageArrayLayers",
    &_VkSwapchainCreateInfoKHR::GetimageArrayLayers,
    &_VkSwapchainCreateInfoKHR::SetimageArrayLayers,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageUsage",
    &_VkSwapchainCreateInfoKHR::GetimageUsage,
    &_VkSwapchainCreateInfoKHR::SetimageUsage,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageSharingMode",
    &_VkSwapchainCreateInfoKHR::GetimageSharingMode,
    &_VkSwapchainCreateInfoKHR::SetimageSharingMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyIndexCount",
    &_VkSwapchainCreateInfoKHR::GetqueueFamilyIndexCount,
    &_VkSwapchainCreateInfoKHR::SetqueueFamilyIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pQueueFamilyIndices",
    &_VkSwapchainCreateInfoKHR::GetpQueueFamilyIndices,
    &_VkSwapchainCreateInfoKHR::SetpQueueFamilyIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "preTransform",
    &_VkSwapchainCreateInfoKHR::GetpreTransform,
    &_VkSwapchainCreateInfoKHR::SetpreTransform,
    napi_enumerable
  ),
  InstanceAccessor(
    "compositeAlpha",
    &_VkSwapchainCreateInfoKHR::GetcompositeAlpha,
    &_VkSwapchainCreateInfoKHR::SetcompositeAlpha,
    napi_enumerable
  ),
  InstanceAccessor(
    "presentMode",
    &_VkSwapchainCreateInfoKHR::GetpresentMode,
    &_VkSwapchainCreateInfoKHR::SetpresentMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "clipped",
    &_VkSwapchainCreateInfoKHR::Getclipped,
    &_VkSwapchainCreateInfoKHR::Setclipped,
    napi_enumerable
  ),
  InstanceAccessor(
    "oldSwapchain",
    &_VkSwapchainCreateInfoKHR::GetoldSwapchain,
    &_VkSwapchainCreateInfoKHR::SetoldSwapchain,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSwapchainCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkSwapchainCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSwapchainCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->surface));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->surface);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->minImageCount));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->minImageCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->imageFormat));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->imageFormat);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->imageColorSpace));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->imageColorSpace);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->imageExtent));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->imageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->imageArrayLayers));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->imageArrayLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->imageUsage));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->imageUsage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->imageSharingMode));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->imageSharingMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->queueFamilyIndexCount));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->queueFamilyIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->pQueueFamilyIndices));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->pQueueFamilyIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->preTransform));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->preTransform);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->compositeAlpha));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->compositeAlpha);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->presentMode));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->presentMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->clipped));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->clipped);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSwapchainCreateInfoKHR *)0)->oldSwapchain));
    uint32_t byteLength = sizeof(((VkSwapchainCreateInfoKHR *)0)->oldSwapchain);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSwapchainCreateInfoKHR::flush() {
  _VkSwapchainCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT) {
      _VkSwapchainCounterCreateInfoEXT* structExt = Napi::ObjectWrap<_VkSwapchainCounterCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR) {
      _VkDeviceGroupSwapchainCreateInfoKHR* structExt = Napi::ObjectWrap<_VkDeviceGroupSwapchainCreateInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->imageExtent.IsEmpty())) {
    Napi::Value value = self->imageExtent.Value();
    
    _VkExtent2D* result = Napi::ObjectWrap<_VkExtent2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.imageExtent = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkSwapchainCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSwapchainCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSwapchainCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSwapchainCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT &&
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSwapchainCreateInfoKHR.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkSwapchainCreateInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSwapchainCreateInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSwapchainCreateFlagsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.flags", "Number");
  
    return;
  }
}// surface
Napi::Value _VkSwapchainCreateInfoKHR::Getsurface(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->surface.IsEmpty()) return env.Null();
  return this->surface.Value().As<Napi::Object>();
}void _VkSwapchainCreateInfoKHR::Setsurface(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSurfaceKHR::constructor.Value())) {
      
      this->surface.Reset(value.ToObject(), 1);
      _VkSurfaceKHR* inst = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
      ;
      this->instance.surface = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.surface", "[object VkSurfaceKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->surface.Reset();
    this->instance.surface = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.surface", "[object VkSurfaceKHR]");
  
    return;
  }
}// minImageCount
Napi::Value _VkSwapchainCreateInfoKHR::GetminImageCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minImageCount);
}void _VkSwapchainCreateInfoKHR::SetminImageCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minImageCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.minImageCount", "Number");
  
    return;
  }
}// imageFormat
Napi::Value _VkSwapchainCreateInfoKHR::GetimageFormat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageFormat);
}void _VkSwapchainCreateInfoKHR::SetimageFormat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageFormat = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageFormat", "Number");
  
    return;
  }
}// imageColorSpace
Napi::Value _VkSwapchainCreateInfoKHR::GetimageColorSpace(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageColorSpace);
}void _VkSwapchainCreateInfoKHR::SetimageColorSpace(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageColorSpace = static_cast<VkColorSpaceKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageColorSpace", "Number");
  
    return;
  }
}// imageExtent
Napi::Value _VkSwapchainCreateInfoKHR::GetimageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageExtent.IsEmpty()) return env.Null();
  return this->imageExtent.Value().As<Napi::Object>();
}void _VkSwapchainCreateInfoKHR::SetimageExtent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent2D::constructor.Value())) {
      
      this->imageExtent.Reset(value.ToObject(), 1);
      _VkExtent2D* inst = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
      inst->flush();
      this->instance.imageExtent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->imageExtent.Reset();
    memset(&this->instance.imageExtent, 0, sizeof(VkExtent2D));
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
    return;
  }
}// imageArrayLayers
Napi::Value _VkSwapchainCreateInfoKHR::GetimageArrayLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageArrayLayers);
}void _VkSwapchainCreateInfoKHR::SetimageArrayLayers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageArrayLayers = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageArrayLayers", "Number");
  
    return;
  }
}// imageUsage
Napi::Value _VkSwapchainCreateInfoKHR::GetimageUsage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageUsage);
}void _VkSwapchainCreateInfoKHR::SetimageUsage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageUsage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageUsage", "Number");
  
    return;
  }
}// imageSharingMode
Napi::Value _VkSwapchainCreateInfoKHR::GetimageSharingMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageSharingMode);
}void _VkSwapchainCreateInfoKHR::SetimageSharingMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageSharingMode = static_cast<VkSharingMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.imageSharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
Napi::Value _VkSwapchainCreateInfoKHR::GetqueueFamilyIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFamilyIndexCount);
}void _VkSwapchainCreateInfoKHR::SetqueueFamilyIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueFamilyIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
Napi::Value _VkSwapchainCreateInfoKHR::GetpQueueFamilyIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pQueueFamilyIndices.IsEmpty()) return env.Null();
  return this->pQueueFamilyIndices.Value().As<Napi::TypedArray>();
}void _VkSwapchainCreateInfoKHR::SetpQueueFamilyIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pQueueFamilyIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pQueueFamilyIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pQueueFamilyIndices = nullptr;
  }
}// preTransform
Napi::Value _VkSwapchainCreateInfoKHR::GetpreTransform(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.preTransform);
}void _VkSwapchainCreateInfoKHR::SetpreTransform(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.preTransform = static_cast<VkSurfaceTransformFlagBitsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.preTransform", "Number");
  
    return;
  }
}// compositeAlpha
Napi::Value _VkSwapchainCreateInfoKHR::GetcompositeAlpha(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compositeAlpha);
}void _VkSwapchainCreateInfoKHR::SetcompositeAlpha(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.compositeAlpha = static_cast<VkCompositeAlphaFlagBitsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.compositeAlpha", "Number");
  
    return;
  }
}// presentMode
Napi::Value _VkSwapchainCreateInfoKHR::GetpresentMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.presentMode);
}void _VkSwapchainCreateInfoKHR::SetpresentMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.presentMode = static_cast<VkPresentModeKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.presentMode", "Number");
  
    return;
  }
}// clipped
Napi::Value _VkSwapchainCreateInfoKHR::Getclipped(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.clipped);
}void _VkSwapchainCreateInfoKHR::Setclipped(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.clipped = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.clipped = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.clipped", "Number");
  
    return;
  }
}// oldSwapchain
Napi::Value _VkSwapchainCreateInfoKHR::GetoldSwapchain(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->oldSwapchain.IsEmpty()) return env.Null();
  return this->oldSwapchain.Value().As<Napi::Object>();
}void _VkSwapchainCreateInfoKHR::SetoldSwapchain(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSwapchainKHR::constructor.Value())) {
      
      this->oldSwapchain.Reset(value.ToObject(), 1);
      _VkSwapchainKHR* inst = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      ;
      this->instance.oldSwapchain = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.oldSwapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->oldSwapchain.Reset();
    this->instance.oldSwapchain = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSwapchainCreateInfoKHR.oldSwapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}
/** ## END VkSwapchainCreateInfoKHR ## **/

/** ## BEGIN VkSurfaceFormatKHR ## **/

Napi::FunctionReference _VkSurfaceFormatKHR::constructor;

_VkSurfaceFormatKHR::_VkSurfaceFormatKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSurfaceFormatKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkSurfaceFormatKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSurfaceFormatKHR::~_VkSurfaceFormatKHR() {
  
  
  
}

Napi::Object _VkSurfaceFormatKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSurfaceFormatKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSurfaceFormatKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSurfaceFormatKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "format",
    &_VkSurfaceFormatKHR::Getformat,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "colorSpace",
    &_VkSurfaceFormatKHR::GetcolorSpace,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSurfaceFormatKHR", func);
  return exports;
}

Napi::Value _VkSurfaceFormatKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSurfaceFormatKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceFormatKHR *)0)->format));
    uint32_t byteLength = sizeof(((VkSurfaceFormatKHR *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceFormatKHR *)0)->colorSpace));
    uint32_t byteLength = sizeof(((VkSurfaceFormatKHR *)0)->colorSpace);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSurfaceFormatKHR::flush() {
  _VkSurfaceFormatKHR *self = this;
  
  return true;
}

// format
Napi::Value _VkSurfaceFormatKHR::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}// colorSpace
Napi::Value _VkSurfaceFormatKHR::GetcolorSpace(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.colorSpace);
}
/** ## END VkSurfaceFormatKHR ## **/

/** ## BEGIN VkWin32SurfaceCreateInfoKHR ## **/

Napi::FunctionReference _VkWin32SurfaceCreateInfoKHR::constructor;

_VkWin32SurfaceCreateInfoKHR::_VkWin32SurfaceCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkWin32SurfaceCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkWin32SurfaceCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkWin32SurfaceCreateInfoKHR::~_VkWin32SurfaceCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkWin32SurfaceCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkWin32SurfaceCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkWin32SurfaceCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkWin32SurfaceCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkWin32SurfaceCreateInfoKHR::GetsType,
    &_VkWin32SurfaceCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkWin32SurfaceCreateInfoKHR::GetpNext,
    &_VkWin32SurfaceCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkWin32SurfaceCreateInfoKHR::Getflags,
    &_VkWin32SurfaceCreateInfoKHR::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkWin32SurfaceCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkWin32SurfaceCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkWin32SurfaceCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32SurfaceCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkWin32SurfaceCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32SurfaceCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkWin32SurfaceCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWin32SurfaceCreateInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkWin32SurfaceCreateInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkWin32SurfaceCreateInfoKHR::flush() {
  _VkWin32SurfaceCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkWin32SurfaceCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkWin32SurfaceCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32SurfaceCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkWin32SurfaceCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkWin32SurfaceCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkWin32SurfaceCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkWin32SurfaceCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkWin32SurfaceCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkWin32SurfaceCreateInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkWin32SurfaceCreateInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkWin32SurfaceCreateFlagsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkWin32SurfaceCreateInfoKHR.flags", "Number");
  
    return;
  }
}
/** ## END VkWin32SurfaceCreateInfoKHR ## **/

/** ## BEGIN VkSurfaceCapabilitiesKHR ## **/

Napi::FunctionReference _VkSurfaceCapabilitiesKHR::constructor;

_VkSurfaceCapabilitiesKHR::_VkSurfaceCapabilitiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSurfaceCapabilitiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkSurfaceCapabilitiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkSurfaceCapabilitiesKHR::~_VkSurfaceCapabilitiesKHR() {
  
  
  
  currentExtent.Reset();
  
  minImageExtent.Reset();
  
  maxImageExtent.Reset();
  
  
  
  
  
  
}

Napi::Object _VkSurfaceCapabilitiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSurfaceCapabilitiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSurfaceCapabilitiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSurfaceCapabilitiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "minImageCount",
    &_VkSurfaceCapabilitiesKHR::GetminImageCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageCount",
    &_VkSurfaceCapabilitiesKHR::GetmaxImageCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "currentExtent",
    &_VkSurfaceCapabilitiesKHR::GetcurrentExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minImageExtent",
    &_VkSurfaceCapabilitiesKHR::GetminImageExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageExtent",
    &_VkSurfaceCapabilitiesKHR::GetmaxImageExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageArrayLayers",
    &_VkSurfaceCapabilitiesKHR::GetmaxImageArrayLayers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedTransforms",
    &_VkSurfaceCapabilitiesKHR::GetsupportedTransforms,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "currentTransform",
    &_VkSurfaceCapabilitiesKHR::GetcurrentTransform,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedCompositeAlpha",
    &_VkSurfaceCapabilitiesKHR::GetsupportedCompositeAlpha,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedUsageFlags",
    &_VkSurfaceCapabilitiesKHR::GetsupportedUsageFlags,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSurfaceCapabilitiesKHR", func);
  return exports;
}

Napi::Value _VkSurfaceCapabilitiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSurfaceCapabilitiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->minImageCount));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->minImageCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->maxImageCount));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->maxImageCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->currentExtent));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->currentExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->minImageExtent));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->minImageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->maxImageExtent));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->maxImageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->maxImageArrayLayers));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->maxImageArrayLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->supportedTransforms));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->supportedTransforms);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->currentTransform));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->currentTransform);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->supportedCompositeAlpha));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->supportedCompositeAlpha);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSurfaceCapabilitiesKHR *)0)->supportedUsageFlags));
    uint32_t byteLength = sizeof(((VkSurfaceCapabilitiesKHR *)0)->supportedUsageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSurfaceCapabilitiesKHR::flush() {
  _VkSurfaceCapabilitiesKHR *self = this;
  if (!(self->currentExtent.IsEmpty())) {
    Napi::Value value = self->currentExtent.Value();
    
  }if (!(self->minImageExtent.IsEmpty())) {
    Napi::Value value = self->minImageExtent.Value();
    
  }if (!(self->maxImageExtent.IsEmpty())) {
    Napi::Value value = self->maxImageExtent.Value();
    
  }
  return true;
}

// minImageCount
Napi::Value _VkSurfaceCapabilitiesKHR::GetminImageCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minImageCount);
}// maxImageCount
Napi::Value _VkSurfaceCapabilitiesKHR::GetmaxImageCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageCount);
}// currentExtent
Napi::Value _VkSurfaceCapabilitiesKHR::GetcurrentExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->currentExtent.IsEmpty()) return env.Null();
  return this->currentExtent.Value().As<Napi::Object>();
}// minImageExtent
Napi::Value _VkSurfaceCapabilitiesKHR::GetminImageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minImageExtent.IsEmpty()) return env.Null();
  return this->minImageExtent.Value().As<Napi::Object>();
}// maxImageExtent
Napi::Value _VkSurfaceCapabilitiesKHR::GetmaxImageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxImageExtent.IsEmpty()) return env.Null();
  return this->maxImageExtent.Value().As<Napi::Object>();
}// maxImageArrayLayers
Napi::Value _VkSurfaceCapabilitiesKHR::GetmaxImageArrayLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageArrayLayers);
}// supportedTransforms
Napi::Value _VkSurfaceCapabilitiesKHR::GetsupportedTransforms(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedTransforms);
}// currentTransform
Napi::Value _VkSurfaceCapabilitiesKHR::GetcurrentTransform(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.currentTransform);
}// supportedCompositeAlpha
Napi::Value _VkSurfaceCapabilitiesKHR::GetsupportedCompositeAlpha(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedCompositeAlpha);
}// supportedUsageFlags
Napi::Value _VkSurfaceCapabilitiesKHR::GetsupportedUsageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedUsageFlags);
}
/** ## END VkSurfaceCapabilitiesKHR ## **/

/** ## BEGIN VkDisplayPresentInfoKHR ## **/

Napi::FunctionReference _VkDisplayPresentInfoKHR::constructor;

_VkDisplayPresentInfoKHR::_VkDisplayPresentInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPresentInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcRect");
      Napi::String sAccess3 = Napi::String::New(env, "dstRect");
      Napi::String sAccess4 = Napi::String::New(env, "persistent");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcRect(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstRect(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setpersistent(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDisplayPresentInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPresentInfoKHR::~_VkDisplayPresentInfoKHR() {
  
  
  pNext.Reset();
  
  srcRect.Reset();
  
  dstRect.Reset();
  
  
}

Napi::Object _VkDisplayPresentInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPresentInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPresentInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPresentInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayPresentInfoKHR::GetsType,
    &_VkDisplayPresentInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayPresentInfoKHR::GetpNext,
    &_VkDisplayPresentInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcRect",
    &_VkDisplayPresentInfoKHR::GetsrcRect,
    &_VkDisplayPresentInfoKHR::SetsrcRect,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstRect",
    &_VkDisplayPresentInfoKHR::GetdstRect,
    &_VkDisplayPresentInfoKHR::SetdstRect,
    napi_enumerable
  ),
  InstanceAccessor(
    "persistent",
    &_VkDisplayPresentInfoKHR::Getpersistent,
    &_VkDisplayPresentInfoKHR::Setpersistent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPresentInfoKHR", func);
  return exports;
}

Napi::Value _VkDisplayPresentInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPresentInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPresentInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayPresentInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPresentInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayPresentInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPresentInfoKHR *)0)->srcRect));
    uint32_t byteLength = sizeof(((VkDisplayPresentInfoKHR *)0)->srcRect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPresentInfoKHR *)0)->dstRect));
    uint32_t byteLength = sizeof(((VkDisplayPresentInfoKHR *)0)->dstRect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPresentInfoKHR *)0)->persistent));
    uint32_t byteLength = sizeof(((VkDisplayPresentInfoKHR *)0)->persistent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPresentInfoKHR::flush() {
  _VkDisplayPresentInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->srcRect.IsEmpty())) {
    Napi::Value value = self->srcRect.Value();
    
    _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.srcRect = result->instance;
  }if (!(self->dstRect.IsEmpty())) {
    Napi::Value value = self->dstRect.Value();
    
    _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.dstRect = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkDisplayPresentInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayPresentInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayPresentInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayPresentInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayPresentInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// srcRect
Napi::Value _VkDisplayPresentInfoKHR::GetsrcRect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcRect.IsEmpty()) return env.Null();
  return this->srcRect.Value().As<Napi::Object>();
}void _VkDisplayPresentInfoKHR::SetsrcRect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRect2D::constructor.Value())) {
      
      this->srcRect.Reset(value.ToObject(), 1);
      _VkRect2D* inst = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      inst->flush();
      this->instance.srcRect = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.srcRect", "[object VkRect2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcRect.Reset();
    memset(&this->instance.srcRect, 0, sizeof(VkRect2D));
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.srcRect", "[object VkRect2D]");
  
    return;
  }
}// dstRect
Napi::Value _VkDisplayPresentInfoKHR::GetdstRect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstRect.IsEmpty()) return env.Null();
  return this->dstRect.Value().As<Napi::Object>();
}void _VkDisplayPresentInfoKHR::SetdstRect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRect2D::constructor.Value())) {
      
      this->dstRect.Reset(value.ToObject(), 1);
      _VkRect2D* inst = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      inst->flush();
      this->instance.dstRect = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.dstRect", "[object VkRect2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstRect.Reset();
    memset(&this->instance.dstRect, 0, sizeof(VkRect2D));
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.dstRect", "[object VkRect2D]");
  
    return;
  }
}// persistent
Napi::Value _VkDisplayPresentInfoKHR::Getpersistent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.persistent);
}void _VkDisplayPresentInfoKHR::Setpersistent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.persistent = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.persistent = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkDisplayPresentInfoKHR.persistent", "Number");
  
    return;
  }
}
/** ## END VkDisplayPresentInfoKHR ## **/

/** ## BEGIN VkDisplaySurfaceCreateInfoKHR ## **/

Napi::FunctionReference _VkDisplaySurfaceCreateInfoKHR::constructor;

_VkDisplaySurfaceCreateInfoKHR::_VkDisplaySurfaceCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplaySurfaceCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "displayMode");
      Napi::String sAccess4 = Napi::String::New(env, "planeIndex");
      Napi::String sAccess5 = Napi::String::New(env, "planeStackIndex");
      Napi::String sAccess6 = Napi::String::New(env, "transform");
      Napi::String sAccess7 = Napi::String::New(env, "globalAlpha");
      Napi::String sAccess8 = Napi::String::New(env, "alphaMode");
      Napi::String sAccess9 = Napi::String::New(env, "imageExtent");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdisplayMode(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetplaneIndex(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetplaneStackIndex(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Settransform(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetglobalAlpha(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetalphaMode(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetimageExtent(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkDisplaySurfaceCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplaySurfaceCreateInfoKHR::~_VkDisplaySurfaceCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  displayMode.Reset();
  
  
  
  
  
  
  imageExtent.Reset();
  
}

Napi::Object _VkDisplaySurfaceCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplaySurfaceCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplaySurfaceCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplaySurfaceCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplaySurfaceCreateInfoKHR::GetsType,
    &_VkDisplaySurfaceCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplaySurfaceCreateInfoKHR::GetpNext,
    &_VkDisplaySurfaceCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDisplaySurfaceCreateInfoKHR::Getflags,
    &_VkDisplaySurfaceCreateInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayMode",
    &_VkDisplaySurfaceCreateInfoKHR::GetdisplayMode,
    &_VkDisplaySurfaceCreateInfoKHR::SetdisplayMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeIndex",
    &_VkDisplaySurfaceCreateInfoKHR::GetplaneIndex,
    &_VkDisplaySurfaceCreateInfoKHR::SetplaneIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeStackIndex",
    &_VkDisplaySurfaceCreateInfoKHR::GetplaneStackIndex,
    &_VkDisplaySurfaceCreateInfoKHR::SetplaneStackIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "transform",
    &_VkDisplaySurfaceCreateInfoKHR::Gettransform,
    &_VkDisplaySurfaceCreateInfoKHR::Settransform,
    napi_enumerable
  ),
  InstanceAccessor(
    "globalAlpha",
    &_VkDisplaySurfaceCreateInfoKHR::GetglobalAlpha,
    &_VkDisplaySurfaceCreateInfoKHR::SetglobalAlpha,
    napi_enumerable
  ),
  InstanceAccessor(
    "alphaMode",
    &_VkDisplaySurfaceCreateInfoKHR::GetalphaMode,
    &_VkDisplaySurfaceCreateInfoKHR::SetalphaMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageExtent",
    &_VkDisplaySurfaceCreateInfoKHR::GetimageExtent,
    &_VkDisplaySurfaceCreateInfoKHR::SetimageExtent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplaySurfaceCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->displayMode));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->displayMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->planeIndex));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->planeIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->planeStackIndex));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->planeStackIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->transform));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->transform);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->globalAlpha));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->globalAlpha);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->alphaMode));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->alphaMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplaySurfaceCreateInfoKHR *)0)->imageExtent));
    uint32_t byteLength = sizeof(((VkDisplaySurfaceCreateInfoKHR *)0)->imageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplaySurfaceCreateInfoKHR::flush() {
  _VkDisplaySurfaceCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->imageExtent.IsEmpty())) {
    Napi::Value value = self->imageExtent.Value();
    
    _VkExtent2D* result = Napi::ObjectWrap<_VkExtent2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.imageExtent = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplaySurfaceCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplaySurfaceCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplaySurfaceCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDisplaySurfaceCreateInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDisplaySurfaceCreateInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDisplaySurfaceCreateFlagsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.flags", "Number");
  
    return;
  }
}// displayMode
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetdisplayMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayMode.IsEmpty()) return env.Null();
  return this->displayMode.Value().As<Napi::Object>();
}void _VkDisplaySurfaceCreateInfoKHR::SetdisplayMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDisplayModeKHR::constructor.Value())) {
      
      this->displayMode.Reset(value.ToObject(), 1);
      _VkDisplayModeKHR* inst = Napi::ObjectWrap<_VkDisplayModeKHR>::Unwrap(obj);
      ;
      this->instance.displayMode = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.displayMode", "[object VkDisplayModeKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->displayMode.Reset();
    this->instance.displayMode = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.displayMode", "[object VkDisplayModeKHR]");
  
    return;
  }
}// planeIndex
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetplaneIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeIndex);
}void _VkDisplaySurfaceCreateInfoKHR::SetplaneIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.planeIndex", "Number");
  
    return;
  }
}// planeStackIndex
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetplaneStackIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeStackIndex);
}void _VkDisplaySurfaceCreateInfoKHR::SetplaneStackIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.planeStackIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.planeStackIndex", "Number");
  
    return;
  }
}// transform
Napi::Value _VkDisplaySurfaceCreateInfoKHR::Gettransform(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.transform);
}void _VkDisplaySurfaceCreateInfoKHR::Settransform(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.transform = static_cast<VkSurfaceTransformFlagBitsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.transform", "Number");
  
    return;
  }
}// globalAlpha
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetglobalAlpha(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.globalAlpha);
}void _VkDisplaySurfaceCreateInfoKHR::SetglobalAlpha(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.globalAlpha = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.globalAlpha", "Number");
  
    return;
  }
}// alphaMode
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetalphaMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.alphaMode);
}void _VkDisplaySurfaceCreateInfoKHR::SetalphaMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.alphaMode = static_cast<VkDisplayPlaneAlphaFlagBitsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.alphaMode", "Number");
  
    return;
  }
}// imageExtent
Napi::Value _VkDisplaySurfaceCreateInfoKHR::GetimageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageExtent.IsEmpty()) return env.Null();
  return this->imageExtent.Value().As<Napi::Object>();
}void _VkDisplaySurfaceCreateInfoKHR::SetimageExtent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent2D::constructor.Value())) {
      
      this->imageExtent.Reset(value.ToObject(), 1);
      _VkExtent2D* inst = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
      inst->flush();
      this->instance.imageExtent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->imageExtent.Reset();
    memset(&this->instance.imageExtent, 0, sizeof(VkExtent2D));
  } else {
    
    NapiObjectTypeError(value, "VkDisplaySurfaceCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
    return;
  }
}
/** ## END VkDisplaySurfaceCreateInfoKHR ## **/

/** ## BEGIN VkDisplayPlaneCapabilitiesKHR ## **/

Napi::FunctionReference _VkDisplayPlaneCapabilitiesKHR::constructor;

_VkDisplayPlaneCapabilitiesKHR::_VkDisplayPlaneCapabilitiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPlaneCapabilitiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkDisplayPlaneCapabilitiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPlaneCapabilitiesKHR::~_VkDisplayPlaneCapabilitiesKHR() {
  
  
  minSrcPosition.Reset();
  
  maxSrcPosition.Reset();
  
  minSrcExtent.Reset();
  
  maxSrcExtent.Reset();
  
  minDstPosition.Reset();
  
  maxDstPosition.Reset();
  
  minDstExtent.Reset();
  
  maxDstExtent.Reset();
  
}

Napi::Object _VkDisplayPlaneCapabilitiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPlaneCapabilitiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPlaneCapabilitiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPlaneCapabilitiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "supportedAlpha",
    &_VkDisplayPlaneCapabilitiesKHR::GetsupportedAlpha,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minSrcPosition",
    &_VkDisplayPlaneCapabilitiesKHR::GetminSrcPosition,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSrcPosition",
    &_VkDisplayPlaneCapabilitiesKHR::GetmaxSrcPosition,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minSrcExtent",
    &_VkDisplayPlaneCapabilitiesKHR::GetminSrcExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSrcExtent",
    &_VkDisplayPlaneCapabilitiesKHR::GetmaxSrcExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minDstPosition",
    &_VkDisplayPlaneCapabilitiesKHR::GetminDstPosition,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDstPosition",
    &_VkDisplayPlaneCapabilitiesKHR::GetmaxDstPosition,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minDstExtent",
    &_VkDisplayPlaneCapabilitiesKHR::GetminDstExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDstExtent",
    &_VkDisplayPlaneCapabilitiesKHR::GetmaxDstExtent,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPlaneCapabilitiesKHR", func);
  return exports;
}

Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->supportedAlpha));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->supportedAlpha);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->minSrcPosition));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->minSrcPosition);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->maxSrcPosition));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->maxSrcPosition);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->minSrcExtent));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->minSrcExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->maxSrcExtent));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->maxSrcExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->minDstPosition));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->minDstPosition);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->maxDstPosition));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->maxDstPosition);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->minDstExtent));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->minDstExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlaneCapabilitiesKHR *)0)->maxDstExtent));
    uint32_t byteLength = sizeof(((VkDisplayPlaneCapabilitiesKHR *)0)->maxDstExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPlaneCapabilitiesKHR::flush() {
  _VkDisplayPlaneCapabilitiesKHR *self = this;
  if (!(self->minSrcPosition.IsEmpty())) {
    Napi::Value value = self->minSrcPosition.Value();
    
  }if (!(self->maxSrcPosition.IsEmpty())) {
    Napi::Value value = self->maxSrcPosition.Value();
    
  }if (!(self->minSrcExtent.IsEmpty())) {
    Napi::Value value = self->minSrcExtent.Value();
    
  }if (!(self->maxSrcExtent.IsEmpty())) {
    Napi::Value value = self->maxSrcExtent.Value();
    
  }if (!(self->minDstPosition.IsEmpty())) {
    Napi::Value value = self->minDstPosition.Value();
    
  }if (!(self->maxDstPosition.IsEmpty())) {
    Napi::Value value = self->maxDstPosition.Value();
    
  }if (!(self->minDstExtent.IsEmpty())) {
    Napi::Value value = self->minDstExtent.Value();
    
  }if (!(self->maxDstExtent.IsEmpty())) {
    Napi::Value value = self->maxDstExtent.Value();
    
  }
  return true;
}

// supportedAlpha
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetsupportedAlpha(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedAlpha);
}// minSrcPosition
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetminSrcPosition(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minSrcPosition.IsEmpty()) return env.Null();
  return this->minSrcPosition.Value().As<Napi::Object>();
}// maxSrcPosition
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetmaxSrcPosition(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxSrcPosition.IsEmpty()) return env.Null();
  return this->maxSrcPosition.Value().As<Napi::Object>();
}// minSrcExtent
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetminSrcExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minSrcExtent.IsEmpty()) return env.Null();
  return this->minSrcExtent.Value().As<Napi::Object>();
}// maxSrcExtent
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetmaxSrcExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxSrcExtent.IsEmpty()) return env.Null();
  return this->maxSrcExtent.Value().As<Napi::Object>();
}// minDstPosition
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetminDstPosition(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minDstPosition.IsEmpty()) return env.Null();
  return this->minDstPosition.Value().As<Napi::Object>();
}// maxDstPosition
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetmaxDstPosition(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxDstPosition.IsEmpty()) return env.Null();
  return this->maxDstPosition.Value().As<Napi::Object>();
}// minDstExtent
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetminDstExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minDstExtent.IsEmpty()) return env.Null();
  return this->minDstExtent.Value().As<Napi::Object>();
}// maxDstExtent
Napi::Value _VkDisplayPlaneCapabilitiesKHR::GetmaxDstExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxDstExtent.IsEmpty()) return env.Null();
  return this->maxDstExtent.Value().As<Napi::Object>();
}
/** ## END VkDisplayPlaneCapabilitiesKHR ## **/

/** ## BEGIN VkDisplayModeCreateInfoKHR ## **/

Napi::FunctionReference _VkDisplayModeCreateInfoKHR::constructor;

_VkDisplayModeCreateInfoKHR::_VkDisplayModeCreateInfoKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayModeCreateInfoKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "parameters");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setparameters(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDisplayModeCreateInfoKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayModeCreateInfoKHR::~_VkDisplayModeCreateInfoKHR() {
  
  
  pNext.Reset();
  
  
  parameters.Reset();
  
}

Napi::Object _VkDisplayModeCreateInfoKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayModeCreateInfoKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayModeCreateInfoKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayModeCreateInfoKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDisplayModeCreateInfoKHR::GetsType,
    &_VkDisplayModeCreateInfoKHR::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDisplayModeCreateInfoKHR::GetpNext,
    &_VkDisplayModeCreateInfoKHR::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDisplayModeCreateInfoKHR::Getflags,
    &_VkDisplayModeCreateInfoKHR::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "parameters",
    &_VkDisplayModeCreateInfoKHR::Getparameters,
    &_VkDisplayModeCreateInfoKHR::Setparameters,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayModeCreateInfoKHR", func);
  return exports;
}

Napi::Value _VkDisplayModeCreateInfoKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayModeCreateInfoKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeCreateInfoKHR *)0)->sType));
    uint32_t byteLength = sizeof(((VkDisplayModeCreateInfoKHR *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeCreateInfoKHR *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDisplayModeCreateInfoKHR *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeCreateInfoKHR *)0)->flags));
    uint32_t byteLength = sizeof(((VkDisplayModeCreateInfoKHR *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeCreateInfoKHR *)0)->parameters));
    uint32_t byteLength = sizeof(((VkDisplayModeCreateInfoKHR *)0)->parameters);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayModeCreateInfoKHR::flush() {
  _VkDisplayModeCreateInfoKHR *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->parameters.IsEmpty())) {
    Napi::Value value = self->parameters.Value();
    
    _VkDisplayModeParametersKHR* result = Napi::ObjectWrap<_VkDisplayModeParametersKHR>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.parameters = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkDisplayModeCreateInfoKHR::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDisplayModeCreateInfoKHR::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeCreateInfoKHR.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDisplayModeCreateInfoKHR::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDisplayModeCreateInfoKHR::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDisplayModeCreateInfoKHR.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDisplayModeCreateInfoKHR.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeCreateInfoKHR.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDisplayModeCreateInfoKHR::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDisplayModeCreateInfoKHR::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDisplayModeCreateFlagsKHR>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeCreateInfoKHR.flags", "Number");
  
    return;
  }
}// parameters
Napi::Value _VkDisplayModeCreateInfoKHR::Getparameters(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->parameters.IsEmpty()) return env.Null();
  return this->parameters.Value().As<Napi::Object>();
}void _VkDisplayModeCreateInfoKHR::Setparameters(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDisplayModeParametersKHR::constructor.Value())) {
      
      this->parameters.Reset(value.ToObject(), 1);
      _VkDisplayModeParametersKHR* inst = Napi::ObjectWrap<_VkDisplayModeParametersKHR>::Unwrap(obj);
      inst->flush();
      this->instance.parameters = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplayModeCreateInfoKHR.parameters", "[object VkDisplayModeParametersKHR]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->parameters.Reset();
    memset(&this->instance.parameters, 0, sizeof(VkDisplayModeParametersKHR));
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeCreateInfoKHR.parameters", "[object VkDisplayModeParametersKHR]");
  
    return;
  }
}
/** ## END VkDisplayModeCreateInfoKHR ## **/

/** ## BEGIN VkDisplayModePropertiesKHR ## **/

Napi::FunctionReference _VkDisplayModePropertiesKHR::constructor;

_VkDisplayModePropertiesKHR::_VkDisplayModePropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayModePropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkDisplayModePropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayModePropertiesKHR::~_VkDisplayModePropertiesKHR() {
  
  displayMode.Reset();
  
  parameters.Reset();
  
}

Napi::Object _VkDisplayModePropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayModePropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayModePropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayModePropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "displayMode",
    &_VkDisplayModePropertiesKHR::GetdisplayMode,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "parameters",
    &_VkDisplayModePropertiesKHR::Getparameters,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayModePropertiesKHR", func);
  return exports;
}

Napi::Value _VkDisplayModePropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayModePropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModePropertiesKHR *)0)->displayMode));
    uint32_t byteLength = sizeof(((VkDisplayModePropertiesKHR *)0)->displayMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModePropertiesKHR *)0)->parameters));
    uint32_t byteLength = sizeof(((VkDisplayModePropertiesKHR *)0)->parameters);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayModePropertiesKHR::flush() {
  _VkDisplayModePropertiesKHR *self = this;
  if (!(self->parameters.IsEmpty())) {
    Napi::Value value = self->parameters.Value();
    
  }
  return true;
}

// displayMode
Napi::Value _VkDisplayModePropertiesKHR::GetdisplayMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayMode.IsEmpty()) return env.Null();
  return this->displayMode.Value().As<Napi::Object>();
}// parameters
Napi::Value _VkDisplayModePropertiesKHR::Getparameters(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->parameters.IsEmpty()) return env.Null();
  return this->parameters.Value().As<Napi::Object>();
}
/** ## END VkDisplayModePropertiesKHR ## **/

/** ## BEGIN VkDisplayModeParametersKHR ## **/

Napi::FunctionReference _VkDisplayModeParametersKHR::constructor;

_VkDisplayModeParametersKHR::_VkDisplayModeParametersKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayModeParametersKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "visibleRegion");
      Napi::String sAccess1 = Napi::String::New(env, "refreshRate");
      if (obj.Has(sAccess0)) this->SetvisibleRegion(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetrefreshRate(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDisplayModeParametersKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayModeParametersKHR::~_VkDisplayModeParametersKHR() {
  
  visibleRegion.Reset();
  
  
}

Napi::Object _VkDisplayModeParametersKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayModeParametersKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayModeParametersKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayModeParametersKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "visibleRegion",
    &_VkDisplayModeParametersKHR::GetvisibleRegion,
    &_VkDisplayModeParametersKHR::SetvisibleRegion,
    napi_enumerable
  ),
  InstanceAccessor(
    "refreshRate",
    &_VkDisplayModeParametersKHR::GetrefreshRate,
    &_VkDisplayModeParametersKHR::SetrefreshRate,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayModeParametersKHR", func);
  return exports;
}

Napi::Value _VkDisplayModeParametersKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayModeParametersKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeParametersKHR *)0)->visibleRegion));
    uint32_t byteLength = sizeof(((VkDisplayModeParametersKHR *)0)->visibleRegion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayModeParametersKHR *)0)->refreshRate));
    uint32_t byteLength = sizeof(((VkDisplayModeParametersKHR *)0)->refreshRate);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayModeParametersKHR::flush() {
  _VkDisplayModeParametersKHR *self = this;
  if (!(self->visibleRegion.IsEmpty())) {
    Napi::Value value = self->visibleRegion.Value();
    
    _VkExtent2D* result = Napi::ObjectWrap<_VkExtent2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.visibleRegion = result->instance;
  }
  return true;
}

// visibleRegion
Napi::Value _VkDisplayModeParametersKHR::GetvisibleRegion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->visibleRegion.IsEmpty()) return env.Null();
  return this->visibleRegion.Value().As<Napi::Object>();
}void _VkDisplayModeParametersKHR::SetvisibleRegion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent2D::constructor.Value())) {
      
      this->visibleRegion.Reset(value.ToObject(), 1);
      _VkExtent2D* inst = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
      inst->flush();
      this->instance.visibleRegion = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDisplayModeParametersKHR.visibleRegion", "[object VkExtent2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->visibleRegion.Reset();
    memset(&this->instance.visibleRegion, 0, sizeof(VkExtent2D));
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeParametersKHR.visibleRegion", "[object VkExtent2D]");
  
    return;
  }
}// refreshRate
Napi::Value _VkDisplayModeParametersKHR::GetrefreshRate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.refreshRate);
}void _VkDisplayModeParametersKHR::SetrefreshRate(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.refreshRate = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDisplayModeParametersKHR.refreshRate", "Number");
  
    return;
  }
}
/** ## END VkDisplayModeParametersKHR ## **/

/** ## BEGIN VkDisplayPlanePropertiesKHR ## **/

Napi::FunctionReference _VkDisplayPlanePropertiesKHR::constructor;

_VkDisplayPlanePropertiesKHR::_VkDisplayPlanePropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPlanePropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkDisplayPlanePropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPlanePropertiesKHR::~_VkDisplayPlanePropertiesKHR() {
  
  currentDisplay.Reset();
  
  
}

Napi::Object _VkDisplayPlanePropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPlanePropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPlanePropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPlanePropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "currentDisplay",
    &_VkDisplayPlanePropertiesKHR::GetcurrentDisplay,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "currentStackIndex",
    &_VkDisplayPlanePropertiesKHR::GetcurrentStackIndex,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPlanePropertiesKHR", func);
  return exports;
}

Napi::Value _VkDisplayPlanePropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPlanePropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlanePropertiesKHR *)0)->currentDisplay));
    uint32_t byteLength = sizeof(((VkDisplayPlanePropertiesKHR *)0)->currentDisplay);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPlanePropertiesKHR *)0)->currentStackIndex));
    uint32_t byteLength = sizeof(((VkDisplayPlanePropertiesKHR *)0)->currentStackIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPlanePropertiesKHR::flush() {
  _VkDisplayPlanePropertiesKHR *self = this;
  
  return true;
}

// currentDisplay
Napi::Value _VkDisplayPlanePropertiesKHR::GetcurrentDisplay(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->currentDisplay.IsEmpty()) return env.Null();
  return this->currentDisplay.Value().As<Napi::Object>();
}// currentStackIndex
Napi::Value _VkDisplayPlanePropertiesKHR::GetcurrentStackIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.currentStackIndex);
}
/** ## END VkDisplayPlanePropertiesKHR ## **/

/** ## BEGIN VkDisplayPropertiesKHR ## **/

Napi::FunctionReference _VkDisplayPropertiesKHR::constructor;

_VkDisplayPropertiesKHR::_VkDisplayPropertiesKHR(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDisplayPropertiesKHR>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkDisplayPropertiesKHR constructor cannot be invoked without 'new'");
    }
  }
}

_VkDisplayPropertiesKHR::~_VkDisplayPropertiesKHR() {
  
  display.Reset();
  
  displayName.Reset();
  
  physicalDimensions.Reset();
  
  physicalResolution.Reset();
  
  
  
  
}

Napi::Object _VkDisplayPropertiesKHR::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDisplayPropertiesKHR", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDisplayPropertiesKHR::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDisplayPropertiesKHR::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "display",
    &_VkDisplayPropertiesKHR::Getdisplay,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "displayName",
    &_VkDisplayPropertiesKHR::GetdisplayName,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalDimensions",
    &_VkDisplayPropertiesKHR::GetphysicalDimensions,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "physicalResolution",
    &_VkDisplayPropertiesKHR::GetphysicalResolution,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "supportedTransforms",
    &_VkDisplayPropertiesKHR::GetsupportedTransforms,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "planeReorderPossible",
    &_VkDisplayPropertiesKHR::GetplaneReorderPossible,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "persistentContent",
    &_VkDisplayPropertiesKHR::GetpersistentContent,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDisplayPropertiesKHR", func);
  return exports;
}

Napi::Value _VkDisplayPropertiesKHR::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDisplayPropertiesKHR::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->display));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->display);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->displayName));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->displayName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->physicalDimensions));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->physicalDimensions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->physicalResolution));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->physicalResolution);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->supportedTransforms));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->supportedTransforms);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->planeReorderPossible));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->planeReorderPossible);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDisplayPropertiesKHR *)0)->persistentContent));
    uint32_t byteLength = sizeof(((VkDisplayPropertiesKHR *)0)->persistentContent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDisplayPropertiesKHR::flush() {
  _VkDisplayPropertiesKHR *self = this;
  if (!(self->physicalDimensions.IsEmpty())) {
    Napi::Value value = self->physicalDimensions.Value();
    
  }if (!(self->physicalResolution.IsEmpty())) {
    Napi::Value value = self->physicalResolution.Value();
    
  }
  return true;
}

// display
Napi::Value _VkDisplayPropertiesKHR::Getdisplay(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->display.IsEmpty()) return env.Null();
  return this->display.Value().As<Napi::Object>();
}// displayName
Napi::Value _VkDisplayPropertiesKHR::GetdisplayName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->displayName.IsEmpty()) return env.Null();
  return this->displayName.Value().ToString();
}// physicalDimensions
Napi::Value _VkDisplayPropertiesKHR::GetphysicalDimensions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->physicalDimensions.IsEmpty()) return env.Null();
  return this->physicalDimensions.Value().As<Napi::Object>();
}// physicalResolution
Napi::Value _VkDisplayPropertiesKHR::GetphysicalResolution(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->physicalResolution.IsEmpty()) return env.Null();
  return this->physicalResolution.Value().As<Napi::Object>();
}// supportedTransforms
Napi::Value _VkDisplayPropertiesKHR::GetsupportedTransforms(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.supportedTransforms);
}// planeReorderPossible
Napi::Value _VkDisplayPropertiesKHR::GetplaneReorderPossible(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.planeReorderPossible);
}// persistentContent
Napi::Value _VkDisplayPropertiesKHR::GetpersistentContent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.persistentContent);
}
/** ## END VkDisplayPropertiesKHR ## **/

/** ## BEGIN VkSubmitInfo ## **/

Napi::FunctionReference _VkSubmitInfo::constructor;

_VkSubmitInfo::_VkSubmitInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubmitInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    vpWaitSemaphores = new std::vector<VkSemaphore>;
    vpCommandBuffers = new std::vector<VkCommandBuffer>;
    vpSignalSemaphores = new std::vector<VkSemaphore>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "waitSemaphoreCount");
      Napi::String sAccess3 = Napi::String::New(env, "pWaitSemaphores");
      Napi::String sAccess4 = Napi::String::New(env, "pWaitDstStageMask");
      Napi::String sAccess5 = Napi::String::New(env, "commandBufferCount");
      Napi::String sAccess6 = Napi::String::New(env, "pCommandBuffers");
      Napi::String sAccess7 = Napi::String::New(env, "signalSemaphoreCount");
      Napi::String sAccess8 = Napi::String::New(env, "pSignalSemaphores");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetwaitSemaphoreCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpWaitSemaphores(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpWaitDstStageMask(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetcommandBufferCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpCommandBuffers(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetsignalSemaphoreCount(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpSignalSemaphores(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkSubmitInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubmitInfo::~_VkSubmitInfo() {
  
  
  pNext.Reset();
  
  
  vpWaitSemaphores->clear();
  delete vpWaitSemaphores;
  
  pWaitSemaphores.Reset();
  
  pWaitDstStageMask.Reset();
  
  
  vpCommandBuffers->clear();
  delete vpCommandBuffers;
  
  pCommandBuffers.Reset();
  
  
  vpSignalSemaphores->clear();
  delete vpSignalSemaphores;
  
  pSignalSemaphores.Reset();
  
}

Napi::Object _VkSubmitInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubmitInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubmitInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubmitInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSubmitInfo::GetsType,
    &_VkSubmitInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSubmitInfo::GetpNext,
    &_VkSubmitInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "waitSemaphoreCount",
    &_VkSubmitInfo::GetwaitSemaphoreCount,
    &_VkSubmitInfo::SetwaitSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitSemaphores",
    &_VkSubmitInfo::GetpWaitSemaphores,
    &_VkSubmitInfo::SetpWaitSemaphores,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitDstStageMask",
    &_VkSubmitInfo::GetpWaitDstStageMask,
    &_VkSubmitInfo::SetpWaitDstStageMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "commandBufferCount",
    &_VkSubmitInfo::GetcommandBufferCount,
    &_VkSubmitInfo::SetcommandBufferCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCommandBuffers",
    &_VkSubmitInfo::GetpCommandBuffers,
    &_VkSubmitInfo::SetpCommandBuffers,
    napi_enumerable
  ),
  InstanceAccessor(
    "signalSemaphoreCount",
    &_VkSubmitInfo::GetsignalSemaphoreCount,
    &_VkSubmitInfo::SetsignalSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSignalSemaphores",
    &_VkSubmitInfo::GetpSignalSemaphores,
    &_VkSubmitInfo::SetpSignalSemaphores,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubmitInfo", func);
  return exports;
}

Napi::Value _VkSubmitInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubmitInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->waitSemaphoreCount));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->waitSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->pWaitSemaphores));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->pWaitSemaphores);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->pWaitDstStageMask));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->pWaitDstStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->commandBufferCount));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->commandBufferCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->pCommandBuffers));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->pCommandBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->signalSemaphoreCount));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->signalSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubmitInfo *)0)->pSignalSemaphores));
    uint32_t byteLength = sizeof(((VkSubmitInfo *)0)->pSignalSemaphores);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubmitInfo::flush() {
  _VkSubmitInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV) {
      _VkWin32KeyedMutexAcquireReleaseInfoNV* structExt = Napi::ObjectWrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR) {
      _VkWin32KeyedMutexAcquireReleaseInfoKHR* structExt = Napi::ObjectWrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR) {
      _VkD3D12FenceSubmitInfoKHR* structExt = Napi::ObjectWrap<_VkD3D12FenceSubmitInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO) {
      _VkDeviceGroupSubmitInfo* structExt = Napi::ObjectWrap<_VkDeviceGroupSubmitInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO) {
      _VkProtectedSubmitInfo* structExt = Napi::ObjectWrap<_VkProtectedSubmitInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pWaitSemaphores.IsEmpty())) {
    Napi::Value value = self->pWaitSemaphores.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.waitSemaphoreCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'waitSemaphoreCount' for 'VkSubmitInfo.pWaitSemaphores'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSemaphore>* data = this->vpWaitSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubmitInfo.pWaitSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pWaitSemaphores = data->data();
  }if (!(self->pCommandBuffers.IsEmpty())) {
    Napi::Value value = self->pCommandBuffers.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.commandBufferCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'commandBufferCount' for 'VkSubmitInfo.pCommandBuffers'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkCommandBuffer>* data = this->vpCommandBuffers;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubmitInfo.pCommandBuffers", "[object VkCommandBuffer]");
  
        return false;
      }
      _VkCommandBuffer* result = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pCommandBuffers = data->data();
  }if (!(self->pSignalSemaphores.IsEmpty())) {
    Napi::Value value = self->pSignalSemaphores.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.signalSemaphoreCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'signalSemaphoreCount' for 'VkSubmitInfo.pSignalSemaphores'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSemaphore>* data = this->vpSignalSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubmitInfo.pSignalSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSignalSemaphores = data->data();
  }
  return true;
}

// sType
Napi::Value _VkSubmitInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSubmitInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSubmitInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSubmitInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO &&
        sType != VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSubmitInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSubmitInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.pNext", "[object Object]");
  
    return;
  }
}// waitSemaphoreCount
Napi::Value _VkSubmitInfo::GetwaitSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.waitSemaphoreCount);
}void _VkSubmitInfo::SetwaitSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.waitSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphores
Napi::Value _VkSubmitInfo::GetpWaitSemaphores(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitSemaphores.IsEmpty()) return env.Null();
  return this->pWaitSemaphores.Value().As<Napi::Array>();
}void _VkSubmitInfo::SetpWaitSemaphores(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pWaitSemaphores.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pWaitSemaphores.Reset();
      this->instance.pWaitSemaphores = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubmitInfo.pWaitSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pWaitSemaphores = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.pWaitSemaphores", "[object VkSemaphore]");
  
    return;
  }
}// pWaitDstStageMask
Napi::Value _VkSubmitInfo::GetpWaitDstStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitDstStageMask.IsEmpty()) return env.Null();
  return this->pWaitDstStageMask.Value().As<Napi::TypedArray>();
}void _VkSubmitInfo::SetpWaitDstStageMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pWaitDstStageMask.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkSubmitInfo.pWaitDstStageMask", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pWaitDstStageMask.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkSubmitInfo.pWaitDstStageMask", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pWaitDstStageMask = reinterpret_cast<const VkPipelineStageFlags *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pWaitDstStageMask = nullptr;
  }
}// commandBufferCount
Napi::Value _VkSubmitInfo::GetcommandBufferCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.commandBufferCount);
}void _VkSubmitInfo::SetcommandBufferCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.commandBufferCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.commandBufferCount", "Number");
  
    return;
  }
}// pCommandBuffers
Napi::Value _VkSubmitInfo::GetpCommandBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCommandBuffers.IsEmpty()) return env.Null();
  return this->pCommandBuffers.Value().As<Napi::Array>();
}void _VkSubmitInfo::SetpCommandBuffers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pCommandBuffers.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pCommandBuffers.Reset();
      this->instance.pCommandBuffers = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubmitInfo.pCommandBuffers", "[object VkCommandBuffer]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pCommandBuffers = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.pCommandBuffers", "[object VkCommandBuffer]");
  
    return;
  }
}// signalSemaphoreCount
Napi::Value _VkSubmitInfo::GetsignalSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.signalSemaphoreCount);
}void _VkSubmitInfo::SetsignalSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.signalSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphores
Napi::Value _VkSubmitInfo::GetpSignalSemaphores(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSignalSemaphores.IsEmpty()) return env.Null();
  return this->pSignalSemaphores.Value().As<Napi::Array>();
}void _VkSubmitInfo::SetpSignalSemaphores(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSignalSemaphores.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSignalSemaphores.Reset();
      this->instance.pSignalSemaphores = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubmitInfo.pSignalSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSignalSemaphores = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSubmitInfo.pSignalSemaphores", "[object VkSemaphore]");
  
    return;
  }
}
/** ## END VkSubmitInfo ## **/

/** ## BEGIN VkDispatchIndirectCommand ## **/

Napi::FunctionReference _VkDispatchIndirectCommand::constructor;

_VkDispatchIndirectCommand::_VkDispatchIndirectCommand(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDispatchIndirectCommand>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      Napi::String sAccess2 = Napi::String::New(env, "z");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setz(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDispatchIndirectCommand constructor cannot be invoked without 'new'");
    }
  }
}

_VkDispatchIndirectCommand::~_VkDispatchIndirectCommand() {
  
  
  
  
}

Napi::Object _VkDispatchIndirectCommand::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDispatchIndirectCommand", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDispatchIndirectCommand::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDispatchIndirectCommand::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkDispatchIndirectCommand::Getx,
    &_VkDispatchIndirectCommand::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkDispatchIndirectCommand::Gety,
    &_VkDispatchIndirectCommand::Sety,
    napi_enumerable
  ),
  InstanceAccessor(
    "z",
    &_VkDispatchIndirectCommand::Getz,
    &_VkDispatchIndirectCommand::Setz,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDispatchIndirectCommand", func);
  return exports;
}

Napi::Value _VkDispatchIndirectCommand::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDispatchIndirectCommand::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDispatchIndirectCommand *)0)->x));
    uint32_t byteLength = sizeof(((VkDispatchIndirectCommand *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDispatchIndirectCommand *)0)->y));
    uint32_t byteLength = sizeof(((VkDispatchIndirectCommand *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDispatchIndirectCommand *)0)->z));
    uint32_t byteLength = sizeof(((VkDispatchIndirectCommand *)0)->z);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDispatchIndirectCommand::flush() {
  _VkDispatchIndirectCommand *self = this;
  
  return true;
}

// x
Napi::Value _VkDispatchIndirectCommand::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkDispatchIndirectCommand::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDispatchIndirectCommand.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkDispatchIndirectCommand::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkDispatchIndirectCommand::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDispatchIndirectCommand.y", "Number");
  
    return;
  }
}// z
Napi::Value _VkDispatchIndirectCommand::Getz(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.z);
}void _VkDispatchIndirectCommand::Setz(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.z = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDispatchIndirectCommand.z", "Number");
  
    return;
  }
}
/** ## END VkDispatchIndirectCommand ## **/

/** ## BEGIN VkDrawIndexedIndirectCommand ## **/

Napi::FunctionReference _VkDrawIndexedIndirectCommand::constructor;

_VkDrawIndexedIndirectCommand::_VkDrawIndexedIndirectCommand(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDrawIndexedIndirectCommand>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "indexCount");
      Napi::String sAccess1 = Napi::String::New(env, "instanceCount");
      Napi::String sAccess2 = Napi::String::New(env, "firstIndex");
      Napi::String sAccess3 = Napi::String::New(env, "vertexOffset");
      Napi::String sAccess4 = Napi::String::New(env, "firstInstance");
      if (obj.Has(sAccess0)) this->SetindexCount(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetinstanceCount(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetfirstIndex(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetvertexOffset(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetfirstInstance(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDrawIndexedIndirectCommand constructor cannot be invoked without 'new'");
    }
  }
}

_VkDrawIndexedIndirectCommand::~_VkDrawIndexedIndirectCommand() {
  
  
  
  
  
  
}

Napi::Object _VkDrawIndexedIndirectCommand::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDrawIndexedIndirectCommand", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDrawIndexedIndirectCommand::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDrawIndexedIndirectCommand::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "indexCount",
    &_VkDrawIndexedIndirectCommand::GetindexCount,
    &_VkDrawIndexedIndirectCommand::SetindexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "instanceCount",
    &_VkDrawIndexedIndirectCommand::GetinstanceCount,
    &_VkDrawIndexedIndirectCommand::SetinstanceCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "firstIndex",
    &_VkDrawIndexedIndirectCommand::GetfirstIndex,
    &_VkDrawIndexedIndirectCommand::SetfirstIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "vertexOffset",
    &_VkDrawIndexedIndirectCommand::GetvertexOffset,
    &_VkDrawIndexedIndirectCommand::SetvertexOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "firstInstance",
    &_VkDrawIndexedIndirectCommand::GetfirstInstance,
    &_VkDrawIndexedIndirectCommand::SetfirstInstance,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDrawIndexedIndirectCommand", func);
  return exports;
}

Napi::Value _VkDrawIndexedIndirectCommand::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDrawIndexedIndirectCommand::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndexedIndirectCommand *)0)->indexCount));
    uint32_t byteLength = sizeof(((VkDrawIndexedIndirectCommand *)0)->indexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndexedIndirectCommand *)0)->instanceCount));
    uint32_t byteLength = sizeof(((VkDrawIndexedIndirectCommand *)0)->instanceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndexedIndirectCommand *)0)->firstIndex));
    uint32_t byteLength = sizeof(((VkDrawIndexedIndirectCommand *)0)->firstIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndexedIndirectCommand *)0)->vertexOffset));
    uint32_t byteLength = sizeof(((VkDrawIndexedIndirectCommand *)0)->vertexOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndexedIndirectCommand *)0)->firstInstance));
    uint32_t byteLength = sizeof(((VkDrawIndexedIndirectCommand *)0)->firstInstance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDrawIndexedIndirectCommand::flush() {
  _VkDrawIndexedIndirectCommand *self = this;
  
  return true;
}

// indexCount
Napi::Value _VkDrawIndexedIndirectCommand::GetindexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.indexCount);
}void _VkDrawIndexedIndirectCommand::SetindexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.indexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndexedIndirectCommand.indexCount", "Number");
  
    return;
  }
}// instanceCount
Napi::Value _VkDrawIndexedIndirectCommand::GetinstanceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.instanceCount);
}void _VkDrawIndexedIndirectCommand::SetinstanceCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.instanceCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndexedIndirectCommand.instanceCount", "Number");
  
    return;
  }
}// firstIndex
Napi::Value _VkDrawIndexedIndirectCommand::GetfirstIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.firstIndex);
}void _VkDrawIndexedIndirectCommand::SetfirstIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.firstIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndexedIndirectCommand.firstIndex", "Number");
  
    return;
  }
}// vertexOffset
Napi::Value _VkDrawIndexedIndirectCommand::GetvertexOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vertexOffset);
}void _VkDrawIndexedIndirectCommand::SetvertexOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.vertexOffset = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndexedIndirectCommand.vertexOffset", "Number");
  
    return;
  }
}// firstInstance
Napi::Value _VkDrawIndexedIndirectCommand::GetfirstInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.firstInstance);
}void _VkDrawIndexedIndirectCommand::SetfirstInstance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.firstInstance = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndexedIndirectCommand.firstInstance", "Number");
  
    return;
  }
}
/** ## END VkDrawIndexedIndirectCommand ## **/

/** ## BEGIN VkDrawIndirectCommand ## **/

Napi::FunctionReference _VkDrawIndirectCommand::constructor;

_VkDrawIndirectCommand::_VkDrawIndirectCommand(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDrawIndirectCommand>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "vertexCount");
      Napi::String sAccess1 = Napi::String::New(env, "instanceCount");
      Napi::String sAccess2 = Napi::String::New(env, "firstVertex");
      Napi::String sAccess3 = Napi::String::New(env, "firstInstance");
      if (obj.Has(sAccess0)) this->SetvertexCount(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetinstanceCount(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetfirstVertex(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetfirstInstance(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkDrawIndirectCommand constructor cannot be invoked without 'new'");
    }
  }
}

_VkDrawIndirectCommand::~_VkDrawIndirectCommand() {
  
  
  
  
  
}

Napi::Object _VkDrawIndirectCommand::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDrawIndirectCommand", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDrawIndirectCommand::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDrawIndirectCommand::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "vertexCount",
    &_VkDrawIndirectCommand::GetvertexCount,
    &_VkDrawIndirectCommand::SetvertexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "instanceCount",
    &_VkDrawIndirectCommand::GetinstanceCount,
    &_VkDrawIndirectCommand::SetinstanceCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "firstVertex",
    &_VkDrawIndirectCommand::GetfirstVertex,
    &_VkDrawIndirectCommand::SetfirstVertex,
    napi_enumerable
  ),
  InstanceAccessor(
    "firstInstance",
    &_VkDrawIndirectCommand::GetfirstInstance,
    &_VkDrawIndirectCommand::SetfirstInstance,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDrawIndirectCommand", func);
  return exports;
}

Napi::Value _VkDrawIndirectCommand::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDrawIndirectCommand::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndirectCommand *)0)->vertexCount));
    uint32_t byteLength = sizeof(((VkDrawIndirectCommand *)0)->vertexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndirectCommand *)0)->instanceCount));
    uint32_t byteLength = sizeof(((VkDrawIndirectCommand *)0)->instanceCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndirectCommand *)0)->firstVertex));
    uint32_t byteLength = sizeof(((VkDrawIndirectCommand *)0)->firstVertex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDrawIndirectCommand *)0)->firstInstance));
    uint32_t byteLength = sizeof(((VkDrawIndirectCommand *)0)->firstInstance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDrawIndirectCommand::flush() {
  _VkDrawIndirectCommand *self = this;
  
  return true;
}

// vertexCount
Napi::Value _VkDrawIndirectCommand::GetvertexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vertexCount);
}void _VkDrawIndirectCommand::SetvertexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.vertexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndirectCommand.vertexCount", "Number");
  
    return;
  }
}// instanceCount
Napi::Value _VkDrawIndirectCommand::GetinstanceCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.instanceCount);
}void _VkDrawIndirectCommand::SetinstanceCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.instanceCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndirectCommand.instanceCount", "Number");
  
    return;
  }
}// firstVertex
Napi::Value _VkDrawIndirectCommand::GetfirstVertex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.firstVertex);
}void _VkDrawIndirectCommand::SetfirstVertex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.firstVertex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndirectCommand.firstVertex", "Number");
  
    return;
  }
}// firstInstance
Napi::Value _VkDrawIndirectCommand::GetfirstInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.firstInstance);
}void _VkDrawIndirectCommand::SetfirstInstance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.firstInstance = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDrawIndirectCommand.firstInstance", "Number");
  
    return;
  }
}
/** ## END VkDrawIndirectCommand ## **/

/** ## BEGIN VkFramebufferCreateInfo ## **/

Napi::FunctionReference _VkFramebufferCreateInfo::constructor;

_VkFramebufferCreateInfo::_VkFramebufferCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFramebufferCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    vpAttachments = new std::vector<VkImageView>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "renderPass");
      Napi::String sAccess4 = Napi::String::New(env, "attachmentCount");
      Napi::String sAccess5 = Napi::String::New(env, "pAttachments");
      Napi::String sAccess6 = Napi::String::New(env, "width");
      Napi::String sAccess7 = Napi::String::New(env, "height");
      Napi::String sAccess8 = Napi::String::New(env, "layers");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetrenderPass(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetattachmentCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpAttachments(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setwidth(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->Setheight(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->Setlayers(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkFramebufferCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkFramebufferCreateInfo::~_VkFramebufferCreateInfo() {
  
  
  pNext.Reset();
  
  
  renderPass.Reset();
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  
  
  
}

Napi::Object _VkFramebufferCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFramebufferCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFramebufferCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFramebufferCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkFramebufferCreateInfo::GetsType,
    &_VkFramebufferCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkFramebufferCreateInfo::GetpNext,
    &_VkFramebufferCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkFramebufferCreateInfo::Getflags,
    &_VkFramebufferCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "renderPass",
    &_VkFramebufferCreateInfo::GetrenderPass,
    &_VkFramebufferCreateInfo::SetrenderPass,
    napi_enumerable
  ),
  InstanceAccessor(
    "attachmentCount",
    &_VkFramebufferCreateInfo::GetattachmentCount,
    &_VkFramebufferCreateInfo::SetattachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAttachments",
    &_VkFramebufferCreateInfo::GetpAttachments,
    &_VkFramebufferCreateInfo::SetpAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "width",
    &_VkFramebufferCreateInfo::Getwidth,
    &_VkFramebufferCreateInfo::Setwidth,
    napi_enumerable
  ),
  InstanceAccessor(
    "height",
    &_VkFramebufferCreateInfo::Getheight,
    &_VkFramebufferCreateInfo::Setheight,
    napi_enumerable
  ),
  InstanceAccessor(
    "layers",
    &_VkFramebufferCreateInfo::Getlayers,
    &_VkFramebufferCreateInfo::Setlayers,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFramebufferCreateInfo", func);
  return exports;
}

Napi::Value _VkFramebufferCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFramebufferCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->renderPass));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->renderPass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->attachmentCount));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->attachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->pAttachments));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->pAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->width));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->width);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->height));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->height);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFramebufferCreateInfo *)0)->layers));
    uint32_t byteLength = sizeof(((VkFramebufferCreateInfo *)0)->layers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFramebufferCreateInfo::flush() {
  _VkFramebufferCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pAttachments.IsEmpty())) {
    Napi::Value value = self->pAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.attachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'attachmentCount' for 'VkFramebufferCreateInfo.pAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkImageView>* data = this->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkImageView::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.pAttachments", "[object VkImageView]");
  
        return false;
      }
      _VkImageView* result = Napi::ObjectWrap<_VkImageView>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }
  return true;
}

// sType
Napi::Value _VkFramebufferCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkFramebufferCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkFramebufferCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkFramebufferCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkFramebufferCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkFramebufferCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkFramebufferCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkFramebufferCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.flags", "Number");
  
    return;
  }
}// renderPass
Napi::Value _VkFramebufferCreateInfo::GetrenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->renderPass.IsEmpty()) return env.Null();
  return this->renderPass.Value().As<Napi::Object>();
}void _VkFramebufferCreateInfo::SetrenderPass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRenderPass::constructor.Value())) {
      
      this->renderPass.Reset(value.ToObject(), 1);
      _VkRenderPass* inst = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
      ;
      this->instance.renderPass = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->renderPass.Reset();
    this->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// attachmentCount
Napi::Value _VkFramebufferCreateInfo::GetattachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachmentCount);
}void _VkFramebufferCreateInfo::SetattachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
Napi::Value _VkFramebufferCreateInfo::GetpAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAttachments.IsEmpty()) return env.Null();
  return this->pAttachments.Value().As<Napi::Array>();
}void _VkFramebufferCreateInfo::SetpAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAttachments.Reset();
      this->instance.pAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.pAttachments", "[object VkImageView]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAttachments = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.pAttachments", "[object VkImageView]");
  
    return;
  }
}// width
Napi::Value _VkFramebufferCreateInfo::Getwidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.width);
}void _VkFramebufferCreateInfo::Setwidth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.width = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.width", "Number");
  
    return;
  }
}// height
Napi::Value _VkFramebufferCreateInfo::Getheight(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.height);
}void _VkFramebufferCreateInfo::Setheight(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.height = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.height", "Number");
  
    return;
  }
}// layers
Napi::Value _VkFramebufferCreateInfo::Getlayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layers);
}void _VkFramebufferCreateInfo::Setlayers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layers = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkFramebufferCreateInfo.layers", "Number");
  
    return;
  }
}
/** ## END VkFramebufferCreateInfo ## **/

/** ## BEGIN VkQueryPoolCreateInfo ## **/

Napi::FunctionReference _VkQueryPoolCreateInfo::constructor;

_VkQueryPoolCreateInfo::_VkQueryPoolCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueryPoolCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "queryType");
      Napi::String sAccess4 = Napi::String::New(env, "queryCount");
      Napi::String sAccess5 = Napi::String::New(env, "pipelineStatistics");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetqueryType(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetqueryCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpipelineStatistics(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkQueryPoolCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkQueryPoolCreateInfo::~_VkQueryPoolCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
}

Napi::Object _VkQueryPoolCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueryPoolCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkQueryPoolCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkQueryPoolCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkQueryPoolCreateInfo::GetsType,
    &_VkQueryPoolCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkQueryPoolCreateInfo::GetpNext,
    &_VkQueryPoolCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkQueryPoolCreateInfo::Getflags,
    &_VkQueryPoolCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "queryType",
    &_VkQueryPoolCreateInfo::GetqueryType,
    &_VkQueryPoolCreateInfo::SetqueryType,
    napi_enumerable
  ),
  InstanceAccessor(
    "queryCount",
    &_VkQueryPoolCreateInfo::GetqueryCount,
    &_VkQueryPoolCreateInfo::SetqueryCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineStatistics",
    &_VkQueryPoolCreateInfo::GetpipelineStatistics,
    &_VkQueryPoolCreateInfo::SetpipelineStatistics,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueryPoolCreateInfo", func);
  return exports;
}

Napi::Value _VkQueryPoolCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkQueryPoolCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueryPoolCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkQueryPoolCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueryPoolCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkQueryPoolCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueryPoolCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkQueryPoolCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueryPoolCreateInfo *)0)->queryType));
    uint32_t byteLength = sizeof(((VkQueryPoolCreateInfo *)0)->queryType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueryPoolCreateInfo *)0)->queryCount));
    uint32_t byteLength = sizeof(((VkQueryPoolCreateInfo *)0)->queryCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueryPoolCreateInfo *)0)->pipelineStatistics));
    uint32_t byteLength = sizeof(((VkQueryPoolCreateInfo *)0)->pipelineStatistics);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkQueryPoolCreateInfo::flush() {
  _VkQueryPoolCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkQueryPoolCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkQueryPoolCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkQueryPoolCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkQueryPoolCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkQueryPoolCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkQueryPoolCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkQueryPoolCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkQueryPoolCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.flags", "Number");
  
    return;
  }
}// queryType
Napi::Value _VkQueryPoolCreateInfo::GetqueryType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queryType);
}void _VkQueryPoolCreateInfo::SetqueryType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queryType = static_cast<VkQueryType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.queryType", "Number");
  
    return;
  }
}// queryCount
Napi::Value _VkQueryPoolCreateInfo::GetqueryCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queryCount);
}void _VkQueryPoolCreateInfo::SetqueryCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queryCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.queryCount", "Number");
  
    return;
  }
}// pipelineStatistics
Napi::Value _VkQueryPoolCreateInfo::GetpipelineStatistics(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineStatistics);
}void _VkQueryPoolCreateInfo::SetpipelineStatistics(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineStatistics = static_cast<VkQueryPipelineStatisticFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkQueryPoolCreateInfo.pipelineStatistics", "Number");
  
    return;
  }
}
/** ## END VkQueryPoolCreateInfo ## **/

/** ## BEGIN VkSemaphoreCreateInfo ## **/

Napi::FunctionReference _VkSemaphoreCreateInfo::constructor;

_VkSemaphoreCreateInfo::_VkSemaphoreCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSemaphoreCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSemaphoreCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSemaphoreCreateInfo::~_VkSemaphoreCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkSemaphoreCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSemaphoreCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSemaphoreCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSemaphoreCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSemaphoreCreateInfo::GetsType,
    &_VkSemaphoreCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSemaphoreCreateInfo::GetpNext,
    &_VkSemaphoreCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSemaphoreCreateInfo::Getflags,
    &_VkSemaphoreCreateInfo::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSemaphoreCreateInfo", func);
  return exports;
}

Napi::Value _VkSemaphoreCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSemaphoreCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkSemaphoreCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSemaphoreCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSemaphoreCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkSemaphoreCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSemaphoreCreateInfo::flush() {
  _VkSemaphoreCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO) {
      _VkExportSemaphoreCreateInfo* structExt = Napi::ObjectWrap<_VkExportSemaphoreCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR) {
      _VkExportSemaphoreWin32HandleInfoKHR* structExt = Napi::ObjectWrap<_VkExportSemaphoreWin32HandleInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkSemaphoreCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSemaphoreCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSemaphoreCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSemaphoreCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO &&
        sType != VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSemaphoreCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSemaphoreCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkSemaphoreCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSemaphoreCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSemaphoreCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSemaphoreCreateInfo.flags", "Number");
  
    return;
  }
}
/** ## END VkSemaphoreCreateInfo ## **/

/** ## BEGIN VkPhysicalDeviceLimits ## **/

Napi::FunctionReference _VkPhysicalDeviceLimits::constructor;

_VkPhysicalDeviceLimits::_VkPhysicalDeviceLimits(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceLimits>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vmaxComputeWorkGroupCount = new std::vector<uint32_t>;
    vmaxComputeWorkGroupSize = new std::vector<uint32_t>;
    vmaxViewportDimensions = new std::vector<uint32_t>;
    vviewportBoundsRange = new std::vector<float>;
    vpointSizeRange = new std::vector<float>;
    vlineWidthRange = new std::vector<float>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceLimits constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceLimits::~_VkPhysicalDeviceLimits() {
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  vmaxComputeWorkGroupCount->clear();
  delete vmaxComputeWorkGroupCount;
  
  maxComputeWorkGroupCount.Reset();
  
  
  vmaxComputeWorkGroupSize->clear();
  delete vmaxComputeWorkGroupSize;
  
  maxComputeWorkGroupSize.Reset();
  
  
  
  
  
  
  
  
  
  vmaxViewportDimensions->clear();
  delete vmaxViewportDimensions;
  
  maxViewportDimensions.Reset();
  
  vviewportBoundsRange->clear();
  delete vviewportBoundsRange;
  
  viewportBoundsRange.Reset();
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  vpointSizeRange->clear();
  delete vpointSizeRange;
  
  pointSizeRange.Reset();
  
  vlineWidthRange->clear();
  delete vlineWidthRange;
  
  lineWidthRange.Reset();
  
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceLimits::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceLimits", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceLimits::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceLimits::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "maxImageDimension1D",
    &_VkPhysicalDeviceLimits::GetmaxImageDimension1D,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageDimension2D",
    &_VkPhysicalDeviceLimits::GetmaxImageDimension2D,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageDimension3D",
    &_VkPhysicalDeviceLimits::GetmaxImageDimension3D,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageDimensionCube",
    &_VkPhysicalDeviceLimits::GetmaxImageDimensionCube,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxImageArrayLayers",
    &_VkPhysicalDeviceLimits::GetmaxImageArrayLayers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTexelBufferElements",
    &_VkPhysicalDeviceLimits::GetmaxTexelBufferElements,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxUniformBufferRange",
    &_VkPhysicalDeviceLimits::GetmaxUniformBufferRange,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxStorageBufferRange",
    &_VkPhysicalDeviceLimits::GetmaxStorageBufferRange,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPushConstantsSize",
    &_VkPhysicalDeviceLimits::GetmaxPushConstantsSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMemoryAllocationCount",
    &_VkPhysicalDeviceLimits::GetmaxMemoryAllocationCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSamplerAllocationCount",
    &_VkPhysicalDeviceLimits::GetmaxSamplerAllocationCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "bufferImageGranularity",
    &_VkPhysicalDeviceLimits::GetbufferImageGranularity,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseAddressSpaceSize",
    &_VkPhysicalDeviceLimits::GetsparseAddressSpaceSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxBoundDescriptorSets",
    &_VkPhysicalDeviceLimits::GetmaxBoundDescriptorSets,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorSamplers",
    &_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorSamplers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorUniformBuffers",
    &_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorUniformBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorStorageBuffers",
    &_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorStorageBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorSampledImages",
    &_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorSampledImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorStorageImages",
    &_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorStorageImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageDescriptorInputAttachments",
    &_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorInputAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxPerStageResources",
    &_VkPhysicalDeviceLimits::GetmaxPerStageResources,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetSamplers",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetSamplers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUniformBuffers",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetUniformBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetUniformBuffersDynamic",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetUniformBuffersDynamic,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetStorageBuffers",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageBuffers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetStorageBuffersDynamic",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageBuffersDynamic,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetSampledImages",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetSampledImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetStorageImages",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageImages,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDescriptorSetInputAttachments",
    &_VkPhysicalDeviceLimits::GetmaxDescriptorSetInputAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVertexInputAttributes",
    &_VkPhysicalDeviceLimits::GetmaxVertexInputAttributes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVertexInputBindings",
    &_VkPhysicalDeviceLimits::GetmaxVertexInputBindings,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVertexInputAttributeOffset",
    &_VkPhysicalDeviceLimits::GetmaxVertexInputAttributeOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVertexInputBindingStride",
    &_VkPhysicalDeviceLimits::GetmaxVertexInputBindingStride,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxVertexOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxVertexOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationGenerationLevel",
    &_VkPhysicalDeviceLimits::GetmaxTessellationGenerationLevel,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationPatchSize",
    &_VkPhysicalDeviceLimits::GetmaxTessellationPatchSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationControlPerVertexInputComponents",
    &_VkPhysicalDeviceLimits::GetmaxTessellationControlPerVertexInputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationControlPerVertexOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxTessellationControlPerVertexOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationControlPerPatchOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxTessellationControlPerPatchOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationControlTotalOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxTessellationControlTotalOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationEvaluationInputComponents",
    &_VkPhysicalDeviceLimits::GetmaxTessellationEvaluationInputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTessellationEvaluationOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxTessellationEvaluationOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxGeometryShaderInvocations",
    &_VkPhysicalDeviceLimits::GetmaxGeometryShaderInvocations,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxGeometryInputComponents",
    &_VkPhysicalDeviceLimits::GetmaxGeometryInputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxGeometryOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxGeometryOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxGeometryOutputVertices",
    &_VkPhysicalDeviceLimits::GetmaxGeometryOutputVertices,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxGeometryTotalOutputComponents",
    &_VkPhysicalDeviceLimits::GetmaxGeometryTotalOutputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFragmentInputComponents",
    &_VkPhysicalDeviceLimits::GetmaxFragmentInputComponents,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFragmentOutputAttachments",
    &_VkPhysicalDeviceLimits::GetmaxFragmentOutputAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFragmentDualSrcAttachments",
    &_VkPhysicalDeviceLimits::GetmaxFragmentDualSrcAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFragmentCombinedOutputResources",
    &_VkPhysicalDeviceLimits::GetmaxFragmentCombinedOutputResources,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxComputeSharedMemorySize",
    &_VkPhysicalDeviceLimits::GetmaxComputeSharedMemorySize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxComputeWorkGroupCount",
    &_VkPhysicalDeviceLimits::GetmaxComputeWorkGroupCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxComputeWorkGroupInvocations",
    &_VkPhysicalDeviceLimits::GetmaxComputeWorkGroupInvocations,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxComputeWorkGroupSize",
    &_VkPhysicalDeviceLimits::GetmaxComputeWorkGroupSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "subPixelPrecisionBits",
    &_VkPhysicalDeviceLimits::GetsubPixelPrecisionBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "subTexelPrecisionBits",
    &_VkPhysicalDeviceLimits::GetsubTexelPrecisionBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "mipmapPrecisionBits",
    &_VkPhysicalDeviceLimits::GetmipmapPrecisionBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDrawIndexedIndexValue",
    &_VkPhysicalDeviceLimits::GetmaxDrawIndexedIndexValue,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDrawIndirectCount",
    &_VkPhysicalDeviceLimits::GetmaxDrawIndirectCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSamplerLodBias",
    &_VkPhysicalDeviceLimits::GetmaxSamplerLodBias,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSamplerAnisotropy",
    &_VkPhysicalDeviceLimits::GetmaxSamplerAnisotropy,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxViewports",
    &_VkPhysicalDeviceLimits::GetmaxViewports,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxViewportDimensions",
    &_VkPhysicalDeviceLimits::GetmaxViewportDimensions,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewportBoundsRange",
    &_VkPhysicalDeviceLimits::GetviewportBoundsRange,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewportSubPixelBits",
    &_VkPhysicalDeviceLimits::GetviewportSubPixelBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minMemoryMapAlignment",
    &_VkPhysicalDeviceLimits::GetminMemoryMapAlignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minTexelBufferOffsetAlignment",
    &_VkPhysicalDeviceLimits::GetminTexelBufferOffsetAlignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minUniformBufferOffsetAlignment",
    &_VkPhysicalDeviceLimits::GetminUniformBufferOffsetAlignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minStorageBufferOffsetAlignment",
    &_VkPhysicalDeviceLimits::GetminStorageBufferOffsetAlignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minTexelOffset",
    &_VkPhysicalDeviceLimits::GetminTexelOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTexelOffset",
    &_VkPhysicalDeviceLimits::GetmaxTexelOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minTexelGatherOffset",
    &_VkPhysicalDeviceLimits::GetminTexelGatherOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxTexelGatherOffset",
    &_VkPhysicalDeviceLimits::GetmaxTexelGatherOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minInterpolationOffset",
    &_VkPhysicalDeviceLimits::GetminInterpolationOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxInterpolationOffset",
    &_VkPhysicalDeviceLimits::GetmaxInterpolationOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "subPixelInterpolationOffsetBits",
    &_VkPhysicalDeviceLimits::GetsubPixelInterpolationOffsetBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFramebufferWidth",
    &_VkPhysicalDeviceLimits::GetmaxFramebufferWidth,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFramebufferHeight",
    &_VkPhysicalDeviceLimits::GetmaxFramebufferHeight,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxFramebufferLayers",
    &_VkPhysicalDeviceLimits::GetmaxFramebufferLayers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "framebufferColorSampleCounts",
    &_VkPhysicalDeviceLimits::GetframebufferColorSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "framebufferDepthSampleCounts",
    &_VkPhysicalDeviceLimits::GetframebufferDepthSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "framebufferStencilSampleCounts",
    &_VkPhysicalDeviceLimits::GetframebufferStencilSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "framebufferNoAttachmentsSampleCounts",
    &_VkPhysicalDeviceLimits::GetframebufferNoAttachmentsSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxColorAttachments",
    &_VkPhysicalDeviceLimits::GetmaxColorAttachments,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampledImageColorSampleCounts",
    &_VkPhysicalDeviceLimits::GetsampledImageColorSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampledImageIntegerSampleCounts",
    &_VkPhysicalDeviceLimits::GetsampledImageIntegerSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampledImageDepthSampleCounts",
    &_VkPhysicalDeviceLimits::GetsampledImageDepthSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampledImageStencilSampleCounts",
    &_VkPhysicalDeviceLimits::GetsampledImageStencilSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "storageImageSampleCounts",
    &_VkPhysicalDeviceLimits::GetstorageImageSampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSampleMaskWords",
    &_VkPhysicalDeviceLimits::GetmaxSampleMaskWords,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "timestampComputeAndGraphics",
    &_VkPhysicalDeviceLimits::GettimestampComputeAndGraphics,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "timestampPeriod",
    &_VkPhysicalDeviceLimits::GettimestampPeriod,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxClipDistances",
    &_VkPhysicalDeviceLimits::GetmaxClipDistances,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxCullDistances",
    &_VkPhysicalDeviceLimits::GetmaxCullDistances,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxCombinedClipAndCullDistances",
    &_VkPhysicalDeviceLimits::GetmaxCombinedClipAndCullDistances,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "discreteQueuePriorities",
    &_VkPhysicalDeviceLimits::GetdiscreteQueuePriorities,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "pointSizeRange",
    &_VkPhysicalDeviceLimits::GetpointSizeRange,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "lineWidthRange",
    &_VkPhysicalDeviceLimits::GetlineWidthRange,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "pointSizeGranularity",
    &_VkPhysicalDeviceLimits::GetpointSizeGranularity,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "lineWidthGranularity",
    &_VkPhysicalDeviceLimits::GetlineWidthGranularity,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "strictLines",
    &_VkPhysicalDeviceLimits::GetstrictLines,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "standardSampleLocations",
    &_VkPhysicalDeviceLimits::GetstandardSampleLocations,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "optimalBufferCopyOffsetAlignment",
    &_VkPhysicalDeviceLimits::GetoptimalBufferCopyOffsetAlignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "optimalBufferCopyRowPitchAlignment",
    &_VkPhysicalDeviceLimits::GetoptimalBufferCopyRowPitchAlignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "nonCoherentAtomSize",
    &_VkPhysicalDeviceLimits::GetnonCoherentAtomSize,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceLimits", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceLimits::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceLimits::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxImageDimension1D));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxImageDimension1D);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxImageDimension2D));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxImageDimension2D);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxImageDimension3D));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxImageDimension3D);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxImageDimensionCube));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxImageDimensionCube);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxImageArrayLayers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxImageArrayLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTexelBufferElements));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTexelBufferElements);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxUniformBufferRange));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxUniformBufferRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxStorageBufferRange));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxStorageBufferRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPushConstantsSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPushConstantsSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxMemoryAllocationCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxMemoryAllocationCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxSamplerAllocationCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxSamplerAllocationCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->bufferImageGranularity));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->bufferImageGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->sparseAddressSpaceSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->sparseAddressSpaceSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxBoundDescriptorSets));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxBoundDescriptorSets);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorSamplers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorSamplers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorUniformBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorUniformBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorStorageBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorStorageBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorSampledImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorSampledImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorStorageImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorStorageImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorInputAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageDescriptorInputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxPerStageResources));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxPerStageResources);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetSamplers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetSamplers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetUniformBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetUniformBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetUniformBuffersDynamic));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetUniformBuffersDynamic);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetStorageBuffers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetStorageBuffers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetStorageBuffersDynamic));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetStorageBuffersDynamic);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetSampledImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetSampledImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetStorageImages));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetStorageImages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetInputAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDescriptorSetInputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxVertexInputAttributes));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxVertexInputAttributes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxVertexInputBindings));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxVertexInputBindings);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxVertexInputAttributeOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxVertexInputAttributeOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxVertexInputBindingStride));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxVertexInputBindingStride);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxVertexOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxVertexOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationGenerationLevel));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationGenerationLevel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationPatchSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationPatchSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationControlPerVertexInputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationControlPerVertexInputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationControlPerVertexOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationControlPerVertexOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationControlPerPatchOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationControlPerPatchOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationControlTotalOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationControlTotalOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationEvaluationInputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationEvaluationInputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTessellationEvaluationOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTessellationEvaluationOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxGeometryShaderInvocations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxGeometryShaderInvocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxGeometryInputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxGeometryInputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxGeometryOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxGeometryOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxGeometryOutputVertices));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxGeometryOutputVertices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxGeometryTotalOutputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxGeometryTotalOutputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFragmentInputComponents));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFragmentInputComponents);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFragmentOutputAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFragmentOutputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFragmentDualSrcAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFragmentDualSrcAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFragmentCombinedOutputResources));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFragmentCombinedOutputResources);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxComputeSharedMemorySize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxComputeSharedMemorySize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxComputeWorkGroupCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxComputeWorkGroupCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxComputeWorkGroupInvocations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxComputeWorkGroupInvocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxComputeWorkGroupSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxComputeWorkGroupSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->subPixelPrecisionBits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->subPixelPrecisionBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->subTexelPrecisionBits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->subTexelPrecisionBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->mipmapPrecisionBits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->mipmapPrecisionBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDrawIndexedIndexValue));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDrawIndexedIndexValue);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxDrawIndirectCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxDrawIndirectCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxSamplerLodBias));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxSamplerLodBias);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxSamplerAnisotropy));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxSamplerAnisotropy);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxViewports));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxViewports);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxViewportDimensions));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxViewportDimensions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->viewportBoundsRange));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->viewportBoundsRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->viewportSubPixelBits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->viewportSubPixelBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minMemoryMapAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minMemoryMapAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minTexelBufferOffsetAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minTexelBufferOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minUniformBufferOffsetAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minUniformBufferOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minStorageBufferOffsetAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minStorageBufferOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minTexelOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minTexelOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTexelOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTexelOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minTexelGatherOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minTexelGatherOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxTexelGatherOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxTexelGatherOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->minInterpolationOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->minInterpolationOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxInterpolationOffset));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxInterpolationOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->subPixelInterpolationOffsetBits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->subPixelInterpolationOffsetBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFramebufferWidth));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFramebufferWidth);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFramebufferHeight));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFramebufferHeight);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxFramebufferLayers));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxFramebufferLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->framebufferColorSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->framebufferColorSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->framebufferDepthSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->framebufferDepthSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->framebufferStencilSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->framebufferStencilSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->framebufferNoAttachmentsSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->framebufferNoAttachmentsSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxColorAttachments));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxColorAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->sampledImageColorSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->sampledImageColorSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->sampledImageIntegerSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->sampledImageIntegerSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->sampledImageDepthSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->sampledImageDepthSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->sampledImageStencilSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->sampledImageStencilSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->storageImageSampleCounts));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->storageImageSampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxSampleMaskWords));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxSampleMaskWords);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->timestampComputeAndGraphics));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->timestampComputeAndGraphics);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->timestampPeriod));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->timestampPeriod);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxClipDistances));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxClipDistances);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxCullDistances));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxCullDistances);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->maxCombinedClipAndCullDistances));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->maxCombinedClipAndCullDistances);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->discreteQueuePriorities));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->discreteQueuePriorities);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->pointSizeRange));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->pointSizeRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->lineWidthRange));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->lineWidthRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->pointSizeGranularity));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->pointSizeGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->lineWidthGranularity));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->lineWidthGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->strictLines));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->strictLines);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->standardSampleLocations));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->standardSampleLocations);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->optimalBufferCopyOffsetAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->optimalBufferCopyOffsetAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->optimalBufferCopyRowPitchAlignment));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->optimalBufferCopyRowPitchAlignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceLimits *)0)->nonCoherentAtomSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceLimits *)0)->nonCoherentAtomSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceLimits::flush() {
  _VkPhysicalDeviceLimits *self = this;
  if (!(self->maxComputeWorkGroupCount.IsEmpty())) {
    Napi::Value value = self->maxComputeWorkGroupCount.Value();
    
  }if (!(self->maxComputeWorkGroupSize.IsEmpty())) {
    Napi::Value value = self->maxComputeWorkGroupSize.Value();
    
  }if (!(self->maxViewportDimensions.IsEmpty())) {
    Napi::Value value = self->maxViewportDimensions.Value();
    
  }if (!(self->viewportBoundsRange.IsEmpty())) {
    Napi::Value value = self->viewportBoundsRange.Value();
    
  }if (!(self->pointSizeRange.IsEmpty())) {
    Napi::Value value = self->pointSizeRange.Value();
    
  }if (!(self->lineWidthRange.IsEmpty())) {
    Napi::Value value = self->lineWidthRange.Value();
    
  }
  return true;
}

// maxImageDimension1D
Napi::Value _VkPhysicalDeviceLimits::GetmaxImageDimension1D(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageDimension1D);
}// maxImageDimension2D
Napi::Value _VkPhysicalDeviceLimits::GetmaxImageDimension2D(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageDimension2D);
}// maxImageDimension3D
Napi::Value _VkPhysicalDeviceLimits::GetmaxImageDimension3D(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageDimension3D);
}// maxImageDimensionCube
Napi::Value _VkPhysicalDeviceLimits::GetmaxImageDimensionCube(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageDimensionCube);
}// maxImageArrayLayers
Napi::Value _VkPhysicalDeviceLimits::GetmaxImageArrayLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxImageArrayLayers);
}// maxTexelBufferElements
Napi::Value _VkPhysicalDeviceLimits::GetmaxTexelBufferElements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTexelBufferElements);
}// maxUniformBufferRange
Napi::Value _VkPhysicalDeviceLimits::GetmaxUniformBufferRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxUniformBufferRange);
}// maxStorageBufferRange
Napi::Value _VkPhysicalDeviceLimits::GetmaxStorageBufferRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxStorageBufferRange);
}// maxPushConstantsSize
Napi::Value _VkPhysicalDeviceLimits::GetmaxPushConstantsSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPushConstantsSize);
}// maxMemoryAllocationCount
Napi::Value _VkPhysicalDeviceLimits::GetmaxMemoryAllocationCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMemoryAllocationCount);
}// maxSamplerAllocationCount
Napi::Value _VkPhysicalDeviceLimits::GetmaxSamplerAllocationCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSamplerAllocationCount);
}// bufferImageGranularity
Napi::Value _VkPhysicalDeviceLimits::GetbufferImageGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bufferImageGranularity);
}// sparseAddressSpaceSize
Napi::Value _VkPhysicalDeviceLimits::GetsparseAddressSpaceSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseAddressSpaceSize);
}// maxBoundDescriptorSets
Napi::Value _VkPhysicalDeviceLimits::GetmaxBoundDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxBoundDescriptorSets);
}// maxPerStageDescriptorSamplers
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageDescriptorSamplers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorSamplers);
}// maxPerStageDescriptorUniformBuffers
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageDescriptorUniformBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorUniformBuffers);
}// maxPerStageDescriptorStorageBuffers
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageDescriptorStorageBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorStorageBuffers);
}// maxPerStageDescriptorSampledImages
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageDescriptorSampledImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorSampledImages);
}// maxPerStageDescriptorStorageImages
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageDescriptorStorageImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorStorageImages);
}// maxPerStageDescriptorInputAttachments
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageDescriptorInputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageDescriptorInputAttachments);
}// maxPerStageResources
Napi::Value _VkPhysicalDeviceLimits::GetmaxPerStageResources(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxPerStageResources);
}// maxDescriptorSetSamplers
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetSamplers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetSamplers);
}// maxDescriptorSetUniformBuffers
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetUniformBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUniformBuffers);
}// maxDescriptorSetUniformBuffersDynamic
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetUniformBuffersDynamic(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetUniformBuffersDynamic);
}// maxDescriptorSetStorageBuffers
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetStorageBuffers);
}// maxDescriptorSetStorageBuffersDynamic
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageBuffersDynamic(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetStorageBuffersDynamic);
}// maxDescriptorSetSampledImages
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetSampledImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetSampledImages);
}// maxDescriptorSetStorageImages
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageImages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetStorageImages);
}// maxDescriptorSetInputAttachments
Napi::Value _VkPhysicalDeviceLimits::GetmaxDescriptorSetInputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDescriptorSetInputAttachments);
}// maxVertexInputAttributes
Napi::Value _VkPhysicalDeviceLimits::GetmaxVertexInputAttributes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVertexInputAttributes);
}// maxVertexInputBindings
Napi::Value _VkPhysicalDeviceLimits::GetmaxVertexInputBindings(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVertexInputBindings);
}// maxVertexInputAttributeOffset
Napi::Value _VkPhysicalDeviceLimits::GetmaxVertexInputAttributeOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVertexInputAttributeOffset);
}// maxVertexInputBindingStride
Napi::Value _VkPhysicalDeviceLimits::GetmaxVertexInputBindingStride(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVertexInputBindingStride);
}// maxVertexOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxVertexOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxVertexOutputComponents);
}// maxTessellationGenerationLevel
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationGenerationLevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationGenerationLevel);
}// maxTessellationPatchSize
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationPatchSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationPatchSize);
}// maxTessellationControlPerVertexInputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationControlPerVertexInputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationControlPerVertexInputComponents);
}// maxTessellationControlPerVertexOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationControlPerVertexOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationControlPerVertexOutputComponents);
}// maxTessellationControlPerPatchOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationControlPerPatchOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationControlPerPatchOutputComponents);
}// maxTessellationControlTotalOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationControlTotalOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationControlTotalOutputComponents);
}// maxTessellationEvaluationInputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationEvaluationInputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationEvaluationInputComponents);
}// maxTessellationEvaluationOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxTessellationEvaluationOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTessellationEvaluationOutputComponents);
}// maxGeometryShaderInvocations
Napi::Value _VkPhysicalDeviceLimits::GetmaxGeometryShaderInvocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxGeometryShaderInvocations);
}// maxGeometryInputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxGeometryInputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxGeometryInputComponents);
}// maxGeometryOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxGeometryOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxGeometryOutputComponents);
}// maxGeometryOutputVertices
Napi::Value _VkPhysicalDeviceLimits::GetmaxGeometryOutputVertices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxGeometryOutputVertices);
}// maxGeometryTotalOutputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxGeometryTotalOutputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxGeometryTotalOutputComponents);
}// maxFragmentInputComponents
Napi::Value _VkPhysicalDeviceLimits::GetmaxFragmentInputComponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFragmentInputComponents);
}// maxFragmentOutputAttachments
Napi::Value _VkPhysicalDeviceLimits::GetmaxFragmentOutputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFragmentOutputAttachments);
}// maxFragmentDualSrcAttachments
Napi::Value _VkPhysicalDeviceLimits::GetmaxFragmentDualSrcAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFragmentDualSrcAttachments);
}// maxFragmentCombinedOutputResources
Napi::Value _VkPhysicalDeviceLimits::GetmaxFragmentCombinedOutputResources(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFragmentCombinedOutputResources);
}// maxComputeSharedMemorySize
Napi::Value _VkPhysicalDeviceLimits::GetmaxComputeSharedMemorySize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxComputeSharedMemorySize);
}// maxComputeWorkGroupCount
Napi::Value _VkPhysicalDeviceLimits::GetmaxComputeWorkGroupCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxComputeWorkGroupCount.IsEmpty()) return env.Null();
  return this->maxComputeWorkGroupCount.Value().As<Napi::Array>();
}// maxComputeWorkGroupInvocations
Napi::Value _VkPhysicalDeviceLimits::GetmaxComputeWorkGroupInvocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxComputeWorkGroupInvocations);
}// maxComputeWorkGroupSize
Napi::Value _VkPhysicalDeviceLimits::GetmaxComputeWorkGroupSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxComputeWorkGroupSize.IsEmpty()) return env.Null();
  return this->maxComputeWorkGroupSize.Value().As<Napi::Array>();
}// subPixelPrecisionBits
Napi::Value _VkPhysicalDeviceLimits::GetsubPixelPrecisionBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subPixelPrecisionBits);
}// subTexelPrecisionBits
Napi::Value _VkPhysicalDeviceLimits::GetsubTexelPrecisionBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subTexelPrecisionBits);
}// mipmapPrecisionBits
Napi::Value _VkPhysicalDeviceLimits::GetmipmapPrecisionBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mipmapPrecisionBits);
}// maxDrawIndexedIndexValue
Napi::Value _VkPhysicalDeviceLimits::GetmaxDrawIndexedIndexValue(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDrawIndexedIndexValue);
}// maxDrawIndirectCount
Napi::Value _VkPhysicalDeviceLimits::GetmaxDrawIndirectCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDrawIndirectCount);
}// maxSamplerLodBias
Napi::Value _VkPhysicalDeviceLimits::GetmaxSamplerLodBias(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSamplerLodBias);
}// maxSamplerAnisotropy
Napi::Value _VkPhysicalDeviceLimits::GetmaxSamplerAnisotropy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSamplerAnisotropy);
}// maxViewports
Napi::Value _VkPhysicalDeviceLimits::GetmaxViewports(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxViewports);
}// maxViewportDimensions
Napi::Value _VkPhysicalDeviceLimits::GetmaxViewportDimensions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxViewportDimensions.IsEmpty()) return env.Null();
  return this->maxViewportDimensions.Value().As<Napi::Array>();
}// viewportBoundsRange
Napi::Value _VkPhysicalDeviceLimits::GetviewportBoundsRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->viewportBoundsRange.IsEmpty()) return env.Null();
  return this->viewportBoundsRange.Value().As<Napi::Array>();
}// viewportSubPixelBits
Napi::Value _VkPhysicalDeviceLimits::GetviewportSubPixelBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewportSubPixelBits);
}// minMemoryMapAlignment
Napi::Value _VkPhysicalDeviceLimits::GetminMemoryMapAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minMemoryMapAlignment);
}// minTexelBufferOffsetAlignment
Napi::Value _VkPhysicalDeviceLimits::GetminTexelBufferOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minTexelBufferOffsetAlignment);
}// minUniformBufferOffsetAlignment
Napi::Value _VkPhysicalDeviceLimits::GetminUniformBufferOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minUniformBufferOffsetAlignment);
}// minStorageBufferOffsetAlignment
Napi::Value _VkPhysicalDeviceLimits::GetminStorageBufferOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minStorageBufferOffsetAlignment);
}// minTexelOffset
Napi::Value _VkPhysicalDeviceLimits::GetminTexelOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minTexelOffset);
}// maxTexelOffset
Napi::Value _VkPhysicalDeviceLimits::GetmaxTexelOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTexelOffset);
}// minTexelGatherOffset
Napi::Value _VkPhysicalDeviceLimits::GetminTexelGatherOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minTexelGatherOffset);
}// maxTexelGatherOffset
Napi::Value _VkPhysicalDeviceLimits::GetmaxTexelGatherOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxTexelGatherOffset);
}// minInterpolationOffset
Napi::Value _VkPhysicalDeviceLimits::GetminInterpolationOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minInterpolationOffset);
}// maxInterpolationOffset
Napi::Value _VkPhysicalDeviceLimits::GetmaxInterpolationOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxInterpolationOffset);
}// subPixelInterpolationOffsetBits
Napi::Value _VkPhysicalDeviceLimits::GetsubPixelInterpolationOffsetBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subPixelInterpolationOffsetBits);
}// maxFramebufferWidth
Napi::Value _VkPhysicalDeviceLimits::GetmaxFramebufferWidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFramebufferWidth);
}// maxFramebufferHeight
Napi::Value _VkPhysicalDeviceLimits::GetmaxFramebufferHeight(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFramebufferHeight);
}// maxFramebufferLayers
Napi::Value _VkPhysicalDeviceLimits::GetmaxFramebufferLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxFramebufferLayers);
}// framebufferColorSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetframebufferColorSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.framebufferColorSampleCounts);
}// framebufferDepthSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetframebufferDepthSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.framebufferDepthSampleCounts);
}// framebufferStencilSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetframebufferStencilSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.framebufferStencilSampleCounts);
}// framebufferNoAttachmentsSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetframebufferNoAttachmentsSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.framebufferNoAttachmentsSampleCounts);
}// maxColorAttachments
Napi::Value _VkPhysicalDeviceLimits::GetmaxColorAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxColorAttachments);
}// sampledImageColorSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetsampledImageColorSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampledImageColorSampleCounts);
}// sampledImageIntegerSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetsampledImageIntegerSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampledImageIntegerSampleCounts);
}// sampledImageDepthSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetsampledImageDepthSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampledImageDepthSampleCounts);
}// sampledImageStencilSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetsampledImageStencilSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampledImageStencilSampleCounts);
}// storageImageSampleCounts
Napi::Value _VkPhysicalDeviceLimits::GetstorageImageSampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storageImageSampleCounts);
}// maxSampleMaskWords
Napi::Value _VkPhysicalDeviceLimits::GetmaxSampleMaskWords(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSampleMaskWords);
}// timestampComputeAndGraphics
Napi::Value _VkPhysicalDeviceLimits::GettimestampComputeAndGraphics(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.timestampComputeAndGraphics);
}// timestampPeriod
Napi::Value _VkPhysicalDeviceLimits::GettimestampPeriod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.timestampPeriod);
}// maxClipDistances
Napi::Value _VkPhysicalDeviceLimits::GetmaxClipDistances(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxClipDistances);
}// maxCullDistances
Napi::Value _VkPhysicalDeviceLimits::GetmaxCullDistances(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxCullDistances);
}// maxCombinedClipAndCullDistances
Napi::Value _VkPhysicalDeviceLimits::GetmaxCombinedClipAndCullDistances(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxCombinedClipAndCullDistances);
}// discreteQueuePriorities
Napi::Value _VkPhysicalDeviceLimits::GetdiscreteQueuePriorities(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.discreteQueuePriorities);
}// pointSizeRange
Napi::Value _VkPhysicalDeviceLimits::GetpointSizeRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pointSizeRange.IsEmpty()) return env.Null();
  return this->pointSizeRange.Value().As<Napi::Array>();
}// lineWidthRange
Napi::Value _VkPhysicalDeviceLimits::GetlineWidthRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->lineWidthRange.IsEmpty()) return env.Null();
  return this->lineWidthRange.Value().As<Napi::Array>();
}// pointSizeGranularity
Napi::Value _VkPhysicalDeviceLimits::GetpointSizeGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pointSizeGranularity);
}// lineWidthGranularity
Napi::Value _VkPhysicalDeviceLimits::GetlineWidthGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.lineWidthGranularity);
}// strictLines
Napi::Value _VkPhysicalDeviceLimits::GetstrictLines(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.strictLines);
}// standardSampleLocations
Napi::Value _VkPhysicalDeviceLimits::GetstandardSampleLocations(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.standardSampleLocations);
}// optimalBufferCopyOffsetAlignment
Napi::Value _VkPhysicalDeviceLimits::GetoptimalBufferCopyOffsetAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.optimalBufferCopyOffsetAlignment);
}// optimalBufferCopyRowPitchAlignment
Napi::Value _VkPhysicalDeviceLimits::GetoptimalBufferCopyRowPitchAlignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.optimalBufferCopyRowPitchAlignment);
}// nonCoherentAtomSize
Napi::Value _VkPhysicalDeviceLimits::GetnonCoherentAtomSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.nonCoherentAtomSize);
}
/** ## END VkPhysicalDeviceLimits ## **/

/** ## BEGIN VkPhysicalDeviceSparseProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceSparseProperties::constructor;

_VkPhysicalDeviceSparseProperties::_VkPhysicalDeviceSparseProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceSparseProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceSparseProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceSparseProperties::~_VkPhysicalDeviceSparseProperties() {
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceSparseProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceSparseProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceSparseProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceSparseProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "residencyStandard2DBlockShape",
    &_VkPhysicalDeviceSparseProperties::GetresidencyStandard2DBlockShape,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "residencyStandard2DMultisampleBlockShape",
    &_VkPhysicalDeviceSparseProperties::GetresidencyStandard2DMultisampleBlockShape,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "residencyStandard3DBlockShape",
    &_VkPhysicalDeviceSparseProperties::GetresidencyStandard3DBlockShape,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "residencyAlignedMipSize",
    &_VkPhysicalDeviceSparseProperties::GetresidencyAlignedMipSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "residencyNonResidentStrict",
    &_VkPhysicalDeviceSparseProperties::GetresidencyNonResidentStrict,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceSparseProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceSparseProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceSparseProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseProperties *)0)->residencyStandard2DBlockShape));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseProperties *)0)->residencyStandard2DBlockShape);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseProperties *)0)->residencyStandard2DMultisampleBlockShape));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseProperties *)0)->residencyStandard2DMultisampleBlockShape);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseProperties *)0)->residencyStandard3DBlockShape));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseProperties *)0)->residencyStandard3DBlockShape);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseProperties *)0)->residencyAlignedMipSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseProperties *)0)->residencyAlignedMipSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceSparseProperties *)0)->residencyNonResidentStrict));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceSparseProperties *)0)->residencyNonResidentStrict);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceSparseProperties::flush() {
  _VkPhysicalDeviceSparseProperties *self = this;
  
  return true;
}

// residencyStandard2DBlockShape
Napi::Value _VkPhysicalDeviceSparseProperties::GetresidencyStandard2DBlockShape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.residencyStandard2DBlockShape);
}// residencyStandard2DMultisampleBlockShape
Napi::Value _VkPhysicalDeviceSparseProperties::GetresidencyStandard2DMultisampleBlockShape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.residencyStandard2DMultisampleBlockShape);
}// residencyStandard3DBlockShape
Napi::Value _VkPhysicalDeviceSparseProperties::GetresidencyStandard3DBlockShape(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.residencyStandard3DBlockShape);
}// residencyAlignedMipSize
Napi::Value _VkPhysicalDeviceSparseProperties::GetresidencyAlignedMipSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.residencyAlignedMipSize);
}// residencyNonResidentStrict
Napi::Value _VkPhysicalDeviceSparseProperties::GetresidencyNonResidentStrict(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.residencyNonResidentStrict);
}
/** ## END VkPhysicalDeviceSparseProperties ## **/

/** ## BEGIN VkPhysicalDeviceFeatures ## **/

Napi::FunctionReference _VkPhysicalDeviceFeatures::constructor;

_VkPhysicalDeviceFeatures::_VkPhysicalDeviceFeatures(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceFeatures>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "robustBufferAccess");
      Napi::String sAccess1 = Napi::String::New(env, "fullDrawIndexUint32");
      Napi::String sAccess2 = Napi::String::New(env, "imageCubeArray");
      Napi::String sAccess3 = Napi::String::New(env, "independentBlend");
      Napi::String sAccess4 = Napi::String::New(env, "geometryShader");
      Napi::String sAccess5 = Napi::String::New(env, "tessellationShader");
      Napi::String sAccess6 = Napi::String::New(env, "sampleRateShading");
      Napi::String sAccess7 = Napi::String::New(env, "dualSrcBlend");
      Napi::String sAccess8 = Napi::String::New(env, "logicOp");
      Napi::String sAccess9 = Napi::String::New(env, "multiDrawIndirect");
      Napi::String sAccess10 = Napi::String::New(env, "drawIndirectFirstInstance");
      Napi::String sAccess11 = Napi::String::New(env, "depthClamp");
      Napi::String sAccess12 = Napi::String::New(env, "depthBiasClamp");
      Napi::String sAccess13 = Napi::String::New(env, "fillModeNonSolid");
      Napi::String sAccess14 = Napi::String::New(env, "depthBounds");
      Napi::String sAccess15 = Napi::String::New(env, "wideLines");
      Napi::String sAccess16 = Napi::String::New(env, "largePoints");
      Napi::String sAccess17 = Napi::String::New(env, "alphaToOne");
      Napi::String sAccess18 = Napi::String::New(env, "multiViewport");
      Napi::String sAccess19 = Napi::String::New(env, "samplerAnisotropy");
      Napi::String sAccess20 = Napi::String::New(env, "textureCompressionETC2");
      Napi::String sAccess21 = Napi::String::New(env, "textureCompressionASTC_LDR");
      Napi::String sAccess22 = Napi::String::New(env, "textureCompressionBC");
      Napi::String sAccess23 = Napi::String::New(env, "occlusionQueryPrecise");
      Napi::String sAccess24 = Napi::String::New(env, "pipelineStatisticsQuery");
      Napi::String sAccess25 = Napi::String::New(env, "vertexPipelineStoresAndAtomics");
      Napi::String sAccess26 = Napi::String::New(env, "fragmentStoresAndAtomics");
      Napi::String sAccess27 = Napi::String::New(env, "shaderTessellationAndGeometryPointSize");
      Napi::String sAccess28 = Napi::String::New(env, "shaderImageGatherExtended");
      Napi::String sAccess29 = Napi::String::New(env, "shaderStorageImageExtendedFormats");
      Napi::String sAccess30 = Napi::String::New(env, "shaderStorageImageMultisample");
      Napi::String sAccess31 = Napi::String::New(env, "shaderStorageImageReadWithoutFormat");
      Napi::String sAccess32 = Napi::String::New(env, "shaderStorageImageWriteWithoutFormat");
      Napi::String sAccess33 = Napi::String::New(env, "shaderUniformBufferArrayDynamicIndexing");
      Napi::String sAccess34 = Napi::String::New(env, "shaderSampledImageArrayDynamicIndexing");
      Napi::String sAccess35 = Napi::String::New(env, "shaderStorageBufferArrayDynamicIndexing");
      Napi::String sAccess36 = Napi::String::New(env, "shaderStorageImageArrayDynamicIndexing");
      Napi::String sAccess37 = Napi::String::New(env, "shaderClipDistance");
      Napi::String sAccess38 = Napi::String::New(env, "shaderCullDistance");
      Napi::String sAccess39 = Napi::String::New(env, "shaderFloat64");
      Napi::String sAccess40 = Napi::String::New(env, "shaderInt64");
      Napi::String sAccess41 = Napi::String::New(env, "shaderInt16");
      Napi::String sAccess42 = Napi::String::New(env, "shaderResourceResidency");
      Napi::String sAccess43 = Napi::String::New(env, "shaderResourceMinLod");
      Napi::String sAccess44 = Napi::String::New(env, "sparseBinding");
      Napi::String sAccess45 = Napi::String::New(env, "sparseResidencyBuffer");
      Napi::String sAccess46 = Napi::String::New(env, "sparseResidencyImage2D");
      Napi::String sAccess47 = Napi::String::New(env, "sparseResidencyImage3D");
      Napi::String sAccess48 = Napi::String::New(env, "sparseResidency2Samples");
      Napi::String sAccess49 = Napi::String::New(env, "sparseResidency4Samples");
      Napi::String sAccess50 = Napi::String::New(env, "sparseResidency8Samples");
      Napi::String sAccess51 = Napi::String::New(env, "sparseResidency16Samples");
      Napi::String sAccess52 = Napi::String::New(env, "sparseResidencyAliased");
      Napi::String sAccess53 = Napi::String::New(env, "variableMultisampleRate");
      Napi::String sAccess54 = Napi::String::New(env, "inheritedQueries");
      if (obj.Has(sAccess0)) this->SetrobustBufferAccess(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetfullDrawIndexUint32(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetimageCubeArray(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetindependentBlend(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetgeometryShader(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SettessellationShader(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetsampleRateShading(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdualSrcBlend(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetlogicOp(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetmultiDrawIndirect(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetdrawIndirectFirstInstance(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetdepthClamp(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetdepthBiasClamp(info, obj.Get(sAccess12));
      if (obj.Has(sAccess13)) this->SetfillModeNonSolid(info, obj.Get(sAccess13));
      if (obj.Has(sAccess14)) this->SetdepthBounds(info, obj.Get(sAccess14));
      if (obj.Has(sAccess15)) this->SetwideLines(info, obj.Get(sAccess15));
      if (obj.Has(sAccess16)) this->SetlargePoints(info, obj.Get(sAccess16));
      if (obj.Has(sAccess17)) this->SetalphaToOne(info, obj.Get(sAccess17));
      if (obj.Has(sAccess18)) this->SetmultiViewport(info, obj.Get(sAccess18));
      if (obj.Has(sAccess19)) this->SetsamplerAnisotropy(info, obj.Get(sAccess19));
      if (obj.Has(sAccess20)) this->SettextureCompressionETC2(info, obj.Get(sAccess20));
      if (obj.Has(sAccess21)) this->SettextureCompressionASTC_LDR(info, obj.Get(sAccess21));
      if (obj.Has(sAccess22)) this->SettextureCompressionBC(info, obj.Get(sAccess22));
      if (obj.Has(sAccess23)) this->SetocclusionQueryPrecise(info, obj.Get(sAccess23));
      if (obj.Has(sAccess24)) this->SetpipelineStatisticsQuery(info, obj.Get(sAccess24));
      if (obj.Has(sAccess25)) this->SetvertexPipelineStoresAndAtomics(info, obj.Get(sAccess25));
      if (obj.Has(sAccess26)) this->SetfragmentStoresAndAtomics(info, obj.Get(sAccess26));
      if (obj.Has(sAccess27)) this->SetshaderTessellationAndGeometryPointSize(info, obj.Get(sAccess27));
      if (obj.Has(sAccess28)) this->SetshaderImageGatherExtended(info, obj.Get(sAccess28));
      if (obj.Has(sAccess29)) this->SetshaderStorageImageExtendedFormats(info, obj.Get(sAccess29));
      if (obj.Has(sAccess30)) this->SetshaderStorageImageMultisample(info, obj.Get(sAccess30));
      if (obj.Has(sAccess31)) this->SetshaderStorageImageReadWithoutFormat(info, obj.Get(sAccess31));
      if (obj.Has(sAccess32)) this->SetshaderStorageImageWriteWithoutFormat(info, obj.Get(sAccess32));
      if (obj.Has(sAccess33)) this->SetshaderUniformBufferArrayDynamicIndexing(info, obj.Get(sAccess33));
      if (obj.Has(sAccess34)) this->SetshaderSampledImageArrayDynamicIndexing(info, obj.Get(sAccess34));
      if (obj.Has(sAccess35)) this->SetshaderStorageBufferArrayDynamicIndexing(info, obj.Get(sAccess35));
      if (obj.Has(sAccess36)) this->SetshaderStorageImageArrayDynamicIndexing(info, obj.Get(sAccess36));
      if (obj.Has(sAccess37)) this->SetshaderClipDistance(info, obj.Get(sAccess37));
      if (obj.Has(sAccess38)) this->SetshaderCullDistance(info, obj.Get(sAccess38));
      if (obj.Has(sAccess39)) this->SetshaderFloat64(info, obj.Get(sAccess39));
      if (obj.Has(sAccess40)) this->SetshaderInt64(info, obj.Get(sAccess40));
      if (obj.Has(sAccess41)) this->SetshaderInt16(info, obj.Get(sAccess41));
      if (obj.Has(sAccess42)) this->SetshaderResourceResidency(info, obj.Get(sAccess42));
      if (obj.Has(sAccess43)) this->SetshaderResourceMinLod(info, obj.Get(sAccess43));
      if (obj.Has(sAccess44)) this->SetsparseBinding(info, obj.Get(sAccess44));
      if (obj.Has(sAccess45)) this->SetsparseResidencyBuffer(info, obj.Get(sAccess45));
      if (obj.Has(sAccess46)) this->SetsparseResidencyImage2D(info, obj.Get(sAccess46));
      if (obj.Has(sAccess47)) this->SetsparseResidencyImage3D(info, obj.Get(sAccess47));
      if (obj.Has(sAccess48)) this->SetsparseResidency2Samples(info, obj.Get(sAccess48));
      if (obj.Has(sAccess49)) this->SetsparseResidency4Samples(info, obj.Get(sAccess49));
      if (obj.Has(sAccess50)) this->SetsparseResidency8Samples(info, obj.Get(sAccess50));
      if (obj.Has(sAccess51)) this->SetsparseResidency16Samples(info, obj.Get(sAccess51));
      if (obj.Has(sAccess52)) this->SetsparseResidencyAliased(info, obj.Get(sAccess52));
      if (obj.Has(sAccess53)) this->SetvariableMultisampleRate(info, obj.Get(sAccess53));
      if (obj.Has(sAccess54)) this->SetinheritedQueries(info, obj.Get(sAccess54));
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceFeatures constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceFeatures::~_VkPhysicalDeviceFeatures() {
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPhysicalDeviceFeatures::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceFeatures", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceFeatures::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceFeatures::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "robustBufferAccess",
    &_VkPhysicalDeviceFeatures::GetrobustBufferAccess,
    &_VkPhysicalDeviceFeatures::SetrobustBufferAccess,
    napi_enumerable
  ),
  InstanceAccessor(
    "fullDrawIndexUint32",
    &_VkPhysicalDeviceFeatures::GetfullDrawIndexUint32,
    &_VkPhysicalDeviceFeatures::SetfullDrawIndexUint32,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageCubeArray",
    &_VkPhysicalDeviceFeatures::GetimageCubeArray,
    &_VkPhysicalDeviceFeatures::SetimageCubeArray,
    napi_enumerable
  ),
  InstanceAccessor(
    "independentBlend",
    &_VkPhysicalDeviceFeatures::GetindependentBlend,
    &_VkPhysicalDeviceFeatures::SetindependentBlend,
    napi_enumerable
  ),
  InstanceAccessor(
    "geometryShader",
    &_VkPhysicalDeviceFeatures::GetgeometryShader,
    &_VkPhysicalDeviceFeatures::SetgeometryShader,
    napi_enumerable
  ),
  InstanceAccessor(
    "tessellationShader",
    &_VkPhysicalDeviceFeatures::GettessellationShader,
    &_VkPhysicalDeviceFeatures::SettessellationShader,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleRateShading",
    &_VkPhysicalDeviceFeatures::GetsampleRateShading,
    &_VkPhysicalDeviceFeatures::SetsampleRateShading,
    napi_enumerable
  ),
  InstanceAccessor(
    "dualSrcBlend",
    &_VkPhysicalDeviceFeatures::GetdualSrcBlend,
    &_VkPhysicalDeviceFeatures::SetdualSrcBlend,
    napi_enumerable
  ),
  InstanceAccessor(
    "logicOp",
    &_VkPhysicalDeviceFeatures::GetlogicOp,
    &_VkPhysicalDeviceFeatures::SetlogicOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiDrawIndirect",
    &_VkPhysicalDeviceFeatures::GetmultiDrawIndirect,
    &_VkPhysicalDeviceFeatures::SetmultiDrawIndirect,
    napi_enumerable
  ),
  InstanceAccessor(
    "drawIndirectFirstInstance",
    &_VkPhysicalDeviceFeatures::GetdrawIndirectFirstInstance,
    &_VkPhysicalDeviceFeatures::SetdrawIndirectFirstInstance,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthClamp",
    &_VkPhysicalDeviceFeatures::GetdepthClamp,
    &_VkPhysicalDeviceFeatures::SetdepthClamp,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBiasClamp",
    &_VkPhysicalDeviceFeatures::GetdepthBiasClamp,
    &_VkPhysicalDeviceFeatures::SetdepthBiasClamp,
    napi_enumerable
  ),
  InstanceAccessor(
    "fillModeNonSolid",
    &_VkPhysicalDeviceFeatures::GetfillModeNonSolid,
    &_VkPhysicalDeviceFeatures::SetfillModeNonSolid,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBounds",
    &_VkPhysicalDeviceFeatures::GetdepthBounds,
    &_VkPhysicalDeviceFeatures::SetdepthBounds,
    napi_enumerable
  ),
  InstanceAccessor(
    "wideLines",
    &_VkPhysicalDeviceFeatures::GetwideLines,
    &_VkPhysicalDeviceFeatures::SetwideLines,
    napi_enumerable
  ),
  InstanceAccessor(
    "largePoints",
    &_VkPhysicalDeviceFeatures::GetlargePoints,
    &_VkPhysicalDeviceFeatures::SetlargePoints,
    napi_enumerable
  ),
  InstanceAccessor(
    "alphaToOne",
    &_VkPhysicalDeviceFeatures::GetalphaToOne,
    &_VkPhysicalDeviceFeatures::SetalphaToOne,
    napi_enumerable
  ),
  InstanceAccessor(
    "multiViewport",
    &_VkPhysicalDeviceFeatures::GetmultiViewport,
    &_VkPhysicalDeviceFeatures::SetmultiViewport,
    napi_enumerable
  ),
  InstanceAccessor(
    "samplerAnisotropy",
    &_VkPhysicalDeviceFeatures::GetsamplerAnisotropy,
    &_VkPhysicalDeviceFeatures::SetsamplerAnisotropy,
    napi_enumerable
  ),
  InstanceAccessor(
    "textureCompressionETC2",
    &_VkPhysicalDeviceFeatures::GettextureCompressionETC2,
    &_VkPhysicalDeviceFeatures::SettextureCompressionETC2,
    napi_enumerable
  ),
  InstanceAccessor(
    "textureCompressionASTC_LDR",
    &_VkPhysicalDeviceFeatures::GettextureCompressionASTC_LDR,
    &_VkPhysicalDeviceFeatures::SettextureCompressionASTC_LDR,
    napi_enumerable
  ),
  InstanceAccessor(
    "textureCompressionBC",
    &_VkPhysicalDeviceFeatures::GettextureCompressionBC,
    &_VkPhysicalDeviceFeatures::SettextureCompressionBC,
    napi_enumerable
  ),
  InstanceAccessor(
    "occlusionQueryPrecise",
    &_VkPhysicalDeviceFeatures::GetocclusionQueryPrecise,
    &_VkPhysicalDeviceFeatures::SetocclusionQueryPrecise,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineStatisticsQuery",
    &_VkPhysicalDeviceFeatures::GetpipelineStatisticsQuery,
    &_VkPhysicalDeviceFeatures::SetpipelineStatisticsQuery,
    napi_enumerable
  ),
  InstanceAccessor(
    "vertexPipelineStoresAndAtomics",
    &_VkPhysicalDeviceFeatures::GetvertexPipelineStoresAndAtomics,
    &_VkPhysicalDeviceFeatures::SetvertexPipelineStoresAndAtomics,
    napi_enumerable
  ),
  InstanceAccessor(
    "fragmentStoresAndAtomics",
    &_VkPhysicalDeviceFeatures::GetfragmentStoresAndAtomics,
    &_VkPhysicalDeviceFeatures::SetfragmentStoresAndAtomics,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderTessellationAndGeometryPointSize",
    &_VkPhysicalDeviceFeatures::GetshaderTessellationAndGeometryPointSize,
    &_VkPhysicalDeviceFeatures::SetshaderTessellationAndGeometryPointSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderImageGatherExtended",
    &_VkPhysicalDeviceFeatures::GetshaderImageGatherExtended,
    &_VkPhysicalDeviceFeatures::SetshaderImageGatherExtended,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageExtendedFormats",
    &_VkPhysicalDeviceFeatures::GetshaderStorageImageExtendedFormats,
    &_VkPhysicalDeviceFeatures::SetshaderStorageImageExtendedFormats,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageMultisample",
    &_VkPhysicalDeviceFeatures::GetshaderStorageImageMultisample,
    &_VkPhysicalDeviceFeatures::SetshaderStorageImageMultisample,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageReadWithoutFormat",
    &_VkPhysicalDeviceFeatures::GetshaderStorageImageReadWithoutFormat,
    &_VkPhysicalDeviceFeatures::SetshaderStorageImageReadWithoutFormat,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageWriteWithoutFormat",
    &_VkPhysicalDeviceFeatures::GetshaderStorageImageWriteWithoutFormat,
    &_VkPhysicalDeviceFeatures::SetshaderStorageImageWriteWithoutFormat,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderUniformBufferArrayDynamicIndexing",
    &_VkPhysicalDeviceFeatures::GetshaderUniformBufferArrayDynamicIndexing,
    &_VkPhysicalDeviceFeatures::SetshaderUniformBufferArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderSampledImageArrayDynamicIndexing",
    &_VkPhysicalDeviceFeatures::GetshaderSampledImageArrayDynamicIndexing,
    &_VkPhysicalDeviceFeatures::SetshaderSampledImageArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageBufferArrayDynamicIndexing",
    &_VkPhysicalDeviceFeatures::GetshaderStorageBufferArrayDynamicIndexing,
    &_VkPhysicalDeviceFeatures::SetshaderStorageBufferArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderStorageImageArrayDynamicIndexing",
    &_VkPhysicalDeviceFeatures::GetshaderStorageImageArrayDynamicIndexing,
    &_VkPhysicalDeviceFeatures::SetshaderStorageImageArrayDynamicIndexing,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderClipDistance",
    &_VkPhysicalDeviceFeatures::GetshaderClipDistance,
    &_VkPhysicalDeviceFeatures::SetshaderClipDistance,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderCullDistance",
    &_VkPhysicalDeviceFeatures::GetshaderCullDistance,
    &_VkPhysicalDeviceFeatures::SetshaderCullDistance,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderFloat64",
    &_VkPhysicalDeviceFeatures::GetshaderFloat64,
    &_VkPhysicalDeviceFeatures::SetshaderFloat64,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderInt64",
    &_VkPhysicalDeviceFeatures::GetshaderInt64,
    &_VkPhysicalDeviceFeatures::SetshaderInt64,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderInt16",
    &_VkPhysicalDeviceFeatures::GetshaderInt16,
    &_VkPhysicalDeviceFeatures::SetshaderInt16,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderResourceResidency",
    &_VkPhysicalDeviceFeatures::GetshaderResourceResidency,
    &_VkPhysicalDeviceFeatures::SetshaderResourceResidency,
    napi_enumerable
  ),
  InstanceAccessor(
    "shaderResourceMinLod",
    &_VkPhysicalDeviceFeatures::GetshaderResourceMinLod,
    &_VkPhysicalDeviceFeatures::SetshaderResourceMinLod,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseBinding",
    &_VkPhysicalDeviceFeatures::GetsparseBinding,
    &_VkPhysicalDeviceFeatures::SetsparseBinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidencyBuffer",
    &_VkPhysicalDeviceFeatures::GetsparseResidencyBuffer,
    &_VkPhysicalDeviceFeatures::SetsparseResidencyBuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidencyImage2D",
    &_VkPhysicalDeviceFeatures::GetsparseResidencyImage2D,
    &_VkPhysicalDeviceFeatures::SetsparseResidencyImage2D,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidencyImage3D",
    &_VkPhysicalDeviceFeatures::GetsparseResidencyImage3D,
    &_VkPhysicalDeviceFeatures::SetsparseResidencyImage3D,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidency2Samples",
    &_VkPhysicalDeviceFeatures::GetsparseResidency2Samples,
    &_VkPhysicalDeviceFeatures::SetsparseResidency2Samples,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidency4Samples",
    &_VkPhysicalDeviceFeatures::GetsparseResidency4Samples,
    &_VkPhysicalDeviceFeatures::SetsparseResidency4Samples,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidency8Samples",
    &_VkPhysicalDeviceFeatures::GetsparseResidency8Samples,
    &_VkPhysicalDeviceFeatures::SetsparseResidency8Samples,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidency16Samples",
    &_VkPhysicalDeviceFeatures::GetsparseResidency16Samples,
    &_VkPhysicalDeviceFeatures::SetsparseResidency16Samples,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseResidencyAliased",
    &_VkPhysicalDeviceFeatures::GetsparseResidencyAliased,
    &_VkPhysicalDeviceFeatures::SetsparseResidencyAliased,
    napi_enumerable
  ),
  InstanceAccessor(
    "variableMultisampleRate",
    &_VkPhysicalDeviceFeatures::GetvariableMultisampleRate,
    &_VkPhysicalDeviceFeatures::SetvariableMultisampleRate,
    napi_enumerable
  ),
  InstanceAccessor(
    "inheritedQueries",
    &_VkPhysicalDeviceFeatures::GetinheritedQueries,
    &_VkPhysicalDeviceFeatures::SetinheritedQueries,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceFeatures", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceFeatures::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceFeatures::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->robustBufferAccess));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->robustBufferAccess);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->fullDrawIndexUint32));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->fullDrawIndexUint32);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->imageCubeArray));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->imageCubeArray);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->independentBlend));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->independentBlend);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->geometryShader));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->geometryShader);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->tessellationShader));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->tessellationShader);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sampleRateShading));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sampleRateShading);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->dualSrcBlend));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->dualSrcBlend);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->logicOp));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->logicOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->multiDrawIndirect));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->multiDrawIndirect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->drawIndirectFirstInstance));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->drawIndirectFirstInstance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->depthClamp));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->depthClamp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->depthBiasClamp));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->depthBiasClamp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->fillModeNonSolid));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->fillModeNonSolid);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->depthBounds));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->depthBounds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->wideLines));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->wideLines);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->largePoints));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->largePoints);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->alphaToOne));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->alphaToOne);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->multiViewport));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->multiViewport);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->samplerAnisotropy));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->samplerAnisotropy);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->textureCompressionETC2));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->textureCompressionETC2);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->textureCompressionASTC_LDR));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->textureCompressionASTC_LDR);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->textureCompressionBC));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->textureCompressionBC);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->occlusionQueryPrecise));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->occlusionQueryPrecise);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->pipelineStatisticsQuery));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->pipelineStatisticsQuery);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->vertexPipelineStoresAndAtomics));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->vertexPipelineStoresAndAtomics);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->fragmentStoresAndAtomics));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->fragmentStoresAndAtomics);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderTessellationAndGeometryPointSize));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderTessellationAndGeometryPointSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderImageGatherExtended));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderImageGatherExtended);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageExtendedFormats));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageExtendedFormats);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageMultisample));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageMultisample);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageReadWithoutFormat));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageReadWithoutFormat);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageWriteWithoutFormat));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageWriteWithoutFormat);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderUniformBufferArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderUniformBufferArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderSampledImageArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderSampledImageArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderStorageBufferArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderStorageBufferArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageArrayDynamicIndexing));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderStorageImageArrayDynamicIndexing);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderClipDistance));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderClipDistance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderCullDistance));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderCullDistance);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderFloat64));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderFloat64);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderInt64));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderInt64);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderInt16));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderInt16);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderResourceResidency));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderResourceResidency);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->shaderResourceMinLod));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->shaderResourceMinLod);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseBinding));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseBinding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidencyBuffer));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidencyBuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidencyImage2D));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidencyImage2D);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidencyImage3D));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidencyImage3D);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidency2Samples));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidency2Samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidency4Samples));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidency4Samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidency8Samples));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidency8Samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidency16Samples));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidency16Samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->sparseResidencyAliased));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->sparseResidencyAliased);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->variableMultisampleRate));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->variableMultisampleRate);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceFeatures *)0)->inheritedQueries));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceFeatures *)0)->inheritedQueries);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceFeatures::flush() {
  _VkPhysicalDeviceFeatures *self = this;
  
  return true;
}

// robustBufferAccess
Napi::Value _VkPhysicalDeviceFeatures::GetrobustBufferAccess(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.robustBufferAccess);
}void _VkPhysicalDeviceFeatures::SetrobustBufferAccess(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.robustBufferAccess = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.robustBufferAccess = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.robustBufferAccess", "Number");
  
    return;
  }
}// fullDrawIndexUint32
Napi::Value _VkPhysicalDeviceFeatures::GetfullDrawIndexUint32(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fullDrawIndexUint32);
}void _VkPhysicalDeviceFeatures::SetfullDrawIndexUint32(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.fullDrawIndexUint32 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.fullDrawIndexUint32 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.fullDrawIndexUint32", "Number");
  
    return;
  }
}// imageCubeArray
Napi::Value _VkPhysicalDeviceFeatures::GetimageCubeArray(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageCubeArray);
}void _VkPhysicalDeviceFeatures::SetimageCubeArray(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.imageCubeArray = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.imageCubeArray = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.imageCubeArray", "Number");
  
    return;
  }
}// independentBlend
Napi::Value _VkPhysicalDeviceFeatures::GetindependentBlend(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.independentBlend);
}void _VkPhysicalDeviceFeatures::SetindependentBlend(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.independentBlend = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.independentBlend = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.independentBlend", "Number");
  
    return;
  }
}// geometryShader
Napi::Value _VkPhysicalDeviceFeatures::GetgeometryShader(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.geometryShader);
}void _VkPhysicalDeviceFeatures::SetgeometryShader(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.geometryShader = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.geometryShader = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.geometryShader", "Number");
  
    return;
  }
}// tessellationShader
Napi::Value _VkPhysicalDeviceFeatures::GettessellationShader(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tessellationShader);
}void _VkPhysicalDeviceFeatures::SettessellationShader(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.tessellationShader = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.tessellationShader = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.tessellationShader", "Number");
  
    return;
  }
}// sampleRateShading
Napi::Value _VkPhysicalDeviceFeatures::GetsampleRateShading(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleRateShading);
}void _VkPhysicalDeviceFeatures::SetsampleRateShading(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sampleRateShading = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sampleRateShading = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sampleRateShading", "Number");
  
    return;
  }
}// dualSrcBlend
Napi::Value _VkPhysicalDeviceFeatures::GetdualSrcBlend(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dualSrcBlend);
}void _VkPhysicalDeviceFeatures::SetdualSrcBlend(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.dualSrcBlend = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.dualSrcBlend = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.dualSrcBlend", "Number");
  
    return;
  }
}// logicOp
Napi::Value _VkPhysicalDeviceFeatures::GetlogicOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.logicOp);
}void _VkPhysicalDeviceFeatures::SetlogicOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.logicOp = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.logicOp = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.logicOp", "Number");
  
    return;
  }
}// multiDrawIndirect
Napi::Value _VkPhysicalDeviceFeatures::GetmultiDrawIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiDrawIndirect);
}void _VkPhysicalDeviceFeatures::SetmultiDrawIndirect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiDrawIndirect = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiDrawIndirect = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.multiDrawIndirect", "Number");
  
    return;
  }
}// drawIndirectFirstInstance
Napi::Value _VkPhysicalDeviceFeatures::GetdrawIndirectFirstInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.drawIndirectFirstInstance);
}void _VkPhysicalDeviceFeatures::SetdrawIndirectFirstInstance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.drawIndirectFirstInstance = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.drawIndirectFirstInstance = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.drawIndirectFirstInstance", "Number");
  
    return;
  }
}// depthClamp
Napi::Value _VkPhysicalDeviceFeatures::GetdepthClamp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthClamp);
}void _VkPhysicalDeviceFeatures::SetdepthClamp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthClamp = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthClamp = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.depthClamp", "Number");
  
    return;
  }
}// depthBiasClamp
Napi::Value _VkPhysicalDeviceFeatures::GetdepthBiasClamp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBiasClamp);
}void _VkPhysicalDeviceFeatures::SetdepthBiasClamp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthBiasClamp = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthBiasClamp = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.depthBiasClamp", "Number");
  
    return;
  }
}// fillModeNonSolid
Napi::Value _VkPhysicalDeviceFeatures::GetfillModeNonSolid(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fillModeNonSolid);
}void _VkPhysicalDeviceFeatures::SetfillModeNonSolid(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.fillModeNonSolid = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.fillModeNonSolid = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.fillModeNonSolid", "Number");
  
    return;
  }
}// depthBounds
Napi::Value _VkPhysicalDeviceFeatures::GetdepthBounds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBounds);
}void _VkPhysicalDeviceFeatures::SetdepthBounds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthBounds = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthBounds = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.depthBounds", "Number");
  
    return;
  }
}// wideLines
Napi::Value _VkPhysicalDeviceFeatures::GetwideLines(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.wideLines);
}void _VkPhysicalDeviceFeatures::SetwideLines(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.wideLines = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.wideLines = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.wideLines", "Number");
  
    return;
  }
}// largePoints
Napi::Value _VkPhysicalDeviceFeatures::GetlargePoints(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.largePoints);
}void _VkPhysicalDeviceFeatures::SetlargePoints(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.largePoints = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.largePoints = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.largePoints", "Number");
  
    return;
  }
}// alphaToOne
Napi::Value _VkPhysicalDeviceFeatures::GetalphaToOne(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.alphaToOne);
}void _VkPhysicalDeviceFeatures::SetalphaToOne(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.alphaToOne = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.alphaToOne = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.alphaToOne", "Number");
  
    return;
  }
}// multiViewport
Napi::Value _VkPhysicalDeviceFeatures::GetmultiViewport(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.multiViewport);
}void _VkPhysicalDeviceFeatures::SetmultiViewport(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.multiViewport = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.multiViewport = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.multiViewport", "Number");
  
    return;
  }
}// samplerAnisotropy
Napi::Value _VkPhysicalDeviceFeatures::GetsamplerAnisotropy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samplerAnisotropy);
}void _VkPhysicalDeviceFeatures::SetsamplerAnisotropy(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.samplerAnisotropy = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.samplerAnisotropy = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.samplerAnisotropy", "Number");
  
    return;
  }
}// textureCompressionETC2
Napi::Value _VkPhysicalDeviceFeatures::GettextureCompressionETC2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.textureCompressionETC2);
}void _VkPhysicalDeviceFeatures::SettextureCompressionETC2(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.textureCompressionETC2 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.textureCompressionETC2 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.textureCompressionETC2", "Number");
  
    return;
  }
}// textureCompressionASTC_LDR
Napi::Value _VkPhysicalDeviceFeatures::GettextureCompressionASTC_LDR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.textureCompressionASTC_LDR);
}void _VkPhysicalDeviceFeatures::SettextureCompressionASTC_LDR(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.textureCompressionASTC_LDR = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.textureCompressionASTC_LDR = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.textureCompressionASTC_LDR", "Number");
  
    return;
  }
}// textureCompressionBC
Napi::Value _VkPhysicalDeviceFeatures::GettextureCompressionBC(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.textureCompressionBC);
}void _VkPhysicalDeviceFeatures::SettextureCompressionBC(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.textureCompressionBC = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.textureCompressionBC = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.textureCompressionBC", "Number");
  
    return;
  }
}// occlusionQueryPrecise
Napi::Value _VkPhysicalDeviceFeatures::GetocclusionQueryPrecise(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.occlusionQueryPrecise);
}void _VkPhysicalDeviceFeatures::SetocclusionQueryPrecise(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.occlusionQueryPrecise = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.occlusionQueryPrecise = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.occlusionQueryPrecise", "Number");
  
    return;
  }
}// pipelineStatisticsQuery
Napi::Value _VkPhysicalDeviceFeatures::GetpipelineStatisticsQuery(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineStatisticsQuery);
}void _VkPhysicalDeviceFeatures::SetpipelineStatisticsQuery(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.pipelineStatisticsQuery = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.pipelineStatisticsQuery = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.pipelineStatisticsQuery", "Number");
  
    return;
  }
}// vertexPipelineStoresAndAtomics
Napi::Value _VkPhysicalDeviceFeatures::GetvertexPipelineStoresAndAtomics(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vertexPipelineStoresAndAtomics);
}void _VkPhysicalDeviceFeatures::SetvertexPipelineStoresAndAtomics(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.vertexPipelineStoresAndAtomics = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.vertexPipelineStoresAndAtomics = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.vertexPipelineStoresAndAtomics", "Number");
  
    return;
  }
}// fragmentStoresAndAtomics
Napi::Value _VkPhysicalDeviceFeatures::GetfragmentStoresAndAtomics(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.fragmentStoresAndAtomics);
}void _VkPhysicalDeviceFeatures::SetfragmentStoresAndAtomics(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.fragmentStoresAndAtomics = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.fragmentStoresAndAtomics = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.fragmentStoresAndAtomics", "Number");
  
    return;
  }
}// shaderTessellationAndGeometryPointSize
Napi::Value _VkPhysicalDeviceFeatures::GetshaderTessellationAndGeometryPointSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderTessellationAndGeometryPointSize);
}void _VkPhysicalDeviceFeatures::SetshaderTessellationAndGeometryPointSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderTessellationAndGeometryPointSize = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderTessellationAndGeometryPointSize = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderTessellationAndGeometryPointSize", "Number");
  
    return;
  }
}// shaderImageGatherExtended
Napi::Value _VkPhysicalDeviceFeatures::GetshaderImageGatherExtended(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderImageGatherExtended);
}void _VkPhysicalDeviceFeatures::SetshaderImageGatherExtended(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderImageGatherExtended = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderImageGatherExtended = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderImageGatherExtended", "Number");
  
    return;
  }
}// shaderStorageImageExtendedFormats
Napi::Value _VkPhysicalDeviceFeatures::GetshaderStorageImageExtendedFormats(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageExtendedFormats);
}void _VkPhysicalDeviceFeatures::SetshaderStorageImageExtendedFormats(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageImageExtendedFormats = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageImageExtendedFormats = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageExtendedFormats", "Number");
  
    return;
  }
}// shaderStorageImageMultisample
Napi::Value _VkPhysicalDeviceFeatures::GetshaderStorageImageMultisample(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageMultisample);
}void _VkPhysicalDeviceFeatures::SetshaderStorageImageMultisample(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageImageMultisample = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageImageMultisample = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageMultisample", "Number");
  
    return;
  }
}// shaderStorageImageReadWithoutFormat
Napi::Value _VkPhysicalDeviceFeatures::GetshaderStorageImageReadWithoutFormat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageReadWithoutFormat);
}void _VkPhysicalDeviceFeatures::SetshaderStorageImageReadWithoutFormat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageImageReadWithoutFormat = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageImageReadWithoutFormat = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageReadWithoutFormat", "Number");
  
    return;
  }
}// shaderStorageImageWriteWithoutFormat
Napi::Value _VkPhysicalDeviceFeatures::GetshaderStorageImageWriteWithoutFormat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageWriteWithoutFormat);
}void _VkPhysicalDeviceFeatures::SetshaderStorageImageWriteWithoutFormat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageImageWriteWithoutFormat = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageImageWriteWithoutFormat = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageWriteWithoutFormat", "Number");
  
    return;
  }
}// shaderUniformBufferArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceFeatures::GetshaderUniformBufferArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderUniformBufferArrayDynamicIndexing);
}void _VkPhysicalDeviceFeatures::SetshaderUniformBufferArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderUniformBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderUniformBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderUniformBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderSampledImageArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceFeatures::GetshaderSampledImageArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderSampledImageArrayDynamicIndexing);
}void _VkPhysicalDeviceFeatures::SetshaderSampledImageArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderSampledImageArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderSampledImageArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderSampledImageArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderStorageBufferArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceFeatures::GetshaderStorageBufferArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageBufferArrayDynamicIndexing);
}void _VkPhysicalDeviceFeatures::SetshaderStorageBufferArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageBufferArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderStorageImageArrayDynamicIndexing
Napi::Value _VkPhysicalDeviceFeatures::GetshaderStorageImageArrayDynamicIndexing(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderStorageImageArrayDynamicIndexing);
}void _VkPhysicalDeviceFeatures::SetshaderStorageImageArrayDynamicIndexing(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderStorageImageArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderStorageImageArrayDynamicIndexing = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderClipDistance
Napi::Value _VkPhysicalDeviceFeatures::GetshaderClipDistance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderClipDistance);
}void _VkPhysicalDeviceFeatures::SetshaderClipDistance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderClipDistance = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderClipDistance = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderClipDistance", "Number");
  
    return;
  }
}// shaderCullDistance
Napi::Value _VkPhysicalDeviceFeatures::GetshaderCullDistance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderCullDistance);
}void _VkPhysicalDeviceFeatures::SetshaderCullDistance(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderCullDistance = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderCullDistance = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderCullDistance", "Number");
  
    return;
  }
}// shaderFloat64
Napi::Value _VkPhysicalDeviceFeatures::GetshaderFloat64(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderFloat64);
}void _VkPhysicalDeviceFeatures::SetshaderFloat64(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderFloat64 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderFloat64 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderFloat64", "Number");
  
    return;
  }
}// shaderInt64
Napi::Value _VkPhysicalDeviceFeatures::GetshaderInt64(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderInt64);
}void _VkPhysicalDeviceFeatures::SetshaderInt64(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderInt64 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderInt64 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderInt64", "Number");
  
    return;
  }
}// shaderInt16
Napi::Value _VkPhysicalDeviceFeatures::GetshaderInt16(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderInt16);
}void _VkPhysicalDeviceFeatures::SetshaderInt16(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderInt16 = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderInt16 = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderInt16", "Number");
  
    return;
  }
}// shaderResourceResidency
Napi::Value _VkPhysicalDeviceFeatures::GetshaderResourceResidency(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderResourceResidency);
}void _VkPhysicalDeviceFeatures::SetshaderResourceResidency(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderResourceResidency = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderResourceResidency = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderResourceResidency", "Number");
  
    return;
  }
}// shaderResourceMinLod
Napi::Value _VkPhysicalDeviceFeatures::GetshaderResourceMinLod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.shaderResourceMinLod);
}void _VkPhysicalDeviceFeatures::SetshaderResourceMinLod(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.shaderResourceMinLod = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.shaderResourceMinLod = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.shaderResourceMinLod", "Number");
  
    return;
  }
}// sparseBinding
Napi::Value _VkPhysicalDeviceFeatures::GetsparseBinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseBinding);
}void _VkPhysicalDeviceFeatures::SetsparseBinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseBinding = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseBinding = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseBinding", "Number");
  
    return;
  }
}// sparseResidencyBuffer
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidencyBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidencyBuffer);
}void _VkPhysicalDeviceFeatures::SetsparseResidencyBuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidencyBuffer = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidencyBuffer = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyBuffer", "Number");
  
    return;
  }
}// sparseResidencyImage2D
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidencyImage2D(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidencyImage2D);
}void _VkPhysicalDeviceFeatures::SetsparseResidencyImage2D(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidencyImage2D = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidencyImage2D = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyImage2D", "Number");
  
    return;
  }
}// sparseResidencyImage3D
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidencyImage3D(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidencyImage3D);
}void _VkPhysicalDeviceFeatures::SetsparseResidencyImage3D(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidencyImage3D = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidencyImage3D = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyImage3D", "Number");
  
    return;
  }
}// sparseResidency2Samples
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidency2Samples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidency2Samples);
}void _VkPhysicalDeviceFeatures::SetsparseResidency2Samples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidency2Samples = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidency2Samples = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency2Samples", "Number");
  
    return;
  }
}// sparseResidency4Samples
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidency4Samples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidency4Samples);
}void _VkPhysicalDeviceFeatures::SetsparseResidency4Samples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidency4Samples = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidency4Samples = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency4Samples", "Number");
  
    return;
  }
}// sparseResidency8Samples
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidency8Samples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidency8Samples);
}void _VkPhysicalDeviceFeatures::SetsparseResidency8Samples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidency8Samples = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidency8Samples = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency8Samples", "Number");
  
    return;
  }
}// sparseResidency16Samples
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidency16Samples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidency16Samples);
}void _VkPhysicalDeviceFeatures::SetsparseResidency16Samples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidency16Samples = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidency16Samples = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency16Samples", "Number");
  
    return;
  }
}// sparseResidencyAliased
Napi::Value _VkPhysicalDeviceFeatures::GetsparseResidencyAliased(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sparseResidencyAliased);
}void _VkPhysicalDeviceFeatures::SetsparseResidencyAliased(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sparseResidencyAliased = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sparseResidencyAliased = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyAliased", "Number");
  
    return;
  }
}// variableMultisampleRate
Napi::Value _VkPhysicalDeviceFeatures::GetvariableMultisampleRate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.variableMultisampleRate);
}void _VkPhysicalDeviceFeatures::SetvariableMultisampleRate(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.variableMultisampleRate = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.variableMultisampleRate = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.variableMultisampleRate", "Number");
  
    return;
  }
}// inheritedQueries
Napi::Value _VkPhysicalDeviceFeatures::GetinheritedQueries(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inheritedQueries);
}void _VkPhysicalDeviceFeatures::SetinheritedQueries(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.inheritedQueries = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.inheritedQueries = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPhysicalDeviceFeatures.inheritedQueries", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFeatures ## **/

/** ## BEGIN VkFenceCreateInfo ## **/

Napi::FunctionReference _VkFenceCreateInfo::constructor;

_VkFenceCreateInfo::_VkFenceCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFenceCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkFenceCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkFenceCreateInfo::~_VkFenceCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkFenceCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFenceCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFenceCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFenceCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkFenceCreateInfo::GetsType,
    &_VkFenceCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkFenceCreateInfo::GetpNext,
    &_VkFenceCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkFenceCreateInfo::Getflags,
    &_VkFenceCreateInfo::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFenceCreateInfo", func);
  return exports;
}

Napi::Value _VkFenceCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFenceCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkFenceCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkFenceCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFenceCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkFenceCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFenceCreateInfo::flush() {
  _VkFenceCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO) {
      _VkExportFenceCreateInfo* structExt = Napi::ObjectWrap<_VkExportFenceCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR) {
      _VkExportFenceWin32HandleInfoKHR* structExt = Napi::ObjectWrap<_VkExportFenceWin32HandleInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkFenceCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkFenceCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFenceCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkFenceCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkFenceCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO &&
        sType != VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkFenceCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkFenceCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkFenceCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkFenceCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkFenceCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkFenceCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkFenceCreateInfo.flags", "Number");
  
    return;
  }
}
/** ## END VkFenceCreateInfo ## **/

/** ## BEGIN VkEventCreateInfo ## **/

Napi::FunctionReference _VkEventCreateInfo::constructor;

_VkEventCreateInfo::_VkEventCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkEventCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkEventCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkEventCreateInfo::~_VkEventCreateInfo() {
  
  
  pNext.Reset();
  
  
}

Napi::Object _VkEventCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkEventCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkEventCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkEventCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkEventCreateInfo::GetsType,
    &_VkEventCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkEventCreateInfo::GetpNext,
    &_VkEventCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkEventCreateInfo::Getflags,
    &_VkEventCreateInfo::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkEventCreateInfo", func);
  return exports;
}

Napi::Value _VkEventCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkEventCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkEventCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkEventCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkEventCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkEventCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkEventCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkEventCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkEventCreateInfo::flush() {
  _VkEventCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkEventCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkEventCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkEventCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkEventCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkEventCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkEventCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkEventCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkEventCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkEventCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkEventCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkEventCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkEventCreateInfo.flags", "Number");
  
    return;
  }
}
/** ## END VkEventCreateInfo ## **/

/** ## BEGIN VkRenderPassCreateInfo ## **/

Napi::FunctionReference _VkRenderPassCreateInfo::constructor;

_VkRenderPassCreateInfo::_VkRenderPassCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    vpAttachments = new std::vector<VkAttachmentDescription>;
    vpSubpasses = new std::vector<VkSubpassDescription>;
    vpDependencies = new std::vector<VkSubpassDependency>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "attachmentCount");
      Napi::String sAccess4 = Napi::String::New(env, "pAttachments");
      Napi::String sAccess5 = Napi::String::New(env, "subpassCount");
      Napi::String sAccess6 = Napi::String::New(env, "pSubpasses");
      Napi::String sAccess7 = Napi::String::New(env, "dependencyCount");
      Napi::String sAccess8 = Napi::String::New(env, "pDependencies");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetattachmentCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpAttachments(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetsubpassCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpSubpasses(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdependencyCount(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpDependencies(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkRenderPassCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassCreateInfo::~_VkRenderPassCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  
  vpSubpasses->clear();
  delete vpSubpasses;
  
  pSubpasses.Reset();
  
  
  vpDependencies->clear();
  delete vpDependencies;
  
  pDependencies.Reset();
  
}

Napi::Object _VkRenderPassCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassCreateInfo::GetsType,
    &_VkRenderPassCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassCreateInfo::GetpNext,
    &_VkRenderPassCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkRenderPassCreateInfo::Getflags,
    &_VkRenderPassCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "attachmentCount",
    &_VkRenderPassCreateInfo::GetattachmentCount,
    &_VkRenderPassCreateInfo::SetattachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAttachments",
    &_VkRenderPassCreateInfo::GetpAttachments,
    &_VkRenderPassCreateInfo::SetpAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "subpassCount",
    &_VkRenderPassCreateInfo::GetsubpassCount,
    &_VkRenderPassCreateInfo::SetsubpassCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSubpasses",
    &_VkRenderPassCreateInfo::GetpSubpasses,
    &_VkRenderPassCreateInfo::SetpSubpasses,
    napi_enumerable
  ),
  InstanceAccessor(
    "dependencyCount",
    &_VkRenderPassCreateInfo::GetdependencyCount,
    &_VkRenderPassCreateInfo::SetdependencyCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDependencies",
    &_VkRenderPassCreateInfo::GetpDependencies,
    &_VkRenderPassCreateInfo::SetpDependencies,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassCreateInfo", func);
  return exports;
}

Napi::Value _VkRenderPassCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->attachmentCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->attachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->pAttachments));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->pAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->subpassCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->subpassCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->pSubpasses));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->pSubpasses);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->dependencyCount));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->dependencyCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassCreateInfo *)0)->pDependencies));
    uint32_t byteLength = sizeof(((VkRenderPassCreateInfo *)0)->pDependencies);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassCreateInfo::flush() {
  _VkRenderPassCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO) {
      _VkRenderPassMultiviewCreateInfo* structExt = Napi::ObjectWrap<_VkRenderPassMultiviewCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO) {
      _VkRenderPassInputAttachmentAspectCreateInfo* structExt = Napi::ObjectWrap<_VkRenderPassInputAttachmentAspectCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pAttachments.IsEmpty())) {
    Napi::Value value = self->pAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.attachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'attachmentCount' for 'VkRenderPassCreateInfo.pAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentDescription>* data = this->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentDescription::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pAttachments", "[object VkAttachmentDescription]");
  
        return false;
      }
      _VkAttachmentDescription* result = Napi::ObjectWrap<_VkAttachmentDescription>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }if (!(self->pSubpasses.IsEmpty())) {
    Napi::Value value = self->pSubpasses.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.subpassCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'subpassCount' for 'VkRenderPassCreateInfo.pSubpasses'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSubpassDescription>* data = this->vpSubpasses;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSubpassDescription::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pSubpasses", "[object VkSubpassDescription]");
  
        return false;
      }
      _VkSubpassDescription* result = Napi::ObjectWrap<_VkSubpassDescription>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSubpasses = data->data();
  }if (!(self->pDependencies.IsEmpty())) {
    Napi::Value value = self->pDependencies.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.dependencyCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'dependencyCount' for 'VkRenderPassCreateInfo.pDependencies'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSubpassDependency>* data = this->vpDependencies;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSubpassDependency::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pDependencies", "[object VkSubpassDependency]");
  
        return false;
      }
      _VkSubpassDependency* result = Napi::ObjectWrap<_VkSubpassDependency>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDependencies = data->data();
  }
  return true;
}

// sType
Napi::Value _VkRenderPassCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO &&
        sType != VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkRenderPassCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkRenderPassCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkRenderPassCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkRenderPassCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.flags", "Number");
  
    return;
  }
}// attachmentCount
Napi::Value _VkRenderPassCreateInfo::GetattachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachmentCount);
}void _VkRenderPassCreateInfo::SetattachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
Napi::Value _VkRenderPassCreateInfo::GetpAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAttachments.IsEmpty()) return env.Null();
  return this->pAttachments.Value().As<Napi::Array>();
}void _VkRenderPassCreateInfo::SetpAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAttachments.Reset();
      this->instance.pAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pAttachments", "[object VkAttachmentDescription]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pAttachments", "[object VkAttachmentDescription]");
  
    return;
  }
}// subpassCount
Napi::Value _VkRenderPassCreateInfo::GetsubpassCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpassCount);
}void _VkRenderPassCreateInfo::SetsubpassCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpassCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.subpassCount", "Number");
  
    return;
  }
}// pSubpasses
Napi::Value _VkRenderPassCreateInfo::GetpSubpasses(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSubpasses.IsEmpty()) return env.Null();
  return this->pSubpasses.Value().As<Napi::Array>();
}void _VkRenderPassCreateInfo::SetpSubpasses(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSubpasses.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSubpasses.Reset();
      this->instance.pSubpasses = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pSubpasses", "[object VkSubpassDescription]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSubpasses = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pSubpasses", "[object VkSubpassDescription]");
  
    return;
  }
}// dependencyCount
Napi::Value _VkRenderPassCreateInfo::GetdependencyCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dependencyCount);
}void _VkRenderPassCreateInfo::SetdependencyCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dependencyCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.dependencyCount", "Number");
  
    return;
  }
}// pDependencies
Napi::Value _VkRenderPassCreateInfo::GetpDependencies(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDependencies.IsEmpty()) return env.Null();
  return this->pDependencies.Value().As<Napi::Array>();
}void _VkRenderPassCreateInfo::SetpDependencies(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pDependencies.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pDependencies.Reset();
      this->instance.pDependencies = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pDependencies", "[object VkSubpassDependency]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pDependencies = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassCreateInfo.pDependencies", "[object VkSubpassDependency]");
  
    return;
  }
}
/** ## END VkRenderPassCreateInfo ## **/

/** ## BEGIN VkSubpassDependency ## **/

Napi::FunctionReference _VkSubpassDependency::constructor;

_VkSubpassDependency::_VkSubpassDependency(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassDependency>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "srcSubpass");
      Napi::String sAccess1 = Napi::String::New(env, "dstSubpass");
      Napi::String sAccess2 = Napi::String::New(env, "srcStageMask");
      Napi::String sAccess3 = Napi::String::New(env, "dstStageMask");
      Napi::String sAccess4 = Napi::String::New(env, "srcAccessMask");
      Napi::String sAccess5 = Napi::String::New(env, "dstAccessMask");
      Napi::String sAccess6 = Napi::String::New(env, "dependencyFlags");
      if (obj.Has(sAccess0)) this->SetsrcSubpass(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdstSubpass(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcStageMask(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstStageMask(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsrcAccessMask(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdstAccessMask(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdependencyFlags(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkSubpassDependency constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassDependency::~_VkSubpassDependency() {
  
  
  
  
  
  
  
  
}

Napi::Object _VkSubpassDependency::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassDependency", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassDependency::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassDependency::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "srcSubpass",
    &_VkSubpassDependency::GetsrcSubpass,
    &_VkSubpassDependency::SetsrcSubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSubpass",
    &_VkSubpassDependency::GetdstSubpass,
    &_VkSubpassDependency::SetdstSubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcStageMask",
    &_VkSubpassDependency::GetsrcStageMask,
    &_VkSubpassDependency::SetsrcStageMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstStageMask",
    &_VkSubpassDependency::GetdstStageMask,
    &_VkSubpassDependency::SetdstStageMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcAccessMask",
    &_VkSubpassDependency::GetsrcAccessMask,
    &_VkSubpassDependency::SetsrcAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstAccessMask",
    &_VkSubpassDependency::GetdstAccessMask,
    &_VkSubpassDependency::SetdstAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dependencyFlags",
    &_VkSubpassDependency::GetdependencyFlags,
    &_VkSubpassDependency::SetdependencyFlags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassDependency", func);
  return exports;
}

Napi::Value _VkSubpassDependency::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassDependency::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->srcSubpass));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->srcSubpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->dstSubpass));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->dstSubpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->srcStageMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->srcStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->dstStageMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->dstStageMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->srcAccessMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->srcAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->dstAccessMask));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->dstAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDependency *)0)->dependencyFlags));
    uint32_t byteLength = sizeof(((VkSubpassDependency *)0)->dependencyFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassDependency::flush() {
  _VkSubpassDependency *self = this;
  
  return true;
}

// srcSubpass
Napi::Value _VkSubpassDependency::GetsrcSubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcSubpass);
}void _VkSubpassDependency::SetsrcSubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcSubpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.srcSubpass", "Number");
  
    return;
  }
}// dstSubpass
Napi::Value _VkSubpassDependency::GetdstSubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstSubpass);
}void _VkSubpassDependency::SetdstSubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstSubpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.dstSubpass", "Number");
  
    return;
  }
}// srcStageMask
Napi::Value _VkSubpassDependency::GetsrcStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcStageMask);
}void _VkSubpassDependency::SetsrcStageMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcStageMask = static_cast<VkPipelineStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.srcStageMask", "Number");
  
    return;
  }
}// dstStageMask
Napi::Value _VkSubpassDependency::GetdstStageMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstStageMask);
}void _VkSubpassDependency::SetdstStageMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstStageMask = static_cast<VkPipelineStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.dstStageMask", "Number");
  
    return;
  }
}// srcAccessMask
Napi::Value _VkSubpassDependency::GetsrcAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcAccessMask);
}void _VkSubpassDependency::SetsrcAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
Napi::Value _VkSubpassDependency::GetdstAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstAccessMask);
}void _VkSubpassDependency::SetdstAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.dstAccessMask", "Number");
  
    return;
  }
}// dependencyFlags
Napi::Value _VkSubpassDependency::GetdependencyFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dependencyFlags);
}void _VkSubpassDependency::SetdependencyFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dependencyFlags = static_cast<VkDependencyFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDependency.dependencyFlags", "Number");
  
    return;
  }
}
/** ## END VkSubpassDependency ## **/

/** ## BEGIN VkSubpassDescription ## **/

Napi::FunctionReference _VkSubpassDescription::constructor;

_VkSubpassDescription::_VkSubpassDescription(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubpassDescription>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpInputAttachments = new std::vector<VkAttachmentReference>;
    vpColorAttachments = new std::vector<VkAttachmentReference>;
    vpResolveAttachments = new std::vector<VkAttachmentReference>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "flags");
      Napi::String sAccess1 = Napi::String::New(env, "pipelineBindPoint");
      Napi::String sAccess2 = Napi::String::New(env, "inputAttachmentCount");
      Napi::String sAccess3 = Napi::String::New(env, "pInputAttachments");
      Napi::String sAccess4 = Napi::String::New(env, "colorAttachmentCount");
      Napi::String sAccess5 = Napi::String::New(env, "pColorAttachments");
      Napi::String sAccess6 = Napi::String::New(env, "pResolveAttachments");
      Napi::String sAccess7 = Napi::String::New(env, "pDepthStencilAttachment");
      Napi::String sAccess8 = Napi::String::New(env, "preserveAttachmentCount");
      Napi::String sAccess9 = Napi::String::New(env, "pPreserveAttachments");
      if (obj.Has(sAccess0)) this->Setflags(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpipelineBindPoint(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetinputAttachmentCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpInputAttachments(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcolorAttachmentCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpColorAttachments(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpResolveAttachments(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpDepthStencilAttachment(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpreserveAttachmentCount(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpPreserveAttachments(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkSubpassDescription constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubpassDescription::~_VkSubpassDescription() {
  
  
  
  
  vpInputAttachments->clear();
  delete vpInputAttachments;
  
  pInputAttachments.Reset();
  
  
  vpColorAttachments->clear();
  delete vpColorAttachments;
  
  pColorAttachments.Reset();
  
  vpResolveAttachments->clear();
  delete vpResolveAttachments;
  
  pResolveAttachments.Reset();
  
  pDepthStencilAttachment.Reset();
  
  
  pPreserveAttachments.Reset();
  
}

Napi::Object _VkSubpassDescription::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubpassDescription", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubpassDescription::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubpassDescription::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "flags",
    &_VkSubpassDescription::Getflags,
    &_VkSubpassDescription::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineBindPoint",
    &_VkSubpassDescription::GetpipelineBindPoint,
    &_VkSubpassDescription::SetpipelineBindPoint,
    napi_enumerable
  ),
  InstanceAccessor(
    "inputAttachmentCount",
    &_VkSubpassDescription::GetinputAttachmentCount,
    &_VkSubpassDescription::SetinputAttachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pInputAttachments",
    &_VkSubpassDescription::GetpInputAttachments,
    &_VkSubpassDescription::SetpInputAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "colorAttachmentCount",
    &_VkSubpassDescription::GetcolorAttachmentCount,
    &_VkSubpassDescription::SetcolorAttachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pColorAttachments",
    &_VkSubpassDescription::GetpColorAttachments,
    &_VkSubpassDescription::SetpColorAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "pResolveAttachments",
    &_VkSubpassDescription::GetpResolveAttachments,
    &_VkSubpassDescription::SetpResolveAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDepthStencilAttachment",
    &_VkSubpassDescription::GetpDepthStencilAttachment,
    &_VkSubpassDescription::SetpDepthStencilAttachment,
    napi_enumerable
  ),
  InstanceAccessor(
    "preserveAttachmentCount",
    &_VkSubpassDescription::GetpreserveAttachmentCount,
    &_VkSubpassDescription::SetpreserveAttachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPreserveAttachments",
    &_VkSubpassDescription::GetpPreserveAttachments,
    &_VkSubpassDescription::SetpPreserveAttachments,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubpassDescription", func);
  return exports;
}

Napi::Value _VkSubpassDescription::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubpassDescription::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->flags));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->pipelineBindPoint));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->pipelineBindPoint);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->inputAttachmentCount));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->inputAttachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->pInputAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->pInputAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->colorAttachmentCount));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->colorAttachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->pColorAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->pColorAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->pResolveAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->pResolveAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->pDepthStencilAttachment));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->pDepthStencilAttachment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->preserveAttachmentCount));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->preserveAttachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubpassDescription *)0)->pPreserveAttachments));
    uint32_t byteLength = sizeof(((VkSubpassDescription *)0)->pPreserveAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubpassDescription::flush() {
  _VkSubpassDescription *self = this;
  if (!(self->pInputAttachments.IsEmpty())) {
    Napi::Value value = self->pInputAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.inputAttachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'inputAttachmentCount' for 'VkSubpassDescription.pInputAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentReference>* data = this->vpInputAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentReference::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubpassDescription.pInputAttachments", "[object VkAttachmentReference]");
  
        return false;
      }
      _VkAttachmentReference* result = Napi::ObjectWrap<_VkAttachmentReference>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pInputAttachments = data->data();
  }if (!(self->pColorAttachments.IsEmpty())) {
    Napi::Value value = self->pColorAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.colorAttachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription.pColorAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentReference>* data = this->vpColorAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentReference::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubpassDescription.pColorAttachments", "[object VkAttachmentReference]");
  
        return false;
      }
      _VkAttachmentReference* result = Napi::ObjectWrap<_VkAttachmentReference>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pColorAttachments = data->data();
  }if (!(self->pResolveAttachments.IsEmpty())) {
    Napi::Value value = self->pResolveAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.colorAttachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription.pResolveAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkAttachmentReference>* data = this->vpResolveAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkAttachmentReference::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSubpassDescription.pResolveAttachments", "[object VkAttachmentReference]");
  
        return false;
      }
      _VkAttachmentReference* result = Napi::ObjectWrap<_VkAttachmentReference>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pResolveAttachments = data->data();
  }
  return true;
}

// flags
Napi::Value _VkSubpassDescription::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSubpassDescription::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSubpassDescriptionFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.flags", "Number");
  
    return;
  }
}// pipelineBindPoint
Napi::Value _VkSubpassDescription::GetpipelineBindPoint(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineBindPoint);
}void _VkSubpassDescription::SetpipelineBindPoint(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.pipelineBindPoint", "Number");
  
    return;
  }
}// inputAttachmentCount
Napi::Value _VkSubpassDescription::GetinputAttachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inputAttachmentCount);
}void _VkSubpassDescription::SetinputAttachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.inputAttachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.inputAttachmentCount", "Number");
  
    return;
  }
}// pInputAttachments
Napi::Value _VkSubpassDescription::GetpInputAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pInputAttachments.IsEmpty()) return env.Null();
  return this->pInputAttachments.Value().As<Napi::Array>();
}void _VkSubpassDescription::SetpInputAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pInputAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pInputAttachments.Reset();
      this->instance.pInputAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription.pInputAttachments", "[object VkAttachmentReference]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pInputAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.pInputAttachments", "[object VkAttachmentReference]");
  
    return;
  }
}// colorAttachmentCount
Napi::Value _VkSubpassDescription::GetcolorAttachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.colorAttachmentCount);
}void _VkSubpassDescription::SetcolorAttachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.colorAttachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.colorAttachmentCount", "Number");
  
    return;
  }
}// pColorAttachments
Napi::Value _VkSubpassDescription::GetpColorAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pColorAttachments.IsEmpty()) return env.Null();
  return this->pColorAttachments.Value().As<Napi::Array>();
}void _VkSubpassDescription::SetpColorAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pColorAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pColorAttachments.Reset();
      this->instance.pColorAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription.pColorAttachments", "[object VkAttachmentReference]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pColorAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.pColorAttachments", "[object VkAttachmentReference]");
  
    return;
  }
}// pResolveAttachments
Napi::Value _VkSubpassDescription::GetpResolveAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pResolveAttachments.IsEmpty()) return env.Null();
  return this->pResolveAttachments.Value().As<Napi::Array>();
}void _VkSubpassDescription::SetpResolveAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pResolveAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pResolveAttachments.Reset();
      this->instance.pResolveAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription.pResolveAttachments", "[object VkAttachmentReference]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pResolveAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.pResolveAttachments", "[object VkAttachmentReference]");
  
    return;
  }
}// pDepthStencilAttachment
Napi::Value _VkSubpassDescription::GetpDepthStencilAttachment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDepthStencilAttachment.IsEmpty()) return env.Null();
  return this->pDepthStencilAttachment.Value().As<Napi::Object>();
}void _VkSubpassDescription::SetpDepthStencilAttachment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkAttachmentReference::constructor.Value())) {
      
      this->pDepthStencilAttachment.Reset(value.ToObject(), 1);
      _VkAttachmentReference* inst = Napi::ObjectWrap<_VkAttachmentReference>::Unwrap(obj);
      inst->flush();
      this->instance.pDepthStencilAttachment = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription.pDepthStencilAttachment", "[object VkAttachmentReference]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pDepthStencilAttachment.Reset();
    this->instance.pDepthStencilAttachment = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.pDepthStencilAttachment", "[object VkAttachmentReference]");
  
    return;
  }
}// preserveAttachmentCount
Napi::Value _VkSubpassDescription::GetpreserveAttachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.preserveAttachmentCount);
}void _VkSubpassDescription::SetpreserveAttachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.preserveAttachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSubpassDescription.preserveAttachmentCount", "Number");
  
    return;
  }
}// pPreserveAttachments
Napi::Value _VkSubpassDescription::GetpPreserveAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPreserveAttachments.IsEmpty()) return env.Null();
  return this->pPreserveAttachments.Value().As<Napi::TypedArray>();
}void _VkSubpassDescription::SetpPreserveAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pPreserveAttachments.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkSubpassDescription.pPreserveAttachments", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pPreserveAttachments.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkSubpassDescription.pPreserveAttachments", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pPreserveAttachments = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pPreserveAttachments = nullptr;
  }
}
/** ## END VkSubpassDescription ## **/

/** ## BEGIN VkAttachmentReference ## **/

Napi::FunctionReference _VkAttachmentReference::constructor;

_VkAttachmentReference::_VkAttachmentReference(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAttachmentReference>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "attachment");
      Napi::String sAccess1 = Napi::String::New(env, "layout");
      if (obj.Has(sAccess0)) this->Setattachment(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setlayout(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkAttachmentReference constructor cannot be invoked without 'new'");
    }
  }
}

_VkAttachmentReference::~_VkAttachmentReference() {
  
  
  
}

Napi::Object _VkAttachmentReference::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAttachmentReference", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAttachmentReference::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAttachmentReference::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "attachment",
    &_VkAttachmentReference::Getattachment,
    &_VkAttachmentReference::Setattachment,
    napi_enumerable
  ),
  InstanceAccessor(
    "layout",
    &_VkAttachmentReference::Getlayout,
    &_VkAttachmentReference::Setlayout,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAttachmentReference", func);
  return exports;
}

Napi::Value _VkAttachmentReference::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAttachmentReference::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference *)0)->attachment));
    uint32_t byteLength = sizeof(((VkAttachmentReference *)0)->attachment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentReference *)0)->layout));
    uint32_t byteLength = sizeof(((VkAttachmentReference *)0)->layout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAttachmentReference::flush() {
  _VkAttachmentReference *self = this;
  
  return true;
}

// attachment
Napi::Value _VkAttachmentReference::Getattachment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachment);
}void _VkAttachmentReference::Setattachment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachment = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference.attachment", "Number");
  
    return;
  }
}// layout
Napi::Value _VkAttachmentReference::Getlayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layout);
}void _VkAttachmentReference::Setlayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentReference.layout", "Number");
  
    return;
  }
}
/** ## END VkAttachmentReference ## **/

/** ## BEGIN VkAttachmentDescription ## **/

Napi::FunctionReference _VkAttachmentDescription::constructor;

_VkAttachmentDescription::_VkAttachmentDescription(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAttachmentDescription>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "flags");
      Napi::String sAccess1 = Napi::String::New(env, "format");
      Napi::String sAccess2 = Napi::String::New(env, "samples");
      Napi::String sAccess3 = Napi::String::New(env, "loadOp");
      Napi::String sAccess4 = Napi::String::New(env, "storeOp");
      Napi::String sAccess5 = Napi::String::New(env, "stencilLoadOp");
      Napi::String sAccess6 = Napi::String::New(env, "stencilStoreOp");
      Napi::String sAccess7 = Napi::String::New(env, "initialLayout");
      Napi::String sAccess8 = Napi::String::New(env, "finalLayout");
      if (obj.Has(sAccess0)) this->Setflags(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setformat(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsamples(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetloadOp(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetstoreOp(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetstencilLoadOp(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetstencilStoreOp(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetinitialLayout(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetfinalLayout(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkAttachmentDescription constructor cannot be invoked without 'new'");
    }
  }
}

_VkAttachmentDescription::~_VkAttachmentDescription() {
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkAttachmentDescription::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAttachmentDescription", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAttachmentDescription::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAttachmentDescription::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "flags",
    &_VkAttachmentDescription::Getflags,
    &_VkAttachmentDescription::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkAttachmentDescription::Getformat,
    &_VkAttachmentDescription::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "samples",
    &_VkAttachmentDescription::Getsamples,
    &_VkAttachmentDescription::Setsamples,
    napi_enumerable
  ),
  InstanceAccessor(
    "loadOp",
    &_VkAttachmentDescription::GetloadOp,
    &_VkAttachmentDescription::SetloadOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "storeOp",
    &_VkAttachmentDescription::GetstoreOp,
    &_VkAttachmentDescription::SetstoreOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "stencilLoadOp",
    &_VkAttachmentDescription::GetstencilLoadOp,
    &_VkAttachmentDescription::SetstencilLoadOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "stencilStoreOp",
    &_VkAttachmentDescription::GetstencilStoreOp,
    &_VkAttachmentDescription::SetstencilStoreOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "initialLayout",
    &_VkAttachmentDescription::GetinitialLayout,
    &_VkAttachmentDescription::SetinitialLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "finalLayout",
    &_VkAttachmentDescription::GetfinalLayout,
    &_VkAttachmentDescription::SetfinalLayout,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAttachmentDescription", func);
  return exports;
}

Napi::Value _VkAttachmentDescription::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAttachmentDescription::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->flags));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->format));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->samples));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->loadOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->loadOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->storeOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->storeOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->stencilLoadOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->stencilLoadOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->stencilStoreOp));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->stencilStoreOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->initialLayout));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->initialLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAttachmentDescription *)0)->finalLayout));
    uint32_t byteLength = sizeof(((VkAttachmentDescription *)0)->finalLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAttachmentDescription::flush() {
  _VkAttachmentDescription *self = this;
  
  return true;
}

// flags
Napi::Value _VkAttachmentDescription::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkAttachmentDescription::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkAttachmentDescriptionFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.flags", "Number");
  
    return;
  }
}// format
Napi::Value _VkAttachmentDescription::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkAttachmentDescription::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.format", "Number");
  
    return;
  }
}// samples
Napi::Value _VkAttachmentDescription::Getsamples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samples);
}void _VkAttachmentDescription::Setsamples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.samples = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.samples", "Number");
  
    return;
  }
}// loadOp
Napi::Value _VkAttachmentDescription::GetloadOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.loadOp);
}void _VkAttachmentDescription::SetloadOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.loadOp = static_cast<VkAttachmentLoadOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.loadOp", "Number");
  
    return;
  }
}// storeOp
Napi::Value _VkAttachmentDescription::GetstoreOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.storeOp);
}void _VkAttachmentDescription::SetstoreOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.storeOp = static_cast<VkAttachmentStoreOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.storeOp", "Number");
  
    return;
  }
}// stencilLoadOp
Napi::Value _VkAttachmentDescription::GetstencilLoadOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stencilLoadOp);
}void _VkAttachmentDescription::SetstencilLoadOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stencilLoadOp = static_cast<VkAttachmentLoadOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.stencilLoadOp", "Number");
  
    return;
  }
}// stencilStoreOp
Napi::Value _VkAttachmentDescription::GetstencilStoreOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stencilStoreOp);
}void _VkAttachmentDescription::SetstencilStoreOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stencilStoreOp = static_cast<VkAttachmentStoreOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.stencilStoreOp", "Number");
  
    return;
  }
}// initialLayout
Napi::Value _VkAttachmentDescription::GetinitialLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.initialLayout);
}void _VkAttachmentDescription::SetinitialLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.initialLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.initialLayout", "Number");
  
    return;
  }
}// finalLayout
Napi::Value _VkAttachmentDescription::GetfinalLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.finalLayout);
}void _VkAttachmentDescription::SetfinalLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.finalLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkAttachmentDescription.finalLayout", "Number");
  
    return;
  }
}
/** ## END VkAttachmentDescription ## **/

/** ## BEGIN VkClearAttachment ## **/

Napi::FunctionReference _VkClearAttachment::constructor;

_VkClearAttachment::_VkClearAttachment(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkClearAttachment>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "aspectMask");
      Napi::String sAccess1 = Napi::String::New(env, "colorAttachment");
      Napi::String sAccess2 = Napi::String::New(env, "clearValue");
      if (obj.Has(sAccess0)) this->SetaspectMask(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetcolorAttachment(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetclearValue(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkClearAttachment constructor cannot be invoked without 'new'");
    }
  }
}

_VkClearAttachment::~_VkClearAttachment() {
  
  
  
  clearValue.Reset();
  
}

Napi::Object _VkClearAttachment::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkClearAttachment", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkClearAttachment::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkClearAttachment::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "aspectMask",
    &_VkClearAttachment::GetaspectMask,
    &_VkClearAttachment::SetaspectMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "colorAttachment",
    &_VkClearAttachment::GetcolorAttachment,
    &_VkClearAttachment::SetcolorAttachment,
    napi_enumerable
  ),
  InstanceAccessor(
    "clearValue",
    &_VkClearAttachment::GetclearValue,
    &_VkClearAttachment::SetclearValue,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkClearAttachment", func);
  return exports;
}

Napi::Value _VkClearAttachment::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkClearAttachment::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearAttachment *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkClearAttachment *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearAttachment *)0)->colorAttachment));
    uint32_t byteLength = sizeof(((VkClearAttachment *)0)->colorAttachment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearAttachment *)0)->clearValue));
    uint32_t byteLength = sizeof(((VkClearAttachment *)0)->clearValue);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkClearAttachment::flush() {
  _VkClearAttachment *self = this;
  if (!(self->clearValue.IsEmpty())) {
    Napi::Value value = self->clearValue.Value();
    
    _VkClearValue* result = Napi::ObjectWrap<_VkClearValue>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.clearValue = result->instance;
  }
  return true;
}

// aspectMask
Napi::Value _VkClearAttachment::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkClearAttachment::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkClearAttachment.aspectMask", "Number");
  
    return;
  }
}// colorAttachment
Napi::Value _VkClearAttachment::GetcolorAttachment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.colorAttachment);
}void _VkClearAttachment::SetcolorAttachment(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.colorAttachment = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkClearAttachment.colorAttachment", "Number");
  
    return;
  }
}// clearValue
Napi::Value _VkClearAttachment::GetclearValue(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->clearValue.IsEmpty()) return env.Null();
  return this->clearValue.Value().As<Napi::Object>();
}void _VkClearAttachment::SetclearValue(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkClearValue::constructor.Value())) {
      
      this->clearValue.Reset(value.ToObject(), 1);
      _VkClearValue* inst = Napi::ObjectWrap<_VkClearValue>::Unwrap(obj);
      inst->flush();
      this->instance.clearValue = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkClearAttachment.clearValue", "[object VkClearValue]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->clearValue.Reset();
    memset(&this->instance.clearValue, 0, sizeof(VkClearValue));
  } else {
    
    NapiObjectTypeError(value, "VkClearAttachment.clearValue", "[object VkClearValue]");
  
    return;
  }
}
/** ## END VkClearAttachment ## **/

/** ## BEGIN VkClearDepthStencilValue ## **/

Napi::FunctionReference _VkClearDepthStencilValue::constructor;

_VkClearDepthStencilValue::_VkClearDepthStencilValue(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkClearDepthStencilValue>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "depth");
      Napi::String sAccess1 = Napi::String::New(env, "stencil");
      if (obj.Has(sAccess0)) this->Setdepth(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setstencil(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkClearDepthStencilValue constructor cannot be invoked without 'new'");
    }
  }
}

_VkClearDepthStencilValue::~_VkClearDepthStencilValue() {
  
  
  
}

Napi::Object _VkClearDepthStencilValue::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkClearDepthStencilValue", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkClearDepthStencilValue::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkClearDepthStencilValue::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "depth",
    &_VkClearDepthStencilValue::Getdepth,
    &_VkClearDepthStencilValue::Setdepth,
    napi_enumerable
  ),
  InstanceAccessor(
    "stencil",
    &_VkClearDepthStencilValue::Getstencil,
    &_VkClearDepthStencilValue::Setstencil,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkClearDepthStencilValue", func);
  return exports;
}

Napi::Value _VkClearDepthStencilValue::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkClearDepthStencilValue::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearDepthStencilValue *)0)->depth));
    uint32_t byteLength = sizeof(((VkClearDepthStencilValue *)0)->depth);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearDepthStencilValue *)0)->stencil));
    uint32_t byteLength = sizeof(((VkClearDepthStencilValue *)0)->stencil);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkClearDepthStencilValue::flush() {
  _VkClearDepthStencilValue *self = this;
  
  return true;
}

// depth
Napi::Value _VkClearDepthStencilValue::Getdepth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depth);
}void _VkClearDepthStencilValue::Setdepth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depth = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkClearDepthStencilValue.depth", "Number");
  
    return;
  }
}// stencil
Napi::Value _VkClearDepthStencilValue::Getstencil(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stencil);
}void _VkClearDepthStencilValue::Setstencil(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stencil = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkClearDepthStencilValue.stencil", "Number");
  
    return;
  }
}
/** ## END VkClearDepthStencilValue ## **/

/** ## BEGIN VkRenderPassBeginInfo ## **/

Napi::FunctionReference _VkRenderPassBeginInfo::constructor;

_VkRenderPassBeginInfo::_VkRenderPassBeginInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRenderPassBeginInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    vpClearValues = new std::vector<VkClearValue>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "renderPass");
      Napi::String sAccess3 = Napi::String::New(env, "framebuffer");
      Napi::String sAccess4 = Napi::String::New(env, "renderArea");
      Napi::String sAccess5 = Napi::String::New(env, "clearValueCount");
      Napi::String sAccess6 = Napi::String::New(env, "pClearValues");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetrenderPass(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setframebuffer(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetrenderArea(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetclearValueCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpClearValues(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkRenderPassBeginInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkRenderPassBeginInfo::~_VkRenderPassBeginInfo() {
  
  
  pNext.Reset();
  
  renderPass.Reset();
  
  framebuffer.Reset();
  
  renderArea.Reset();
  
  
  vpClearValues->clear();
  delete vpClearValues;
  
  pClearValues.Reset();
  
}

Napi::Object _VkRenderPassBeginInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRenderPassBeginInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRenderPassBeginInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRenderPassBeginInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkRenderPassBeginInfo::GetsType,
    &_VkRenderPassBeginInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkRenderPassBeginInfo::GetpNext,
    &_VkRenderPassBeginInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "renderPass",
    &_VkRenderPassBeginInfo::GetrenderPass,
    &_VkRenderPassBeginInfo::SetrenderPass,
    napi_enumerable
  ),
  InstanceAccessor(
    "framebuffer",
    &_VkRenderPassBeginInfo::Getframebuffer,
    &_VkRenderPassBeginInfo::Setframebuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "renderArea",
    &_VkRenderPassBeginInfo::GetrenderArea,
    &_VkRenderPassBeginInfo::SetrenderArea,
    napi_enumerable
  ),
  InstanceAccessor(
    "clearValueCount",
    &_VkRenderPassBeginInfo::GetclearValueCount,
    &_VkRenderPassBeginInfo::SetclearValueCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pClearValues",
    &_VkRenderPassBeginInfo::GetpClearValues,
    &_VkRenderPassBeginInfo::SetpClearValues,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRenderPassBeginInfo", func);
  return exports;
}

Napi::Value _VkRenderPassBeginInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRenderPassBeginInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->renderPass));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->renderPass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->framebuffer));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->framebuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->renderArea));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->renderArea);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->clearValueCount));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->clearValueCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRenderPassBeginInfo *)0)->pClearValues));
    uint32_t byteLength = sizeof(((VkRenderPassBeginInfo *)0)->pClearValues);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRenderPassBeginInfo::flush() {
  _VkRenderPassBeginInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO) {
      _VkDeviceGroupRenderPassBeginInfo* structExt = Napi::ObjectWrap<_VkDeviceGroupRenderPassBeginInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT) {
      _VkRenderPassSampleLocationsBeginInfoEXT* structExt = Napi::ObjectWrap<_VkRenderPassSampleLocationsBeginInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->renderArea.IsEmpty())) {
    Napi::Value value = self->renderArea.Value();
    
    _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.renderArea = result->instance;
  }if (!(self->pClearValues.IsEmpty())) {
    Napi::Value value = self->pClearValues.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.clearValueCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'clearValueCount' for 'VkRenderPassBeginInfo.pClearValues'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkClearValue>* data = this->vpClearValues;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkClearValue::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.pClearValues", "[object VkClearValue]");
  
        return false;
      }
      _VkClearValue* result = Napi::ObjectWrap<_VkClearValue>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pClearValues = data->data();
  }
  return true;
}

// sType
Napi::Value _VkRenderPassBeginInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkRenderPassBeginInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkRenderPassBeginInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkRenderPassBeginInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO &&
        sType != VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkRenderPassBeginInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.pNext", "[object Object]");
  
    return;
  }
}// renderPass
Napi::Value _VkRenderPassBeginInfo::GetrenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->renderPass.IsEmpty()) return env.Null();
  return this->renderPass.Value().As<Napi::Object>();
}void _VkRenderPassBeginInfo::SetrenderPass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRenderPass::constructor.Value())) {
      
      this->renderPass.Reset(value.ToObject(), 1);
      _VkRenderPass* inst = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
      ;
      this->instance.renderPass = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->renderPass.Reset();
    this->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// framebuffer
Napi::Value _VkRenderPassBeginInfo::Getframebuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->framebuffer.IsEmpty()) return env.Null();
  return this->framebuffer.Value().As<Napi::Object>();
}void _VkRenderPassBeginInfo::Setframebuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFramebuffer::constructor.Value())) {
      
      this->framebuffer.Reset(value.ToObject(), 1);
      _VkFramebuffer* inst = Napi::ObjectWrap<_VkFramebuffer>::Unwrap(obj);
      ;
      this->instance.framebuffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.framebuffer", "[object VkFramebuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->framebuffer.Reset();
    this->instance.framebuffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.framebuffer", "[object VkFramebuffer]");
  
    return;
  }
}// renderArea
Napi::Value _VkRenderPassBeginInfo::GetrenderArea(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->renderArea.IsEmpty()) return env.Null();
  return this->renderArea.Value().As<Napi::Object>();
}void _VkRenderPassBeginInfo::SetrenderArea(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRect2D::constructor.Value())) {
      
      this->renderArea.Reset(value.ToObject(), 1);
      _VkRect2D* inst = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      inst->flush();
      this->instance.renderArea = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.renderArea", "[object VkRect2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->renderArea.Reset();
    memset(&this->instance.renderArea, 0, sizeof(VkRect2D));
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.renderArea", "[object VkRect2D]");
  
    return;
  }
}// clearValueCount
Napi::Value _VkRenderPassBeginInfo::GetclearValueCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.clearValueCount);
}void _VkRenderPassBeginInfo::SetclearValueCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.clearValueCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.clearValueCount", "Number");
  
    return;
  }
}// pClearValues
Napi::Value _VkRenderPassBeginInfo::GetpClearValues(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pClearValues.IsEmpty()) return env.Null();
  return this->pClearValues.Value().As<Napi::Array>();
}void _VkRenderPassBeginInfo::SetpClearValues(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pClearValues.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pClearValues.Reset();
      this->instance.pClearValues = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.pClearValues", "[object VkClearValue]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pClearValues = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkRenderPassBeginInfo.pClearValues", "[object VkClearValue]");
  
    return;
  }
}
/** ## END VkRenderPassBeginInfo ## **/

/** ## BEGIN VkCommandBufferBeginInfo ## **/

Napi::FunctionReference _VkCommandBufferBeginInfo::constructor;

_VkCommandBufferBeginInfo::_VkCommandBufferBeginInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandBufferBeginInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "pInheritanceInfo");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpInheritanceInfo(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkCommandBufferBeginInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkCommandBufferBeginInfo::~_VkCommandBufferBeginInfo() {
  
  
  pNext.Reset();
  
  
  pInheritanceInfo.Reset();
  
}

Napi::Object _VkCommandBufferBeginInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandBufferBeginInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCommandBufferBeginInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCommandBufferBeginInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCommandBufferBeginInfo::GetsType,
    &_VkCommandBufferBeginInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCommandBufferBeginInfo::GetpNext,
    &_VkCommandBufferBeginInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkCommandBufferBeginInfo::Getflags,
    &_VkCommandBufferBeginInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pInheritanceInfo",
    &_VkCommandBufferBeginInfo::GetpInheritanceInfo,
    &_VkCommandBufferBeginInfo::SetpInheritanceInfo,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandBufferBeginInfo", func);
  return exports;
}

Napi::Value _VkCommandBufferBeginInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCommandBufferBeginInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferBeginInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkCommandBufferBeginInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferBeginInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCommandBufferBeginInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferBeginInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkCommandBufferBeginInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferBeginInfo *)0)->pInheritanceInfo));
    uint32_t byteLength = sizeof(((VkCommandBufferBeginInfo *)0)->pInheritanceInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCommandBufferBeginInfo::flush() {
  _VkCommandBufferBeginInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO) {
      _VkDeviceGroupCommandBufferBeginInfo* structExt = Napi::ObjectWrap<_VkDeviceGroupCommandBufferBeginInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkCommandBufferBeginInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCommandBufferBeginInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferBeginInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCommandBufferBeginInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCommandBufferBeginInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkCommandBufferBeginInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferBeginInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferBeginInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkCommandBufferBeginInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkCommandBufferBeginInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkCommandBufferUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferBeginInfo.flags", "Number");
  
    return;
  }
}// pInheritanceInfo
Napi::Value _VkCommandBufferBeginInfo::GetpInheritanceInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pInheritanceInfo.IsEmpty()) return env.Null();
  return this->pInheritanceInfo.Value().As<Napi::Object>();
}void _VkCommandBufferBeginInfo::SetpInheritanceInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkCommandBufferInheritanceInfo::constructor.Value())) {
      
      this->pInheritanceInfo.Reset(value.ToObject(), 1);
      _VkCommandBufferInheritanceInfo* inst = Napi::ObjectWrap<_VkCommandBufferInheritanceInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pInheritanceInfo = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferBeginInfo.pInheritanceInfo", "[object VkCommandBufferInheritanceInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pInheritanceInfo.Reset();
    this->instance.pInheritanceInfo = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferBeginInfo.pInheritanceInfo", "[object VkCommandBufferInheritanceInfo]");
  
    return;
  }
}
/** ## END VkCommandBufferBeginInfo ## **/

/** ## BEGIN VkCommandBufferInheritanceInfo ## **/

Napi::FunctionReference _VkCommandBufferInheritanceInfo::constructor;

_VkCommandBufferInheritanceInfo::_VkCommandBufferInheritanceInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandBufferInheritanceInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "renderPass");
      Napi::String sAccess3 = Napi::String::New(env, "subpass");
      Napi::String sAccess4 = Napi::String::New(env, "framebuffer");
      Napi::String sAccess5 = Napi::String::New(env, "occlusionQueryEnable");
      Napi::String sAccess6 = Napi::String::New(env, "queryFlags");
      Napi::String sAccess7 = Napi::String::New(env, "pipelineStatistics");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetrenderPass(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setsubpass(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setframebuffer(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetocclusionQueryEnable(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetqueryFlags(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpipelineStatistics(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkCommandBufferInheritanceInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkCommandBufferInheritanceInfo::~_VkCommandBufferInheritanceInfo() {
  
  
  pNext.Reset();
  
  renderPass.Reset();
  
  
  framebuffer.Reset();
  
  
  
  
}

Napi::Object _VkCommandBufferInheritanceInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandBufferInheritanceInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCommandBufferInheritanceInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCommandBufferInheritanceInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCommandBufferInheritanceInfo::GetsType,
    &_VkCommandBufferInheritanceInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCommandBufferInheritanceInfo::GetpNext,
    &_VkCommandBufferInheritanceInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "renderPass",
    &_VkCommandBufferInheritanceInfo::GetrenderPass,
    &_VkCommandBufferInheritanceInfo::SetrenderPass,
    napi_enumerable
  ),
  InstanceAccessor(
    "subpass",
    &_VkCommandBufferInheritanceInfo::Getsubpass,
    &_VkCommandBufferInheritanceInfo::Setsubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "framebuffer",
    &_VkCommandBufferInheritanceInfo::Getframebuffer,
    &_VkCommandBufferInheritanceInfo::Setframebuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "occlusionQueryEnable",
    &_VkCommandBufferInheritanceInfo::GetocclusionQueryEnable,
    &_VkCommandBufferInheritanceInfo::SetocclusionQueryEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "queryFlags",
    &_VkCommandBufferInheritanceInfo::GetqueryFlags,
    &_VkCommandBufferInheritanceInfo::SetqueryFlags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineStatistics",
    &_VkCommandBufferInheritanceInfo::GetpipelineStatistics,
    &_VkCommandBufferInheritanceInfo::SetpipelineStatistics,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandBufferInheritanceInfo", func);
  return exports;
}

Napi::Value _VkCommandBufferInheritanceInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCommandBufferInheritanceInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->renderPass));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->renderPass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->subpass));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->subpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->framebuffer));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->framebuffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->occlusionQueryEnable));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->occlusionQueryEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->queryFlags));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->queryFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferInheritanceInfo *)0)->pipelineStatistics));
    uint32_t byteLength = sizeof(((VkCommandBufferInheritanceInfo *)0)->pipelineStatistics);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCommandBufferInheritanceInfo::flush() {
  _VkCommandBufferInheritanceInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT) {
      _VkCommandBufferInheritanceConditionalRenderingInfoEXT* structExt = Napi::ObjectWrap<_VkCommandBufferInheritanceConditionalRenderingInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkCommandBufferInheritanceInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCommandBufferInheritanceInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCommandBufferInheritanceInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCommandBufferInheritanceInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkCommandBufferInheritanceInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.pNext", "[object Object]");
  
    return;
  }
}// renderPass
Napi::Value _VkCommandBufferInheritanceInfo::GetrenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->renderPass.IsEmpty()) return env.Null();
  return this->renderPass.Value().As<Napi::Object>();
}void _VkCommandBufferInheritanceInfo::SetrenderPass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRenderPass::constructor.Value())) {
      
      this->renderPass.Reset(value.ToObject(), 1);
      _VkRenderPass* inst = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
      ;
      this->instance.renderPass = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->renderPass.Reset();
    this->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// subpass
Napi::Value _VkCommandBufferInheritanceInfo::Getsubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpass);
}void _VkCommandBufferInheritanceInfo::Setsubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.subpass", "Number");
  
    return;
  }
}// framebuffer
Napi::Value _VkCommandBufferInheritanceInfo::Getframebuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->framebuffer.IsEmpty()) return env.Null();
  return this->framebuffer.Value().As<Napi::Object>();
}void _VkCommandBufferInheritanceInfo::Setframebuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkFramebuffer::constructor.Value())) {
      
      this->framebuffer.Reset(value.ToObject(), 1);
      _VkFramebuffer* inst = Napi::ObjectWrap<_VkFramebuffer>::Unwrap(obj);
      ;
      this->instance.framebuffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.framebuffer", "[object VkFramebuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->framebuffer.Reset();
    this->instance.framebuffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.framebuffer", "[object VkFramebuffer]");
  
    return;
  }
}// occlusionQueryEnable
Napi::Value _VkCommandBufferInheritanceInfo::GetocclusionQueryEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.occlusionQueryEnable);
}void _VkCommandBufferInheritanceInfo::SetocclusionQueryEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.occlusionQueryEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.occlusionQueryEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.occlusionQueryEnable", "Number");
  
    return;
  }
}// queryFlags
Napi::Value _VkCommandBufferInheritanceInfo::GetqueryFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queryFlags);
}void _VkCommandBufferInheritanceInfo::SetqueryFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queryFlags = static_cast<VkQueryControlFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.queryFlags", "Number");
  
    return;
  }
}// pipelineStatistics
Napi::Value _VkCommandBufferInheritanceInfo::GetpipelineStatistics(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pipelineStatistics);
}void _VkCommandBufferInheritanceInfo::SetpipelineStatistics(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pipelineStatistics = static_cast<VkQueryPipelineStatisticFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferInheritanceInfo.pipelineStatistics", "Number");
  
    return;
  }
}
/** ## END VkCommandBufferInheritanceInfo ## **/

/** ## BEGIN VkCommandBufferAllocateInfo ## **/

Napi::FunctionReference _VkCommandBufferAllocateInfo::constructor;

_VkCommandBufferAllocateInfo::_VkCommandBufferAllocateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandBufferAllocateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "commandPool");
      Napi::String sAccess3 = Napi::String::New(env, "level");
      Napi::String sAccess4 = Napi::String::New(env, "commandBufferCount");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetcommandPool(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setlevel(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcommandBufferCount(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkCommandBufferAllocateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkCommandBufferAllocateInfo::~_VkCommandBufferAllocateInfo() {
  
  
  pNext.Reset();
  
  commandPool.Reset();
  
  
  
}

Napi::Object _VkCommandBufferAllocateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandBufferAllocateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCommandBufferAllocateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCommandBufferAllocateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCommandBufferAllocateInfo::GetsType,
    &_VkCommandBufferAllocateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCommandBufferAllocateInfo::GetpNext,
    &_VkCommandBufferAllocateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "commandPool",
    &_VkCommandBufferAllocateInfo::GetcommandPool,
    &_VkCommandBufferAllocateInfo::SetcommandPool,
    napi_enumerable
  ),
  InstanceAccessor(
    "level",
    &_VkCommandBufferAllocateInfo::Getlevel,
    &_VkCommandBufferAllocateInfo::Setlevel,
    napi_enumerable
  ),
  InstanceAccessor(
    "commandBufferCount",
    &_VkCommandBufferAllocateInfo::GetcommandBufferCount,
    &_VkCommandBufferAllocateInfo::SetcommandBufferCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandBufferAllocateInfo", func);
  return exports;
}

Napi::Value _VkCommandBufferAllocateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCommandBufferAllocateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferAllocateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkCommandBufferAllocateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferAllocateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCommandBufferAllocateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferAllocateInfo *)0)->commandPool));
    uint32_t byteLength = sizeof(((VkCommandBufferAllocateInfo *)0)->commandPool);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferAllocateInfo *)0)->level));
    uint32_t byteLength = sizeof(((VkCommandBufferAllocateInfo *)0)->level);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandBufferAllocateInfo *)0)->commandBufferCount));
    uint32_t byteLength = sizeof(((VkCommandBufferAllocateInfo *)0)->commandBufferCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCommandBufferAllocateInfo::flush() {
  _VkCommandBufferAllocateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkCommandBufferAllocateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCommandBufferAllocateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCommandBufferAllocateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCommandBufferAllocateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCommandBufferAllocateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.pNext", "[object Object]");
  
    return;
  }
}// commandPool
Napi::Value _VkCommandBufferAllocateInfo::GetcommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->commandPool.IsEmpty()) return env.Null();
  return this->commandPool.Value().As<Napi::Object>();
}void _VkCommandBufferAllocateInfo::SetcommandPool(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkCommandPool::constructor.Value())) {
      
      this->commandPool.Reset(value.ToObject(), 1);
      _VkCommandPool* inst = Napi::ObjectWrap<_VkCommandPool>::Unwrap(obj);
      ;
      this->instance.commandPool = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.commandPool", "[object VkCommandPool]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->commandPool.Reset();
    this->instance.commandPool = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.commandPool", "[object VkCommandPool]");
  
    return;
  }
}// level
Napi::Value _VkCommandBufferAllocateInfo::Getlevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.level);
}void _VkCommandBufferAllocateInfo::Setlevel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.level = static_cast<VkCommandBufferLevel>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.level", "Number");
  
    return;
  }
}// commandBufferCount
Napi::Value _VkCommandBufferAllocateInfo::GetcommandBufferCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.commandBufferCount);
}void _VkCommandBufferAllocateInfo::SetcommandBufferCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.commandBufferCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandBufferAllocateInfo.commandBufferCount", "Number");
  
    return;
  }
}
/** ## END VkCommandBufferAllocateInfo ## **/

/** ## BEGIN VkCommandPoolCreateInfo ## **/

Napi::FunctionReference _VkCommandPoolCreateInfo::constructor;

_VkCommandPoolCreateInfo::_VkCommandPoolCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCommandPoolCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "queueFamilyIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetqueueFamilyIndex(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkCommandPoolCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkCommandPoolCreateInfo::~_VkCommandPoolCreateInfo() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkCommandPoolCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCommandPoolCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCommandPoolCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCommandPoolCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCommandPoolCreateInfo::GetsType,
    &_VkCommandPoolCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCommandPoolCreateInfo::GetpNext,
    &_VkCommandPoolCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkCommandPoolCreateInfo::Getflags,
    &_VkCommandPoolCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyIndex",
    &_VkCommandPoolCreateInfo::GetqueueFamilyIndex,
    &_VkCommandPoolCreateInfo::SetqueueFamilyIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCommandPoolCreateInfo", func);
  return exports;
}

Napi::Value _VkCommandPoolCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCommandPoolCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandPoolCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkCommandPoolCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandPoolCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCommandPoolCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandPoolCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkCommandPoolCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCommandPoolCreateInfo *)0)->queueFamilyIndex));
    uint32_t byteLength = sizeof(((VkCommandPoolCreateInfo *)0)->queueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCommandPoolCreateInfo::flush() {
  _VkCommandPoolCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkCommandPoolCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCommandPoolCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandPoolCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCommandPoolCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCommandPoolCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCommandPoolCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCommandPoolCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCommandPoolCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkCommandPoolCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkCommandPoolCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkCommandPoolCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandPoolCreateInfo.flags", "Number");
  
    return;
  }
}// queueFamilyIndex
Napi::Value _VkCommandPoolCreateInfo::GetqueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFamilyIndex);
}void _VkCommandPoolCreateInfo::SetqueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCommandPoolCreateInfo.queueFamilyIndex", "Number");
  
    return;
  }
}
/** ## END VkCommandPoolCreateInfo ## **/

/** ## BEGIN VkSamplerCreateInfo ## **/

Napi::FunctionReference _VkSamplerCreateInfo::constructor;

_VkSamplerCreateInfo::_VkSamplerCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSamplerCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "magFilter");
      Napi::String sAccess4 = Napi::String::New(env, "minFilter");
      Napi::String sAccess5 = Napi::String::New(env, "mipmapMode");
      Napi::String sAccess6 = Napi::String::New(env, "addressModeU");
      Napi::String sAccess7 = Napi::String::New(env, "addressModeV");
      Napi::String sAccess8 = Napi::String::New(env, "addressModeW");
      Napi::String sAccess9 = Napi::String::New(env, "mipLodBias");
      Napi::String sAccess10 = Napi::String::New(env, "anisotropyEnable");
      Napi::String sAccess11 = Napi::String::New(env, "maxAnisotropy");
      Napi::String sAccess12 = Napi::String::New(env, "compareEnable");
      Napi::String sAccess13 = Napi::String::New(env, "compareOp");
      Napi::String sAccess14 = Napi::String::New(env, "minLod");
      Napi::String sAccess15 = Napi::String::New(env, "maxLod");
      Napi::String sAccess16 = Napi::String::New(env, "borderColor");
      Napi::String sAccess17 = Napi::String::New(env, "unnormalizedCoordinates");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmagFilter(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetminFilter(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetmipmapMode(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetaddressModeU(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetaddressModeV(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetaddressModeW(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetmipLodBias(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetanisotropyEnable(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetmaxAnisotropy(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetcompareEnable(info, obj.Get(sAccess12));
      if (obj.Has(sAccess13)) this->SetcompareOp(info, obj.Get(sAccess13));
      if (obj.Has(sAccess14)) this->SetminLod(info, obj.Get(sAccess14));
      if (obj.Has(sAccess15)) this->SetmaxLod(info, obj.Get(sAccess15));
      if (obj.Has(sAccess16)) this->SetborderColor(info, obj.Get(sAccess16));
      if (obj.Has(sAccess17)) this->SetunnormalizedCoordinates(info, obj.Get(sAccess17));
      
    } else {
      Napi::Error::New(env, "VkSamplerCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSamplerCreateInfo::~_VkSamplerCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkSamplerCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSamplerCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSamplerCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSamplerCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkSamplerCreateInfo::GetsType,
    &_VkSamplerCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkSamplerCreateInfo::GetpNext,
    &_VkSamplerCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSamplerCreateInfo::Getflags,
    &_VkSamplerCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "magFilter",
    &_VkSamplerCreateInfo::GetmagFilter,
    &_VkSamplerCreateInfo::SetmagFilter,
    napi_enumerable
  ),
  InstanceAccessor(
    "minFilter",
    &_VkSamplerCreateInfo::GetminFilter,
    &_VkSamplerCreateInfo::SetminFilter,
    napi_enumerable
  ),
  InstanceAccessor(
    "mipmapMode",
    &_VkSamplerCreateInfo::GetmipmapMode,
    &_VkSamplerCreateInfo::SetmipmapMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "addressModeU",
    &_VkSamplerCreateInfo::GetaddressModeU,
    &_VkSamplerCreateInfo::SetaddressModeU,
    napi_enumerable
  ),
  InstanceAccessor(
    "addressModeV",
    &_VkSamplerCreateInfo::GetaddressModeV,
    &_VkSamplerCreateInfo::SetaddressModeV,
    napi_enumerable
  ),
  InstanceAccessor(
    "addressModeW",
    &_VkSamplerCreateInfo::GetaddressModeW,
    &_VkSamplerCreateInfo::SetaddressModeW,
    napi_enumerable
  ),
  InstanceAccessor(
    "mipLodBias",
    &_VkSamplerCreateInfo::GetmipLodBias,
    &_VkSamplerCreateInfo::SetmipLodBias,
    napi_enumerable
  ),
  InstanceAccessor(
    "anisotropyEnable",
    &_VkSamplerCreateInfo::GetanisotropyEnable,
    &_VkSamplerCreateInfo::SetanisotropyEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxAnisotropy",
    &_VkSamplerCreateInfo::GetmaxAnisotropy,
    &_VkSamplerCreateInfo::SetmaxAnisotropy,
    napi_enumerable
  ),
  InstanceAccessor(
    "compareEnable",
    &_VkSamplerCreateInfo::GetcompareEnable,
    &_VkSamplerCreateInfo::SetcompareEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "compareOp",
    &_VkSamplerCreateInfo::GetcompareOp,
    &_VkSamplerCreateInfo::SetcompareOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "minLod",
    &_VkSamplerCreateInfo::GetminLod,
    &_VkSamplerCreateInfo::SetminLod,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxLod",
    &_VkSamplerCreateInfo::GetmaxLod,
    &_VkSamplerCreateInfo::SetmaxLod,
    napi_enumerable
  ),
  InstanceAccessor(
    "borderColor",
    &_VkSamplerCreateInfo::GetborderColor,
    &_VkSamplerCreateInfo::SetborderColor,
    napi_enumerable
  ),
  InstanceAccessor(
    "unnormalizedCoordinates",
    &_VkSamplerCreateInfo::GetunnormalizedCoordinates,
    &_VkSamplerCreateInfo::SetunnormalizedCoordinates,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSamplerCreateInfo", func);
  return exports;
}

Napi::Value _VkSamplerCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSamplerCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->magFilter));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->magFilter);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->minFilter));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->minFilter);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->mipmapMode));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->mipmapMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->addressModeU));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->addressModeU);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->addressModeV));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->addressModeV);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->addressModeW));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->addressModeW);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->mipLodBias));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->mipLodBias);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->anisotropyEnable));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->anisotropyEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->maxAnisotropy));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->maxAnisotropy);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->compareEnable));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->compareEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->compareOp));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->compareOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->minLod));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->minLod);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->maxLod));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->maxLod);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->borderColor));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->borderColor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSamplerCreateInfo *)0)->unnormalizedCoordinates));
    uint32_t byteLength = sizeof(((VkSamplerCreateInfo *)0)->unnormalizedCoordinates);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSamplerCreateInfo::flush() {
  _VkSamplerCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO) {
      _VkSamplerYcbcrConversionInfo* structExt = Napi::ObjectWrap<_VkSamplerYcbcrConversionInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT) {
      _VkSamplerReductionModeCreateInfoEXT* structExt = Napi::ObjectWrap<_VkSamplerReductionModeCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkSamplerCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkSamplerCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkSamplerCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkSamplerCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO &&
        sType != VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkSamplerCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkSamplerCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkSamplerCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSamplerCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSamplerCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.flags", "Number");
  
    return;
  }
}// magFilter
Napi::Value _VkSamplerCreateInfo::GetmagFilter(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.magFilter);
}void _VkSamplerCreateInfo::SetmagFilter(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.magFilter = static_cast<VkFilter>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.magFilter", "Number");
  
    return;
  }
}// minFilter
Napi::Value _VkSamplerCreateInfo::GetminFilter(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minFilter);
}void _VkSamplerCreateInfo::SetminFilter(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minFilter = static_cast<VkFilter>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.minFilter", "Number");
  
    return;
  }
}// mipmapMode
Napi::Value _VkSamplerCreateInfo::GetmipmapMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mipmapMode);
}void _VkSamplerCreateInfo::SetmipmapMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mipmapMode = static_cast<VkSamplerMipmapMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.mipmapMode", "Number");
  
    return;
  }
}// addressModeU
Napi::Value _VkSamplerCreateInfo::GetaddressModeU(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.addressModeU);
}void _VkSamplerCreateInfo::SetaddressModeU(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.addressModeU = static_cast<VkSamplerAddressMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.addressModeU", "Number");
  
    return;
  }
}// addressModeV
Napi::Value _VkSamplerCreateInfo::GetaddressModeV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.addressModeV);
}void _VkSamplerCreateInfo::SetaddressModeV(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.addressModeV = static_cast<VkSamplerAddressMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.addressModeV", "Number");
  
    return;
  }
}// addressModeW
Napi::Value _VkSamplerCreateInfo::GetaddressModeW(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.addressModeW);
}void _VkSamplerCreateInfo::SetaddressModeW(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.addressModeW = static_cast<VkSamplerAddressMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.addressModeW", "Number");
  
    return;
  }
}// mipLodBias
Napi::Value _VkSamplerCreateInfo::GetmipLodBias(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mipLodBias);
}void _VkSamplerCreateInfo::SetmipLodBias(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mipLodBias = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.mipLodBias", "Number");
  
    return;
  }
}// anisotropyEnable
Napi::Value _VkSamplerCreateInfo::GetanisotropyEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.anisotropyEnable);
}void _VkSamplerCreateInfo::SetanisotropyEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.anisotropyEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.anisotropyEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.anisotropyEnable", "Number");
  
    return;
  }
}// maxAnisotropy
Napi::Value _VkSamplerCreateInfo::GetmaxAnisotropy(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxAnisotropy);
}void _VkSamplerCreateInfo::SetmaxAnisotropy(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxAnisotropy = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.maxAnisotropy", "Number");
  
    return;
  }
}// compareEnable
Napi::Value _VkSamplerCreateInfo::GetcompareEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compareEnable);
}void _VkSamplerCreateInfo::SetcompareEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.compareEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.compareEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.compareEnable", "Number");
  
    return;
  }
}// compareOp
Napi::Value _VkSamplerCreateInfo::GetcompareOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compareOp);
}void _VkSamplerCreateInfo::SetcompareOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.compareOp = static_cast<VkCompareOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.compareOp", "Number");
  
    return;
  }
}// minLod
Napi::Value _VkSamplerCreateInfo::GetminLod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minLod);
}void _VkSamplerCreateInfo::SetminLod(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minLod = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.minLod", "Number");
  
    return;
  }
}// maxLod
Napi::Value _VkSamplerCreateInfo::GetmaxLod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxLod);
}void _VkSamplerCreateInfo::SetmaxLod(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxLod = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.maxLod", "Number");
  
    return;
  }
}// borderColor
Napi::Value _VkSamplerCreateInfo::GetborderColor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.borderColor);
}void _VkSamplerCreateInfo::SetborderColor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.borderColor = static_cast<VkBorderColor>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.borderColor", "Number");
  
    return;
  }
}// unnormalizedCoordinates
Napi::Value _VkSamplerCreateInfo::GetunnormalizedCoordinates(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.unnormalizedCoordinates);
}void _VkSamplerCreateInfo::SetunnormalizedCoordinates(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.unnormalizedCoordinates = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.unnormalizedCoordinates = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkSamplerCreateInfo.unnormalizedCoordinates", "Number");
  
    return;
  }
}
/** ## END VkSamplerCreateInfo ## **/

/** ## BEGIN VkPipelineLayoutCreateInfo ## **/

Napi::FunctionReference _VkPipelineLayoutCreateInfo::constructor;

_VkPipelineLayoutCreateInfo::_VkPipelineLayoutCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineLayoutCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    vpSetLayouts = new std::vector<VkDescriptorSetLayout>;
    vpPushConstantRanges = new std::vector<VkPushConstantRange>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "setLayoutCount");
      Napi::String sAccess4 = Napi::String::New(env, "pSetLayouts");
      Napi::String sAccess5 = Napi::String::New(env, "pushConstantRangeCount");
      Napi::String sAccess6 = Napi::String::New(env, "pPushConstantRanges");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetsetLayoutCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpSetLayouts(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpushConstantRangeCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpPushConstantRanges(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPipelineLayoutCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineLayoutCreateInfo::~_VkPipelineLayoutCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpSetLayouts->clear();
  delete vpSetLayouts;
  
  pSetLayouts.Reset();
  
  
  vpPushConstantRanges->clear();
  delete vpPushConstantRanges;
  
  pPushConstantRanges.Reset();
  
}

Napi::Object _VkPipelineLayoutCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineLayoutCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineLayoutCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineLayoutCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineLayoutCreateInfo::GetsType,
    &_VkPipelineLayoutCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineLayoutCreateInfo::GetpNext,
    &_VkPipelineLayoutCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineLayoutCreateInfo::Getflags,
    &_VkPipelineLayoutCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "setLayoutCount",
    &_VkPipelineLayoutCreateInfo::GetsetLayoutCount,
    &_VkPipelineLayoutCreateInfo::SetsetLayoutCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSetLayouts",
    &_VkPipelineLayoutCreateInfo::GetpSetLayouts,
    &_VkPipelineLayoutCreateInfo::SetpSetLayouts,
    napi_enumerable
  ),
  InstanceAccessor(
    "pushConstantRangeCount",
    &_VkPipelineLayoutCreateInfo::GetpushConstantRangeCount,
    &_VkPipelineLayoutCreateInfo::SetpushConstantRangeCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPushConstantRanges",
    &_VkPipelineLayoutCreateInfo::GetpPushConstantRanges,
    &_VkPipelineLayoutCreateInfo::SetpPushConstantRanges,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineLayoutCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineLayoutCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineLayoutCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->setLayoutCount));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->setLayoutCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->pSetLayouts));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->pSetLayouts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->pushConstantRangeCount));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->pushConstantRangeCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineLayoutCreateInfo *)0)->pPushConstantRanges));
    uint32_t byteLength = sizeof(((VkPipelineLayoutCreateInfo *)0)->pPushConstantRanges);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineLayoutCreateInfo::flush() {
  _VkPipelineLayoutCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pSetLayouts.IsEmpty())) {
    Napi::Value value = self->pSetLayouts.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.setLayoutCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'setLayoutCount' for 'VkPipelineLayoutCreateInfo.pSetLayouts'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorSetLayout>* data = this->vpSetLayouts;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorSetLayout::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
        return false;
      }
      _VkDescriptorSetLayout* result = Napi::ObjectWrap<_VkDescriptorSetLayout>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSetLayouts = data->data();
  }if (!(self->pPushConstantRanges.IsEmpty())) {
    Napi::Value value = self->pPushConstantRanges.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.pushConstantRangeCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'pushConstantRangeCount' for 'VkPipelineLayoutCreateInfo.pPushConstantRanges'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPushConstantRange>* data = this->vpPushConstantRanges;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPushConstantRange::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pPushConstantRanges", "[object VkPushConstantRange]");
  
        return false;
      }
      _VkPushConstantRange* result = Napi::ObjectWrap<_VkPushConstantRange>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPushConstantRanges = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineLayoutCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineLayoutCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineLayoutCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineLayoutCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineLayoutCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineLayoutCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineLayoutCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineLayoutCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.flags", "Number");
  
    return;
  }
}// setLayoutCount
Napi::Value _VkPipelineLayoutCreateInfo::GetsetLayoutCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.setLayoutCount);
}void _VkPipelineLayoutCreateInfo::SetsetLayoutCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.setLayoutCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.setLayoutCount", "Number");
  
    return;
  }
}// pSetLayouts
Napi::Value _VkPipelineLayoutCreateInfo::GetpSetLayouts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSetLayouts.IsEmpty()) return env.Null();
  return this->pSetLayouts.Value().As<Napi::Array>();
}void _VkPipelineLayoutCreateInfo::SetpSetLayouts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSetLayouts.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSetLayouts.Reset();
      this->instance.pSetLayouts = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSetLayouts = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
    return;
  }
}// pushConstantRangeCount
Napi::Value _VkPipelineLayoutCreateInfo::GetpushConstantRangeCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.pushConstantRangeCount);
}void _VkPipelineLayoutCreateInfo::SetpushConstantRangeCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.pushConstantRangeCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pushConstantRangeCount", "Number");
  
    return;
  }
}// pPushConstantRanges
Napi::Value _VkPipelineLayoutCreateInfo::GetpPushConstantRanges(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPushConstantRanges.IsEmpty()) return env.Null();
  return this->pPushConstantRanges.Value().As<Napi::Array>();
}void _VkPipelineLayoutCreateInfo::SetpPushConstantRanges(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pPushConstantRanges.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pPushConstantRanges.Reset();
      this->instance.pPushConstantRanges = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pPushConstantRanges", "[object VkPushConstantRange]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pPushConstantRanges = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineLayoutCreateInfo.pPushConstantRanges", "[object VkPushConstantRange]");
  
    return;
  }
}
/** ## END VkPipelineLayoutCreateInfo ## **/

/** ## BEGIN VkPushConstantRange ## **/

Napi::FunctionReference _VkPushConstantRange::constructor;

_VkPushConstantRange::_VkPushConstantRange(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPushConstantRange>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "stageFlags");
      Napi::String sAccess1 = Napi::String::New(env, "offset");
      Napi::String sAccess2 = Napi::String::New(env, "size");
      if (obj.Has(sAccess0)) this->SetstageFlags(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setoffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsize(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkPushConstantRange constructor cannot be invoked without 'new'");
    }
  }
}

_VkPushConstantRange::~_VkPushConstantRange() {
  
  
  
  
}

Napi::Object _VkPushConstantRange::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPushConstantRange", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPushConstantRange::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPushConstantRange::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "stageFlags",
    &_VkPushConstantRange::GetstageFlags,
    &_VkPushConstantRange::SetstageFlags,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkPushConstantRange::Getoffset,
    &_VkPushConstantRange::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkPushConstantRange::Getsize,
    &_VkPushConstantRange::Setsize,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPushConstantRange", func);
  return exports;
}

Napi::Value _VkPushConstantRange::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPushConstantRange::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPushConstantRange *)0)->stageFlags));
    uint32_t byteLength = sizeof(((VkPushConstantRange *)0)->stageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPushConstantRange *)0)->offset));
    uint32_t byteLength = sizeof(((VkPushConstantRange *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPushConstantRange *)0)->size));
    uint32_t byteLength = sizeof(((VkPushConstantRange *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPushConstantRange::flush() {
  _VkPushConstantRange *self = this;
  
  return true;
}

// stageFlags
Napi::Value _VkPushConstantRange::GetstageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stageFlags);
}void _VkPushConstantRange::SetstageFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stageFlags = static_cast<VkShaderStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPushConstantRange.stageFlags", "Number");
  
    return;
  }
}// offset
Napi::Value _VkPushConstantRange::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkPushConstantRange::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPushConstantRange.offset", "Number");
  
    return;
  }
}// size
Napi::Value _VkPushConstantRange::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkPushConstantRange::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPushConstantRange.size", "Number");
  
    return;
  }
}
/** ## END VkPushConstantRange ## **/

/** ## BEGIN VkPipelineCacheCreateInfo ## **/

Napi::FunctionReference _VkPipelineCacheCreateInfo::constructor;

_VkPipelineCacheCreateInfo::_VkPipelineCacheCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineCacheCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "initialDataSize");
      Napi::String sAccess4 = Napi::String::New(env, "pInitialData");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetinitialDataSize(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpInitialData(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineCacheCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineCacheCreateInfo::~_VkPipelineCacheCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  pInitialData.Reset();
  
}

Napi::Object _VkPipelineCacheCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineCacheCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineCacheCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineCacheCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineCacheCreateInfo::GetsType,
    &_VkPipelineCacheCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineCacheCreateInfo::GetpNext,
    &_VkPipelineCacheCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineCacheCreateInfo::Getflags,
    &_VkPipelineCacheCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "initialDataSize",
    &_VkPipelineCacheCreateInfo::GetinitialDataSize,
    &_VkPipelineCacheCreateInfo::SetinitialDataSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "pInitialData",
    &_VkPipelineCacheCreateInfo::GetpInitialData,
    &_VkPipelineCacheCreateInfo::SetpInitialData,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineCacheCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineCacheCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineCacheCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCacheCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineCacheCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCacheCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineCacheCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCacheCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineCacheCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCacheCreateInfo *)0)->initialDataSize));
    uint32_t byteLength = sizeof(((VkPipelineCacheCreateInfo *)0)->initialDataSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineCacheCreateInfo *)0)->pInitialData));
    uint32_t byteLength = sizeof(((VkPipelineCacheCreateInfo *)0)->pInitialData);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineCacheCreateInfo::flush() {
  _VkPipelineCacheCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineCacheCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineCacheCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCacheCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineCacheCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineCacheCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineCacheCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineCacheCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCacheCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineCacheCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineCacheCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineCacheCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCacheCreateInfo.flags", "Number");
  
    return;
  }
}// initialDataSize
Napi::Value _VkPipelineCacheCreateInfo::GetinitialDataSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.initialDataSize);
}void _VkPipelineCacheCreateInfo::SetinitialDataSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.initialDataSize = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCacheCreateInfo.initialDataSize", "Number");
  
    return;
  }
}// pInitialData
Napi::Value _VkPipelineCacheCreateInfo::GetpInitialData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pInitialData.IsEmpty()) return env.Null();
  return this->pInitialData.Value().As<Napi::Object>();
}void _VkPipelineCacheCreateInfo::SetpInitialData(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pInitialData = buffer.Data();
    this->pInitialData.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pInitialData = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineCacheCreateInfo.pInitialData", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkPipelineCacheCreateInfo ## **/

/** ## BEGIN VkGraphicsPipelineCreateInfo ## **/

Napi::FunctionReference _VkGraphicsPipelineCreateInfo::constructor;

_VkGraphicsPipelineCreateInfo::_VkGraphicsPipelineCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkGraphicsPipelineCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    vpStages = new std::vector<VkPipelineShaderStageCreateInfo>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "stageCount");
      Napi::String sAccess4 = Napi::String::New(env, "pStages");
      Napi::String sAccess5 = Napi::String::New(env, "pVertexInputState");
      Napi::String sAccess6 = Napi::String::New(env, "pInputAssemblyState");
      Napi::String sAccess7 = Napi::String::New(env, "pTessellationState");
      Napi::String sAccess8 = Napi::String::New(env, "pViewportState");
      Napi::String sAccess9 = Napi::String::New(env, "pRasterizationState");
      Napi::String sAccess10 = Napi::String::New(env, "pMultisampleState");
      Napi::String sAccess11 = Napi::String::New(env, "pDepthStencilState");
      Napi::String sAccess12 = Napi::String::New(env, "pColorBlendState");
      Napi::String sAccess13 = Napi::String::New(env, "pDynamicState");
      Napi::String sAccess14 = Napi::String::New(env, "layout");
      Napi::String sAccess15 = Napi::String::New(env, "renderPass");
      Napi::String sAccess16 = Napi::String::New(env, "subpass");
      Napi::String sAccess17 = Napi::String::New(env, "basePipelineHandle");
      Napi::String sAccess18 = Napi::String::New(env, "basePipelineIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetstageCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpStages(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpVertexInputState(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpInputAssemblyState(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpTessellationState(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpViewportState(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpRasterizationState(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetpMultisampleState(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetpDepthStencilState(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetpColorBlendState(info, obj.Get(sAccess12));
      if (obj.Has(sAccess13)) this->SetpDynamicState(info, obj.Get(sAccess13));
      if (obj.Has(sAccess14)) this->Setlayout(info, obj.Get(sAccess14));
      if (obj.Has(sAccess15)) this->SetrenderPass(info, obj.Get(sAccess15));
      if (obj.Has(sAccess16)) this->Setsubpass(info, obj.Get(sAccess16));
      if (obj.Has(sAccess17)) this->SetbasePipelineHandle(info, obj.Get(sAccess17));
      if (obj.Has(sAccess18)) this->SetbasePipelineIndex(info, obj.Get(sAccess18));
      
    } else {
      Napi::Error::New(env, "VkGraphicsPipelineCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkGraphicsPipelineCreateInfo::~_VkGraphicsPipelineCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpStages->clear();
  delete vpStages;
  
  pStages.Reset();
  
  pVertexInputState.Reset();
  
  pInputAssemblyState.Reset();
  
  pTessellationState.Reset();
  
  pViewportState.Reset();
  
  pRasterizationState.Reset();
  
  pMultisampleState.Reset();
  
  pDepthStencilState.Reset();
  
  pColorBlendState.Reset();
  
  pDynamicState.Reset();
  
  layout.Reset();
  
  renderPass.Reset();
  
  
  basePipelineHandle.Reset();
  
  
}

Napi::Object _VkGraphicsPipelineCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkGraphicsPipelineCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkGraphicsPipelineCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkGraphicsPipelineCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkGraphicsPipelineCreateInfo::GetsType,
    &_VkGraphicsPipelineCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkGraphicsPipelineCreateInfo::GetpNext,
    &_VkGraphicsPipelineCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkGraphicsPipelineCreateInfo::Getflags,
    &_VkGraphicsPipelineCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "stageCount",
    &_VkGraphicsPipelineCreateInfo::GetstageCount,
    &_VkGraphicsPipelineCreateInfo::SetstageCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pStages",
    &_VkGraphicsPipelineCreateInfo::GetpStages,
    &_VkGraphicsPipelineCreateInfo::SetpStages,
    napi_enumerable
  ),
  InstanceAccessor(
    "pVertexInputState",
    &_VkGraphicsPipelineCreateInfo::GetpVertexInputState,
    &_VkGraphicsPipelineCreateInfo::SetpVertexInputState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pInputAssemblyState",
    &_VkGraphicsPipelineCreateInfo::GetpInputAssemblyState,
    &_VkGraphicsPipelineCreateInfo::SetpInputAssemblyState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pTessellationState",
    &_VkGraphicsPipelineCreateInfo::GetpTessellationState,
    &_VkGraphicsPipelineCreateInfo::SetpTessellationState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewportState",
    &_VkGraphicsPipelineCreateInfo::GetpViewportState,
    &_VkGraphicsPipelineCreateInfo::SetpViewportState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pRasterizationState",
    &_VkGraphicsPipelineCreateInfo::GetpRasterizationState,
    &_VkGraphicsPipelineCreateInfo::SetpRasterizationState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pMultisampleState",
    &_VkGraphicsPipelineCreateInfo::GetpMultisampleState,
    &_VkGraphicsPipelineCreateInfo::SetpMultisampleState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDepthStencilState",
    &_VkGraphicsPipelineCreateInfo::GetpDepthStencilState,
    &_VkGraphicsPipelineCreateInfo::SetpDepthStencilState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pColorBlendState",
    &_VkGraphicsPipelineCreateInfo::GetpColorBlendState,
    &_VkGraphicsPipelineCreateInfo::SetpColorBlendState,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDynamicState",
    &_VkGraphicsPipelineCreateInfo::GetpDynamicState,
    &_VkGraphicsPipelineCreateInfo::SetpDynamicState,
    napi_enumerable
  ),
  InstanceAccessor(
    "layout",
    &_VkGraphicsPipelineCreateInfo::Getlayout,
    &_VkGraphicsPipelineCreateInfo::Setlayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "renderPass",
    &_VkGraphicsPipelineCreateInfo::GetrenderPass,
    &_VkGraphicsPipelineCreateInfo::SetrenderPass,
    napi_enumerable
  ),
  InstanceAccessor(
    "subpass",
    &_VkGraphicsPipelineCreateInfo::Getsubpass,
    &_VkGraphicsPipelineCreateInfo::Setsubpass,
    napi_enumerable
  ),
  InstanceAccessor(
    "basePipelineHandle",
    &_VkGraphicsPipelineCreateInfo::GetbasePipelineHandle,
    &_VkGraphicsPipelineCreateInfo::SetbasePipelineHandle,
    napi_enumerable
  ),
  InstanceAccessor(
    "basePipelineIndex",
    &_VkGraphicsPipelineCreateInfo::GetbasePipelineIndex,
    &_VkGraphicsPipelineCreateInfo::SetbasePipelineIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkGraphicsPipelineCreateInfo", func);
  return exports;
}

Napi::Value _VkGraphicsPipelineCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkGraphicsPipelineCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->stageCount));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->stageCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pStages));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pStages);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pVertexInputState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pVertexInputState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pInputAssemblyState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pInputAssemblyState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pTessellationState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pTessellationState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pViewportState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pViewportState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pRasterizationState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pRasterizationState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pMultisampleState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pMultisampleState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pDepthStencilState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pDepthStencilState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pColorBlendState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pColorBlendState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->pDynamicState));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->pDynamicState);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->layout));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->layout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->renderPass));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->renderPass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->subpass));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->subpass);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->basePipelineHandle));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->basePipelineHandle);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkGraphicsPipelineCreateInfo *)0)->basePipelineIndex));
    uint32_t byteLength = sizeof(((VkGraphicsPipelineCreateInfo *)0)->basePipelineIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkGraphicsPipelineCreateInfo::flush() {
  _VkGraphicsPipelineCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT) {
      _VkPipelineDiscardRectangleStateCreateInfoEXT* structExt = Napi::ObjectWrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pStages.IsEmpty())) {
    Napi::Value value = self->pStages.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.stageCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'stageCount' for 'VkGraphicsPipelineCreateInfo.pStages'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPipelineShaderStageCreateInfo>* data = this->vpStages;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPipelineShaderStageCreateInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
        return false;
      }
      _VkPipelineShaderStageCreateInfo* result = Napi::ObjectWrap<_VkPipelineShaderStageCreateInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pStages = data->data();
  }
  return true;
}

// sType
Napi::Value _VkGraphicsPipelineCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkGraphicsPipelineCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkGraphicsPipelineCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkGraphicsPipelineCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkGraphicsPipelineCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.flags", "Number");
  
    return;
  }
}// stageCount
Napi::Value _VkGraphicsPipelineCreateInfo::GetstageCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stageCount);
}void _VkGraphicsPipelineCreateInfo::SetstageCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stageCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.stageCount", "Number");
  
    return;
  }
}// pStages
Napi::Value _VkGraphicsPipelineCreateInfo::GetpStages(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pStages.IsEmpty()) return env.Null();
  return this->pStages.Value().As<Napi::Array>();
}void _VkGraphicsPipelineCreateInfo::SetpStages(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pStages.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pStages.Reset();
      this->instance.pStages = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pStages = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
    return;
  }
}// pVertexInputState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpVertexInputState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pVertexInputState.IsEmpty()) return env.Null();
  return this->pVertexInputState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpVertexInputState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineVertexInputStateCreateInfo::constructor.Value())) {
      
      this->pVertexInputState.Reset(value.ToObject(), 1);
      _VkPipelineVertexInputStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineVertexInputStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pVertexInputState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pVertexInputState", "[object VkPipelineVertexInputStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pVertexInputState.Reset();
    this->instance.pVertexInputState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pVertexInputState", "[object VkPipelineVertexInputStateCreateInfo]");
  
    return;
  }
}// pInputAssemblyState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpInputAssemblyState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pInputAssemblyState.IsEmpty()) return env.Null();
  return this->pInputAssemblyState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpInputAssemblyState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineInputAssemblyStateCreateInfo::constructor.Value())) {
      
      this->pInputAssemblyState.Reset(value.ToObject(), 1);
      _VkPipelineInputAssemblyStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineInputAssemblyStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pInputAssemblyState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pInputAssemblyState", "[object VkPipelineInputAssemblyStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pInputAssemblyState.Reset();
    this->instance.pInputAssemblyState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pInputAssemblyState", "[object VkPipelineInputAssemblyStateCreateInfo]");
  
    return;
  }
}// pTessellationState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpTessellationState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pTessellationState.IsEmpty()) return env.Null();
  return this->pTessellationState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpTessellationState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineTessellationStateCreateInfo::constructor.Value())) {
      
      this->pTessellationState.Reset(value.ToObject(), 1);
      _VkPipelineTessellationStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineTessellationStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pTessellationState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pTessellationState", "[object VkPipelineTessellationStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pTessellationState.Reset();
    this->instance.pTessellationState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pTessellationState", "[object VkPipelineTessellationStateCreateInfo]");
  
    return;
  }
}// pViewportState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpViewportState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewportState.IsEmpty()) return env.Null();
  return this->pViewportState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpViewportState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineViewportStateCreateInfo::constructor.Value())) {
      
      this->pViewportState.Reset(value.ToObject(), 1);
      _VkPipelineViewportStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineViewportStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pViewportState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pViewportState", "[object VkPipelineViewportStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pViewportState.Reset();
    this->instance.pViewportState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pViewportState", "[object VkPipelineViewportStateCreateInfo]");
  
    return;
  }
}// pRasterizationState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpRasterizationState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pRasterizationState.IsEmpty()) return env.Null();
  return this->pRasterizationState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpRasterizationState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineRasterizationStateCreateInfo::constructor.Value())) {
      
      this->pRasterizationState.Reset(value.ToObject(), 1);
      _VkPipelineRasterizationStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineRasterizationStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pRasterizationState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pRasterizationState", "[object VkPipelineRasterizationStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pRasterizationState.Reset();
    this->instance.pRasterizationState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pRasterizationState", "[object VkPipelineRasterizationStateCreateInfo]");
  
    return;
  }
}// pMultisampleState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpMultisampleState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pMultisampleState.IsEmpty()) return env.Null();
  return this->pMultisampleState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpMultisampleState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineMultisampleStateCreateInfo::constructor.Value())) {
      
      this->pMultisampleState.Reset(value.ToObject(), 1);
      _VkPipelineMultisampleStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineMultisampleStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pMultisampleState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pMultisampleState", "[object VkPipelineMultisampleStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pMultisampleState.Reset();
    this->instance.pMultisampleState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pMultisampleState", "[object VkPipelineMultisampleStateCreateInfo]");
  
    return;
  }
}// pDepthStencilState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpDepthStencilState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDepthStencilState.IsEmpty()) return env.Null();
  return this->pDepthStencilState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpDepthStencilState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineDepthStencilStateCreateInfo::constructor.Value())) {
      
      this->pDepthStencilState.Reset(value.ToObject(), 1);
      _VkPipelineDepthStencilStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineDepthStencilStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pDepthStencilState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pDepthStencilState", "[object VkPipelineDepthStencilStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pDepthStencilState.Reset();
    this->instance.pDepthStencilState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pDepthStencilState", "[object VkPipelineDepthStencilStateCreateInfo]");
  
    return;
  }
}// pColorBlendState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpColorBlendState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pColorBlendState.IsEmpty()) return env.Null();
  return this->pColorBlendState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpColorBlendState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineColorBlendStateCreateInfo::constructor.Value())) {
      
      this->pColorBlendState.Reset(value.ToObject(), 1);
      _VkPipelineColorBlendStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineColorBlendStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pColorBlendState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pColorBlendState", "[object VkPipelineColorBlendStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pColorBlendState.Reset();
    this->instance.pColorBlendState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pColorBlendState", "[object VkPipelineColorBlendStateCreateInfo]");
  
    return;
  }
}// pDynamicState
Napi::Value _VkGraphicsPipelineCreateInfo::GetpDynamicState(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDynamicState.IsEmpty()) return env.Null();
  return this->pDynamicState.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetpDynamicState(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineDynamicStateCreateInfo::constructor.Value())) {
      
      this->pDynamicState.Reset(value.ToObject(), 1);
      _VkPipelineDynamicStateCreateInfo* inst = Napi::ObjectWrap<_VkPipelineDynamicStateCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pDynamicState = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pDynamicState", "[object VkPipelineDynamicStateCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pDynamicState.Reset();
    this->instance.pDynamicState = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.pDynamicState", "[object VkPipelineDynamicStateCreateInfo]");
  
    return;
  }
}// layout
Napi::Value _VkGraphicsPipelineCreateInfo::Getlayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->layout.IsEmpty()) return env.Null();
  return this->layout.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::Setlayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineLayout::constructor.Value())) {
      
      this->layout.Reset(value.ToObject(), 1);
      _VkPipelineLayout* inst = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
      ;
      this->instance.layout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->layout.Reset();
    this->instance.layout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
    return;
  }
}// renderPass
Napi::Value _VkGraphicsPipelineCreateInfo::GetrenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->renderPass.IsEmpty()) return env.Null();
  return this->renderPass.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetrenderPass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRenderPass::constructor.Value())) {
      
      this->renderPass.Reset(value.ToObject(), 1);
      _VkRenderPass* inst = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
      ;
      this->instance.renderPass = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->renderPass.Reset();
    this->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// subpass
Napi::Value _VkGraphicsPipelineCreateInfo::Getsubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.subpass);
}void _VkGraphicsPipelineCreateInfo::Setsubpass(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.subpass = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.subpass", "Number");
  
    return;
  }
}// basePipelineHandle
Napi::Value _VkGraphicsPipelineCreateInfo::GetbasePipelineHandle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->basePipelineHandle.IsEmpty()) return env.Null();
  return this->basePipelineHandle.Value().As<Napi::Object>();
}void _VkGraphicsPipelineCreateInfo::SetbasePipelineHandle(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipeline::constructor.Value())) {
      
      this->basePipelineHandle.Reset(value.ToObject(), 1);
      _VkPipeline* inst = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      ;
      this->instance.basePipelineHandle = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->basePipelineHandle.Reset();
    this->instance.basePipelineHandle = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
    return;
  }
}// basePipelineIndex
Napi::Value _VkGraphicsPipelineCreateInfo::GetbasePipelineIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.basePipelineIndex);
}void _VkGraphicsPipelineCreateInfo::SetbasePipelineIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.basePipelineIndex = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkGraphicsPipelineCreateInfo.basePipelineIndex", "Number");
  
    return;
  }
}
/** ## END VkGraphicsPipelineCreateInfo ## **/

/** ## BEGIN VkPipelineDepthStencilStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineDepthStencilStateCreateInfo::constructor;

_VkPipelineDepthStencilStateCreateInfo::_VkPipelineDepthStencilStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineDepthStencilStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "depthTestEnable");
      Napi::String sAccess4 = Napi::String::New(env, "depthWriteEnable");
      Napi::String sAccess5 = Napi::String::New(env, "depthCompareOp");
      Napi::String sAccess6 = Napi::String::New(env, "depthBoundsTestEnable");
      Napi::String sAccess7 = Napi::String::New(env, "stencilTestEnable");
      Napi::String sAccess8 = Napi::String::New(env, "front");
      Napi::String sAccess9 = Napi::String::New(env, "back");
      Napi::String sAccess10 = Napi::String::New(env, "minDepthBounds");
      Napi::String sAccess11 = Napi::String::New(env, "maxDepthBounds");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdepthTestEnable(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetdepthWriteEnable(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdepthCompareOp(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdepthBoundsTestEnable(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetstencilTestEnable(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->Setfront(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->Setback(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetminDepthBounds(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetmaxDepthBounds(info, obj.Get(sAccess11));
      
    } else {
      Napi::Error::New(env, "VkPipelineDepthStencilStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineDepthStencilStateCreateInfo::~_VkPipelineDepthStencilStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  front.Reset();
  
  back.Reset();
  
  
  
}

Napi::Object _VkPipelineDepthStencilStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineDepthStencilStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineDepthStencilStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineDepthStencilStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineDepthStencilStateCreateInfo::GetsType,
    &_VkPipelineDepthStencilStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineDepthStencilStateCreateInfo::GetpNext,
    &_VkPipelineDepthStencilStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineDepthStencilStateCreateInfo::Getflags,
    &_VkPipelineDepthStencilStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthTestEnable",
    &_VkPipelineDepthStencilStateCreateInfo::GetdepthTestEnable,
    &_VkPipelineDepthStencilStateCreateInfo::SetdepthTestEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthWriteEnable",
    &_VkPipelineDepthStencilStateCreateInfo::GetdepthWriteEnable,
    &_VkPipelineDepthStencilStateCreateInfo::SetdepthWriteEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthCompareOp",
    &_VkPipelineDepthStencilStateCreateInfo::GetdepthCompareOp,
    &_VkPipelineDepthStencilStateCreateInfo::SetdepthCompareOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBoundsTestEnable",
    &_VkPipelineDepthStencilStateCreateInfo::GetdepthBoundsTestEnable,
    &_VkPipelineDepthStencilStateCreateInfo::SetdepthBoundsTestEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "stencilTestEnable",
    &_VkPipelineDepthStencilStateCreateInfo::GetstencilTestEnable,
    &_VkPipelineDepthStencilStateCreateInfo::SetstencilTestEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "front",
    &_VkPipelineDepthStencilStateCreateInfo::Getfront,
    &_VkPipelineDepthStencilStateCreateInfo::Setfront,
    napi_enumerable
  ),
  InstanceAccessor(
    "back",
    &_VkPipelineDepthStencilStateCreateInfo::Getback,
    &_VkPipelineDepthStencilStateCreateInfo::Setback,
    napi_enumerable
  ),
  InstanceAccessor(
    "minDepthBounds",
    &_VkPipelineDepthStencilStateCreateInfo::GetminDepthBounds,
    &_VkPipelineDepthStencilStateCreateInfo::SetminDepthBounds,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDepthBounds",
    &_VkPipelineDepthStencilStateCreateInfo::GetmaxDepthBounds,
    &_VkPipelineDepthStencilStateCreateInfo::SetmaxDepthBounds,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineDepthStencilStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->depthTestEnable));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->depthTestEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->depthWriteEnable));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->depthWriteEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->depthCompareOp));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->depthCompareOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->depthBoundsTestEnable));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->depthBoundsTestEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->stencilTestEnable));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->stencilTestEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->front));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->front);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->back));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->back);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->minDepthBounds));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->minDepthBounds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDepthStencilStateCreateInfo *)0)->maxDepthBounds));
    uint32_t byteLength = sizeof(((VkPipelineDepthStencilStateCreateInfo *)0)->maxDepthBounds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineDepthStencilStateCreateInfo::flush() {
  _VkPipelineDepthStencilStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->front.IsEmpty())) {
    Napi::Value value = self->front.Value();
    
    _VkStencilOpState* result = Napi::ObjectWrap<_VkStencilOpState>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.front = result->instance;
  }if (!(self->back.IsEmpty())) {
    Napi::Value value = self->back.Value();
    
    _VkStencilOpState* result = Napi::ObjectWrap<_VkStencilOpState>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.back = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineDepthStencilStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineDepthStencilStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineDepthStencilStateCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineDepthStencilStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineDepthStencilStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineDepthStencilStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.flags", "Number");
  
    return;
  }
}// depthTestEnable
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetdepthTestEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthTestEnable);
}void _VkPipelineDepthStencilStateCreateInfo::SetdepthTestEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthTestEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthTestEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthTestEnable", "Number");
  
    return;
  }
}// depthWriteEnable
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetdepthWriteEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthWriteEnable);
}void _VkPipelineDepthStencilStateCreateInfo::SetdepthWriteEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthWriteEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthWriteEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthWriteEnable", "Number");
  
    return;
  }
}// depthCompareOp
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetdepthCompareOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthCompareOp);
}void _VkPipelineDepthStencilStateCreateInfo::SetdepthCompareOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depthCompareOp = static_cast<VkCompareOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthCompareOp", "Number");
  
    return;
  }
}// depthBoundsTestEnable
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetdepthBoundsTestEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBoundsTestEnable);
}void _VkPipelineDepthStencilStateCreateInfo::SetdepthBoundsTestEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthBoundsTestEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthBoundsTestEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthBoundsTestEnable", "Number");
  
    return;
  }
}// stencilTestEnable
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetstencilTestEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stencilTestEnable);
}void _VkPipelineDepthStencilStateCreateInfo::SetstencilTestEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.stencilTestEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.stencilTestEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.stencilTestEnable", "Number");
  
    return;
  }
}// front
Napi::Value _VkPipelineDepthStencilStateCreateInfo::Getfront(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->front.IsEmpty()) return env.Null();
  return this->front.Value().As<Napi::Object>();
}void _VkPipelineDepthStencilStateCreateInfo::Setfront(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkStencilOpState::constructor.Value())) {
      
      this->front.Reset(value.ToObject(), 1);
      _VkStencilOpState* inst = Napi::ObjectWrap<_VkStencilOpState>::Unwrap(obj);
      inst->flush();
      this->instance.front = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.front", "[object VkStencilOpState]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->front.Reset();
    memset(&this->instance.front, 0, sizeof(VkStencilOpState));
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.front", "[object VkStencilOpState]");
  
    return;
  }
}// back
Napi::Value _VkPipelineDepthStencilStateCreateInfo::Getback(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->back.IsEmpty()) return env.Null();
  return this->back.Value().As<Napi::Object>();
}void _VkPipelineDepthStencilStateCreateInfo::Setback(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkStencilOpState::constructor.Value())) {
      
      this->back.Reset(value.ToObject(), 1);
      _VkStencilOpState* inst = Napi::ObjectWrap<_VkStencilOpState>::Unwrap(obj);
      inst->flush();
      this->instance.back = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.back", "[object VkStencilOpState]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->back.Reset();
    memset(&this->instance.back, 0, sizeof(VkStencilOpState));
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.back", "[object VkStencilOpState]");
  
    return;
  }
}// minDepthBounds
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetminDepthBounds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minDepthBounds);
}void _VkPipelineDepthStencilStateCreateInfo::SetminDepthBounds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minDepthBounds = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.minDepthBounds", "Number");
  
    return;
  }
}// maxDepthBounds
Napi::Value _VkPipelineDepthStencilStateCreateInfo::GetmaxDepthBounds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDepthBounds);
}void _VkPipelineDepthStencilStateCreateInfo::SetmaxDepthBounds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxDepthBounds = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDepthStencilStateCreateInfo.maxDepthBounds", "Number");
  
    return;
  }
}
/** ## END VkPipelineDepthStencilStateCreateInfo ## **/

/** ## BEGIN VkStencilOpState ## **/

Napi::FunctionReference _VkStencilOpState::constructor;

_VkStencilOpState::_VkStencilOpState(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkStencilOpState>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "failOp");
      Napi::String sAccess1 = Napi::String::New(env, "passOp");
      Napi::String sAccess2 = Napi::String::New(env, "depthFailOp");
      Napi::String sAccess3 = Napi::String::New(env, "compareOp");
      Napi::String sAccess4 = Napi::String::New(env, "compareMask");
      Napi::String sAccess5 = Napi::String::New(env, "writeMask");
      Napi::String sAccess6 = Napi::String::New(env, "reference");
      if (obj.Has(sAccess0)) this->SetfailOp(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpassOp(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdepthFailOp(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetcompareOp(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetcompareMask(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetwriteMask(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setreference(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkStencilOpState constructor cannot be invoked without 'new'");
    }
  }
}

_VkStencilOpState::~_VkStencilOpState() {
  
  
  
  
  
  
  
  
}

Napi::Object _VkStencilOpState::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkStencilOpState", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkStencilOpState::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkStencilOpState::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "failOp",
    &_VkStencilOpState::GetfailOp,
    &_VkStencilOpState::SetfailOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "passOp",
    &_VkStencilOpState::GetpassOp,
    &_VkStencilOpState::SetpassOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthFailOp",
    &_VkStencilOpState::GetdepthFailOp,
    &_VkStencilOpState::SetdepthFailOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "compareOp",
    &_VkStencilOpState::GetcompareOp,
    &_VkStencilOpState::SetcompareOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "compareMask",
    &_VkStencilOpState::GetcompareMask,
    &_VkStencilOpState::SetcompareMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "writeMask",
    &_VkStencilOpState::GetwriteMask,
    &_VkStencilOpState::SetwriteMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "reference",
    &_VkStencilOpState::Getreference,
    &_VkStencilOpState::Setreference,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkStencilOpState", func);
  return exports;
}

Napi::Value _VkStencilOpState::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkStencilOpState::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->failOp));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->failOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->passOp));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->passOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->depthFailOp));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->depthFailOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->compareOp));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->compareOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->compareMask));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->compareMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->writeMask));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->writeMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkStencilOpState *)0)->reference));
    uint32_t byteLength = sizeof(((VkStencilOpState *)0)->reference);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkStencilOpState::flush() {
  _VkStencilOpState *self = this;
  
  return true;
}

// failOp
Napi::Value _VkStencilOpState::GetfailOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.failOp);
}void _VkStencilOpState::SetfailOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.failOp = static_cast<VkStencilOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.failOp", "Number");
  
    return;
  }
}// passOp
Napi::Value _VkStencilOpState::GetpassOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.passOp);
}void _VkStencilOpState::SetpassOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.passOp = static_cast<VkStencilOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.passOp", "Number");
  
    return;
  }
}// depthFailOp
Napi::Value _VkStencilOpState::GetdepthFailOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthFailOp);
}void _VkStencilOpState::SetdepthFailOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depthFailOp = static_cast<VkStencilOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.depthFailOp", "Number");
  
    return;
  }
}// compareOp
Napi::Value _VkStencilOpState::GetcompareOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compareOp);
}void _VkStencilOpState::SetcompareOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.compareOp = static_cast<VkCompareOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.compareOp", "Number");
  
    return;
  }
}// compareMask
Napi::Value _VkStencilOpState::GetcompareMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.compareMask);
}void _VkStencilOpState::SetcompareMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.compareMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.compareMask", "Number");
  
    return;
  }
}// writeMask
Napi::Value _VkStencilOpState::GetwriteMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.writeMask);
}void _VkStencilOpState::SetwriteMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.writeMask = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.writeMask", "Number");
  
    return;
  }
}// reference
Napi::Value _VkStencilOpState::Getreference(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.reference);
}void _VkStencilOpState::Setreference(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.reference = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkStencilOpState.reference", "Number");
  
    return;
  }
}
/** ## END VkStencilOpState ## **/

/** ## BEGIN VkPipelineDynamicStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineDynamicStateCreateInfo::constructor;

_VkPipelineDynamicStateCreateInfo::_VkPipelineDynamicStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineDynamicStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "dynamicStateCount");
      Napi::String sAccess4 = Napi::String::New(env, "pDynamicStates");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdynamicStateCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpDynamicStates(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineDynamicStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineDynamicStateCreateInfo::~_VkPipelineDynamicStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  pDynamicStates.Reset();
  
}

Napi::Object _VkPipelineDynamicStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineDynamicStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineDynamicStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineDynamicStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineDynamicStateCreateInfo::GetsType,
    &_VkPipelineDynamicStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineDynamicStateCreateInfo::GetpNext,
    &_VkPipelineDynamicStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineDynamicStateCreateInfo::Getflags,
    &_VkPipelineDynamicStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "dynamicStateCount",
    &_VkPipelineDynamicStateCreateInfo::GetdynamicStateCount,
    &_VkPipelineDynamicStateCreateInfo::SetdynamicStateCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pDynamicStates",
    &_VkPipelineDynamicStateCreateInfo::GetpDynamicStates,
    &_VkPipelineDynamicStateCreateInfo::SetpDynamicStates,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineDynamicStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineDynamicStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineDynamicStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDynamicStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineDynamicStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDynamicStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineDynamicStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDynamicStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineDynamicStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDynamicStateCreateInfo *)0)->dynamicStateCount));
    uint32_t byteLength = sizeof(((VkPipelineDynamicStateCreateInfo *)0)->dynamicStateCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineDynamicStateCreateInfo *)0)->pDynamicStates));
    uint32_t byteLength = sizeof(((VkPipelineDynamicStateCreateInfo *)0)->pDynamicStates);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineDynamicStateCreateInfo::flush() {
  _VkPipelineDynamicStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineDynamicStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineDynamicStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineDynamicStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineDynamicStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineDynamicStateCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineDynamicStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineDynamicStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineDynamicStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.flags", "Number");
  
    return;
  }
}// dynamicStateCount
Napi::Value _VkPipelineDynamicStateCreateInfo::GetdynamicStateCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dynamicStateCount);
}void _VkPipelineDynamicStateCreateInfo::SetdynamicStateCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dynamicStateCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.dynamicStateCount", "Number");
  
    return;
  }
}// pDynamicStates
Napi::Value _VkPipelineDynamicStateCreateInfo::GetpDynamicStates(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pDynamicStates.IsEmpty()) return env.Null();
  return this->pDynamicStates.Value().As<Napi::TypedArray>();
}void _VkPipelineDynamicStateCreateInfo::SetpDynamicStates(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_int32_array) {
        this->pDynamicStates.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.pDynamicStates", "Int32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pDynamicStates.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineDynamicStateCreateInfo.pDynamicStates", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pDynamicStates = reinterpret_cast<const VkDynamicState *>(getTypedArrayData<int32_t>(value, nullptr));
  } else {
    this->instance.pDynamicStates = nullptr;
  }
}
/** ## END VkPipelineDynamicStateCreateInfo ## **/

/** ## BEGIN VkPipelineColorBlendStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineColorBlendStateCreateInfo::constructor;

_VkPipelineColorBlendStateCreateInfo::_VkPipelineColorBlendStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineColorBlendStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    vpAttachments = new std::vector<VkPipelineColorBlendAttachmentState>;
    vblendConstants = new std::vector<float>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "logicOpEnable");
      Napi::String sAccess4 = Napi::String::New(env, "logicOp");
      Napi::String sAccess5 = Napi::String::New(env, "attachmentCount");
      Napi::String sAccess6 = Napi::String::New(env, "pAttachments");
      Napi::String sAccess7 = Napi::String::New(env, "blendConstants");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetlogicOpEnable(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetlogicOp(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetattachmentCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpAttachments(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetblendConstants(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkPipelineColorBlendStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineColorBlendStateCreateInfo::~_VkPipelineColorBlendStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  vblendConstants->clear();
  delete vblendConstants;
  
  blendConstants.Reset();
  
}

Napi::Object _VkPipelineColorBlendStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineColorBlendStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineColorBlendStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineColorBlendStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineColorBlendStateCreateInfo::GetsType,
    &_VkPipelineColorBlendStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineColorBlendStateCreateInfo::GetpNext,
    &_VkPipelineColorBlendStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineColorBlendStateCreateInfo::Getflags,
    &_VkPipelineColorBlendStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "logicOpEnable",
    &_VkPipelineColorBlendStateCreateInfo::GetlogicOpEnable,
    &_VkPipelineColorBlendStateCreateInfo::SetlogicOpEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "logicOp",
    &_VkPipelineColorBlendStateCreateInfo::GetlogicOp,
    &_VkPipelineColorBlendStateCreateInfo::SetlogicOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "attachmentCount",
    &_VkPipelineColorBlendStateCreateInfo::GetattachmentCount,
    &_VkPipelineColorBlendStateCreateInfo::SetattachmentCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pAttachments",
    &_VkPipelineColorBlendStateCreateInfo::GetpAttachments,
    &_VkPipelineColorBlendStateCreateInfo::SetpAttachments,
    napi_enumerable
  ),
  InstanceAccessor(
    "blendConstants",
    &_VkPipelineColorBlendStateCreateInfo::GetblendConstants,
    &_VkPipelineColorBlendStateCreateInfo::SetblendConstants,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineColorBlendStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineColorBlendStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineColorBlendStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->logicOpEnable));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->logicOpEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->logicOp));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->logicOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->attachmentCount));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->attachmentCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->pAttachments));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->pAttachments);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendStateCreateInfo *)0)->blendConstants));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendStateCreateInfo *)0)->blendConstants);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineColorBlendStateCreateInfo::flush() {
  _VkPipelineColorBlendStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT) {
      _VkPipelineColorBlendAdvancedStateCreateInfoEXT* structExt = Napi::ObjectWrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pAttachments.IsEmpty())) {
    Napi::Value value = self->pAttachments.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.attachmentCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'attachmentCount' for 'VkPipelineColorBlendStateCreateInfo.pAttachments'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkPipelineColorBlendAttachmentState>* data = this->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkPipelineColorBlendAttachmentState::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.pAttachments", "[object VkPipelineColorBlendAttachmentState]");
  
        return false;
      }
      _VkPipelineColorBlendAttachmentState* result = Napi::ObjectWrap<_VkPipelineColorBlendAttachmentState>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }if (!(self->blendConstants.IsEmpty())) {
    Napi::Value value = self->blendConstants.Value();
    
    if (value.IsArray()) {
      // validate length
      if (value.As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '4' for 'VkPipelineColorBlendStateCreateInfo.blendConstants'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(this->instance.blendConstants, array.data(), sizeof(float) * 4);
    } else if (value.IsNull()) {
      memset(&this->instance.blendConstants, 0, sizeof(float));
    } else {
      
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.blendConstants", "Array");
  
      return false;
    }
  }
  return true;
}

// sType
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineColorBlendStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineColorBlendStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineColorBlendStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineColorBlendStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineColorBlendStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.flags", "Number");
  
    return;
  }
}// logicOpEnable
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetlogicOpEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.logicOpEnable);
}void _VkPipelineColorBlendStateCreateInfo::SetlogicOpEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.logicOpEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.logicOpEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.logicOpEnable", "Number");
  
    return;
  }
}// logicOp
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetlogicOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.logicOp);
}void _VkPipelineColorBlendStateCreateInfo::SetlogicOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.logicOp = static_cast<VkLogicOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.logicOp", "Number");
  
    return;
  }
}// attachmentCount
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetattachmentCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.attachmentCount);
}void _VkPipelineColorBlendStateCreateInfo::SetattachmentCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.attachmentCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetpAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pAttachments.IsEmpty()) return env.Null();
  return this->pAttachments.Value().As<Napi::Array>();
}void _VkPipelineColorBlendStateCreateInfo::SetpAttachments(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pAttachments.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pAttachments.Reset();
      this->instance.pAttachments = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.pAttachments", "[object VkPipelineColorBlendAttachmentState]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pAttachments = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.pAttachments", "[object VkPipelineColorBlendAttachmentState]");
  
    return;
  }
}// blendConstants
Napi::Value _VkPipelineColorBlendStateCreateInfo::GetblendConstants(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->blendConstants.IsEmpty()) return env.Null();
  return this->blendConstants.Value().As<Napi::Array>();
}void _VkPipelineColorBlendStateCreateInfo::SetblendConstants(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->blendConstants.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->blendConstants.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendStateCreateInfo.blendConstants", "Array");
  
    return;
  }
}
/** ## END VkPipelineColorBlendStateCreateInfo ## **/

/** ## BEGIN VkPipelineColorBlendAttachmentState ## **/

Napi::FunctionReference _VkPipelineColorBlendAttachmentState::constructor;

_VkPipelineColorBlendAttachmentState::_VkPipelineColorBlendAttachmentState(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineColorBlendAttachmentState>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "blendEnable");
      Napi::String sAccess1 = Napi::String::New(env, "srcColorBlendFactor");
      Napi::String sAccess2 = Napi::String::New(env, "dstColorBlendFactor");
      Napi::String sAccess3 = Napi::String::New(env, "colorBlendOp");
      Napi::String sAccess4 = Napi::String::New(env, "srcAlphaBlendFactor");
      Napi::String sAccess5 = Napi::String::New(env, "dstAlphaBlendFactor");
      Napi::String sAccess6 = Napi::String::New(env, "alphaBlendOp");
      Napi::String sAccess7 = Napi::String::New(env, "colorWriteMask");
      if (obj.Has(sAccess0)) this->SetblendEnable(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetsrcColorBlendFactor(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdstColorBlendFactor(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetcolorBlendOp(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsrcAlphaBlendFactor(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdstAlphaBlendFactor(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetalphaBlendOp(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetcolorWriteMask(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkPipelineColorBlendAttachmentState constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineColorBlendAttachmentState::~_VkPipelineColorBlendAttachmentState() {
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPipelineColorBlendAttachmentState::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineColorBlendAttachmentState", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineColorBlendAttachmentState::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineColorBlendAttachmentState::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "blendEnable",
    &_VkPipelineColorBlendAttachmentState::GetblendEnable,
    &_VkPipelineColorBlendAttachmentState::SetblendEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcColorBlendFactor",
    &_VkPipelineColorBlendAttachmentState::GetsrcColorBlendFactor,
    &_VkPipelineColorBlendAttachmentState::SetsrcColorBlendFactor,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstColorBlendFactor",
    &_VkPipelineColorBlendAttachmentState::GetdstColorBlendFactor,
    &_VkPipelineColorBlendAttachmentState::SetdstColorBlendFactor,
    napi_enumerable
  ),
  InstanceAccessor(
    "colorBlendOp",
    &_VkPipelineColorBlendAttachmentState::GetcolorBlendOp,
    &_VkPipelineColorBlendAttachmentState::SetcolorBlendOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcAlphaBlendFactor",
    &_VkPipelineColorBlendAttachmentState::GetsrcAlphaBlendFactor,
    &_VkPipelineColorBlendAttachmentState::SetsrcAlphaBlendFactor,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstAlphaBlendFactor",
    &_VkPipelineColorBlendAttachmentState::GetdstAlphaBlendFactor,
    &_VkPipelineColorBlendAttachmentState::SetdstAlphaBlendFactor,
    napi_enumerable
  ),
  InstanceAccessor(
    "alphaBlendOp",
    &_VkPipelineColorBlendAttachmentState::GetalphaBlendOp,
    &_VkPipelineColorBlendAttachmentState::SetalphaBlendOp,
    napi_enumerable
  ),
  InstanceAccessor(
    "colorWriteMask",
    &_VkPipelineColorBlendAttachmentState::GetcolorWriteMask,
    &_VkPipelineColorBlendAttachmentState::SetcolorWriteMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineColorBlendAttachmentState", func);
  return exports;
}

Napi::Value _VkPipelineColorBlendAttachmentState::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineColorBlendAttachmentState::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->blendEnable));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->blendEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->srcColorBlendFactor));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->srcColorBlendFactor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->dstColorBlendFactor));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->dstColorBlendFactor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->colorBlendOp));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->colorBlendOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->srcAlphaBlendFactor));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->srcAlphaBlendFactor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->dstAlphaBlendFactor));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->dstAlphaBlendFactor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->alphaBlendOp));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->alphaBlendOp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineColorBlendAttachmentState *)0)->colorWriteMask));
    uint32_t byteLength = sizeof(((VkPipelineColorBlendAttachmentState *)0)->colorWriteMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineColorBlendAttachmentState::flush() {
  _VkPipelineColorBlendAttachmentState *self = this;
  
  return true;
}

// blendEnable
Napi::Value _VkPipelineColorBlendAttachmentState::GetblendEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.blendEnable);
}void _VkPipelineColorBlendAttachmentState::SetblendEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.blendEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.blendEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.blendEnable", "Number");
  
    return;
  }
}// srcColorBlendFactor
Napi::Value _VkPipelineColorBlendAttachmentState::GetsrcColorBlendFactor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcColorBlendFactor);
}void _VkPipelineColorBlendAttachmentState::SetsrcColorBlendFactor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcColorBlendFactor = static_cast<VkBlendFactor>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.srcColorBlendFactor", "Number");
  
    return;
  }
}// dstColorBlendFactor
Napi::Value _VkPipelineColorBlendAttachmentState::GetdstColorBlendFactor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstColorBlendFactor);
}void _VkPipelineColorBlendAttachmentState::SetdstColorBlendFactor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstColorBlendFactor = static_cast<VkBlendFactor>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.dstColorBlendFactor", "Number");
  
    return;
  }
}// colorBlendOp
Napi::Value _VkPipelineColorBlendAttachmentState::GetcolorBlendOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.colorBlendOp);
}void _VkPipelineColorBlendAttachmentState::SetcolorBlendOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.colorBlendOp = static_cast<VkBlendOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.colorBlendOp", "Number");
  
    return;
  }
}// srcAlphaBlendFactor
Napi::Value _VkPipelineColorBlendAttachmentState::GetsrcAlphaBlendFactor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcAlphaBlendFactor);
}void _VkPipelineColorBlendAttachmentState::SetsrcAlphaBlendFactor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcAlphaBlendFactor = static_cast<VkBlendFactor>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor", "Number");
  
    return;
  }
}// dstAlphaBlendFactor
Napi::Value _VkPipelineColorBlendAttachmentState::GetdstAlphaBlendFactor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstAlphaBlendFactor);
}void _VkPipelineColorBlendAttachmentState::SetdstAlphaBlendFactor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstAlphaBlendFactor = static_cast<VkBlendFactor>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor", "Number");
  
    return;
  }
}// alphaBlendOp
Napi::Value _VkPipelineColorBlendAttachmentState::GetalphaBlendOp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.alphaBlendOp);
}void _VkPipelineColorBlendAttachmentState::SetalphaBlendOp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.alphaBlendOp = static_cast<VkBlendOp>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.alphaBlendOp", "Number");
  
    return;
  }
}// colorWriteMask
Napi::Value _VkPipelineColorBlendAttachmentState::GetcolorWriteMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.colorWriteMask);
}void _VkPipelineColorBlendAttachmentState::SetcolorWriteMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.colorWriteMask = static_cast<VkColorComponentFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineColorBlendAttachmentState.colorWriteMask", "Number");
  
    return;
  }
}
/** ## END VkPipelineColorBlendAttachmentState ## **/

/** ## BEGIN VkPipelineMultisampleStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineMultisampleStateCreateInfo::constructor;

_VkPipelineMultisampleStateCreateInfo::_VkPipelineMultisampleStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineMultisampleStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "rasterizationSamples");
      Napi::String sAccess4 = Napi::String::New(env, "sampleShadingEnable");
      Napi::String sAccess5 = Napi::String::New(env, "minSampleShading");
      Napi::String sAccess6 = Napi::String::New(env, "pSampleMask");
      Napi::String sAccess7 = Napi::String::New(env, "alphaToCoverageEnable");
      Napi::String sAccess8 = Napi::String::New(env, "alphaToOneEnable");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetrasterizationSamples(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsampleShadingEnable(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetminSampleShading(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpSampleMask(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetalphaToCoverageEnable(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetalphaToOneEnable(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkPipelineMultisampleStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineMultisampleStateCreateInfo::~_VkPipelineMultisampleStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
  pSampleMask.Reset();
  
  
  
}

Napi::Object _VkPipelineMultisampleStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineMultisampleStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineMultisampleStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineMultisampleStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineMultisampleStateCreateInfo::GetsType,
    &_VkPipelineMultisampleStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineMultisampleStateCreateInfo::GetpNext,
    &_VkPipelineMultisampleStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineMultisampleStateCreateInfo::Getflags,
    &_VkPipelineMultisampleStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "rasterizationSamples",
    &_VkPipelineMultisampleStateCreateInfo::GetrasterizationSamples,
    &_VkPipelineMultisampleStateCreateInfo::SetrasterizationSamples,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleShadingEnable",
    &_VkPipelineMultisampleStateCreateInfo::GetsampleShadingEnable,
    &_VkPipelineMultisampleStateCreateInfo::SetsampleShadingEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "minSampleShading",
    &_VkPipelineMultisampleStateCreateInfo::GetminSampleShading,
    &_VkPipelineMultisampleStateCreateInfo::SetminSampleShading,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSampleMask",
    &_VkPipelineMultisampleStateCreateInfo::GetpSampleMask,
    &_VkPipelineMultisampleStateCreateInfo::SetpSampleMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "alphaToCoverageEnable",
    &_VkPipelineMultisampleStateCreateInfo::GetalphaToCoverageEnable,
    &_VkPipelineMultisampleStateCreateInfo::SetalphaToCoverageEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "alphaToOneEnable",
    &_VkPipelineMultisampleStateCreateInfo::GetalphaToOneEnable,
    &_VkPipelineMultisampleStateCreateInfo::SetalphaToOneEnable,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineMultisampleStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineMultisampleStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineMultisampleStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->rasterizationSamples));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->rasterizationSamples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->sampleShadingEnable));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->sampleShadingEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->minSampleShading));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->minSampleShading);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->pSampleMask));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->pSampleMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->alphaToCoverageEnable));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->alphaToCoverageEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineMultisampleStateCreateInfo *)0)->alphaToOneEnable));
    uint32_t byteLength = sizeof(((VkPipelineMultisampleStateCreateInfo *)0)->alphaToOneEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineMultisampleStateCreateInfo::flush() {
  _VkPipelineMultisampleStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV) {
      _VkPipelineCoverageToColorStateCreateInfoNV* structExt = Napi::ObjectWrap<_VkPipelineCoverageToColorStateCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT) {
      _VkPipelineSampleLocationsStateCreateInfoEXT* structExt = Napi::ObjectWrap<_VkPipelineSampleLocationsStateCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV) {
      _VkPipelineCoverageModulationStateCreateInfoNV* structExt = Napi::ObjectWrap<_VkPipelineCoverageModulationStateCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineMultisampleStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineMultisampleStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT &&
        sType != VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineMultisampleStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineMultisampleStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineMultisampleStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.flags", "Number");
  
    return;
  }
}// rasterizationSamples
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetrasterizationSamples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.rasterizationSamples);
}void _VkPipelineMultisampleStateCreateInfo::SetrasterizationSamples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.rasterizationSamples = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.rasterizationSamples", "Number");
  
    return;
  }
}// sampleShadingEnable
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetsampleShadingEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleShadingEnable);
}void _VkPipelineMultisampleStateCreateInfo::SetsampleShadingEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.sampleShadingEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.sampleShadingEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.sampleShadingEnable", "Number");
  
    return;
  }
}// minSampleShading
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetminSampleShading(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minSampleShading);
}void _VkPipelineMultisampleStateCreateInfo::SetminSampleShading(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minSampleShading = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.minSampleShading", "Number");
  
    return;
  }
}// pSampleMask
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetpSampleMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSampleMask.IsEmpty()) return env.Null();
  return this->pSampleMask.Value().As<Napi::TypedArray>();
}void _VkPipelineMultisampleStateCreateInfo::SetpSampleMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pSampleMask.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.pSampleMask", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pSampleMask.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.pSampleMask", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pSampleMask = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pSampleMask = nullptr;
  }
}// alphaToCoverageEnable
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetalphaToCoverageEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.alphaToCoverageEnable);
}void _VkPipelineMultisampleStateCreateInfo::SetalphaToCoverageEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.alphaToCoverageEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.alphaToCoverageEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.alphaToCoverageEnable", "Number");
  
    return;
  }
}// alphaToOneEnable
Napi::Value _VkPipelineMultisampleStateCreateInfo::GetalphaToOneEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.alphaToOneEnable);
}void _VkPipelineMultisampleStateCreateInfo::SetalphaToOneEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.alphaToOneEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.alphaToOneEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineMultisampleStateCreateInfo.alphaToOneEnable", "Number");
  
    return;
  }
}
/** ## END VkPipelineMultisampleStateCreateInfo ## **/

/** ## BEGIN VkPipelineRasterizationStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineRasterizationStateCreateInfo::constructor;

_VkPipelineRasterizationStateCreateInfo::_VkPipelineRasterizationStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineRasterizationStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "depthClampEnable");
      Napi::String sAccess4 = Napi::String::New(env, "rasterizerDiscardEnable");
      Napi::String sAccess5 = Napi::String::New(env, "polygonMode");
      Napi::String sAccess6 = Napi::String::New(env, "cullMode");
      Napi::String sAccess7 = Napi::String::New(env, "frontFace");
      Napi::String sAccess8 = Napi::String::New(env, "depthBiasEnable");
      Napi::String sAccess9 = Napi::String::New(env, "depthBiasConstantFactor");
      Napi::String sAccess10 = Napi::String::New(env, "depthBiasClamp");
      Napi::String sAccess11 = Napi::String::New(env, "depthBiasSlopeFactor");
      Napi::String sAccess12 = Napi::String::New(env, "lineWidth");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdepthClampEnable(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetrasterizerDiscardEnable(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpolygonMode(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetcullMode(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetfrontFace(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetdepthBiasEnable(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetdepthBiasConstantFactor(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetdepthBiasClamp(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetdepthBiasSlopeFactor(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetlineWidth(info, obj.Get(sAccess12));
      
    } else {
      Napi::Error::New(env, "VkPipelineRasterizationStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineRasterizationStateCreateInfo::~_VkPipelineRasterizationStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  
  
  
  
  
}

Napi::Object _VkPipelineRasterizationStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineRasterizationStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineRasterizationStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineRasterizationStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineRasterizationStateCreateInfo::GetsType,
    &_VkPipelineRasterizationStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineRasterizationStateCreateInfo::GetpNext,
    &_VkPipelineRasterizationStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineRasterizationStateCreateInfo::Getflags,
    &_VkPipelineRasterizationStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthClampEnable",
    &_VkPipelineRasterizationStateCreateInfo::GetdepthClampEnable,
    &_VkPipelineRasterizationStateCreateInfo::SetdepthClampEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "rasterizerDiscardEnable",
    &_VkPipelineRasterizationStateCreateInfo::GetrasterizerDiscardEnable,
    &_VkPipelineRasterizationStateCreateInfo::SetrasterizerDiscardEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "polygonMode",
    &_VkPipelineRasterizationStateCreateInfo::GetpolygonMode,
    &_VkPipelineRasterizationStateCreateInfo::SetpolygonMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "cullMode",
    &_VkPipelineRasterizationStateCreateInfo::GetcullMode,
    &_VkPipelineRasterizationStateCreateInfo::SetcullMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "frontFace",
    &_VkPipelineRasterizationStateCreateInfo::GetfrontFace,
    &_VkPipelineRasterizationStateCreateInfo::SetfrontFace,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBiasEnable",
    &_VkPipelineRasterizationStateCreateInfo::GetdepthBiasEnable,
    &_VkPipelineRasterizationStateCreateInfo::SetdepthBiasEnable,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBiasConstantFactor",
    &_VkPipelineRasterizationStateCreateInfo::GetdepthBiasConstantFactor,
    &_VkPipelineRasterizationStateCreateInfo::SetdepthBiasConstantFactor,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBiasClamp",
    &_VkPipelineRasterizationStateCreateInfo::GetdepthBiasClamp,
    &_VkPipelineRasterizationStateCreateInfo::SetdepthBiasClamp,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthBiasSlopeFactor",
    &_VkPipelineRasterizationStateCreateInfo::GetdepthBiasSlopeFactor,
    &_VkPipelineRasterizationStateCreateInfo::SetdepthBiasSlopeFactor,
    napi_enumerable
  ),
  InstanceAccessor(
    "lineWidth",
    &_VkPipelineRasterizationStateCreateInfo::GetlineWidth,
    &_VkPipelineRasterizationStateCreateInfo::SetlineWidth,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineRasterizationStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineRasterizationStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineRasterizationStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->depthClampEnable));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->depthClampEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->rasterizerDiscardEnable));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->rasterizerDiscardEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->polygonMode));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->polygonMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->cullMode));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->cullMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->frontFace));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->frontFace);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasEnable));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasConstantFactor));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasConstantFactor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasClamp));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasClamp);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasSlopeFactor));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->depthBiasSlopeFactor);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineRasterizationStateCreateInfo *)0)->lineWidth));
    uint32_t byteLength = sizeof(((VkPipelineRasterizationStateCreateInfo *)0)->lineWidth);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineRasterizationStateCreateInfo::flush() {
  _VkPipelineRasterizationStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD) {
      _VkPipelineRasterizationStateRasterizationOrderAMD* structExt = Napi::ObjectWrap<_VkPipelineRasterizationStateRasterizationOrderAMD>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT) {
      _VkPipelineRasterizationConservativeStateCreateInfoEXT* structExt = Napi::ObjectWrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineRasterizationStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineRasterizationStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD &&
        sType != VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineRasterizationStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineRasterizationStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineRasterizationStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.flags", "Number");
  
    return;
  }
}// depthClampEnable
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetdepthClampEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthClampEnable);
}void _VkPipelineRasterizationStateCreateInfo::SetdepthClampEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthClampEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthClampEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthClampEnable", "Number");
  
    return;
  }
}// rasterizerDiscardEnable
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetrasterizerDiscardEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.rasterizerDiscardEnable);
}void _VkPipelineRasterizationStateCreateInfo::SetrasterizerDiscardEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.rasterizerDiscardEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.rasterizerDiscardEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.rasterizerDiscardEnable", "Number");
  
    return;
  }
}// polygonMode
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetpolygonMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.polygonMode);
}void _VkPipelineRasterizationStateCreateInfo::SetpolygonMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.polygonMode = static_cast<VkPolygonMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.polygonMode", "Number");
  
    return;
  }
}// cullMode
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetcullMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.cullMode);
}void _VkPipelineRasterizationStateCreateInfo::SetcullMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.cullMode = static_cast<VkCullModeFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.cullMode", "Number");
  
    return;
  }
}// frontFace
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetfrontFace(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.frontFace);
}void _VkPipelineRasterizationStateCreateInfo::SetfrontFace(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.frontFace = static_cast<VkFrontFace>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.frontFace", "Number");
  
    return;
  }
}// depthBiasEnable
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetdepthBiasEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBiasEnable);
}void _VkPipelineRasterizationStateCreateInfo::SetdepthBiasEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.depthBiasEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.depthBiasEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasEnable", "Number");
  
    return;
  }
}// depthBiasConstantFactor
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetdepthBiasConstantFactor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBiasConstantFactor);
}void _VkPipelineRasterizationStateCreateInfo::SetdepthBiasConstantFactor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depthBiasConstantFactor = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor", "Number");
  
    return;
  }
}// depthBiasClamp
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetdepthBiasClamp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBiasClamp);
}void _VkPipelineRasterizationStateCreateInfo::SetdepthBiasClamp(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depthBiasClamp = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasClamp", "Number");
  
    return;
  }
}// depthBiasSlopeFactor
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetdepthBiasSlopeFactor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthBiasSlopeFactor);
}void _VkPipelineRasterizationStateCreateInfo::SetdepthBiasSlopeFactor(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depthBiasSlopeFactor = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor", "Number");
  
    return;
  }
}// lineWidth
Napi::Value _VkPipelineRasterizationStateCreateInfo::GetlineWidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.lineWidth);
}void _VkPipelineRasterizationStateCreateInfo::SetlineWidth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.lineWidth = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineRasterizationStateCreateInfo.lineWidth", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationStateCreateInfo ## **/

/** ## BEGIN VkPipelineViewportStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineViewportStateCreateInfo::constructor;

_VkPipelineViewportStateCreateInfo::_VkPipelineViewportStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineViewportStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    vpViewports = new std::vector<VkViewport>;
    vpScissors = new std::vector<VkRect2D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "viewportCount");
      Napi::String sAccess4 = Napi::String::New(env, "pViewports");
      Napi::String sAccess5 = Napi::String::New(env, "scissorCount");
      Napi::String sAccess6 = Napi::String::New(env, "pScissors");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetviewportCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpViewports(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetscissorCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpScissors(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPipelineViewportStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineViewportStateCreateInfo::~_VkPipelineViewportStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpViewports->clear();
  delete vpViewports;
  
  pViewports.Reset();
  
  
  vpScissors->clear();
  delete vpScissors;
  
  pScissors.Reset();
  
}

Napi::Object _VkPipelineViewportStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineViewportStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineViewportStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineViewportStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineViewportStateCreateInfo::GetsType,
    &_VkPipelineViewportStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineViewportStateCreateInfo::GetpNext,
    &_VkPipelineViewportStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineViewportStateCreateInfo::Getflags,
    &_VkPipelineViewportStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewportCount",
    &_VkPipelineViewportStateCreateInfo::GetviewportCount,
    &_VkPipelineViewportStateCreateInfo::SetviewportCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pViewports",
    &_VkPipelineViewportStateCreateInfo::GetpViewports,
    &_VkPipelineViewportStateCreateInfo::SetpViewports,
    napi_enumerable
  ),
  InstanceAccessor(
    "scissorCount",
    &_VkPipelineViewportStateCreateInfo::GetscissorCount,
    &_VkPipelineViewportStateCreateInfo::SetscissorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pScissors",
    &_VkPipelineViewportStateCreateInfo::GetpScissors,
    &_VkPipelineViewportStateCreateInfo::SetpScissors,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineViewportStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineViewportStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineViewportStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->viewportCount));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->viewportCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->pViewports));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->pViewports);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->scissorCount));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->scissorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineViewportStateCreateInfo *)0)->pScissors));
    uint32_t byteLength = sizeof(((VkPipelineViewportStateCreateInfo *)0)->pScissors);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineViewportStateCreateInfo::flush() {
  _VkPipelineViewportStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV) {
      _VkPipelineViewportWScalingStateCreateInfoNV* structExt = Napi::ObjectWrap<_VkPipelineViewportWScalingStateCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV) {
      _VkPipelineViewportSwizzleStateCreateInfoNV* structExt = Napi::ObjectWrap<_VkPipelineViewportSwizzleStateCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pViewports.IsEmpty())) {
    Napi::Value value = self->pViewports.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.viewportCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportStateCreateInfo.pViewports'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkViewport>* data = this->vpViewports;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkViewport::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pViewports", "[object VkViewport]");
  
        return false;
      }
      _VkViewport* result = Napi::ObjectWrap<_VkViewport>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pViewports = data->data();
  }if (!(self->pScissors.IsEmpty())) {
    Napi::Value value = self->pScissors.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.scissorCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'scissorCount' for 'VkPipelineViewportStateCreateInfo.pScissors'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkRect2D>* data = this->vpScissors;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkRect2D::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pScissors", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pScissors = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineViewportStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineViewportStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineViewportStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineViewportStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineViewportStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineViewportStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineViewportStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.flags", "Number");
  
    return;
  }
}// viewportCount
Napi::Value _VkPipelineViewportStateCreateInfo::GetviewportCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewportCount);
}void _VkPipelineViewportStateCreateInfo::SetviewportCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewportCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.viewportCount", "Number");
  
    return;
  }
}// pViewports
Napi::Value _VkPipelineViewportStateCreateInfo::GetpViewports(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pViewports.IsEmpty()) return env.Null();
  return this->pViewports.Value().As<Napi::Array>();
}void _VkPipelineViewportStateCreateInfo::SetpViewports(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pViewports.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pViewports.Reset();
      this->instance.pViewports = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pViewports", "[object VkViewport]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pViewports = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pViewports", "[object VkViewport]");
  
    return;
  }
}// scissorCount
Napi::Value _VkPipelineViewportStateCreateInfo::GetscissorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.scissorCount);
}void _VkPipelineViewportStateCreateInfo::SetscissorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.scissorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.scissorCount", "Number");
  
    return;
  }
}// pScissors
Napi::Value _VkPipelineViewportStateCreateInfo::GetpScissors(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pScissors.IsEmpty()) return env.Null();
  return this->pScissors.Value().As<Napi::Array>();
}void _VkPipelineViewportStateCreateInfo::SetpScissors(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pScissors.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pScissors.Reset();
      this->instance.pScissors = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pScissors", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pScissors = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineViewportStateCreateInfo.pScissors", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkPipelineViewportStateCreateInfo ## **/

/** ## BEGIN VkPipelineTessellationStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineTessellationStateCreateInfo::constructor;

_VkPipelineTessellationStateCreateInfo::_VkPipelineTessellationStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineTessellationStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "patchControlPoints");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpatchControlPoints(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkPipelineTessellationStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineTessellationStateCreateInfo::~_VkPipelineTessellationStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkPipelineTessellationStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineTessellationStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineTessellationStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineTessellationStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineTessellationStateCreateInfo::GetsType,
    &_VkPipelineTessellationStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineTessellationStateCreateInfo::GetpNext,
    &_VkPipelineTessellationStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineTessellationStateCreateInfo::Getflags,
    &_VkPipelineTessellationStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "patchControlPoints",
    &_VkPipelineTessellationStateCreateInfo::GetpatchControlPoints,
    &_VkPipelineTessellationStateCreateInfo::SetpatchControlPoints,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineTessellationStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineTessellationStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineTessellationStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineTessellationStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineTessellationStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineTessellationStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineTessellationStateCreateInfo *)0)->patchControlPoints));
    uint32_t byteLength = sizeof(((VkPipelineTessellationStateCreateInfo *)0)->patchControlPoints);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineTessellationStateCreateInfo::flush() {
  _VkPipelineTessellationStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO) {
      _VkPipelineTessellationDomainOriginStateCreateInfo* structExt = Napi::ObjectWrap<_VkPipelineTessellationDomainOriginStateCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkPipelineTessellationStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineTessellationStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineTessellationStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineTessellationStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPipelineTessellationStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineTessellationStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineTessellationStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineTessellationStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationStateCreateInfo.flags", "Number");
  
    return;
  }
}// patchControlPoints
Napi::Value _VkPipelineTessellationStateCreateInfo::GetpatchControlPoints(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.patchControlPoints);
}void _VkPipelineTessellationStateCreateInfo::SetpatchControlPoints(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.patchControlPoints = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineTessellationStateCreateInfo.patchControlPoints", "Number");
  
    return;
  }
}
/** ## END VkPipelineTessellationStateCreateInfo ## **/

/** ## BEGIN VkPipelineInputAssemblyStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineInputAssemblyStateCreateInfo::constructor;

_VkPipelineInputAssemblyStateCreateInfo::_VkPipelineInputAssemblyStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineInputAssemblyStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "topology");
      Napi::String sAccess4 = Napi::String::New(env, "primitiveRestartEnable");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Settopology(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetprimitiveRestartEnable(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkPipelineInputAssemblyStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineInputAssemblyStateCreateInfo::~_VkPipelineInputAssemblyStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
}

Napi::Object _VkPipelineInputAssemblyStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineInputAssemblyStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineInputAssemblyStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineInputAssemblyStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineInputAssemblyStateCreateInfo::GetsType,
    &_VkPipelineInputAssemblyStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineInputAssemblyStateCreateInfo::GetpNext,
    &_VkPipelineInputAssemblyStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineInputAssemblyStateCreateInfo::Getflags,
    &_VkPipelineInputAssemblyStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "topology",
    &_VkPipelineInputAssemblyStateCreateInfo::Gettopology,
    &_VkPipelineInputAssemblyStateCreateInfo::Settopology,
    napi_enumerable
  ),
  InstanceAccessor(
    "primitiveRestartEnable",
    &_VkPipelineInputAssemblyStateCreateInfo::GetprimitiveRestartEnable,
    &_VkPipelineInputAssemblyStateCreateInfo::SetprimitiveRestartEnable,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineInputAssemblyStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineInputAssemblyStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineInputAssemblyStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineInputAssemblyStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineInputAssemblyStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineInputAssemblyStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineInputAssemblyStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineInputAssemblyStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineInputAssemblyStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineInputAssemblyStateCreateInfo *)0)->topology));
    uint32_t byteLength = sizeof(((VkPipelineInputAssemblyStateCreateInfo *)0)->topology);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineInputAssemblyStateCreateInfo *)0)->primitiveRestartEnable));
    uint32_t byteLength = sizeof(((VkPipelineInputAssemblyStateCreateInfo *)0)->primitiveRestartEnable);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineInputAssemblyStateCreateInfo::flush() {
  _VkPipelineInputAssemblyStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineInputAssemblyStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineInputAssemblyStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineInputAssemblyStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineInputAssemblyStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineInputAssemblyStateCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineInputAssemblyStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineInputAssemblyStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineInputAssemblyStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.flags", "Number");
  
    return;
  }
}// topology
Napi::Value _VkPipelineInputAssemblyStateCreateInfo::Gettopology(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.topology);
}void _VkPipelineInputAssemblyStateCreateInfo::Settopology(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.topology = static_cast<VkPrimitiveTopology>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.topology", "Number");
  
    return;
  }
}// primitiveRestartEnable
Napi::Value _VkPipelineInputAssemblyStateCreateInfo::GetprimitiveRestartEnable(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.primitiveRestartEnable);
}void _VkPipelineInputAssemblyStateCreateInfo::SetprimitiveRestartEnable(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsBoolean() || value.IsNumber()) {
    if (value.IsBoolean()) {
      this->instance.primitiveRestartEnable = static_cast<uint32_t>(value.As<Napi::Boolean>().Value()) ? VK_TRUE : VK_FALSE;
    } else {
      this->instance.primitiveRestartEnable = static_cast<uint32_t>(value.As<Napi::Number>().Int32Value()) > 0 ? VK_TRUE : VK_FALSE;
    }
  } else {
    
    NapiObjectTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.primitiveRestartEnable", "Number");
  
    return;
  }
}
/** ## END VkPipelineInputAssemblyStateCreateInfo ## **/

/** ## BEGIN VkPipelineVertexInputStateCreateInfo ## **/

Napi::FunctionReference _VkPipelineVertexInputStateCreateInfo::constructor;

_VkPipelineVertexInputStateCreateInfo::_VkPipelineVertexInputStateCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineVertexInputStateCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vpVertexBindingDescriptions = new std::vector<VkVertexInputBindingDescription>;
    vpVertexAttributeDescriptions = new std::vector<VkVertexInputAttributeDescription>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "vertexBindingDescriptionCount");
      Napi::String sAccess4 = Napi::String::New(env, "pVertexBindingDescriptions");
      Napi::String sAccess5 = Napi::String::New(env, "vertexAttributeDescriptionCount");
      Napi::String sAccess6 = Napi::String::New(env, "pVertexAttributeDescriptions");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetvertexBindingDescriptionCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpVertexBindingDescriptions(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetvertexAttributeDescriptionCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpVertexAttributeDescriptions(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPipelineVertexInputStateCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineVertexInputStateCreateInfo::~_VkPipelineVertexInputStateCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpVertexBindingDescriptions->clear();
  delete vpVertexBindingDescriptions;
  
  pVertexBindingDescriptions.Reset();
  
  
  vpVertexAttributeDescriptions->clear();
  delete vpVertexAttributeDescriptions;
  
  pVertexAttributeDescriptions.Reset();
  
}

Napi::Object _VkPipelineVertexInputStateCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineVertexInputStateCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineVertexInputStateCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineVertexInputStateCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineVertexInputStateCreateInfo::GetsType,
    &_VkPipelineVertexInputStateCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineVertexInputStateCreateInfo::GetpNext,
    &_VkPipelineVertexInputStateCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineVertexInputStateCreateInfo::Getflags,
    &_VkPipelineVertexInputStateCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "vertexBindingDescriptionCount",
    &_VkPipelineVertexInputStateCreateInfo::GetvertexBindingDescriptionCount,
    &_VkPipelineVertexInputStateCreateInfo::SetvertexBindingDescriptionCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pVertexBindingDescriptions",
    &_VkPipelineVertexInputStateCreateInfo::GetpVertexBindingDescriptions,
    &_VkPipelineVertexInputStateCreateInfo::SetpVertexBindingDescriptions,
    napi_enumerable
  ),
  InstanceAccessor(
    "vertexAttributeDescriptionCount",
    &_VkPipelineVertexInputStateCreateInfo::GetvertexAttributeDescriptionCount,
    &_VkPipelineVertexInputStateCreateInfo::SetvertexAttributeDescriptionCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pVertexAttributeDescriptions",
    &_VkPipelineVertexInputStateCreateInfo::GetpVertexAttributeDescriptions,
    &_VkPipelineVertexInputStateCreateInfo::SetpVertexAttributeDescriptions,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineVertexInputStateCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineVertexInputStateCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineVertexInputStateCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->vertexBindingDescriptionCount));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->vertexBindingDescriptionCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->pVertexBindingDescriptions));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->pVertexBindingDescriptions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->vertexAttributeDescriptionCount));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->vertexAttributeDescriptionCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineVertexInputStateCreateInfo *)0)->pVertexAttributeDescriptions));
    uint32_t byteLength = sizeof(((VkPipelineVertexInputStateCreateInfo *)0)->pVertexAttributeDescriptions);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineVertexInputStateCreateInfo::flush() {
  _VkPipelineVertexInputStateCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT) {
      _VkPipelineVertexInputDivisorStateCreateInfoEXT* structExt = Napi::ObjectWrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pVertexBindingDescriptions.IsEmpty())) {
    Napi::Value value = self->pVertexBindingDescriptions.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.vertexBindingDescriptionCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'vertexBindingDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkVertexInputBindingDescription>* data = this->vpVertexBindingDescriptions;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkVertexInputBindingDescription::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions", "[object VkVertexInputBindingDescription]");
  
        return false;
      }
      _VkVertexInputBindingDescription* result = Napi::ObjectWrap<_VkVertexInputBindingDescription>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pVertexBindingDescriptions = data->data();
  }if (!(self->pVertexAttributeDescriptions.IsEmpty())) {
    Napi::Value value = self->pVertexAttributeDescriptions.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.vertexAttributeDescriptionCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'vertexAttributeDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkVertexInputAttributeDescription>* data = this->vpVertexAttributeDescriptions;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkVertexInputAttributeDescription::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions", "[object VkVertexInputAttributeDescription]");
  
        return false;
      }
      _VkVertexInputAttributeDescription* result = Napi::ObjectWrap<_VkVertexInputAttributeDescription>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pVertexAttributeDescriptions = data->data();
  }
  return true;
}

// sType
Napi::Value _VkPipelineVertexInputStateCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineVertexInputStateCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineVertexInputStateCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineVertexInputStateCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineVertexInputStateCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineVertexInputStateCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineVertexInputStateCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.flags", "Number");
  
    return;
  }
}// vertexBindingDescriptionCount
Napi::Value _VkPipelineVertexInputStateCreateInfo::GetvertexBindingDescriptionCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vertexBindingDescriptionCount);
}void _VkPipelineVertexInputStateCreateInfo::SetvertexBindingDescriptionCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.vertexBindingDescriptionCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount", "Number");
  
    return;
  }
}// pVertexBindingDescriptions
Napi::Value _VkPipelineVertexInputStateCreateInfo::GetpVertexBindingDescriptions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pVertexBindingDescriptions.IsEmpty()) return env.Null();
  return this->pVertexBindingDescriptions.Value().As<Napi::Array>();
}void _VkPipelineVertexInputStateCreateInfo::SetpVertexBindingDescriptions(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pVertexBindingDescriptions.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pVertexBindingDescriptions.Reset();
      this->instance.pVertexBindingDescriptions = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions", "[object VkVertexInputBindingDescription]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pVertexBindingDescriptions = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions", "[object VkVertexInputBindingDescription]");
  
    return;
  }
}// vertexAttributeDescriptionCount
Napi::Value _VkPipelineVertexInputStateCreateInfo::GetvertexAttributeDescriptionCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vertexAttributeDescriptionCount);
}void _VkPipelineVertexInputStateCreateInfo::SetvertexAttributeDescriptionCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.vertexAttributeDescriptionCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount", "Number");
  
    return;
  }
}// pVertexAttributeDescriptions
Napi::Value _VkPipelineVertexInputStateCreateInfo::GetpVertexAttributeDescriptions(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pVertexAttributeDescriptions.IsEmpty()) return env.Null();
  return this->pVertexAttributeDescriptions.Value().As<Napi::Array>();
}void _VkPipelineVertexInputStateCreateInfo::SetpVertexAttributeDescriptions(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pVertexAttributeDescriptions.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pVertexAttributeDescriptions.Reset();
      this->instance.pVertexAttributeDescriptions = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions", "[object VkVertexInputAttributeDescription]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pVertexAttributeDescriptions = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions", "[object VkVertexInputAttributeDescription]");
  
    return;
  }
}
/** ## END VkPipelineVertexInputStateCreateInfo ## **/

/** ## BEGIN VkVertexInputAttributeDescription ## **/

Napi::FunctionReference _VkVertexInputAttributeDescription::constructor;

_VkVertexInputAttributeDescription::_VkVertexInputAttributeDescription(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkVertexInputAttributeDescription>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "location");
      Napi::String sAccess1 = Napi::String::New(env, "binding");
      Napi::String sAccess2 = Napi::String::New(env, "format");
      Napi::String sAccess3 = Napi::String::New(env, "offset");
      if (obj.Has(sAccess0)) this->Setlocation(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setbinding(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setformat(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setoffset(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkVertexInputAttributeDescription constructor cannot be invoked without 'new'");
    }
  }
}

_VkVertexInputAttributeDescription::~_VkVertexInputAttributeDescription() {
  
  
  
  
  
}

Napi::Object _VkVertexInputAttributeDescription::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkVertexInputAttributeDescription", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkVertexInputAttributeDescription::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkVertexInputAttributeDescription::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "location",
    &_VkVertexInputAttributeDescription::Getlocation,
    &_VkVertexInputAttributeDescription::Setlocation,
    napi_enumerable
  ),
  InstanceAccessor(
    "binding",
    &_VkVertexInputAttributeDescription::Getbinding,
    &_VkVertexInputAttributeDescription::Setbinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkVertexInputAttributeDescription::Getformat,
    &_VkVertexInputAttributeDescription::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkVertexInputAttributeDescription::Getoffset,
    &_VkVertexInputAttributeDescription::Setoffset,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkVertexInputAttributeDescription", func);
  return exports;
}

Napi::Value _VkVertexInputAttributeDescription::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkVertexInputAttributeDescription::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputAttributeDescription *)0)->location));
    uint32_t byteLength = sizeof(((VkVertexInputAttributeDescription *)0)->location);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputAttributeDescription *)0)->binding));
    uint32_t byteLength = sizeof(((VkVertexInputAttributeDescription *)0)->binding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputAttributeDescription *)0)->format));
    uint32_t byteLength = sizeof(((VkVertexInputAttributeDescription *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputAttributeDescription *)0)->offset));
    uint32_t byteLength = sizeof(((VkVertexInputAttributeDescription *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkVertexInputAttributeDescription::flush() {
  _VkVertexInputAttributeDescription *self = this;
  
  return true;
}

// location
Napi::Value _VkVertexInputAttributeDescription::Getlocation(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.location);
}void _VkVertexInputAttributeDescription::Setlocation(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.location = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputAttributeDescription.location", "Number");
  
    return;
  }
}// binding
Napi::Value _VkVertexInputAttributeDescription::Getbinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.binding);
}void _VkVertexInputAttributeDescription::Setbinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.binding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputAttributeDescription.binding", "Number");
  
    return;
  }
}// format
Napi::Value _VkVertexInputAttributeDescription::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkVertexInputAttributeDescription::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputAttributeDescription.format", "Number");
  
    return;
  }
}// offset
Napi::Value _VkVertexInputAttributeDescription::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkVertexInputAttributeDescription::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputAttributeDescription.offset", "Number");
  
    return;
  }
}
/** ## END VkVertexInputAttributeDescription ## **/

/** ## BEGIN VkVertexInputBindingDescription ## **/

Napi::FunctionReference _VkVertexInputBindingDescription::constructor;

_VkVertexInputBindingDescription::_VkVertexInputBindingDescription(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkVertexInputBindingDescription>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "binding");
      Napi::String sAccess1 = Napi::String::New(env, "stride");
      Napi::String sAccess2 = Napi::String::New(env, "inputRate");
      if (obj.Has(sAccess0)) this->Setbinding(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setstride(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetinputRate(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkVertexInputBindingDescription constructor cannot be invoked without 'new'");
    }
  }
}

_VkVertexInputBindingDescription::~_VkVertexInputBindingDescription() {
  
  
  
  
}

Napi::Object _VkVertexInputBindingDescription::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkVertexInputBindingDescription", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkVertexInputBindingDescription::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkVertexInputBindingDescription::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "binding",
    &_VkVertexInputBindingDescription::Getbinding,
    &_VkVertexInputBindingDescription::Setbinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "stride",
    &_VkVertexInputBindingDescription::Getstride,
    &_VkVertexInputBindingDescription::Setstride,
    napi_enumerable
  ),
  InstanceAccessor(
    "inputRate",
    &_VkVertexInputBindingDescription::GetinputRate,
    &_VkVertexInputBindingDescription::SetinputRate,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkVertexInputBindingDescription", func);
  return exports;
}

Napi::Value _VkVertexInputBindingDescription::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkVertexInputBindingDescription::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputBindingDescription *)0)->binding));
    uint32_t byteLength = sizeof(((VkVertexInputBindingDescription *)0)->binding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputBindingDescription *)0)->stride));
    uint32_t byteLength = sizeof(((VkVertexInputBindingDescription *)0)->stride);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkVertexInputBindingDescription *)0)->inputRate));
    uint32_t byteLength = sizeof(((VkVertexInputBindingDescription *)0)->inputRate);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkVertexInputBindingDescription::flush() {
  _VkVertexInputBindingDescription *self = this;
  
  return true;
}

// binding
Napi::Value _VkVertexInputBindingDescription::Getbinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.binding);
}void _VkVertexInputBindingDescription::Setbinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.binding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputBindingDescription.binding", "Number");
  
    return;
  }
}// stride
Napi::Value _VkVertexInputBindingDescription::Getstride(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stride);
}void _VkVertexInputBindingDescription::Setstride(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stride = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputBindingDescription.stride", "Number");
  
    return;
  }
}// inputRate
Napi::Value _VkVertexInputBindingDescription::GetinputRate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.inputRate);
}void _VkVertexInputBindingDescription::SetinputRate(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.inputRate = static_cast<VkVertexInputRate>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkVertexInputBindingDescription.inputRate", "Number");
  
    return;
  }
}
/** ## END VkVertexInputBindingDescription ## **/

/** ## BEGIN VkComputePipelineCreateInfo ## **/

Napi::FunctionReference _VkComputePipelineCreateInfo::constructor;

_VkComputePipelineCreateInfo::_VkComputePipelineCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkComputePipelineCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "stage");
      Napi::String sAccess4 = Napi::String::New(env, "layout");
      Napi::String sAccess5 = Napi::String::New(env, "basePipelineHandle");
      Napi::String sAccess6 = Napi::String::New(env, "basePipelineIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setstage(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setlayout(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetbasePipelineHandle(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetbasePipelineIndex(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkComputePipelineCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkComputePipelineCreateInfo::~_VkComputePipelineCreateInfo() {
  
  
  pNext.Reset();
  
  
  stage.Reset();
  
  layout.Reset();
  
  basePipelineHandle.Reset();
  
  
}

Napi::Object _VkComputePipelineCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkComputePipelineCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkComputePipelineCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkComputePipelineCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkComputePipelineCreateInfo::GetsType,
    &_VkComputePipelineCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkComputePipelineCreateInfo::GetpNext,
    &_VkComputePipelineCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkComputePipelineCreateInfo::Getflags,
    &_VkComputePipelineCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "stage",
    &_VkComputePipelineCreateInfo::Getstage,
    &_VkComputePipelineCreateInfo::Setstage,
    napi_enumerable
  ),
  InstanceAccessor(
    "layout",
    &_VkComputePipelineCreateInfo::Getlayout,
    &_VkComputePipelineCreateInfo::Setlayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "basePipelineHandle",
    &_VkComputePipelineCreateInfo::GetbasePipelineHandle,
    &_VkComputePipelineCreateInfo::SetbasePipelineHandle,
    napi_enumerable
  ),
  InstanceAccessor(
    "basePipelineIndex",
    &_VkComputePipelineCreateInfo::GetbasePipelineIndex,
    &_VkComputePipelineCreateInfo::SetbasePipelineIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkComputePipelineCreateInfo", func);
  return exports;
}

Napi::Value _VkComputePipelineCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkComputePipelineCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->stage));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->stage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->layout));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->layout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->basePipelineHandle));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->basePipelineHandle);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComputePipelineCreateInfo *)0)->basePipelineIndex));
    uint32_t byteLength = sizeof(((VkComputePipelineCreateInfo *)0)->basePipelineIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkComputePipelineCreateInfo::flush() {
  _VkComputePipelineCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->stage.IsEmpty())) {
    Napi::Value value = self->stage.Value();
    
    _VkPipelineShaderStageCreateInfo* result = Napi::ObjectWrap<_VkPipelineShaderStageCreateInfo>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.stage = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkComputePipelineCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkComputePipelineCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkComputePipelineCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkComputePipelineCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkComputePipelineCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkComputePipelineCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkComputePipelineCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.flags", "Number");
  
    return;
  }
}// stage
Napi::Value _VkComputePipelineCreateInfo::Getstage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->stage.IsEmpty()) return env.Null();
  return this->stage.Value().As<Napi::Object>();
}void _VkComputePipelineCreateInfo::Setstage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineShaderStageCreateInfo::constructor.Value())) {
      
      this->stage.Reset(value.ToObject(), 1);
      _VkPipelineShaderStageCreateInfo* inst = Napi::ObjectWrap<_VkPipelineShaderStageCreateInfo>::Unwrap(obj);
      inst->flush();
      this->instance.stage = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.stage", "[object VkPipelineShaderStageCreateInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->stage.Reset();
    memset(&this->instance.stage, 0, sizeof(VkPipelineShaderStageCreateInfo));
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.stage", "[object VkPipelineShaderStageCreateInfo]");
  
    return;
  }
}// layout
Napi::Value _VkComputePipelineCreateInfo::Getlayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->layout.IsEmpty()) return env.Null();
  return this->layout.Value().As<Napi::Object>();
}void _VkComputePipelineCreateInfo::Setlayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipelineLayout::constructor.Value())) {
      
      this->layout.Reset(value.ToObject(), 1);
      _VkPipelineLayout* inst = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
      ;
      this->instance.layout = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->layout.Reset();
    this->instance.layout = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
    return;
  }
}// basePipelineHandle
Napi::Value _VkComputePipelineCreateInfo::GetbasePipelineHandle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->basePipelineHandle.IsEmpty()) return env.Null();
  return this->basePipelineHandle.Value().As<Napi::Object>();
}void _VkComputePipelineCreateInfo::SetbasePipelineHandle(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPipeline::constructor.Value())) {
      
      this->basePipelineHandle.Reset(value.ToObject(), 1);
      _VkPipeline* inst = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      ;
      this->instance.basePipelineHandle = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->basePipelineHandle.Reset();
    this->instance.basePipelineHandle = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
    return;
  }
}// basePipelineIndex
Napi::Value _VkComputePipelineCreateInfo::GetbasePipelineIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.basePipelineIndex);
}void _VkComputePipelineCreateInfo::SetbasePipelineIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.basePipelineIndex = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkComputePipelineCreateInfo.basePipelineIndex", "Number");
  
    return;
  }
}
/** ## END VkComputePipelineCreateInfo ## **/

/** ## BEGIN VkPipelineShaderStageCreateInfo ## **/

Napi::FunctionReference _VkPipelineShaderStageCreateInfo::constructor;

_VkPipelineShaderStageCreateInfo::_VkPipelineShaderStageCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPipelineShaderStageCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "stage");
      Napi::String sAccess4 = Napi::String::New(env, "module");
      Napi::String sAccess5 = Napi::String::New(env, "pName");
      Napi::String sAccess6 = Napi::String::New(env, "pSpecializationInfo");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setstage(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setmodule(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpName(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetpSpecializationInfo(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkPipelineShaderStageCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkPipelineShaderStageCreateInfo::~_VkPipelineShaderStageCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  module.Reset();
  
  pName.Reset();
  
  pSpecializationInfo.Reset();
  
}

Napi::Object _VkPipelineShaderStageCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPipelineShaderStageCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPipelineShaderStageCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPipelineShaderStageCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkPipelineShaderStageCreateInfo::GetsType,
    &_VkPipelineShaderStageCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkPipelineShaderStageCreateInfo::GetpNext,
    &_VkPipelineShaderStageCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkPipelineShaderStageCreateInfo::Getflags,
    &_VkPipelineShaderStageCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "stage",
    &_VkPipelineShaderStageCreateInfo::Getstage,
    &_VkPipelineShaderStageCreateInfo::Setstage,
    napi_enumerable
  ),
  InstanceAccessor(
    "module",
    &_VkPipelineShaderStageCreateInfo::Getmodule,
    &_VkPipelineShaderStageCreateInfo::Setmodule,
    napi_enumerable
  ),
  InstanceAccessor(
    "pName",
    &_VkPipelineShaderStageCreateInfo::GetpName,
    &_VkPipelineShaderStageCreateInfo::SetpName,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSpecializationInfo",
    &_VkPipelineShaderStageCreateInfo::GetpSpecializationInfo,
    &_VkPipelineShaderStageCreateInfo::SetpSpecializationInfo,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPipelineShaderStageCreateInfo", func);
  return exports;
}

Napi::Value _VkPipelineShaderStageCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPipelineShaderStageCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->stage));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->stage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->module));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->module);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->pName));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->pName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPipelineShaderStageCreateInfo *)0)->pSpecializationInfo));
    uint32_t byteLength = sizeof(((VkPipelineShaderStageCreateInfo *)0)->pSpecializationInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPipelineShaderStageCreateInfo::flush() {
  _VkPipelineShaderStageCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkPipelineShaderStageCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkPipelineShaderStageCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkPipelineShaderStageCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkPipelineShaderStageCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkPipelineShaderStageCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkPipelineShaderStageCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkPipelineShaderStageCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkPipelineShaderStageCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.flags", "Number");
  
    return;
  }
}// stage
Napi::Value _VkPipelineShaderStageCreateInfo::Getstage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stage);
}void _VkPipelineShaderStageCreateInfo::Setstage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stage = static_cast<VkShaderStageFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.stage", "Number");
  
    return;
  }
}// module
Napi::Value _VkPipelineShaderStageCreateInfo::Getmodule(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->module.IsEmpty()) return env.Null();
  return this->module.Value().As<Napi::Object>();
}void _VkPipelineShaderStageCreateInfo::Setmodule(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkShaderModule::constructor.Value())) {
      
      this->module.Reset(value.ToObject(), 1);
      _VkShaderModule* inst = Napi::ObjectWrap<_VkShaderModule>::Unwrap(obj);
      ;
      this->instance.module = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.module", "[object VkShaderModule]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->module.Reset();
    this->instance.module = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.module", "[object VkShaderModule]");
  
    return;
  }
}// pName
Napi::Value _VkPipelineShaderStageCreateInfo::GetpName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pName.IsEmpty()) return env.Null();
  return this->pName.Value().ToString();
}void _VkPipelineShaderStageCreateInfo::SetpName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pName) delete[] this->instance.pName;
    this->instance.pName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.pName", "String");
  
    return;
  }
}// pSpecializationInfo
Napi::Value _VkPipelineShaderStageCreateInfo::GetpSpecializationInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSpecializationInfo.IsEmpty()) return env.Null();
  return this->pSpecializationInfo.Value().As<Napi::Object>();
}void _VkPipelineShaderStageCreateInfo::SetpSpecializationInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSpecializationInfo::constructor.Value())) {
      
      this->pSpecializationInfo.Reset(value.ToObject(), 1);
      _VkSpecializationInfo* inst = Napi::ObjectWrap<_VkSpecializationInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pSpecializationInfo = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.pSpecializationInfo", "[object VkSpecializationInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pSpecializationInfo.Reset();
    this->instance.pSpecializationInfo = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkPipelineShaderStageCreateInfo.pSpecializationInfo", "[object VkSpecializationInfo]");
  
    return;
  }
}
/** ## END VkPipelineShaderStageCreateInfo ## **/

/** ## BEGIN VkSpecializationInfo ## **/

Napi::FunctionReference _VkSpecializationInfo::constructor;

_VkSpecializationInfo::_VkSpecializationInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSpecializationInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpMapEntries = new std::vector<VkSpecializationMapEntry>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "mapEntryCount");
      Napi::String sAccess1 = Napi::String::New(env, "pMapEntries");
      Napi::String sAccess2 = Napi::String::New(env, "dataSize");
      Napi::String sAccess3 = Napi::String::New(env, "pData");
      if (obj.Has(sAccess0)) this->SetmapEntryCount(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpMapEntries(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdataSize(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpData(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkSpecializationInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSpecializationInfo::~_VkSpecializationInfo() {
  
  
  vpMapEntries->clear();
  delete vpMapEntries;
  
  pMapEntries.Reset();
  
  
  pData.Reset();
  
}

Napi::Object _VkSpecializationInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSpecializationInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSpecializationInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSpecializationInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "mapEntryCount",
    &_VkSpecializationInfo::GetmapEntryCount,
    &_VkSpecializationInfo::SetmapEntryCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pMapEntries",
    &_VkSpecializationInfo::GetpMapEntries,
    &_VkSpecializationInfo::SetpMapEntries,
    napi_enumerable
  ),
  InstanceAccessor(
    "dataSize",
    &_VkSpecializationInfo::GetdataSize,
    &_VkSpecializationInfo::SetdataSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "pData",
    &_VkSpecializationInfo::GetpData,
    &_VkSpecializationInfo::SetpData,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSpecializationInfo", func);
  return exports;
}

Napi::Value _VkSpecializationInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSpecializationInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationInfo *)0)->mapEntryCount));
    uint32_t byteLength = sizeof(((VkSpecializationInfo *)0)->mapEntryCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationInfo *)0)->pMapEntries));
    uint32_t byteLength = sizeof(((VkSpecializationInfo *)0)->pMapEntries);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationInfo *)0)->dataSize));
    uint32_t byteLength = sizeof(((VkSpecializationInfo *)0)->dataSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationInfo *)0)->pData));
    uint32_t byteLength = sizeof(((VkSpecializationInfo *)0)->pData);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSpecializationInfo::flush() {
  _VkSpecializationInfo *self = this;
  if (!(self->pMapEntries.IsEmpty())) {
    Napi::Value value = self->pMapEntries.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.mapEntryCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'mapEntryCount' for 'VkSpecializationInfo.pMapEntries'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSpecializationMapEntry>* data = this->vpMapEntries;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSpecializationMapEntry::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSpecializationInfo.pMapEntries", "[object VkSpecializationMapEntry]");
  
        return false;
      }
      _VkSpecializationMapEntry* result = Napi::ObjectWrap<_VkSpecializationMapEntry>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pMapEntries = data->data();
  }
  return true;
}

// mapEntryCount
Napi::Value _VkSpecializationInfo::GetmapEntryCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mapEntryCount);
}void _VkSpecializationInfo::SetmapEntryCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mapEntryCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationInfo.mapEntryCount", "Number");
  
    return;
  }
}// pMapEntries
Napi::Value _VkSpecializationInfo::GetpMapEntries(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pMapEntries.IsEmpty()) return env.Null();
  return this->pMapEntries.Value().As<Napi::Array>();
}void _VkSpecializationInfo::SetpMapEntries(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pMapEntries.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pMapEntries.Reset();
      this->instance.pMapEntries = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSpecializationInfo.pMapEntries", "[object VkSpecializationMapEntry]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pMapEntries = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationInfo.pMapEntries", "[object VkSpecializationMapEntry]");
  
    return;
  }
}// dataSize
Napi::Value _VkSpecializationInfo::GetdataSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dataSize);
}void _VkSpecializationInfo::SetdataSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dataSize = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationInfo.dataSize", "Number");
  
    return;
  }
}// pData
Napi::Value _VkSpecializationInfo::GetpData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pData.IsEmpty()) return env.Null();
  return this->pData.Value().As<Napi::Object>();
}void _VkSpecializationInfo::SetpData(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pData = buffer.Data();
    this->pData.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pData = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationInfo.pData", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkSpecializationInfo ## **/

/** ## BEGIN VkSpecializationMapEntry ## **/

Napi::FunctionReference _VkSpecializationMapEntry::constructor;

_VkSpecializationMapEntry::_VkSpecializationMapEntry(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSpecializationMapEntry>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "constantID");
      Napi::String sAccess1 = Napi::String::New(env, "offset");
      Napi::String sAccess2 = Napi::String::New(env, "size");
      if (obj.Has(sAccess0)) this->SetconstantID(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setoffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsize(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSpecializationMapEntry constructor cannot be invoked without 'new'");
    }
  }
}

_VkSpecializationMapEntry::~_VkSpecializationMapEntry() {
  
  
  
  
}

Napi::Object _VkSpecializationMapEntry::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSpecializationMapEntry", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSpecializationMapEntry::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSpecializationMapEntry::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "constantID",
    &_VkSpecializationMapEntry::GetconstantID,
    &_VkSpecializationMapEntry::SetconstantID,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkSpecializationMapEntry::Getoffset,
    &_VkSpecializationMapEntry::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkSpecializationMapEntry::Getsize,
    &_VkSpecializationMapEntry::Setsize,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSpecializationMapEntry", func);
  return exports;
}

Napi::Value _VkSpecializationMapEntry::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSpecializationMapEntry::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationMapEntry *)0)->constantID));
    uint32_t byteLength = sizeof(((VkSpecializationMapEntry *)0)->constantID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationMapEntry *)0)->offset));
    uint32_t byteLength = sizeof(((VkSpecializationMapEntry *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSpecializationMapEntry *)0)->size));
    uint32_t byteLength = sizeof(((VkSpecializationMapEntry *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSpecializationMapEntry::flush() {
  _VkSpecializationMapEntry *self = this;
  
  return true;
}

// constantID
Napi::Value _VkSpecializationMapEntry::GetconstantID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.constantID);
}void _VkSpecializationMapEntry::SetconstantID(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.constantID = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationMapEntry.constantID", "Number");
  
    return;
  }
}// offset
Napi::Value _VkSpecializationMapEntry::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkSpecializationMapEntry::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationMapEntry.offset", "Number");
  
    return;
  }
}// size
Napi::Value _VkSpecializationMapEntry::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkSpecializationMapEntry::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSpecializationMapEntry.size", "Number");
  
    return;
  }
}
/** ## END VkSpecializationMapEntry ## **/

/** ## BEGIN VkDescriptorSetAllocateInfo ## **/

Napi::FunctionReference _VkDescriptorSetAllocateInfo::constructor;

_VkDescriptorSetAllocateInfo::_VkDescriptorSetAllocateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetAllocateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    vpSetLayouts = new std::vector<VkDescriptorSetLayout>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "descriptorPool");
      Napi::String sAccess3 = Napi::String::New(env, "descriptorSetCount");
      Napi::String sAccess4 = Napi::String::New(env, "pSetLayouts");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdescriptorPool(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdescriptorSetCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpSetLayouts(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetAllocateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetAllocateInfo::~_VkDescriptorSetAllocateInfo() {
  
  
  pNext.Reset();
  
  descriptorPool.Reset();
  
  
  vpSetLayouts->clear();
  delete vpSetLayouts;
  
  pSetLayouts.Reset();
  
}

Napi::Object _VkDescriptorSetAllocateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetAllocateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetAllocateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetAllocateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetAllocateInfo::GetsType,
    &_VkDescriptorSetAllocateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetAllocateInfo::GetpNext,
    &_VkDescriptorSetAllocateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorPool",
    &_VkDescriptorSetAllocateInfo::GetdescriptorPool,
    &_VkDescriptorSetAllocateInfo::SetdescriptorPool,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorSetCount",
    &_VkDescriptorSetAllocateInfo::GetdescriptorSetCount,
    &_VkDescriptorSetAllocateInfo::SetdescriptorSetCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSetLayouts",
    &_VkDescriptorSetAllocateInfo::GetpSetLayouts,
    &_VkDescriptorSetAllocateInfo::SetpSetLayouts,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetAllocateInfo", func);
  return exports;
}

Napi::Value _VkDescriptorSetAllocateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetAllocateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetAllocateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetAllocateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetAllocateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetAllocateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetAllocateInfo *)0)->descriptorPool));
    uint32_t byteLength = sizeof(((VkDescriptorSetAllocateInfo *)0)->descriptorPool);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetAllocateInfo *)0)->descriptorSetCount));
    uint32_t byteLength = sizeof(((VkDescriptorSetAllocateInfo *)0)->descriptorSetCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetAllocateInfo *)0)->pSetLayouts));
    uint32_t byteLength = sizeof(((VkDescriptorSetAllocateInfo *)0)->pSetLayouts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetAllocateInfo::flush() {
  _VkDescriptorSetAllocateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT) {
      _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* structExt = Napi::ObjectWrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pSetLayouts.IsEmpty())) {
    Napi::Value value = self->pSetLayouts.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorSetCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorSetCount' for 'VkDescriptorSetAllocateInfo.pSetLayouts'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorSetLayout>* data = this->vpSetLayouts;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorSetLayout::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
        return false;
      }
      _VkDescriptorSetLayout* result = Napi::ObjectWrap<_VkDescriptorSetLayout>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSetLayouts = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetAllocateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetAllocateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetAllocateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetAllocateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkDescriptorSetAllocateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.pNext", "[object Object]");
  
    return;
  }
}// descriptorPool
Napi::Value _VkDescriptorSetAllocateInfo::GetdescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->descriptorPool.IsEmpty()) return env.Null();
  return this->descriptorPool.Value().As<Napi::Object>();
}void _VkDescriptorSetAllocateInfo::SetdescriptorPool(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorPool::constructor.Value())) {
      
      this->descriptorPool.Reset(value.ToObject(), 1);
      _VkDescriptorPool* inst = Napi::ObjectWrap<_VkDescriptorPool>::Unwrap(obj);
      ;
      this->instance.descriptorPool = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.descriptorPool", "[object VkDescriptorPool]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->descriptorPool.Reset();
    this->instance.descriptorPool = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.descriptorPool", "[object VkDescriptorPool]");
  
    return;
  }
}// descriptorSetCount
Napi::Value _VkDescriptorSetAllocateInfo::GetdescriptorSetCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorSetCount);
}void _VkDescriptorSetAllocateInfo::SetdescriptorSetCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorSetCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.descriptorSetCount", "Number");
  
    return;
  }
}// pSetLayouts
Napi::Value _VkDescriptorSetAllocateInfo::GetpSetLayouts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSetLayouts.IsEmpty()) return env.Null();
  return this->pSetLayouts.Value().As<Napi::Array>();
}void _VkDescriptorSetAllocateInfo::SetpSetLayouts(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSetLayouts.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSetLayouts.Reset();
      this->instance.pSetLayouts = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSetLayouts = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetAllocateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
    return;
  }
}
/** ## END VkDescriptorSetAllocateInfo ## **/

/** ## BEGIN VkDescriptorPoolCreateInfo ## **/

Napi::FunctionReference _VkDescriptorPoolCreateInfo::constructor;

_VkDescriptorPoolCreateInfo::_VkDescriptorPoolCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorPoolCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    vpPoolSizes = new std::vector<VkDescriptorPoolSize>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "maxSets");
      Napi::String sAccess4 = Napi::String::New(env, "poolSizeCount");
      Napi::String sAccess5 = Napi::String::New(env, "pPoolSizes");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmaxSets(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpoolSizeCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpPoolSizes(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkDescriptorPoolCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorPoolCreateInfo::~_VkDescriptorPoolCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  vpPoolSizes->clear();
  delete vpPoolSizes;
  
  pPoolSizes.Reset();
  
}

Napi::Object _VkDescriptorPoolCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorPoolCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorPoolCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorPoolCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorPoolCreateInfo::GetsType,
    &_VkDescriptorPoolCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorPoolCreateInfo::GetpNext,
    &_VkDescriptorPoolCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDescriptorPoolCreateInfo::Getflags,
    &_VkDescriptorPoolCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxSets",
    &_VkDescriptorPoolCreateInfo::GetmaxSets,
    &_VkDescriptorPoolCreateInfo::SetmaxSets,
    napi_enumerable
  ),
  InstanceAccessor(
    "poolSizeCount",
    &_VkDescriptorPoolCreateInfo::GetpoolSizeCount,
    &_VkDescriptorPoolCreateInfo::SetpoolSizeCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pPoolSizes",
    &_VkDescriptorPoolCreateInfo::GetpPoolSizes,
    &_VkDescriptorPoolCreateInfo::SetpPoolSizes,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorPoolCreateInfo", func);
  return exports;
}

Napi::Value _VkDescriptorPoolCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorPoolCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorPoolCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorPoolCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkDescriptorPoolCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolCreateInfo *)0)->maxSets));
    uint32_t byteLength = sizeof(((VkDescriptorPoolCreateInfo *)0)->maxSets);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolCreateInfo *)0)->poolSizeCount));
    uint32_t byteLength = sizeof(((VkDescriptorPoolCreateInfo *)0)->poolSizeCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolCreateInfo *)0)->pPoolSizes));
    uint32_t byteLength = sizeof(((VkDescriptorPoolCreateInfo *)0)->pPoolSizes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorPoolCreateInfo::flush() {
  _VkDescriptorPoolCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pPoolSizes.IsEmpty())) {
    Napi::Value value = self->pPoolSizes.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.poolSizeCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'poolSizeCount' for 'VkDescriptorPoolCreateInfo.pPoolSizes'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorPoolSize>* data = this->vpPoolSizes;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorPoolSize::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.pPoolSizes", "[object VkDescriptorPoolSize]");
  
        return false;
      }
      _VkDescriptorPoolSize* result = Napi::ObjectWrap<_VkDescriptorPoolSize>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPoolSizes = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDescriptorPoolCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorPoolCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorPoolCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorPoolCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkDescriptorPoolCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDescriptorPoolCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDescriptorPoolCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDescriptorPoolCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.flags", "Number");
  
    return;
  }
}// maxSets
Napi::Value _VkDescriptorPoolCreateInfo::GetmaxSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxSets);
}void _VkDescriptorPoolCreateInfo::SetmaxSets(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxSets = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.maxSets", "Number");
  
    return;
  }
}// poolSizeCount
Napi::Value _VkDescriptorPoolCreateInfo::GetpoolSizeCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.poolSizeCount);
}void _VkDescriptorPoolCreateInfo::SetpoolSizeCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.poolSizeCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.poolSizeCount", "Number");
  
    return;
  }
}// pPoolSizes
Napi::Value _VkDescriptorPoolCreateInfo::GetpPoolSizes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pPoolSizes.IsEmpty()) return env.Null();
  return this->pPoolSizes.Value().As<Napi::Array>();
}void _VkDescriptorPoolCreateInfo::SetpPoolSizes(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pPoolSizes.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pPoolSizes.Reset();
      this->instance.pPoolSizes = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.pPoolSizes", "[object VkDescriptorPoolSize]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pPoolSizes = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolCreateInfo.pPoolSizes", "[object VkDescriptorPoolSize]");
  
    return;
  }
}
/** ## END VkDescriptorPoolCreateInfo ## **/

/** ## BEGIN VkDescriptorPoolSize ## **/

Napi::FunctionReference _VkDescriptorPoolSize::constructor;

_VkDescriptorPoolSize::_VkDescriptorPoolSize(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorPoolSize>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "type");
      Napi::String sAccess1 = Napi::String::New(env, "descriptorCount");
      if (obj.Has(sAccess0)) this->Settype(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdescriptorCount(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkDescriptorPoolSize constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorPoolSize::~_VkDescriptorPoolSize() {
  
  
  
}

Napi::Object _VkDescriptorPoolSize::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorPoolSize", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorPoolSize::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorPoolSize::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "type",
    &_VkDescriptorPoolSize::Gettype,
    &_VkDescriptorPoolSize::Settype,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorCount",
    &_VkDescriptorPoolSize::GetdescriptorCount,
    &_VkDescriptorPoolSize::SetdescriptorCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorPoolSize", func);
  return exports;
}

Napi::Value _VkDescriptorPoolSize::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorPoolSize::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolSize *)0)->type));
    uint32_t byteLength = sizeof(((VkDescriptorPoolSize *)0)->type);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorPoolSize *)0)->descriptorCount));
    uint32_t byteLength = sizeof(((VkDescriptorPoolSize *)0)->descriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorPoolSize::flush() {
  _VkDescriptorPoolSize *self = this;
  
  return true;
}

// type
Napi::Value _VkDescriptorPoolSize::Gettype(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.type);
}void _VkDescriptorPoolSize::Settype(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.type = static_cast<VkDescriptorType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolSize.type", "Number");
  
    return;
  }
}// descriptorCount
Napi::Value _VkDescriptorPoolSize::GetdescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorCount);
}void _VkDescriptorPoolSize::SetdescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorPoolSize.descriptorCount", "Number");
  
    return;
  }
}
/** ## END VkDescriptorPoolSize ## **/

/** ## BEGIN VkDescriptorSetLayoutCreateInfo ## **/

Napi::FunctionReference _VkDescriptorSetLayoutCreateInfo::constructor;

_VkDescriptorSetLayoutCreateInfo::_VkDescriptorSetLayoutCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetLayoutCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    vpBindings = new std::vector<VkDescriptorSetLayoutBinding>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "bindingCount");
      Napi::String sAccess4 = Napi::String::New(env, "pBindings");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetbindingCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpBindings(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetLayoutCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetLayoutCreateInfo::~_VkDescriptorSetLayoutCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpBindings->clear();
  delete vpBindings;
  
  pBindings.Reset();
  
}

Napi::Object _VkDescriptorSetLayoutCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetLayoutCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetLayoutCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetLayoutCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDescriptorSetLayoutCreateInfo::GetsType,
    &_VkDescriptorSetLayoutCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDescriptorSetLayoutCreateInfo::GetpNext,
    &_VkDescriptorSetLayoutCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDescriptorSetLayoutCreateInfo::Getflags,
    &_VkDescriptorSetLayoutCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "bindingCount",
    &_VkDescriptorSetLayoutCreateInfo::GetbindingCount,
    &_VkDescriptorSetLayoutCreateInfo::SetbindingCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBindings",
    &_VkDescriptorSetLayoutCreateInfo::GetpBindings,
    &_VkDescriptorSetLayoutCreateInfo::SetpBindings,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetLayoutCreateInfo", func);
  return exports;
}

Napi::Value _VkDescriptorSetLayoutCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetLayoutCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutCreateInfo *)0)->bindingCount));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutCreateInfo *)0)->bindingCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutCreateInfo *)0)->pBindings));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutCreateInfo *)0)->pBindings);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetLayoutCreateInfo::flush() {
  _VkDescriptorSetLayoutCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT) {
      _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* structExt = Napi::ObjectWrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pBindings.IsEmpty())) {
    Napi::Value value = self->pBindings.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.bindingCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'bindingCount' for 'VkDescriptorSetLayoutCreateInfo.pBindings'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorSetLayoutBinding>* data = this->vpBindings;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorSetLayoutBinding::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.pBindings", "[object VkDescriptorSetLayoutBinding]");
  
        return false;
      }
      _VkDescriptorSetLayoutBinding* result = Napi::ObjectWrap<_VkDescriptorSetLayoutBinding>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBindings = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDescriptorSetLayoutCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDescriptorSetLayoutCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDescriptorSetLayoutCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDescriptorSetLayoutCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDescriptorSetLayoutCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDescriptorSetLayoutCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDescriptorSetLayoutCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.flags", "Number");
  
    return;
  }
}// bindingCount
Napi::Value _VkDescriptorSetLayoutCreateInfo::GetbindingCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bindingCount);
}void _VkDescriptorSetLayoutCreateInfo::SetbindingCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bindingCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.bindingCount", "Number");
  
    return;
  }
}// pBindings
Napi::Value _VkDescriptorSetLayoutCreateInfo::GetpBindings(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBindings.IsEmpty()) return env.Null();
  return this->pBindings.Value().As<Napi::Array>();
}void _VkDescriptorSetLayoutCreateInfo::SetpBindings(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pBindings.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pBindings.Reset();
      this->instance.pBindings = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.pBindings", "[object VkDescriptorSetLayoutBinding]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pBindings = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutCreateInfo.pBindings", "[object VkDescriptorSetLayoutBinding]");
  
    return;
  }
}
/** ## END VkDescriptorSetLayoutCreateInfo ## **/

/** ## BEGIN VkDescriptorSetLayoutBinding ## **/

Napi::FunctionReference _VkDescriptorSetLayoutBinding::constructor;

_VkDescriptorSetLayoutBinding::_VkDescriptorSetLayoutBinding(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorSetLayoutBinding>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpImmutableSamplers = new std::vector<VkSampler>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "binding");
      Napi::String sAccess1 = Napi::String::New(env, "descriptorType");
      Napi::String sAccess2 = Napi::String::New(env, "descriptorCount");
      Napi::String sAccess3 = Napi::String::New(env, "stageFlags");
      Napi::String sAccess4 = Napi::String::New(env, "pImmutableSamplers");
      if (obj.Has(sAccess0)) this->Setbinding(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdescriptorType(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdescriptorCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetstageFlags(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpImmutableSamplers(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkDescriptorSetLayoutBinding constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorSetLayoutBinding::~_VkDescriptorSetLayoutBinding() {
  
  
  
  
  
  vpImmutableSamplers->clear();
  delete vpImmutableSamplers;
  
  pImmutableSamplers.Reset();
  
}

Napi::Object _VkDescriptorSetLayoutBinding::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorSetLayoutBinding", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorSetLayoutBinding::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorSetLayoutBinding::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "binding",
    &_VkDescriptorSetLayoutBinding::Getbinding,
    &_VkDescriptorSetLayoutBinding::Setbinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorType",
    &_VkDescriptorSetLayoutBinding::GetdescriptorType,
    &_VkDescriptorSetLayoutBinding::SetdescriptorType,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorCount",
    &_VkDescriptorSetLayoutBinding::GetdescriptorCount,
    &_VkDescriptorSetLayoutBinding::SetdescriptorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "stageFlags",
    &_VkDescriptorSetLayoutBinding::GetstageFlags,
    &_VkDescriptorSetLayoutBinding::SetstageFlags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pImmutableSamplers",
    &_VkDescriptorSetLayoutBinding::GetpImmutableSamplers,
    &_VkDescriptorSetLayoutBinding::SetpImmutableSamplers,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorSetLayoutBinding", func);
  return exports;
}

Napi::Value _VkDescriptorSetLayoutBinding::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorSetLayoutBinding::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBinding *)0)->binding));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBinding *)0)->binding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBinding *)0)->descriptorType));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBinding *)0)->descriptorType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBinding *)0)->descriptorCount));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBinding *)0)->descriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBinding *)0)->stageFlags));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBinding *)0)->stageFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorSetLayoutBinding *)0)->pImmutableSamplers));
    uint32_t byteLength = sizeof(((VkDescriptorSetLayoutBinding *)0)->pImmutableSamplers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorSetLayoutBinding::flush() {
  _VkDescriptorSetLayoutBinding *self = this;
  if (!(self->pImmutableSamplers.IsEmpty())) {
    Napi::Value value = self->pImmutableSamplers.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorCount' for 'VkDescriptorSetLayoutBinding.pImmutableSamplers'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSampler>* data = this->vpImmutableSamplers;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSampler::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.pImmutableSamplers", "[object VkSampler]");
  
        return false;
      }
      _VkSampler* result = Napi::ObjectWrap<_VkSampler>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pImmutableSamplers = data->data();
  }
  return true;
}

// binding
Napi::Value _VkDescriptorSetLayoutBinding::Getbinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.binding);
}void _VkDescriptorSetLayoutBinding::Setbinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.binding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.binding", "Number");
  
    return;
  }
}// descriptorType
Napi::Value _VkDescriptorSetLayoutBinding::GetdescriptorType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorType);
}void _VkDescriptorSetLayoutBinding::SetdescriptorType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorType = static_cast<VkDescriptorType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.descriptorType", "Number");
  
    return;
  }
}// descriptorCount
Napi::Value _VkDescriptorSetLayoutBinding::GetdescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorCount);
}void _VkDescriptorSetLayoutBinding::SetdescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.descriptorCount", "Number");
  
    return;
  }
}// stageFlags
Napi::Value _VkDescriptorSetLayoutBinding::GetstageFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.stageFlags);
}void _VkDescriptorSetLayoutBinding::SetstageFlags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.stageFlags = static_cast<VkShaderStageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.stageFlags", "Number");
  
    return;
  }
}// pImmutableSamplers
Napi::Value _VkDescriptorSetLayoutBinding::GetpImmutableSamplers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pImmutableSamplers.IsEmpty()) return env.Null();
  return this->pImmutableSamplers.Value().As<Napi::Array>();
}void _VkDescriptorSetLayoutBinding::SetpImmutableSamplers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pImmutableSamplers.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pImmutableSamplers.Reset();
      this->instance.pImmutableSamplers = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.pImmutableSamplers", "[object VkSampler]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pImmutableSamplers = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorSetLayoutBinding.pImmutableSamplers", "[object VkSampler]");
  
    return;
  }
}
/** ## END VkDescriptorSetLayoutBinding ## **/

/** ## BEGIN VkShaderModuleCreateInfo ## **/

Napi::FunctionReference _VkShaderModuleCreateInfo::constructor;

_VkShaderModuleCreateInfo::_VkShaderModuleCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkShaderModuleCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "codeSize");
      Napi::String sAccess4 = Napi::String::New(env, "pCode");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetcodeSize(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpCode(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkShaderModuleCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkShaderModuleCreateInfo::~_VkShaderModuleCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  pCode.Reset();
  
}

Napi::Object _VkShaderModuleCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkShaderModuleCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkShaderModuleCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkShaderModuleCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkShaderModuleCreateInfo::GetsType,
    &_VkShaderModuleCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkShaderModuleCreateInfo::GetpNext,
    &_VkShaderModuleCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkShaderModuleCreateInfo::Getflags,
    &_VkShaderModuleCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "codeSize",
    &_VkShaderModuleCreateInfo::GetcodeSize,
    &_VkShaderModuleCreateInfo::SetcodeSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "pCode",
    &_VkShaderModuleCreateInfo::GetpCode,
    &_VkShaderModuleCreateInfo::SetpCode,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkShaderModuleCreateInfo", func);
  return exports;
}

Napi::Value _VkShaderModuleCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkShaderModuleCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkShaderModuleCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkShaderModuleCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkShaderModuleCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleCreateInfo *)0)->codeSize));
    uint32_t byteLength = sizeof(((VkShaderModuleCreateInfo *)0)->codeSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkShaderModuleCreateInfo *)0)->pCode));
    uint32_t byteLength = sizeof(((VkShaderModuleCreateInfo *)0)->pCode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkShaderModuleCreateInfo::flush() {
  _VkShaderModuleCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT) {
      _VkShaderModuleValidationCacheCreateInfoEXT* structExt = Napi::ObjectWrap<_VkShaderModuleValidationCacheCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkShaderModuleCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkShaderModuleCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkShaderModuleCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkShaderModuleCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkShaderModuleCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkShaderModuleCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkShaderModuleCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkShaderModuleCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.flags", "Number");
  
    return;
  }
}// codeSize
Napi::Value _VkShaderModuleCreateInfo::GetcodeSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.codeSize);
}void _VkShaderModuleCreateInfo::SetcodeSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.codeSize = static_cast<size_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.codeSize", "Number");
  
    return;
  }
}// pCode
Napi::Value _VkShaderModuleCreateInfo::GetpCode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pCode.IsEmpty()) return env.Null();
  return this->pCode.Value().As<Napi::TypedArray>();
}void _VkShaderModuleCreateInfo::SetpCode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint8_array) {
        this->pCode.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.pCode", "Uint8Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pCode.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkShaderModuleCreateInfo.pCode", "Uint8Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pCode = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pCode = nullptr;
  }
}
/** ## END VkShaderModuleCreateInfo ## **/

/** ## BEGIN VkImageResolve ## **/

Napi::FunctionReference _VkImageResolve::constructor;

_VkImageResolve::_VkImageResolve(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageResolve>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "srcSubresource");
      Napi::String sAccess1 = Napi::String::New(env, "srcOffset");
      Napi::String sAccess2 = Napi::String::New(env, "dstSubresource");
      Napi::String sAccess3 = Napi::String::New(env, "dstOffset");
      Napi::String sAccess4 = Napi::String::New(env, "extent");
      if (obj.Has(sAccess0)) this->SetsrcSubresource(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetsrcOffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdstSubresource(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstOffset(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setextent(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkImageResolve constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageResolve::~_VkImageResolve() {
  
  srcSubresource.Reset();
  
  srcOffset.Reset();
  
  dstSubresource.Reset();
  
  dstOffset.Reset();
  
  extent.Reset();
  
}

Napi::Object _VkImageResolve::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageResolve", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageResolve::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageResolve::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "srcSubresource",
    &_VkImageResolve::GetsrcSubresource,
    &_VkImageResolve::SetsrcSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcOffset",
    &_VkImageResolve::GetsrcOffset,
    &_VkImageResolve::SetsrcOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSubresource",
    &_VkImageResolve::GetdstSubresource,
    &_VkImageResolve::SetdstSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstOffset",
    &_VkImageResolve::GetdstOffset,
    &_VkImageResolve::SetdstOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "extent",
    &_VkImageResolve::Getextent,
    &_VkImageResolve::Setextent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageResolve", func);
  return exports;
}

Napi::Value _VkImageResolve::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageResolve::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageResolve *)0)->srcSubresource));
    uint32_t byteLength = sizeof(((VkImageResolve *)0)->srcSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageResolve *)0)->srcOffset));
    uint32_t byteLength = sizeof(((VkImageResolve *)0)->srcOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageResolve *)0)->dstSubresource));
    uint32_t byteLength = sizeof(((VkImageResolve *)0)->dstSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageResolve *)0)->dstOffset));
    uint32_t byteLength = sizeof(((VkImageResolve *)0)->dstOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageResolve *)0)->extent));
    uint32_t byteLength = sizeof(((VkImageResolve *)0)->extent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageResolve::flush() {
  _VkImageResolve *self = this;
  if (!(self->srcSubresource.IsEmpty())) {
    Napi::Value value = self->srcSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.srcSubresource = result->instance;
  }if (!(self->srcOffset.IsEmpty())) {
    Napi::Value value = self->srcOffset.Value();
    
    _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.srcOffset = result->instance;
  }if (!(self->dstSubresource.IsEmpty())) {
    Napi::Value value = self->dstSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.dstSubresource = result->instance;
  }if (!(self->dstOffset.IsEmpty())) {
    Napi::Value value = self->dstOffset.Value();
    
    _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.dstOffset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    Napi::Value value = self->extent.Value();
    
    _VkExtent3D* result = Napi::ObjectWrap<_VkExtent3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

// srcSubresource
Napi::Value _VkImageResolve::GetsrcSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcSubresource.IsEmpty()) return env.Null();
  return this->srcSubresource.Value().As<Napi::Object>();
}void _VkImageResolve::SetsrcSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->srcSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.srcSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageResolve.srcSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcSubresource.Reset();
    memset(&this->instance.srcSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkImageResolve.srcSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// srcOffset
Napi::Value _VkImageResolve::GetsrcOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcOffset.IsEmpty()) return env.Null();
  return this->srcOffset.Value().As<Napi::Object>();
}void _VkImageResolve::SetsrcOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset3D::constructor.Value())) {
      
      this->srcOffset.Reset(value.ToObject(), 1);
      _VkOffset3D* inst = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
      inst->flush();
      this->instance.srcOffset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageResolve.srcOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcOffset.Reset();
    memset(&this->instance.srcOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageResolve.srcOffset", "[object VkOffset3D]");
  
    return;
  }
}// dstSubresource
Napi::Value _VkImageResolve::GetdstSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstSubresource.IsEmpty()) return env.Null();
  return this->dstSubresource.Value().As<Napi::Object>();
}void _VkImageResolve::SetdstSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->dstSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.dstSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageResolve.dstSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstSubresource.Reset();
    memset(&this->instance.dstSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkImageResolve.dstSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// dstOffset
Napi::Value _VkImageResolve::GetdstOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstOffset.IsEmpty()) return env.Null();
  return this->dstOffset.Value().As<Napi::Object>();
}void _VkImageResolve::SetdstOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset3D::constructor.Value())) {
      
      this->dstOffset.Reset(value.ToObject(), 1);
      _VkOffset3D* inst = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
      inst->flush();
      this->instance.dstOffset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageResolve.dstOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstOffset.Reset();
    memset(&this->instance.dstOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageResolve.dstOffset", "[object VkOffset3D]");
  
    return;
  }
}// extent
Napi::Value _VkImageResolve::Getextent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extent.IsEmpty()) return env.Null();
  return this->extent.Value().As<Napi::Object>();
}void _VkImageResolve::Setextent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent3D::constructor.Value())) {
      
      this->extent.Reset(value.ToObject(), 1);
      _VkExtent3D* inst = Napi::ObjectWrap<_VkExtent3D>::Unwrap(obj);
      inst->flush();
      this->instance.extent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageResolve.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->extent.Reset();
    memset(&this->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageResolve.extent", "[object VkExtent3D]");
  
    return;
  }
}
/** ## END VkImageResolve ## **/

/** ## BEGIN VkBufferImageCopy ## **/

Napi::FunctionReference _VkBufferImageCopy::constructor;

_VkBufferImageCopy::_VkBufferImageCopy(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferImageCopy>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "bufferOffset");
      Napi::String sAccess1 = Napi::String::New(env, "bufferRowLength");
      Napi::String sAccess2 = Napi::String::New(env, "bufferImageHeight");
      Napi::String sAccess3 = Napi::String::New(env, "imageSubresource");
      Napi::String sAccess4 = Napi::String::New(env, "imageOffset");
      Napi::String sAccess5 = Napi::String::New(env, "imageExtent");
      if (obj.Has(sAccess0)) this->SetbufferOffset(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbufferRowLength(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetbufferImageHeight(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetimageSubresource(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetimageOffset(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetimageExtent(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkBufferImageCopy constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferImageCopy::~_VkBufferImageCopy() {
  
  
  
  
  imageSubresource.Reset();
  
  imageOffset.Reset();
  
  imageExtent.Reset();
  
}

Napi::Object _VkBufferImageCopy::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferImageCopy", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferImageCopy::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferImageCopy::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "bufferOffset",
    &_VkBufferImageCopy::GetbufferOffset,
    &_VkBufferImageCopy::SetbufferOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "bufferRowLength",
    &_VkBufferImageCopy::GetbufferRowLength,
    &_VkBufferImageCopy::SetbufferRowLength,
    napi_enumerable
  ),
  InstanceAccessor(
    "bufferImageHeight",
    &_VkBufferImageCopy::GetbufferImageHeight,
    &_VkBufferImageCopy::SetbufferImageHeight,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageSubresource",
    &_VkBufferImageCopy::GetimageSubresource,
    &_VkBufferImageCopy::SetimageSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageOffset",
    &_VkBufferImageCopy::GetimageOffset,
    &_VkBufferImageCopy::SetimageOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageExtent",
    &_VkBufferImageCopy::GetimageExtent,
    &_VkBufferImageCopy::SetimageExtent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferImageCopy", func);
  return exports;
}

Napi::Value _VkBufferImageCopy::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferImageCopy::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferImageCopy *)0)->bufferOffset));
    uint32_t byteLength = sizeof(((VkBufferImageCopy *)0)->bufferOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferImageCopy *)0)->bufferRowLength));
    uint32_t byteLength = sizeof(((VkBufferImageCopy *)0)->bufferRowLength);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferImageCopy *)0)->bufferImageHeight));
    uint32_t byteLength = sizeof(((VkBufferImageCopy *)0)->bufferImageHeight);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferImageCopy *)0)->imageSubresource));
    uint32_t byteLength = sizeof(((VkBufferImageCopy *)0)->imageSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferImageCopy *)0)->imageOffset));
    uint32_t byteLength = sizeof(((VkBufferImageCopy *)0)->imageOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferImageCopy *)0)->imageExtent));
    uint32_t byteLength = sizeof(((VkBufferImageCopy *)0)->imageExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferImageCopy::flush() {
  _VkBufferImageCopy *self = this;
  if (!(self->imageSubresource.IsEmpty())) {
    Napi::Value value = self->imageSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.imageSubresource = result->instance;
  }if (!(self->imageOffset.IsEmpty())) {
    Napi::Value value = self->imageOffset.Value();
    
    _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.imageOffset = result->instance;
  }if (!(self->imageExtent.IsEmpty())) {
    Napi::Value value = self->imageExtent.Value();
    
    _VkExtent3D* result = Napi::ObjectWrap<_VkExtent3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.imageExtent = result->instance;
  }
  return true;
}

// bufferOffset
Napi::Value _VkBufferImageCopy::GetbufferOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bufferOffset);
}void _VkBufferImageCopy::SetbufferOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bufferOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferImageCopy.bufferOffset", "Number");
  
    return;
  }
}// bufferRowLength
Napi::Value _VkBufferImageCopy::GetbufferRowLength(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bufferRowLength);
}void _VkBufferImageCopy::SetbufferRowLength(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bufferRowLength = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferImageCopy.bufferRowLength", "Number");
  
    return;
  }
}// bufferImageHeight
Napi::Value _VkBufferImageCopy::GetbufferImageHeight(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bufferImageHeight);
}void _VkBufferImageCopy::SetbufferImageHeight(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bufferImageHeight = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferImageCopy.bufferImageHeight", "Number");
  
    return;
  }
}// imageSubresource
Napi::Value _VkBufferImageCopy::GetimageSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageSubresource.IsEmpty()) return env.Null();
  return this->imageSubresource.Value().As<Napi::Object>();
}void _VkBufferImageCopy::SetimageSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->imageSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.imageSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferImageCopy.imageSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->imageSubresource.Reset();
    memset(&this->instance.imageSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkBufferImageCopy.imageSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// imageOffset
Napi::Value _VkBufferImageCopy::GetimageOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageOffset.IsEmpty()) return env.Null();
  return this->imageOffset.Value().As<Napi::Object>();
}void _VkBufferImageCopy::SetimageOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset3D::constructor.Value())) {
      
      this->imageOffset.Reset(value.ToObject(), 1);
      _VkOffset3D* inst = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
      inst->flush();
      this->instance.imageOffset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferImageCopy.imageOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->imageOffset.Reset();
    memset(&this->instance.imageOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NapiObjectTypeError(value, "VkBufferImageCopy.imageOffset", "[object VkOffset3D]");
  
    return;
  }
}// imageExtent
Napi::Value _VkBufferImageCopy::GetimageExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageExtent.IsEmpty()) return env.Null();
  return this->imageExtent.Value().As<Napi::Object>();
}void _VkBufferImageCopy::SetimageExtent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent3D::constructor.Value())) {
      
      this->imageExtent.Reset(value.ToObject(), 1);
      _VkExtent3D* inst = Napi::ObjectWrap<_VkExtent3D>::Unwrap(obj);
      inst->flush();
      this->instance.imageExtent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferImageCopy.imageExtent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->imageExtent.Reset();
    memset(&this->instance.imageExtent, 0, sizeof(VkExtent3D));
  } else {
    
    NapiObjectTypeError(value, "VkBufferImageCopy.imageExtent", "[object VkExtent3D]");
  
    return;
  }
}
/** ## END VkBufferImageCopy ## **/

/** ## BEGIN VkImageBlit ## **/

Napi::FunctionReference _VkImageBlit::constructor;

_VkImageBlit::_VkImageBlit(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageBlit>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vsrcOffsets = new std::vector<VkOffset3D>;
    vdstOffsets = new std::vector<VkOffset3D>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "srcSubresource");
      Napi::String sAccess1 = Napi::String::New(env, "srcOffsets");
      Napi::String sAccess2 = Napi::String::New(env, "dstSubresource");
      Napi::String sAccess3 = Napi::String::New(env, "dstOffsets");
      if (obj.Has(sAccess0)) this->SetsrcSubresource(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetsrcOffsets(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdstSubresource(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstOffsets(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkImageBlit constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageBlit::~_VkImageBlit() {
  
  srcSubresource.Reset();
  
  vsrcOffsets->clear();
  delete vsrcOffsets;
  
  srcOffsets.Reset();
  
  dstSubresource.Reset();
  
  vdstOffsets->clear();
  delete vdstOffsets;
  
  dstOffsets.Reset();
  
}

Napi::Object _VkImageBlit::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageBlit", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageBlit::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageBlit::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "srcSubresource",
    &_VkImageBlit::GetsrcSubresource,
    &_VkImageBlit::SetsrcSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcOffsets",
    &_VkImageBlit::GetsrcOffsets,
    &_VkImageBlit::SetsrcOffsets,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSubresource",
    &_VkImageBlit::GetdstSubresource,
    &_VkImageBlit::SetdstSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstOffsets",
    &_VkImageBlit::GetdstOffsets,
    &_VkImageBlit::SetdstOffsets,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageBlit", func);
  return exports;
}

Napi::Value _VkImageBlit::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageBlit::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageBlit *)0)->srcSubresource));
    uint32_t byteLength = sizeof(((VkImageBlit *)0)->srcSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageBlit *)0)->srcOffsets));
    uint32_t byteLength = sizeof(((VkImageBlit *)0)->srcOffsets);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageBlit *)0)->dstSubresource));
    uint32_t byteLength = sizeof(((VkImageBlit *)0)->dstSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageBlit *)0)->dstOffsets));
    uint32_t byteLength = sizeof(((VkImageBlit *)0)->dstOffsets);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageBlit::flush() {
  _VkImageBlit *self = this;
  if (!(self->srcSubresource.IsEmpty())) {
    Napi::Value value = self->srcSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.srcSubresource = result->instance;
  }if (!(self->srcOffsets.IsEmpty())) {
    Napi::Value value = self->srcOffsets.Value();
    
    if (value.IsArray()) {
      Napi::Array array = value.As<Napi::Array>();
      // validate length
      if (array.Length() != 2) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '2' for 'VkImageBlit.srcOffsets'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<VkOffset3D>* data = this->vsrcOffsets;
      data->clear();
      for (unsigned int ii = 0; ii < array.Length(); ++ii) {
        Napi::Object obj = array.Get(ii).As<Napi::Object>();
        if (!(obj.InstanceOf(_VkOffset3D::constructor.Value()))) {
          
    NapiObjectTypeError(value, "VkImageBlit.srcOffsets", "[object VkOffset3D]");
  
          return false;
        }
        _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
        if (!result->flush()) return false;
        data->push_back(result->instance);
      };
      memcpy(this->instance.srcOffsets, data->data(), sizeof(VkOffset3D) * 2);
    } else if (value.IsNull()) {
      memset(&this->instance.srcOffsets, 0, sizeof(VkOffset3D));
    } else {
      
    NapiObjectTypeError(value, "VkImageBlit.srcOffsets", "[object VkOffset3D]");
  
      return false;
    }
  }if (!(self->dstSubresource.IsEmpty())) {
    Napi::Value value = self->dstSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.dstSubresource = result->instance;
  }if (!(self->dstOffsets.IsEmpty())) {
    Napi::Value value = self->dstOffsets.Value();
    
    if (value.IsArray()) {
      Napi::Array array = value.As<Napi::Array>();
      // validate length
      if (array.Length() != 2) {
        Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of '2' for 'VkImageBlit.dstOffsets'").ThrowAsJavaScriptException();
        return false;
      }
      std::vector<VkOffset3D>* data = this->vdstOffsets;
      data->clear();
      for (unsigned int ii = 0; ii < array.Length(); ++ii) {
        Napi::Object obj = array.Get(ii).As<Napi::Object>();
        if (!(obj.InstanceOf(_VkOffset3D::constructor.Value()))) {
          
    NapiObjectTypeError(value, "VkImageBlit.dstOffsets", "[object VkOffset3D]");
  
          return false;
        }
        _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
        if (!result->flush()) return false;
        data->push_back(result->instance);
      };
      memcpy(this->instance.dstOffsets, data->data(), sizeof(VkOffset3D) * 2);
    } else if (value.IsNull()) {
      memset(&this->instance.dstOffsets, 0, sizeof(VkOffset3D));
    } else {
      
    NapiObjectTypeError(value, "VkImageBlit.dstOffsets", "[object VkOffset3D]");
  
      return false;
    }
  }
  return true;
}

// srcSubresource
Napi::Value _VkImageBlit::GetsrcSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcSubresource.IsEmpty()) return env.Null();
  return this->srcSubresource.Value().As<Napi::Object>();
}void _VkImageBlit::SetsrcSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->srcSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.srcSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageBlit.srcSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcSubresource.Reset();
    memset(&this->instance.srcSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkImageBlit.srcSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// srcOffsets
Napi::Value _VkImageBlit::GetsrcOffsets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcOffsets.IsEmpty()) return env.Null();
  return this->srcOffsets.Value().As<Napi::Array>();
}void _VkImageBlit::SetsrcOffsets(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->srcOffsets.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->srcOffsets.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkImageBlit.srcOffsets", "[object VkOffset3D]");
  
    return;
  }
}// dstSubresource
Napi::Value _VkImageBlit::GetdstSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstSubresource.IsEmpty()) return env.Null();
  return this->dstSubresource.Value().As<Napi::Object>();
}void _VkImageBlit::SetdstSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->dstSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.dstSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageBlit.dstSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstSubresource.Reset();
    memset(&this->instance.dstSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkImageBlit.dstSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// dstOffsets
Napi::Value _VkImageBlit::GetdstOffsets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstOffsets.IsEmpty()) return env.Null();
  return this->dstOffsets.Value().As<Napi::Array>();
}void _VkImageBlit::SetdstOffsets(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (value.IsArray()) {
    this->dstOffsets.Reset(value.ToObject(), 1);
  } else if (value.IsNull()) {
    this->dstOffsets.Reset();
  } else {
    
    NapiObjectTypeError(value, "VkImageBlit.dstOffsets", "[object VkOffset3D]");
  
    return;
  }
}
/** ## END VkImageBlit ## **/

/** ## BEGIN VkImageCopy ## **/

Napi::FunctionReference _VkImageCopy::constructor;

_VkImageCopy::_VkImageCopy(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageCopy>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "srcSubresource");
      Napi::String sAccess1 = Napi::String::New(env, "srcOffset");
      Napi::String sAccess2 = Napi::String::New(env, "dstSubresource");
      Napi::String sAccess3 = Napi::String::New(env, "dstOffset");
      Napi::String sAccess4 = Napi::String::New(env, "extent");
      if (obj.Has(sAccess0)) this->SetsrcSubresource(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetsrcOffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdstSubresource(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstOffset(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setextent(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkImageCopy constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageCopy::~_VkImageCopy() {
  
  srcSubresource.Reset();
  
  srcOffset.Reset();
  
  dstSubresource.Reset();
  
  dstOffset.Reset();
  
  extent.Reset();
  
}

Napi::Object _VkImageCopy::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageCopy", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageCopy::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageCopy::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "srcSubresource",
    &_VkImageCopy::GetsrcSubresource,
    &_VkImageCopy::SetsrcSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcOffset",
    &_VkImageCopy::GetsrcOffset,
    &_VkImageCopy::SetsrcOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSubresource",
    &_VkImageCopy::GetdstSubresource,
    &_VkImageCopy::SetdstSubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstOffset",
    &_VkImageCopy::GetdstOffset,
    &_VkImageCopy::SetdstOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "extent",
    &_VkImageCopy::Getextent,
    &_VkImageCopy::Setextent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageCopy", func);
  return exports;
}

Napi::Value _VkImageCopy::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageCopy::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCopy *)0)->srcSubresource));
    uint32_t byteLength = sizeof(((VkImageCopy *)0)->srcSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCopy *)0)->srcOffset));
    uint32_t byteLength = sizeof(((VkImageCopy *)0)->srcOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCopy *)0)->dstSubresource));
    uint32_t byteLength = sizeof(((VkImageCopy *)0)->dstSubresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCopy *)0)->dstOffset));
    uint32_t byteLength = sizeof(((VkImageCopy *)0)->dstOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCopy *)0)->extent));
    uint32_t byteLength = sizeof(((VkImageCopy *)0)->extent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageCopy::flush() {
  _VkImageCopy *self = this;
  if (!(self->srcSubresource.IsEmpty())) {
    Napi::Value value = self->srcSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.srcSubresource = result->instance;
  }if (!(self->srcOffset.IsEmpty())) {
    Napi::Value value = self->srcOffset.Value();
    
    _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.srcOffset = result->instance;
  }if (!(self->dstSubresource.IsEmpty())) {
    Napi::Value value = self->dstSubresource.Value();
    
    _VkImageSubresourceLayers* result = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.dstSubresource = result->instance;
  }if (!(self->dstOffset.IsEmpty())) {
    Napi::Value value = self->dstOffset.Value();
    
    _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.dstOffset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    Napi::Value value = self->extent.Value();
    
    _VkExtent3D* result = Napi::ObjectWrap<_VkExtent3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

// srcSubresource
Napi::Value _VkImageCopy::GetsrcSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcSubresource.IsEmpty()) return env.Null();
  return this->srcSubresource.Value().As<Napi::Object>();
}void _VkImageCopy::SetsrcSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->srcSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.srcSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageCopy.srcSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcSubresource.Reset();
    memset(&this->instance.srcSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkImageCopy.srcSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// srcOffset
Napi::Value _VkImageCopy::GetsrcOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcOffset.IsEmpty()) return env.Null();
  return this->srcOffset.Value().As<Napi::Object>();
}void _VkImageCopy::SetsrcOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset3D::constructor.Value())) {
      
      this->srcOffset.Reset(value.ToObject(), 1);
      _VkOffset3D* inst = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
      inst->flush();
      this->instance.srcOffset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageCopy.srcOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcOffset.Reset();
    memset(&this->instance.srcOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageCopy.srcOffset", "[object VkOffset3D]");
  
    return;
  }
}// dstSubresource
Napi::Value _VkImageCopy::GetdstSubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstSubresource.IsEmpty()) return env.Null();
  return this->dstSubresource.Value().As<Napi::Object>();
}void _VkImageCopy::SetdstSubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceLayers::constructor.Value())) {
      
      this->dstSubresource.Reset(value.ToObject(), 1);
      _VkImageSubresourceLayers* inst = Napi::ObjectWrap<_VkImageSubresourceLayers>::Unwrap(obj);
      inst->flush();
      this->instance.dstSubresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageCopy.dstSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstSubresource.Reset();
    memset(&this->instance.dstSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NapiObjectTypeError(value, "VkImageCopy.dstSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// dstOffset
Napi::Value _VkImageCopy::GetdstOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstOffset.IsEmpty()) return env.Null();
  return this->dstOffset.Value().As<Napi::Object>();
}void _VkImageCopy::SetdstOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset3D::constructor.Value())) {
      
      this->dstOffset.Reset(value.ToObject(), 1);
      _VkOffset3D* inst = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
      inst->flush();
      this->instance.dstOffset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageCopy.dstOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstOffset.Reset();
    memset(&this->instance.dstOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageCopy.dstOffset", "[object VkOffset3D]");
  
    return;
  }
}// extent
Napi::Value _VkImageCopy::Getextent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extent.IsEmpty()) return env.Null();
  return this->extent.Value().As<Napi::Object>();
}void _VkImageCopy::Setextent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent3D::constructor.Value())) {
      
      this->extent.Reset(value.ToObject(), 1);
      _VkExtent3D* inst = Napi::ObjectWrap<_VkExtent3D>::Unwrap(obj);
      inst->flush();
      this->instance.extent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageCopy.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->extent.Reset();
    memset(&this->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageCopy.extent", "[object VkExtent3D]");
  
    return;
  }
}
/** ## END VkImageCopy ## **/

/** ## BEGIN VkBindSparseInfo ## **/

Napi::FunctionReference _VkBindSparseInfo::constructor;

_VkBindSparseInfo::_VkBindSparseInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBindSparseInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
    vpWaitSemaphores = new std::vector<VkSemaphore>;
    vpBufferBinds = new std::vector<VkSparseBufferMemoryBindInfo>;
    vpImageOpaqueBinds = new std::vector<VkSparseImageOpaqueMemoryBindInfo>;
    vpImageBinds = new std::vector<VkSparseImageMemoryBindInfo>;
    vpSignalSemaphores = new std::vector<VkSemaphore>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "waitSemaphoreCount");
      Napi::String sAccess3 = Napi::String::New(env, "pWaitSemaphores");
      Napi::String sAccess4 = Napi::String::New(env, "bufferBindCount");
      Napi::String sAccess5 = Napi::String::New(env, "pBufferBinds");
      Napi::String sAccess6 = Napi::String::New(env, "imageOpaqueBindCount");
      Napi::String sAccess7 = Napi::String::New(env, "pImageOpaqueBinds");
      Napi::String sAccess8 = Napi::String::New(env, "imageBindCount");
      Napi::String sAccess9 = Napi::String::New(env, "pImageBinds");
      Napi::String sAccess10 = Napi::String::New(env, "signalSemaphoreCount");
      Napi::String sAccess11 = Napi::String::New(env, "pSignalSemaphores");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetwaitSemaphoreCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpWaitSemaphores(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetbufferBindCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpBufferBinds(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetimageOpaqueBindCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpImageOpaqueBinds(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetimageBindCount(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpImageBinds(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->SetsignalSemaphoreCount(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetpSignalSemaphores(info, obj.Get(sAccess11));
      
    } else {
      Napi::Error::New(env, "VkBindSparseInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBindSparseInfo::~_VkBindSparseInfo() {
  
  
  pNext.Reset();
  
  
  vpWaitSemaphores->clear();
  delete vpWaitSemaphores;
  
  pWaitSemaphores.Reset();
  
  
  vpBufferBinds->clear();
  delete vpBufferBinds;
  
  pBufferBinds.Reset();
  
  
  vpImageOpaqueBinds->clear();
  delete vpImageOpaqueBinds;
  
  pImageOpaqueBinds.Reset();
  
  
  vpImageBinds->clear();
  delete vpImageBinds;
  
  pImageBinds.Reset();
  
  
  vpSignalSemaphores->clear();
  delete vpSignalSemaphores;
  
  pSignalSemaphores.Reset();
  
}

Napi::Object _VkBindSparseInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBindSparseInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBindSparseInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBindSparseInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBindSparseInfo::GetsType,
    &_VkBindSparseInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBindSparseInfo::GetpNext,
    &_VkBindSparseInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "waitSemaphoreCount",
    &_VkBindSparseInfo::GetwaitSemaphoreCount,
    &_VkBindSparseInfo::SetwaitSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pWaitSemaphores",
    &_VkBindSparseInfo::GetpWaitSemaphores,
    &_VkBindSparseInfo::SetpWaitSemaphores,
    napi_enumerable
  ),
  InstanceAccessor(
    "bufferBindCount",
    &_VkBindSparseInfo::GetbufferBindCount,
    &_VkBindSparseInfo::SetbufferBindCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBufferBinds",
    &_VkBindSparseInfo::GetpBufferBinds,
    &_VkBindSparseInfo::SetpBufferBinds,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageOpaqueBindCount",
    &_VkBindSparseInfo::GetimageOpaqueBindCount,
    &_VkBindSparseInfo::SetimageOpaqueBindCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pImageOpaqueBinds",
    &_VkBindSparseInfo::GetpImageOpaqueBinds,
    &_VkBindSparseInfo::SetpImageOpaqueBinds,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageBindCount",
    &_VkBindSparseInfo::GetimageBindCount,
    &_VkBindSparseInfo::SetimageBindCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pImageBinds",
    &_VkBindSparseInfo::GetpImageBinds,
    &_VkBindSparseInfo::SetpImageBinds,
    napi_enumerable
  ),
  InstanceAccessor(
    "signalSemaphoreCount",
    &_VkBindSparseInfo::GetsignalSemaphoreCount,
    &_VkBindSparseInfo::SetsignalSemaphoreCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pSignalSemaphores",
    &_VkBindSparseInfo::GetpSignalSemaphores,
    &_VkBindSparseInfo::SetpSignalSemaphores,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBindSparseInfo", func);
  return exports;
}

Napi::Value _VkBindSparseInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBindSparseInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->waitSemaphoreCount));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->waitSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->pWaitSemaphores));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->pWaitSemaphores);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->bufferBindCount));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->bufferBindCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->pBufferBinds));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->pBufferBinds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->imageOpaqueBindCount));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->imageOpaqueBindCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->pImageOpaqueBinds));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->pImageOpaqueBinds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->imageBindCount));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->imageBindCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->pImageBinds));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->pImageBinds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->signalSemaphoreCount));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->signalSemaphoreCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBindSparseInfo *)0)->pSignalSemaphores));
    uint32_t byteLength = sizeof(((VkBindSparseInfo *)0)->pSignalSemaphores);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBindSparseInfo::flush() {
  _VkBindSparseInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO) {
      _VkDeviceGroupBindSparseInfo* structExt = Napi::ObjectWrap<_VkDeviceGroupBindSparseInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pWaitSemaphores.IsEmpty())) {
    Napi::Value value = self->pWaitSemaphores.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.waitSemaphoreCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'waitSemaphoreCount' for 'VkBindSparseInfo.pWaitSemaphores'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSemaphore>* data = this->vpWaitSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindSparseInfo.pWaitSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pWaitSemaphores = data->data();
  }if (!(self->pBufferBinds.IsEmpty())) {
    Napi::Value value = self->pBufferBinds.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.bufferBindCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'bufferBindCount' for 'VkBindSparseInfo.pBufferBinds'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSparseBufferMemoryBindInfo>* data = this->vpBufferBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSparseBufferMemoryBindInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindSparseInfo.pBufferBinds", "[object VkSparseBufferMemoryBindInfo]");
  
        return false;
      }
      _VkSparseBufferMemoryBindInfo* result = Napi::ObjectWrap<_VkSparseBufferMemoryBindInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBufferBinds = data->data();
  }if (!(self->pImageOpaqueBinds.IsEmpty())) {
    Napi::Value value = self->pImageOpaqueBinds.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.imageOpaqueBindCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'imageOpaqueBindCount' for 'VkBindSparseInfo.pImageOpaqueBinds'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSparseImageOpaqueMemoryBindInfo>* data = this->vpImageOpaqueBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSparseImageOpaqueMemoryBindInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindSparseInfo.pImageOpaqueBinds", "[object VkSparseImageOpaqueMemoryBindInfo]");
  
        return false;
      }
      _VkSparseImageOpaqueMemoryBindInfo* result = Napi::ObjectWrap<_VkSparseImageOpaqueMemoryBindInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pImageOpaqueBinds = data->data();
  }if (!(self->pImageBinds.IsEmpty())) {
    Napi::Value value = self->pImageBinds.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.imageBindCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'imageBindCount' for 'VkBindSparseInfo.pImageBinds'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSparseImageMemoryBindInfo>* data = this->vpImageBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSparseImageMemoryBindInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindSparseInfo.pImageBinds", "[object VkSparseImageMemoryBindInfo]");
  
        return false;
      }
      _VkSparseImageMemoryBindInfo* result = Napi::ObjectWrap<_VkSparseImageMemoryBindInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pImageBinds = data->data();
  }if (!(self->pSignalSemaphores.IsEmpty())) {
    Napi::Value value = self->pSignalSemaphores.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.signalSemaphoreCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'signalSemaphoreCount' for 'VkBindSparseInfo.pSignalSemaphores'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSemaphore>* data = this->vpSignalSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkBindSparseInfo.pSignalSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSignalSemaphores = data->data();
  }
  return true;
}

// sType
Napi::Value _VkBindSparseInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBindSparseInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBindSparseInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBindSparseInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkBindSparseInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkBindSparseInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.pNext", "[object Object]");
  
    return;
  }
}// waitSemaphoreCount
Napi::Value _VkBindSparseInfo::GetwaitSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.waitSemaphoreCount);
}void _VkBindSparseInfo::SetwaitSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.waitSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphores
Napi::Value _VkBindSparseInfo::GetpWaitSemaphores(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pWaitSemaphores.IsEmpty()) return env.Null();
  return this->pWaitSemaphores.Value().As<Napi::Array>();
}void _VkBindSparseInfo::SetpWaitSemaphores(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pWaitSemaphores.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pWaitSemaphores.Reset();
      this->instance.pWaitSemaphores = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindSparseInfo.pWaitSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pWaitSemaphores = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.pWaitSemaphores", "[object VkSemaphore]");
  
    return;
  }
}// bufferBindCount
Napi::Value _VkBindSparseInfo::GetbufferBindCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bufferBindCount);
}void _VkBindSparseInfo::SetbufferBindCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bufferBindCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.bufferBindCount", "Number");
  
    return;
  }
}// pBufferBinds
Napi::Value _VkBindSparseInfo::GetpBufferBinds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBufferBinds.IsEmpty()) return env.Null();
  return this->pBufferBinds.Value().As<Napi::Array>();
}void _VkBindSparseInfo::SetpBufferBinds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pBufferBinds.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pBufferBinds.Reset();
      this->instance.pBufferBinds = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindSparseInfo.pBufferBinds", "[object VkSparseBufferMemoryBindInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pBufferBinds = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.pBufferBinds", "[object VkSparseBufferMemoryBindInfo]");
  
    return;
  }
}// imageOpaqueBindCount
Napi::Value _VkBindSparseInfo::GetimageOpaqueBindCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageOpaqueBindCount);
}void _VkBindSparseInfo::SetimageOpaqueBindCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageOpaqueBindCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.imageOpaqueBindCount", "Number");
  
    return;
  }
}// pImageOpaqueBinds
Napi::Value _VkBindSparseInfo::GetpImageOpaqueBinds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pImageOpaqueBinds.IsEmpty()) return env.Null();
  return this->pImageOpaqueBinds.Value().As<Napi::Array>();
}void _VkBindSparseInfo::SetpImageOpaqueBinds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pImageOpaqueBinds.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pImageOpaqueBinds.Reset();
      this->instance.pImageOpaqueBinds = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindSparseInfo.pImageOpaqueBinds", "[object VkSparseImageOpaqueMemoryBindInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pImageOpaqueBinds = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.pImageOpaqueBinds", "[object VkSparseImageOpaqueMemoryBindInfo]");
  
    return;
  }
}// imageBindCount
Napi::Value _VkBindSparseInfo::GetimageBindCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageBindCount);
}void _VkBindSparseInfo::SetimageBindCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageBindCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.imageBindCount", "Number");
  
    return;
  }
}// pImageBinds
Napi::Value _VkBindSparseInfo::GetpImageBinds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pImageBinds.IsEmpty()) return env.Null();
  return this->pImageBinds.Value().As<Napi::Array>();
}void _VkBindSparseInfo::SetpImageBinds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pImageBinds.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pImageBinds.Reset();
      this->instance.pImageBinds = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindSparseInfo.pImageBinds", "[object VkSparseImageMemoryBindInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pImageBinds = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.pImageBinds", "[object VkSparseImageMemoryBindInfo]");
  
    return;
  }
}// signalSemaphoreCount
Napi::Value _VkBindSparseInfo::GetsignalSemaphoreCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.signalSemaphoreCount);
}void _VkBindSparseInfo::SetsignalSemaphoreCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.signalSemaphoreCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphores
Napi::Value _VkBindSparseInfo::GetpSignalSemaphores(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pSignalSemaphores.IsEmpty()) return env.Null();
  return this->pSignalSemaphores.Value().As<Napi::Array>();
}void _VkBindSparseInfo::SetpSignalSemaphores(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pSignalSemaphores.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pSignalSemaphores.Reset();
      this->instance.pSignalSemaphores = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkBindSparseInfo.pSignalSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pSignalSemaphores = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBindSparseInfo.pSignalSemaphores", "[object VkSemaphore]");
  
    return;
  }
}
/** ## END VkBindSparseInfo ## **/

/** ## BEGIN VkSparseImageMemoryBindInfo ## **/

Napi::FunctionReference _VkSparseImageMemoryBindInfo::constructor;

_VkSparseImageMemoryBindInfo::_VkSparseImageMemoryBindInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageMemoryBindInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpBinds = new std::vector<VkSparseImageMemoryBind>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "image");
      Napi::String sAccess1 = Napi::String::New(env, "bindCount");
      Napi::String sAccess2 = Napi::String::New(env, "pBinds");
      if (obj.Has(sAccess0)) this->Setimage(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbindCount(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpBinds(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSparseImageMemoryBindInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageMemoryBindInfo::~_VkSparseImageMemoryBindInfo() {
  
  image.Reset();
  
  
  vpBinds->clear();
  delete vpBinds;
  
  pBinds.Reset();
  
}

Napi::Object _VkSparseImageMemoryBindInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageMemoryBindInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageMemoryBindInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageMemoryBindInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "image",
    &_VkSparseImageMemoryBindInfo::Getimage,
    &_VkSparseImageMemoryBindInfo::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "bindCount",
    &_VkSparseImageMemoryBindInfo::GetbindCount,
    &_VkSparseImageMemoryBindInfo::SetbindCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBinds",
    &_VkSparseImageMemoryBindInfo::GetpBinds,
    &_VkSparseImageMemoryBindInfo::SetpBinds,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageMemoryBindInfo", func);
  return exports;
}

Napi::Value _VkSparseImageMemoryBindInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageMemoryBindInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBindInfo *)0)->image));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBindInfo *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBindInfo *)0)->bindCount));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBindInfo *)0)->bindCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBindInfo *)0)->pBinds));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBindInfo *)0)->pBinds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageMemoryBindInfo::flush() {
  _VkSparseImageMemoryBindInfo *self = this;
  if (!(self->pBinds.IsEmpty())) {
    Napi::Value value = self->pBinds.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.bindCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'bindCount' for 'VkSparseImageMemoryBindInfo.pBinds'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSparseImageMemoryBind>* data = this->vpBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSparseImageMemoryBind::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSparseImageMemoryBindInfo.pBinds", "[object VkSparseImageMemoryBind]");
  
        return false;
      }
      _VkSparseImageMemoryBind* result = Napi::ObjectWrap<_VkSparseImageMemoryBind>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBinds = data->data();
  }
  return true;
}

// image
Napi::Value _VkSparseImageMemoryBindInfo::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkSparseImageMemoryBindInfo::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryBindInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBindInfo.image", "[object VkImage]");
  
    return;
  }
}// bindCount
Napi::Value _VkSparseImageMemoryBindInfo::GetbindCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bindCount);
}void _VkSparseImageMemoryBindInfo::SetbindCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bindCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBindInfo.bindCount", "Number");
  
    return;
  }
}// pBinds
Napi::Value _VkSparseImageMemoryBindInfo::GetpBinds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBinds.IsEmpty()) return env.Null();
  return this->pBinds.Value().As<Napi::Array>();
}void _VkSparseImageMemoryBindInfo::SetpBinds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pBinds.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pBinds.Reset();
      this->instance.pBinds = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryBindInfo.pBinds", "[object VkSparseImageMemoryBind]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pBinds = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBindInfo.pBinds", "[object VkSparseImageMemoryBind]");
  
    return;
  }
}
/** ## END VkSparseImageMemoryBindInfo ## **/

/** ## BEGIN VkSparseImageOpaqueMemoryBindInfo ## **/

Napi::FunctionReference _VkSparseImageOpaqueMemoryBindInfo::constructor;

_VkSparseImageOpaqueMemoryBindInfo::_VkSparseImageOpaqueMemoryBindInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageOpaqueMemoryBindInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpBinds = new std::vector<VkSparseMemoryBind>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "image");
      Napi::String sAccess1 = Napi::String::New(env, "bindCount");
      Napi::String sAccess2 = Napi::String::New(env, "pBinds");
      if (obj.Has(sAccess0)) this->Setimage(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbindCount(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpBinds(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSparseImageOpaqueMemoryBindInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageOpaqueMemoryBindInfo::~_VkSparseImageOpaqueMemoryBindInfo() {
  
  image.Reset();
  
  
  vpBinds->clear();
  delete vpBinds;
  
  pBinds.Reset();
  
}

Napi::Object _VkSparseImageOpaqueMemoryBindInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageOpaqueMemoryBindInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageOpaqueMemoryBindInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageOpaqueMemoryBindInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "image",
    &_VkSparseImageOpaqueMemoryBindInfo::Getimage,
    &_VkSparseImageOpaqueMemoryBindInfo::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "bindCount",
    &_VkSparseImageOpaqueMemoryBindInfo::GetbindCount,
    &_VkSparseImageOpaqueMemoryBindInfo::SetbindCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBinds",
    &_VkSparseImageOpaqueMemoryBindInfo::GetpBinds,
    &_VkSparseImageOpaqueMemoryBindInfo::SetpBinds,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageOpaqueMemoryBindInfo", func);
  return exports;
}

Napi::Value _VkSparseImageOpaqueMemoryBindInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageOpaqueMemoryBindInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageOpaqueMemoryBindInfo *)0)->image));
    uint32_t byteLength = sizeof(((VkSparseImageOpaqueMemoryBindInfo *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageOpaqueMemoryBindInfo *)0)->bindCount));
    uint32_t byteLength = sizeof(((VkSparseImageOpaqueMemoryBindInfo *)0)->bindCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageOpaqueMemoryBindInfo *)0)->pBinds));
    uint32_t byteLength = sizeof(((VkSparseImageOpaqueMemoryBindInfo *)0)->pBinds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageOpaqueMemoryBindInfo::flush() {
  _VkSparseImageOpaqueMemoryBindInfo *self = this;
  if (!(self->pBinds.IsEmpty())) {
    Napi::Value value = self->pBinds.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.bindCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'bindCount' for 'VkSparseImageOpaqueMemoryBindInfo.pBinds'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSparseMemoryBind>* data = this->vpBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSparseMemoryBind::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
        return false;
      }
      _VkSparseMemoryBind* result = Napi::ObjectWrap<_VkSparseMemoryBind>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBinds = data->data();
  }
  return true;
}

// image
Napi::Value _VkSparseImageOpaqueMemoryBindInfo::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkSparseImageOpaqueMemoryBindInfo::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.image", "[object VkImage]");
  
    return;
  }
}// bindCount
Napi::Value _VkSparseImageOpaqueMemoryBindInfo::GetbindCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bindCount);
}void _VkSparseImageOpaqueMemoryBindInfo::SetbindCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bindCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.bindCount", "Number");
  
    return;
  }
}// pBinds
Napi::Value _VkSparseImageOpaqueMemoryBindInfo::GetpBinds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBinds.IsEmpty()) return env.Null();
  return this->pBinds.Value().As<Napi::Array>();
}void _VkSparseImageOpaqueMemoryBindInfo::SetpBinds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pBinds.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pBinds.Reset();
      this->instance.pBinds = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pBinds = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
    return;
  }
}
/** ## END VkSparseImageOpaqueMemoryBindInfo ## **/

/** ## BEGIN VkSparseBufferMemoryBindInfo ## **/

Napi::FunctionReference _VkSparseBufferMemoryBindInfo::constructor;

_VkSparseBufferMemoryBindInfo::_VkSparseBufferMemoryBindInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseBufferMemoryBindInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpBinds = new std::vector<VkSparseMemoryBind>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "buffer");
      Napi::String sAccess1 = Napi::String::New(env, "bindCount");
      Napi::String sAccess2 = Napi::String::New(env, "pBinds");
      if (obj.Has(sAccess0)) this->Setbuffer(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbindCount(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpBinds(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkSparseBufferMemoryBindInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseBufferMemoryBindInfo::~_VkSparseBufferMemoryBindInfo() {
  
  buffer.Reset();
  
  
  vpBinds->clear();
  delete vpBinds;
  
  pBinds.Reset();
  
}

Napi::Object _VkSparseBufferMemoryBindInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseBufferMemoryBindInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseBufferMemoryBindInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseBufferMemoryBindInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "buffer",
    &_VkSparseBufferMemoryBindInfo::Getbuffer,
    &_VkSparseBufferMemoryBindInfo::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "bindCount",
    &_VkSparseBufferMemoryBindInfo::GetbindCount,
    &_VkSparseBufferMemoryBindInfo::SetbindCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBinds",
    &_VkSparseBufferMemoryBindInfo::GetpBinds,
    &_VkSparseBufferMemoryBindInfo::SetpBinds,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseBufferMemoryBindInfo", func);
  return exports;
}

Napi::Value _VkSparseBufferMemoryBindInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseBufferMemoryBindInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseBufferMemoryBindInfo *)0)->buffer));
    uint32_t byteLength = sizeof(((VkSparseBufferMemoryBindInfo *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseBufferMemoryBindInfo *)0)->bindCount));
    uint32_t byteLength = sizeof(((VkSparseBufferMemoryBindInfo *)0)->bindCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseBufferMemoryBindInfo *)0)->pBinds));
    uint32_t byteLength = sizeof(((VkSparseBufferMemoryBindInfo *)0)->pBinds);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseBufferMemoryBindInfo::flush() {
  _VkSparseBufferMemoryBindInfo *self = this;
  if (!(self->pBinds.IsEmpty())) {
    Napi::Value value = self->pBinds.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.bindCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'bindCount' for 'VkSparseBufferMemoryBindInfo.pBinds'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkSparseMemoryBind>* data = this->vpBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkSparseMemoryBind::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkSparseBufferMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
        return false;
      }
      _VkSparseMemoryBind* result = Napi::ObjectWrap<_VkSparseMemoryBind>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBinds = data->data();
  }
  return true;
}

// buffer
Napi::Value _VkSparseBufferMemoryBindInfo::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkSparseBufferMemoryBindInfo::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseBufferMemoryBindInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSparseBufferMemoryBindInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// bindCount
Napi::Value _VkSparseBufferMemoryBindInfo::GetbindCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bindCount);
}void _VkSparseBufferMemoryBindInfo::SetbindCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.bindCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseBufferMemoryBindInfo.bindCount", "Number");
  
    return;
  }
}// pBinds
Napi::Value _VkSparseBufferMemoryBindInfo::GetpBinds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBinds.IsEmpty()) return env.Null();
  return this->pBinds.Value().As<Napi::Array>();
}void _VkSparseBufferMemoryBindInfo::SetpBinds(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pBinds.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pBinds.Reset();
      this->instance.pBinds = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkSparseBufferMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pBinds = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkSparseBufferMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
    return;
  }
}
/** ## END VkSparseBufferMemoryBindInfo ## **/

/** ## BEGIN VkSparseImageMemoryBind ## **/

Napi::FunctionReference _VkSparseImageMemoryBind::constructor;

_VkSparseImageMemoryBind::_VkSparseImageMemoryBind(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageMemoryBind>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "subresource");
      Napi::String sAccess1 = Napi::String::New(env, "offset");
      Napi::String sAccess2 = Napi::String::New(env, "extent");
      Napi::String sAccess3 = Napi::String::New(env, "memory");
      Napi::String sAccess4 = Napi::String::New(env, "memoryOffset");
      Napi::String sAccess5 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->Setsubresource(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setoffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setextent(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setmemory(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetmemoryOffset(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setflags(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkSparseImageMemoryBind constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageMemoryBind::~_VkSparseImageMemoryBind() {
  
  subresource.Reset();
  
  offset.Reset();
  
  extent.Reset();
  
  memory.Reset();
  
  
  
}

Napi::Object _VkSparseImageMemoryBind::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageMemoryBind", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageMemoryBind::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageMemoryBind::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "subresource",
    &_VkSparseImageMemoryBind::Getsubresource,
    &_VkSparseImageMemoryBind::Setsubresource,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkSparseImageMemoryBind::Getoffset,
    &_VkSparseImageMemoryBind::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "extent",
    &_VkSparseImageMemoryBind::Getextent,
    &_VkSparseImageMemoryBind::Setextent,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkSparseImageMemoryBind::Getmemory,
    &_VkSparseImageMemoryBind::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryOffset",
    &_VkSparseImageMemoryBind::GetmemoryOffset,
    &_VkSparseImageMemoryBind::SetmemoryOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSparseImageMemoryBind::Getflags,
    &_VkSparseImageMemoryBind::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageMemoryBind", func);
  return exports;
}

Napi::Value _VkSparseImageMemoryBind::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageMemoryBind::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBind *)0)->subresource));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBind *)0)->subresource);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBind *)0)->offset));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBind *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBind *)0)->extent));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBind *)0)->extent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBind *)0)->memory));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBind *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBind *)0)->memoryOffset));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBind *)0)->memoryOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryBind *)0)->flags));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryBind *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageMemoryBind::flush() {
  _VkSparseImageMemoryBind *self = this;
  if (!(self->subresource.IsEmpty())) {
    Napi::Value value = self->subresource.Value();
    
    _VkImageSubresource* result = Napi::ObjectWrap<_VkImageSubresource>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.subresource = result->instance;
  }if (!(self->offset.IsEmpty())) {
    Napi::Value value = self->offset.Value();
    
    _VkOffset3D* result = Napi::ObjectWrap<_VkOffset3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.offset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    Napi::Value value = self->extent.Value();
    
    _VkExtent3D* result = Napi::ObjectWrap<_VkExtent3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

// subresource
Napi::Value _VkSparseImageMemoryBind::Getsubresource(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->subresource.IsEmpty()) return env.Null();
  return this->subresource.Value().As<Napi::Object>();
}void _VkSparseImageMemoryBind::Setsubresource(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresource::constructor.Value())) {
      
      this->subresource.Reset(value.ToObject(), 1);
      _VkImageSubresource* inst = Napi::ObjectWrap<_VkImageSubresource>::Unwrap(obj);
      inst->flush();
      this->instance.subresource = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.subresource", "[object VkImageSubresource]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->subresource.Reset();
    memset(&this->instance.subresource, 0, sizeof(VkImageSubresource));
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.subresource", "[object VkImageSubresource]");
  
    return;
  }
}// offset
Napi::Value _VkSparseImageMemoryBind::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->offset.IsEmpty()) return env.Null();
  return this->offset.Value().As<Napi::Object>();
}void _VkSparseImageMemoryBind::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset3D::constructor.Value())) {
      
      this->offset.Reset(value.ToObject(), 1);
      _VkOffset3D* inst = Napi::ObjectWrap<_VkOffset3D>::Unwrap(obj);
      inst->flush();
      this->instance.offset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.offset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->offset.Reset();
    memset(&this->instance.offset, 0, sizeof(VkOffset3D));
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.offset", "[object VkOffset3D]");
  
    return;
  }
}// extent
Napi::Value _VkSparseImageMemoryBind::Getextent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extent.IsEmpty()) return env.Null();
  return this->extent.Value().As<Napi::Object>();
}void _VkSparseImageMemoryBind::Setextent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent3D::constructor.Value())) {
      
      this->extent.Reset(value.ToObject(), 1);
      _VkExtent3D* inst = Napi::ObjectWrap<_VkExtent3D>::Unwrap(obj);
      inst->flush();
      this->instance.extent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->extent.Reset();
    memset(&this->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.extent", "[object VkExtent3D]");
  
    return;
  }
}// memory
Napi::Value _VkSparseImageMemoryBind::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkSparseImageMemoryBind::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
Napi::Value _VkSparseImageMemoryBind::GetmemoryOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryOffset);
}void _VkSparseImageMemoryBind::SetmemoryOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.memoryOffset", "Number");
  
    return;
  }
}// flags
Napi::Value _VkSparseImageMemoryBind::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSparseImageMemoryBind::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSparseMemoryBindFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseImageMemoryBind.flags", "Number");
  
    return;
  }
}
/** ## END VkSparseImageMemoryBind ## **/

/** ## BEGIN VkSparseMemoryBind ## **/

Napi::FunctionReference _VkSparseMemoryBind::constructor;

_VkSparseMemoryBind::_VkSparseMemoryBind(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseMemoryBind>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "resourceOffset");
      Napi::String sAccess1 = Napi::String::New(env, "size");
      Napi::String sAccess2 = Napi::String::New(env, "memory");
      Napi::String sAccess3 = Napi::String::New(env, "memoryOffset");
      Napi::String sAccess4 = Napi::String::New(env, "flags");
      if (obj.Has(sAccess0)) this->SetresourceOffset(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setsize(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmemory(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmemoryOffset(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setflags(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkSparseMemoryBind constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseMemoryBind::~_VkSparseMemoryBind() {
  
  
  
  memory.Reset();
  
  
  
}

Napi::Object _VkSparseMemoryBind::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseMemoryBind", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseMemoryBind::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseMemoryBind::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "resourceOffset",
    &_VkSparseMemoryBind::GetresourceOffset,
    &_VkSparseMemoryBind::SetresourceOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkSparseMemoryBind::Getsize,
    &_VkSparseMemoryBind::Setsize,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkSparseMemoryBind::Getmemory,
    &_VkSparseMemoryBind::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryOffset",
    &_VkSparseMemoryBind::GetmemoryOffset,
    &_VkSparseMemoryBind::SetmemoryOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSparseMemoryBind::Getflags,
    &_VkSparseMemoryBind::Setflags,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseMemoryBind", func);
  return exports;
}

Napi::Value _VkSparseMemoryBind::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseMemoryBind::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseMemoryBind *)0)->resourceOffset));
    uint32_t byteLength = sizeof(((VkSparseMemoryBind *)0)->resourceOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseMemoryBind *)0)->size));
    uint32_t byteLength = sizeof(((VkSparseMemoryBind *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseMemoryBind *)0)->memory));
    uint32_t byteLength = sizeof(((VkSparseMemoryBind *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseMemoryBind *)0)->memoryOffset));
    uint32_t byteLength = sizeof(((VkSparseMemoryBind *)0)->memoryOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseMemoryBind *)0)->flags));
    uint32_t byteLength = sizeof(((VkSparseMemoryBind *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseMemoryBind::flush() {
  _VkSparseMemoryBind *self = this;
  
  return true;
}

// resourceOffset
Napi::Value _VkSparseMemoryBind::GetresourceOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.resourceOffset);
}void _VkSparseMemoryBind::SetresourceOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.resourceOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseMemoryBind.resourceOffset", "Number");
  
    return;
  }
}// size
Napi::Value _VkSparseMemoryBind::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkSparseMemoryBind::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseMemoryBind.size", "Number");
  
    return;
  }
}// memory
Napi::Value _VkSparseMemoryBind::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkSparseMemoryBind::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkSparseMemoryBind.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkSparseMemoryBind.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
Napi::Value _VkSparseMemoryBind::GetmemoryOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryOffset);
}void _VkSparseMemoryBind::SetmemoryOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseMemoryBind.memoryOffset", "Number");
  
    return;
  }
}// flags
Napi::Value _VkSparseMemoryBind::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkSparseMemoryBind::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkSparseMemoryBindFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkSparseMemoryBind.flags", "Number");
  
    return;
  }
}
/** ## END VkSparseMemoryBind ## **/

/** ## BEGIN VkBufferCopy ## **/

Napi::FunctionReference _VkBufferCopy::constructor;

_VkBufferCopy::_VkBufferCopy(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferCopy>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "srcOffset");
      Napi::String sAccess1 = Napi::String::New(env, "dstOffset");
      Napi::String sAccess2 = Napi::String::New(env, "size");
      if (obj.Has(sAccess0)) this->SetsrcOffset(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetdstOffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setsize(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkBufferCopy constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferCopy::~_VkBufferCopy() {
  
  
  
  
}

Napi::Object _VkBufferCopy::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferCopy", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferCopy::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferCopy::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "srcOffset",
    &_VkBufferCopy::GetsrcOffset,
    &_VkBufferCopy::SetsrcOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstOffset",
    &_VkBufferCopy::GetdstOffset,
    &_VkBufferCopy::SetdstOffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkBufferCopy::Getsize,
    &_VkBufferCopy::Setsize,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferCopy", func);
  return exports;
}

Napi::Value _VkBufferCopy::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferCopy::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCopy *)0)->srcOffset));
    uint32_t byteLength = sizeof(((VkBufferCopy *)0)->srcOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCopy *)0)->dstOffset));
    uint32_t byteLength = sizeof(((VkBufferCopy *)0)->dstOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCopy *)0)->size));
    uint32_t byteLength = sizeof(((VkBufferCopy *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferCopy::flush() {
  _VkBufferCopy *self = this;
  
  return true;
}

// srcOffset
Napi::Value _VkBufferCopy::GetsrcOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcOffset);
}void _VkBufferCopy::SetsrcOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCopy.srcOffset", "Number");
  
    return;
  }
}// dstOffset
Napi::Value _VkBufferCopy::GetdstOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstOffset);
}void _VkBufferCopy::SetdstOffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstOffset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCopy.dstOffset", "Number");
  
    return;
  }
}// size
Napi::Value _VkBufferCopy::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkBufferCopy::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCopy.size", "Number");
  
    return;
  }
}
/** ## END VkBufferCopy ## **/

/** ## BEGIN VkImageViewCreateInfo ## **/

Napi::FunctionReference _VkImageViewCreateInfo::constructor;

_VkImageViewCreateInfo::_VkImageViewCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageViewCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "image");
      Napi::String sAccess4 = Napi::String::New(env, "viewType");
      Napi::String sAccess5 = Napi::String::New(env, "format");
      Napi::String sAccess6 = Napi::String::New(env, "components");
      Napi::String sAccess7 = Napi::String::New(env, "subresourceRange");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setimage(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetviewType(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setformat(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setcomponents(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetsubresourceRange(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkImageViewCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageViewCreateInfo::~_VkImageViewCreateInfo() {
  
  
  pNext.Reset();
  
  
  image.Reset();
  
  
  
  components.Reset();
  
  subresourceRange.Reset();
  
}

Napi::Object _VkImageViewCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageViewCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageViewCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageViewCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageViewCreateInfo::GetsType,
    &_VkImageViewCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageViewCreateInfo::GetpNext,
    &_VkImageViewCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkImageViewCreateInfo::Getflags,
    &_VkImageViewCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkImageViewCreateInfo::Getimage,
    &_VkImageViewCreateInfo::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "viewType",
    &_VkImageViewCreateInfo::GetviewType,
    &_VkImageViewCreateInfo::SetviewType,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkImageViewCreateInfo::Getformat,
    &_VkImageViewCreateInfo::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "components",
    &_VkImageViewCreateInfo::Getcomponents,
    &_VkImageViewCreateInfo::Setcomponents,
    napi_enumerable
  ),
  InstanceAccessor(
    "subresourceRange",
    &_VkImageViewCreateInfo::GetsubresourceRange,
    &_VkImageViewCreateInfo::SetsubresourceRange,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageViewCreateInfo", func);
  return exports;
}

Napi::Value _VkImageViewCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageViewCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->image));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->viewType));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->viewType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->format));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->components));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->components);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageViewCreateInfo *)0)->subresourceRange));
    uint32_t byteLength = sizeof(((VkImageViewCreateInfo *)0)->subresourceRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageViewCreateInfo::flush() {
  _VkImageViewCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO) {
      _VkImageViewUsageCreateInfo* structExt = Napi::ObjectWrap<_VkImageViewUsageCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO) {
      _VkSamplerYcbcrConversionInfo* structExt = Napi::ObjectWrap<_VkSamplerYcbcrConversionInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->components.IsEmpty())) {
    Napi::Value value = self->components.Value();
    
    _VkComponentMapping* result = Napi::ObjectWrap<_VkComponentMapping>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.components = result->instance;
  }if (!(self->subresourceRange.IsEmpty())) {
    Napi::Value value = self->subresourceRange.Value();
    
    _VkImageSubresourceRange* result = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.subresourceRange = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkImageViewCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageViewCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageViewCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageViewCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO &&
        sType != VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageViewCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageViewCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkImageViewCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkImageViewCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkImageViewCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.flags", "Number");
  
    return;
  }
}// image
Napi::Value _VkImageViewCreateInfo::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkImageViewCreateInfo::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageViewCreateInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.image", "[object VkImage]");
  
    return;
  }
}// viewType
Napi::Value _VkImageViewCreateInfo::GetviewType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.viewType);
}void _VkImageViewCreateInfo::SetviewType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.viewType = static_cast<VkImageViewType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.viewType", "Number");
  
    return;
  }
}// format
Napi::Value _VkImageViewCreateInfo::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkImageViewCreateInfo::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.format", "Number");
  
    return;
  }
}// components
Napi::Value _VkImageViewCreateInfo::Getcomponents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->components.IsEmpty()) return env.Null();
  return this->components.Value().As<Napi::Object>();
}void _VkImageViewCreateInfo::Setcomponents(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkComponentMapping::constructor.Value())) {
      
      this->components.Reset(value.ToObject(), 1);
      _VkComponentMapping* inst = Napi::ObjectWrap<_VkComponentMapping>::Unwrap(obj);
      inst->flush();
      this->instance.components = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageViewCreateInfo.components", "[object VkComponentMapping]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->components.Reset();
    memset(&this->instance.components, 0, sizeof(VkComponentMapping));
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.components", "[object VkComponentMapping]");
  
    return;
  }
}// subresourceRange
Napi::Value _VkImageViewCreateInfo::GetsubresourceRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->subresourceRange.IsEmpty()) return env.Null();
  return this->subresourceRange.Value().As<Napi::Object>();
}void _VkImageViewCreateInfo::SetsubresourceRange(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceRange::constructor.Value())) {
      
      this->subresourceRange.Reset(value.ToObject(), 1);
      _VkImageSubresourceRange* inst = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(obj);
      inst->flush();
      this->instance.subresourceRange = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageViewCreateInfo.subresourceRange", "[object VkImageSubresourceRange]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->subresourceRange.Reset();
    memset(&this->instance.subresourceRange, 0, sizeof(VkImageSubresourceRange));
  } else {
    
    NapiObjectTypeError(value, "VkImageViewCreateInfo.subresourceRange", "[object VkImageSubresourceRange]");
  
    return;
  }
}
/** ## END VkImageViewCreateInfo ## **/

/** ## BEGIN VkSubresourceLayout ## **/

Napi::FunctionReference _VkSubresourceLayout::constructor;

_VkSubresourceLayout::_VkSubresourceLayout(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSubresourceLayout>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkSubresourceLayout constructor cannot be invoked without 'new'");
    }
  }
}

_VkSubresourceLayout::~_VkSubresourceLayout() {
  
  
  
  
  
  
}

Napi::Object _VkSubresourceLayout::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSubresourceLayout", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSubresourceLayout::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSubresourceLayout::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "offset",
    &_VkSubresourceLayout::Getoffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkSubresourceLayout::Getsize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "rowPitch",
    &_VkSubresourceLayout::GetrowPitch,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "arrayPitch",
    &_VkSubresourceLayout::GetarrayPitch,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "depthPitch",
    &_VkSubresourceLayout::GetdepthPitch,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSubresourceLayout", func);
  return exports;
}

Napi::Value _VkSubresourceLayout::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSubresourceLayout::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubresourceLayout *)0)->offset));
    uint32_t byteLength = sizeof(((VkSubresourceLayout *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubresourceLayout *)0)->size));
    uint32_t byteLength = sizeof(((VkSubresourceLayout *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubresourceLayout *)0)->rowPitch));
    uint32_t byteLength = sizeof(((VkSubresourceLayout *)0)->rowPitch);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubresourceLayout *)0)->arrayPitch));
    uint32_t byteLength = sizeof(((VkSubresourceLayout *)0)->arrayPitch);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSubresourceLayout *)0)->depthPitch));
    uint32_t byteLength = sizeof(((VkSubresourceLayout *)0)->depthPitch);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSubresourceLayout::flush() {
  _VkSubresourceLayout *self = this;
  
  return true;
}

// offset
Napi::Value _VkSubresourceLayout::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}// size
Napi::Value _VkSubresourceLayout::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}// rowPitch
Napi::Value _VkSubresourceLayout::GetrowPitch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.rowPitch);
}// arrayPitch
Napi::Value _VkSubresourceLayout::GetarrayPitch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.arrayPitch);
}// depthPitch
Napi::Value _VkSubresourceLayout::GetdepthPitch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depthPitch);
}
/** ## END VkSubresourceLayout ## **/

/** ## BEGIN VkImageCreateInfo ## **/

Napi::FunctionReference _VkImageCreateInfo::constructor;

_VkImageCreateInfo::_VkImageCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "imageType");
      Napi::String sAccess4 = Napi::String::New(env, "format");
      Napi::String sAccess5 = Napi::String::New(env, "extent");
      Napi::String sAccess6 = Napi::String::New(env, "mipLevels");
      Napi::String sAccess7 = Napi::String::New(env, "arrayLayers");
      Napi::String sAccess8 = Napi::String::New(env, "samples");
      Napi::String sAccess9 = Napi::String::New(env, "tiling");
      Napi::String sAccess10 = Napi::String::New(env, "usage");
      Napi::String sAccess11 = Napi::String::New(env, "sharingMode");
      Napi::String sAccess12 = Napi::String::New(env, "queueFamilyIndexCount");
      Napi::String sAccess13 = Napi::String::New(env, "pQueueFamilyIndices");
      Napi::String sAccess14 = Napi::String::New(env, "initialLayout");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetimageType(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setformat(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setextent(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetmipLevels(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetarrayLayers(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->Setsamples(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->Settiling(info, obj.Get(sAccess9));
      if (obj.Has(sAccess10)) this->Setusage(info, obj.Get(sAccess10));
      if (obj.Has(sAccess11)) this->SetsharingMode(info, obj.Get(sAccess11));
      if (obj.Has(sAccess12)) this->SetqueueFamilyIndexCount(info, obj.Get(sAccess12));
      if (obj.Has(sAccess13)) this->SetpQueueFamilyIndices(info, obj.Get(sAccess13));
      if (obj.Has(sAccess14)) this->SetinitialLayout(info, obj.Get(sAccess14));
      
    } else {
      Napi::Error::New(env, "VkImageCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageCreateInfo::~_VkImageCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  extent.Reset();
  
  
  
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
  
}

Napi::Object _VkImageCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageCreateInfo::GetsType,
    &_VkImageCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageCreateInfo::GetpNext,
    &_VkImageCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkImageCreateInfo::Getflags,
    &_VkImageCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageType",
    &_VkImageCreateInfo::GetimageType,
    &_VkImageCreateInfo::SetimageType,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkImageCreateInfo::Getformat,
    &_VkImageCreateInfo::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "extent",
    &_VkImageCreateInfo::Getextent,
    &_VkImageCreateInfo::Setextent,
    napi_enumerable
  ),
  InstanceAccessor(
    "mipLevels",
    &_VkImageCreateInfo::GetmipLevels,
    &_VkImageCreateInfo::SetmipLevels,
    napi_enumerable
  ),
  InstanceAccessor(
    "arrayLayers",
    &_VkImageCreateInfo::GetarrayLayers,
    &_VkImageCreateInfo::SetarrayLayers,
    napi_enumerable
  ),
  InstanceAccessor(
    "samples",
    &_VkImageCreateInfo::Getsamples,
    &_VkImageCreateInfo::Setsamples,
    napi_enumerable
  ),
  InstanceAccessor(
    "tiling",
    &_VkImageCreateInfo::Gettiling,
    &_VkImageCreateInfo::Settiling,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkImageCreateInfo::Getusage,
    &_VkImageCreateInfo::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "sharingMode",
    &_VkImageCreateInfo::GetsharingMode,
    &_VkImageCreateInfo::SetsharingMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyIndexCount",
    &_VkImageCreateInfo::GetqueueFamilyIndexCount,
    &_VkImageCreateInfo::SetqueueFamilyIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pQueueFamilyIndices",
    &_VkImageCreateInfo::GetpQueueFamilyIndices,
    &_VkImageCreateInfo::SetpQueueFamilyIndices,
    napi_enumerable
  ),
  InstanceAccessor(
    "initialLayout",
    &_VkImageCreateInfo::GetinitialLayout,
    &_VkImageCreateInfo::SetinitialLayout,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageCreateInfo", func);
  return exports;
}

Napi::Value _VkImageCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->imageType));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->imageType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->format));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->extent));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->extent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->mipLevels));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->mipLevels);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->arrayLayers));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->arrayLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->samples));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->samples);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->tiling));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->tiling);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->usage));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->sharingMode));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->sharingMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->queueFamilyIndexCount));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->queueFamilyIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->pQueueFamilyIndices));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->pQueueFamilyIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageCreateInfo *)0)->initialLayout));
    uint32_t byteLength = sizeof(((VkImageCreateInfo *)0)->initialLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageCreateInfo::flush() {
  _VkImageCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV) {
      _VkDedicatedAllocationImageCreateInfoNV* structExt = Napi::ObjectWrap<_VkDedicatedAllocationImageCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV) {
      _VkExternalMemoryImageCreateInfoNV* structExt = Napi::ObjectWrap<_VkExternalMemoryImageCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO) {
      _VkExternalMemoryImageCreateInfo* structExt = Napi::ObjectWrap<_VkExternalMemoryImageCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR) {
      _VkImageSwapchainCreateInfoKHR* structExt = Napi::ObjectWrap<_VkImageSwapchainCreateInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR) {
      _VkImageFormatListCreateInfoKHR* structExt = Napi::ObjectWrap<_VkImageFormatListCreateInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->extent.IsEmpty())) {
    Napi::Value value = self->extent.Value();
    
    _VkExtent3D* result = Napi::ObjectWrap<_VkExtent3D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkImageCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO &&
        sType != VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkImageCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkImageCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkImageCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.flags", "Number");
  
    return;
  }
}// imageType
Napi::Value _VkImageCreateInfo::GetimageType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageType);
}void _VkImageCreateInfo::SetimageType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageType = static_cast<VkImageType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.imageType", "Number");
  
    return;
  }
}// format
Napi::Value _VkImageCreateInfo::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkImageCreateInfo::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.format", "Number");
  
    return;
  }
}// extent
Napi::Value _VkImageCreateInfo::Getextent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extent.IsEmpty()) return env.Null();
  return this->extent.Value().As<Napi::Object>();
}void _VkImageCreateInfo::Setextent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent3D::constructor.Value())) {
      
      this->extent.Reset(value.ToObject(), 1);
      _VkExtent3D* inst = Napi::ObjectWrap<_VkExtent3D>::Unwrap(obj);
      inst->flush();
      this->instance.extent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageCreateInfo.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->extent.Reset();
    memset(&this->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.extent", "[object VkExtent3D]");
  
    return;
  }
}// mipLevels
Napi::Value _VkImageCreateInfo::GetmipLevels(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mipLevels);
}void _VkImageCreateInfo::SetmipLevels(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mipLevels = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.mipLevels", "Number");
  
    return;
  }
}// arrayLayers
Napi::Value _VkImageCreateInfo::GetarrayLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.arrayLayers);
}void _VkImageCreateInfo::SetarrayLayers(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.arrayLayers = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.arrayLayers", "Number");
  
    return;
  }
}// samples
Napi::Value _VkImageCreateInfo::Getsamples(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.samples);
}void _VkImageCreateInfo::Setsamples(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.samples = static_cast<VkSampleCountFlagBits>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.samples", "Number");
  
    return;
  }
}// tiling
Napi::Value _VkImageCreateInfo::Gettiling(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.tiling);
}void _VkImageCreateInfo::Settiling(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.tiling = static_cast<VkImageTiling>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.tiling", "Number");
  
    return;
  }
}// usage
Napi::Value _VkImageCreateInfo::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkImageCreateInfo::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkImageUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.usage", "Number");
  
    return;
  }
}// sharingMode
Napi::Value _VkImageCreateInfo::GetsharingMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sharingMode);
}void _VkImageCreateInfo::SetsharingMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sharingMode = static_cast<VkSharingMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.sharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
Napi::Value _VkImageCreateInfo::GetqueueFamilyIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFamilyIndexCount);
}void _VkImageCreateInfo::SetqueueFamilyIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueFamilyIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
Napi::Value _VkImageCreateInfo::GetpQueueFamilyIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pQueueFamilyIndices.IsEmpty()) return env.Null();
  return this->pQueueFamilyIndices.Value().As<Napi::TypedArray>();
}void _VkImageCreateInfo::SetpQueueFamilyIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pQueueFamilyIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkImageCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pQueueFamilyIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkImageCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pQueueFamilyIndices = nullptr;
  }
}// initialLayout
Napi::Value _VkImageCreateInfo::GetinitialLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.initialLayout);
}void _VkImageCreateInfo::SetinitialLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.initialLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageCreateInfo.initialLayout", "Number");
  
    return;
  }
}
/** ## END VkImageCreateInfo ## **/

/** ## BEGIN VkImageMemoryBarrier ## **/

Napi::FunctionReference _VkImageMemoryBarrier::constructor;

_VkImageMemoryBarrier::_VkImageMemoryBarrier(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageMemoryBarrier>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcAccessMask");
      Napi::String sAccess3 = Napi::String::New(env, "dstAccessMask");
      Napi::String sAccess4 = Napi::String::New(env, "oldLayout");
      Napi::String sAccess5 = Napi::String::New(env, "newLayout");
      Napi::String sAccess6 = Napi::String::New(env, "srcQueueFamilyIndex");
      Napi::String sAccess7 = Napi::String::New(env, "dstQueueFamilyIndex");
      Napi::String sAccess8 = Napi::String::New(env, "image");
      Napi::String sAccess9 = Napi::String::New(env, "subresourceRange");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcAccessMask(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstAccessMask(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetoldLayout(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetnewLayout(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetsrcQueueFamilyIndex(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdstQueueFamilyIndex(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->Setimage(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetsubresourceRange(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkImageMemoryBarrier constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageMemoryBarrier::~_VkImageMemoryBarrier() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  
  image.Reset();
  
  subresourceRange.Reset();
  
}

Napi::Object _VkImageMemoryBarrier::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageMemoryBarrier", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageMemoryBarrier::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageMemoryBarrier::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkImageMemoryBarrier::GetsType,
    &_VkImageMemoryBarrier::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkImageMemoryBarrier::GetpNext,
    &_VkImageMemoryBarrier::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcAccessMask",
    &_VkImageMemoryBarrier::GetsrcAccessMask,
    &_VkImageMemoryBarrier::SetsrcAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstAccessMask",
    &_VkImageMemoryBarrier::GetdstAccessMask,
    &_VkImageMemoryBarrier::SetdstAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "oldLayout",
    &_VkImageMemoryBarrier::GetoldLayout,
    &_VkImageMemoryBarrier::SetoldLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "newLayout",
    &_VkImageMemoryBarrier::GetnewLayout,
    &_VkImageMemoryBarrier::SetnewLayout,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcQueueFamilyIndex",
    &_VkImageMemoryBarrier::GetsrcQueueFamilyIndex,
    &_VkImageMemoryBarrier::SetsrcQueueFamilyIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstQueueFamilyIndex",
    &_VkImageMemoryBarrier::GetdstQueueFamilyIndex,
    &_VkImageMemoryBarrier::SetdstQueueFamilyIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "image",
    &_VkImageMemoryBarrier::Getimage,
    &_VkImageMemoryBarrier::Setimage,
    napi_enumerable
  ),
  InstanceAccessor(
    "subresourceRange",
    &_VkImageMemoryBarrier::GetsubresourceRange,
    &_VkImageMemoryBarrier::SetsubresourceRange,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageMemoryBarrier", func);
  return exports;
}

Napi::Value _VkImageMemoryBarrier::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageMemoryBarrier::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->sType));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->pNext));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->srcAccessMask));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->srcAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->dstAccessMask));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->dstAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->oldLayout));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->oldLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->newLayout));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->newLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->srcQueueFamilyIndex));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->srcQueueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->dstQueueFamilyIndex));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->dstQueueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->image));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->image);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageMemoryBarrier *)0)->subresourceRange));
    uint32_t byteLength = sizeof(((VkImageMemoryBarrier *)0)->subresourceRange);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageMemoryBarrier::flush() {
  _VkImageMemoryBarrier *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT) {
      _VkSampleLocationsInfoEXT* structExt = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->subresourceRange.IsEmpty())) {
    Napi::Value value = self->subresourceRange.Value();
    
    _VkImageSubresourceRange* result = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.subresourceRange = result->instance;
  }
  return true;
}

// sType
Napi::Value _VkImageMemoryBarrier::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkImageMemoryBarrier::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkImageMemoryBarrier::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkImageMemoryBarrier::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkImageMemoryBarrier.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryBarrier.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.pNext", "[object Object]");
  
    return;
  }
}// srcAccessMask
Napi::Value _VkImageMemoryBarrier::GetsrcAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcAccessMask);
}void _VkImageMemoryBarrier::SetsrcAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
Napi::Value _VkImageMemoryBarrier::GetdstAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstAccessMask);
}void _VkImageMemoryBarrier::SetdstAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.dstAccessMask", "Number");
  
    return;
  }
}// oldLayout
Napi::Value _VkImageMemoryBarrier::GetoldLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.oldLayout);
}void _VkImageMemoryBarrier::SetoldLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.oldLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.oldLayout", "Number");
  
    return;
  }
}// newLayout
Napi::Value _VkImageMemoryBarrier::GetnewLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.newLayout);
}void _VkImageMemoryBarrier::SetnewLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.newLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.newLayout", "Number");
  
    return;
  }
}// srcQueueFamilyIndex
Napi::Value _VkImageMemoryBarrier::GetsrcQueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcQueueFamilyIndex);
}void _VkImageMemoryBarrier::SetsrcQueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcQueueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.srcQueueFamilyIndex", "Number");
  
    return;
  }
}// dstQueueFamilyIndex
Napi::Value _VkImageMemoryBarrier::GetdstQueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstQueueFamilyIndex);
}void _VkImageMemoryBarrier::SetdstQueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstQueueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.dstQueueFamilyIndex", "Number");
  
    return;
  }
}// image
Napi::Value _VkImageMemoryBarrier::Getimage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->image.IsEmpty()) return env.Null();
  return this->image.Value().As<Napi::Object>();
}void _VkImageMemoryBarrier::Setimage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImage::constructor.Value())) {
      
      this->image.Reset(value.ToObject(), 1);
      _VkImage* inst = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      ;
      this->instance.image = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryBarrier.image", "[object VkImage]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->image.Reset();
    this->instance.image = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.image", "[object VkImage]");
  
    return;
  }
}// subresourceRange
Napi::Value _VkImageMemoryBarrier::GetsubresourceRange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->subresourceRange.IsEmpty()) return env.Null();
  return this->subresourceRange.Value().As<Napi::Object>();
}void _VkImageMemoryBarrier::SetsubresourceRange(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageSubresourceRange::constructor.Value())) {
      
      this->subresourceRange.Reset(value.ToObject(), 1);
      _VkImageSubresourceRange* inst = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(obj);
      inst->flush();
      this->instance.subresourceRange = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkImageMemoryBarrier.subresourceRange", "[object VkImageSubresourceRange]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->subresourceRange.Reset();
    memset(&this->instance.subresourceRange, 0, sizeof(VkImageSubresourceRange));
  } else {
    
    NapiObjectTypeError(value, "VkImageMemoryBarrier.subresourceRange", "[object VkImageSubresourceRange]");
  
    return;
  }
}
/** ## END VkImageMemoryBarrier ## **/

/** ## BEGIN VkBufferMemoryBarrier ## **/

Napi::FunctionReference _VkBufferMemoryBarrier::constructor;

_VkBufferMemoryBarrier::_VkBufferMemoryBarrier(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferMemoryBarrier>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcAccessMask");
      Napi::String sAccess3 = Napi::String::New(env, "dstAccessMask");
      Napi::String sAccess4 = Napi::String::New(env, "srcQueueFamilyIndex");
      Napi::String sAccess5 = Napi::String::New(env, "dstQueueFamilyIndex");
      Napi::String sAccess6 = Napi::String::New(env, "buffer");
      Napi::String sAccess7 = Napi::String::New(env, "offset");
      Napi::String sAccess8 = Napi::String::New(env, "size");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcAccessMask(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstAccessMask(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsrcQueueFamilyIndex(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdstQueueFamilyIndex(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setbuffer(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->Setoffset(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->Setsize(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkBufferMemoryBarrier constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferMemoryBarrier::~_VkBufferMemoryBarrier() {
  
  
  pNext.Reset();
  
  
  
  
  
  buffer.Reset();
  
  
  
}

Napi::Object _VkBufferMemoryBarrier::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferMemoryBarrier", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferMemoryBarrier::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferMemoryBarrier::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBufferMemoryBarrier::GetsType,
    &_VkBufferMemoryBarrier::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBufferMemoryBarrier::GetpNext,
    &_VkBufferMemoryBarrier::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcAccessMask",
    &_VkBufferMemoryBarrier::GetsrcAccessMask,
    &_VkBufferMemoryBarrier::SetsrcAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstAccessMask",
    &_VkBufferMemoryBarrier::GetdstAccessMask,
    &_VkBufferMemoryBarrier::SetdstAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcQueueFamilyIndex",
    &_VkBufferMemoryBarrier::GetsrcQueueFamilyIndex,
    &_VkBufferMemoryBarrier::SetsrcQueueFamilyIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstQueueFamilyIndex",
    &_VkBufferMemoryBarrier::GetdstQueueFamilyIndex,
    &_VkBufferMemoryBarrier::SetdstQueueFamilyIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkBufferMemoryBarrier::Getbuffer,
    &_VkBufferMemoryBarrier::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkBufferMemoryBarrier::Getoffset,
    &_VkBufferMemoryBarrier::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkBufferMemoryBarrier::Getsize,
    &_VkBufferMemoryBarrier::Setsize,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferMemoryBarrier", func);
  return exports;
}

Napi::Value _VkBufferMemoryBarrier::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferMemoryBarrier::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->sType));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->srcAccessMask));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->srcAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->dstAccessMask));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->dstAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->srcQueueFamilyIndex));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->srcQueueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->dstQueueFamilyIndex));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->dstQueueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->buffer));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->offset));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferMemoryBarrier *)0)->size));
    uint32_t byteLength = sizeof(((VkBufferMemoryBarrier *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferMemoryBarrier::flush() {
  _VkBufferMemoryBarrier *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBufferMemoryBarrier::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBufferMemoryBarrier::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBufferMemoryBarrier::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBufferMemoryBarrier::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBufferMemoryBarrier.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.pNext", "[object Object]");
  
    return;
  }
}// srcAccessMask
Napi::Value _VkBufferMemoryBarrier::GetsrcAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcAccessMask);
}void _VkBufferMemoryBarrier::SetsrcAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
Napi::Value _VkBufferMemoryBarrier::GetdstAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstAccessMask);
}void _VkBufferMemoryBarrier::SetdstAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.dstAccessMask", "Number");
  
    return;
  }
}// srcQueueFamilyIndex
Napi::Value _VkBufferMemoryBarrier::GetsrcQueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcQueueFamilyIndex);
}void _VkBufferMemoryBarrier::SetsrcQueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcQueueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.srcQueueFamilyIndex", "Number");
  
    return;
  }
}// dstQueueFamilyIndex
Napi::Value _VkBufferMemoryBarrier::GetdstQueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstQueueFamilyIndex);
}void _VkBufferMemoryBarrier::SetdstQueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstQueueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.dstQueueFamilyIndex", "Number");
  
    return;
  }
}// buffer
Napi::Value _VkBufferMemoryBarrier::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkBufferMemoryBarrier::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
Napi::Value _VkBufferMemoryBarrier::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkBufferMemoryBarrier::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.offset", "Number");
  
    return;
  }
}// size
Napi::Value _VkBufferMemoryBarrier::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkBufferMemoryBarrier::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferMemoryBarrier.size", "Number");
  
    return;
  }
}
/** ## END VkBufferMemoryBarrier ## **/

/** ## BEGIN VkMemoryBarrier ## **/

Napi::FunctionReference _VkMemoryBarrier::constructor;

_VkMemoryBarrier::_VkMemoryBarrier(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryBarrier>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcAccessMask");
      Napi::String sAccess3 = Napi::String::New(env, "dstAccessMask");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcAccessMask(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstAccessMask(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryBarrier constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryBarrier::~_VkMemoryBarrier() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkMemoryBarrier::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryBarrier", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryBarrier::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryBarrier::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryBarrier::GetsType,
    &_VkMemoryBarrier::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryBarrier::GetpNext,
    &_VkMemoryBarrier::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcAccessMask",
    &_VkMemoryBarrier::GetsrcAccessMask,
    &_VkMemoryBarrier::SetsrcAccessMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstAccessMask",
    &_VkMemoryBarrier::GetdstAccessMask,
    &_VkMemoryBarrier::SetdstAccessMask,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryBarrier", func);
  return exports;
}

Napi::Value _VkMemoryBarrier::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryBarrier::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryBarrier *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryBarrier *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryBarrier *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryBarrier *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryBarrier *)0)->srcAccessMask));
    uint32_t byteLength = sizeof(((VkMemoryBarrier *)0)->srcAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryBarrier *)0)->dstAccessMask));
    uint32_t byteLength = sizeof(((VkMemoryBarrier *)0)->dstAccessMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryBarrier::flush() {
  _VkMemoryBarrier *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMemoryBarrier::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryBarrier::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryBarrier.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryBarrier::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryBarrier::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMemoryBarrier.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMemoryBarrier.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryBarrier.pNext", "[object Object]");
  
    return;
  }
}// srcAccessMask
Napi::Value _VkMemoryBarrier::GetsrcAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcAccessMask);
}void _VkMemoryBarrier::SetsrcAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryBarrier.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
Napi::Value _VkMemoryBarrier::GetdstAccessMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstAccessMask);
}void _VkMemoryBarrier::SetdstAccessMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstAccessMask = static_cast<VkAccessFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryBarrier.dstAccessMask", "Number");
  
    return;
  }
}
/** ## END VkMemoryBarrier ## **/

/** ## BEGIN VkImageSubresourceRange ## **/

Napi::FunctionReference _VkImageSubresourceRange::constructor;

_VkImageSubresourceRange::_VkImageSubresourceRange(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageSubresourceRange>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "aspectMask");
      Napi::String sAccess1 = Napi::String::New(env, "baseMipLevel");
      Napi::String sAccess2 = Napi::String::New(env, "levelCount");
      Napi::String sAccess3 = Napi::String::New(env, "baseArrayLayer");
      Napi::String sAccess4 = Napi::String::New(env, "layerCount");
      if (obj.Has(sAccess0)) this->SetaspectMask(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbaseMipLevel(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetlevelCount(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetbaseArrayLayer(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetlayerCount(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkImageSubresourceRange constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageSubresourceRange::~_VkImageSubresourceRange() {
  
  
  
  
  
  
}

Napi::Object _VkImageSubresourceRange::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageSubresourceRange", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageSubresourceRange::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageSubresourceRange::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "aspectMask",
    &_VkImageSubresourceRange::GetaspectMask,
    &_VkImageSubresourceRange::SetaspectMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "baseMipLevel",
    &_VkImageSubresourceRange::GetbaseMipLevel,
    &_VkImageSubresourceRange::SetbaseMipLevel,
    napi_enumerable
  ),
  InstanceAccessor(
    "levelCount",
    &_VkImageSubresourceRange::GetlevelCount,
    &_VkImageSubresourceRange::SetlevelCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "baseArrayLayer",
    &_VkImageSubresourceRange::GetbaseArrayLayer,
    &_VkImageSubresourceRange::SetbaseArrayLayer,
    napi_enumerable
  ),
  InstanceAccessor(
    "layerCount",
    &_VkImageSubresourceRange::GetlayerCount,
    &_VkImageSubresourceRange::SetlayerCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageSubresourceRange", func);
  return exports;
}

Napi::Value _VkImageSubresourceRange::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageSubresourceRange::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceRange *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkImageSubresourceRange *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceRange *)0)->baseMipLevel));
    uint32_t byteLength = sizeof(((VkImageSubresourceRange *)0)->baseMipLevel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceRange *)0)->levelCount));
    uint32_t byteLength = sizeof(((VkImageSubresourceRange *)0)->levelCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceRange *)0)->baseArrayLayer));
    uint32_t byteLength = sizeof(((VkImageSubresourceRange *)0)->baseArrayLayer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceRange *)0)->layerCount));
    uint32_t byteLength = sizeof(((VkImageSubresourceRange *)0)->layerCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageSubresourceRange::flush() {
  _VkImageSubresourceRange *self = this;
  
  return true;
}

// aspectMask
Napi::Value _VkImageSubresourceRange::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkImageSubresourceRange::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceRange.aspectMask", "Number");
  
    return;
  }
}// baseMipLevel
Napi::Value _VkImageSubresourceRange::GetbaseMipLevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.baseMipLevel);
}void _VkImageSubresourceRange::SetbaseMipLevel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.baseMipLevel = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceRange.baseMipLevel", "Number");
  
    return;
  }
}// levelCount
Napi::Value _VkImageSubresourceRange::GetlevelCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.levelCount);
}void _VkImageSubresourceRange::SetlevelCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.levelCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceRange.levelCount", "Number");
  
    return;
  }
}// baseArrayLayer
Napi::Value _VkImageSubresourceRange::GetbaseArrayLayer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.baseArrayLayer);
}void _VkImageSubresourceRange::SetbaseArrayLayer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.baseArrayLayer = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceRange.baseArrayLayer", "Number");
  
    return;
  }
}// layerCount
Napi::Value _VkImageSubresourceRange::GetlayerCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layerCount);
}void _VkImageSubresourceRange::SetlayerCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layerCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceRange.layerCount", "Number");
  
    return;
  }
}
/** ## END VkImageSubresourceRange ## **/

/** ## BEGIN VkImageSubresourceLayers ## **/

Napi::FunctionReference _VkImageSubresourceLayers::constructor;

_VkImageSubresourceLayers::_VkImageSubresourceLayers(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageSubresourceLayers>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "aspectMask");
      Napi::String sAccess1 = Napi::String::New(env, "mipLevel");
      Napi::String sAccess2 = Napi::String::New(env, "baseArrayLayer");
      Napi::String sAccess3 = Napi::String::New(env, "layerCount");
      if (obj.Has(sAccess0)) this->SetaspectMask(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetmipLevel(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetbaseArrayLayer(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetlayerCount(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkImageSubresourceLayers constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageSubresourceLayers::~_VkImageSubresourceLayers() {
  
  
  
  
  
}

Napi::Object _VkImageSubresourceLayers::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageSubresourceLayers", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageSubresourceLayers::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageSubresourceLayers::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "aspectMask",
    &_VkImageSubresourceLayers::GetaspectMask,
    &_VkImageSubresourceLayers::SetaspectMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "mipLevel",
    &_VkImageSubresourceLayers::GetmipLevel,
    &_VkImageSubresourceLayers::SetmipLevel,
    napi_enumerable
  ),
  InstanceAccessor(
    "baseArrayLayer",
    &_VkImageSubresourceLayers::GetbaseArrayLayer,
    &_VkImageSubresourceLayers::SetbaseArrayLayer,
    napi_enumerable
  ),
  InstanceAccessor(
    "layerCount",
    &_VkImageSubresourceLayers::GetlayerCount,
    &_VkImageSubresourceLayers::SetlayerCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageSubresourceLayers", func);
  return exports;
}

Napi::Value _VkImageSubresourceLayers::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageSubresourceLayers::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceLayers *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkImageSubresourceLayers *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceLayers *)0)->mipLevel));
    uint32_t byteLength = sizeof(((VkImageSubresourceLayers *)0)->mipLevel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceLayers *)0)->baseArrayLayer));
    uint32_t byteLength = sizeof(((VkImageSubresourceLayers *)0)->baseArrayLayer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresourceLayers *)0)->layerCount));
    uint32_t byteLength = sizeof(((VkImageSubresourceLayers *)0)->layerCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageSubresourceLayers::flush() {
  _VkImageSubresourceLayers *self = this;
  
  return true;
}

// aspectMask
Napi::Value _VkImageSubresourceLayers::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkImageSubresourceLayers::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceLayers.aspectMask", "Number");
  
    return;
  }
}// mipLevel
Napi::Value _VkImageSubresourceLayers::GetmipLevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mipLevel);
}void _VkImageSubresourceLayers::SetmipLevel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mipLevel = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceLayers.mipLevel", "Number");
  
    return;
  }
}// baseArrayLayer
Napi::Value _VkImageSubresourceLayers::GetbaseArrayLayer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.baseArrayLayer);
}void _VkImageSubresourceLayers::SetbaseArrayLayer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.baseArrayLayer = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceLayers.baseArrayLayer", "Number");
  
    return;
  }
}// layerCount
Napi::Value _VkImageSubresourceLayers::GetlayerCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layerCount);
}void _VkImageSubresourceLayers::SetlayerCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layerCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresourceLayers.layerCount", "Number");
  
    return;
  }
}
/** ## END VkImageSubresourceLayers ## **/

/** ## BEGIN VkImageSubresource ## **/

Napi::FunctionReference _VkImageSubresource::constructor;

_VkImageSubresource::_VkImageSubresource(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageSubresource>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "aspectMask");
      Napi::String sAccess1 = Napi::String::New(env, "mipLevel");
      Napi::String sAccess2 = Napi::String::New(env, "arrayLayer");
      if (obj.Has(sAccess0)) this->SetaspectMask(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetmipLevel(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetarrayLayer(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkImageSubresource constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageSubresource::~_VkImageSubresource() {
  
  
  
  
}

Napi::Object _VkImageSubresource::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageSubresource", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageSubresource::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageSubresource::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "aspectMask",
    &_VkImageSubresource::GetaspectMask,
    &_VkImageSubresource::SetaspectMask,
    napi_enumerable
  ),
  InstanceAccessor(
    "mipLevel",
    &_VkImageSubresource::GetmipLevel,
    &_VkImageSubresource::SetmipLevel,
    napi_enumerable
  ),
  InstanceAccessor(
    "arrayLayer",
    &_VkImageSubresource::GetarrayLayer,
    &_VkImageSubresource::SetarrayLayer,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageSubresource", func);
  return exports;
}

Napi::Value _VkImageSubresource::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageSubresource::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresource *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkImageSubresource *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresource *)0)->mipLevel));
    uint32_t byteLength = sizeof(((VkImageSubresource *)0)->mipLevel);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageSubresource *)0)->arrayLayer));
    uint32_t byteLength = sizeof(((VkImageSubresource *)0)->arrayLayer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageSubresource::flush() {
  _VkImageSubresource *self = this;
  
  return true;
}

// aspectMask
Napi::Value _VkImageSubresource::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}void _VkImageSubresource::SetaspectMask(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.aspectMask = static_cast<VkImageAspectFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresource.aspectMask", "Number");
  
    return;
  }
}// mipLevel
Napi::Value _VkImageSubresource::GetmipLevel(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.mipLevel);
}void _VkImageSubresource::SetmipLevel(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.mipLevel = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresource.mipLevel", "Number");
  
    return;
  }
}// arrayLayer
Napi::Value _VkImageSubresource::GetarrayLayer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.arrayLayer);
}void _VkImageSubresource::SetarrayLayer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.arrayLayer = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkImageSubresource.arrayLayer", "Number");
  
    return;
  }
}
/** ## END VkImageSubresource ## **/

/** ## BEGIN VkBufferViewCreateInfo ## **/

Napi::FunctionReference _VkBufferViewCreateInfo::constructor;

_VkBufferViewCreateInfo::_VkBufferViewCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferViewCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "buffer");
      Napi::String sAccess4 = Napi::String::New(env, "format");
      Napi::String sAccess5 = Napi::String::New(env, "offset");
      Napi::String sAccess6 = Napi::String::New(env, "range");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setbuffer(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setformat(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->Setoffset(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->Setrange(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkBufferViewCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferViewCreateInfo::~_VkBufferViewCreateInfo() {
  
  
  pNext.Reset();
  
  
  buffer.Reset();
  
  
  
  
}

Napi::Object _VkBufferViewCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferViewCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferViewCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferViewCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBufferViewCreateInfo::GetsType,
    &_VkBufferViewCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBufferViewCreateInfo::GetpNext,
    &_VkBufferViewCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkBufferViewCreateInfo::Getflags,
    &_VkBufferViewCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "buffer",
    &_VkBufferViewCreateInfo::Getbuffer,
    &_VkBufferViewCreateInfo::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "format",
    &_VkBufferViewCreateInfo::Getformat,
    &_VkBufferViewCreateInfo::Setformat,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkBufferViewCreateInfo::Getoffset,
    &_VkBufferViewCreateInfo::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "range",
    &_VkBufferViewCreateInfo::Getrange,
    &_VkBufferViewCreateInfo::Setrange,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferViewCreateInfo", func);
  return exports;
}

Napi::Value _VkBufferViewCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferViewCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->buffer));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->format));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->format);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->offset));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferViewCreateInfo *)0)->range));
    uint32_t byteLength = sizeof(((VkBufferViewCreateInfo *)0)->range);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferViewCreateInfo::flush() {
  _VkBufferViewCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkBufferViewCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBufferViewCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBufferViewCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBufferViewCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkBufferViewCreateInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkBufferViewCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkBufferViewCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkBufferViewCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.flags", "Number");
  
    return;
  }
}// buffer
Napi::Value _VkBufferViewCreateInfo::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkBufferViewCreateInfo::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// format
Napi::Value _VkBufferViewCreateInfo::Getformat(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.format);
}void _VkBufferViewCreateInfo::Setformat(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.format = static_cast<VkFormat>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.format", "Number");
  
    return;
  }
}// offset
Napi::Value _VkBufferViewCreateInfo::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkBufferViewCreateInfo::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.offset", "Number");
  
    return;
  }
}// range
Napi::Value _VkBufferViewCreateInfo::Getrange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.range);
}void _VkBufferViewCreateInfo::Setrange(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.range = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferViewCreateInfo.range", "Number");
  
    return;
  }
}
/** ## END VkBufferViewCreateInfo ## **/

/** ## BEGIN VkBufferCreateInfo ## **/

Napi::FunctionReference _VkBufferCreateInfo::constructor;

_VkBufferCreateInfo::_VkBufferCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBufferCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "size");
      Napi::String sAccess4 = Napi::String::New(env, "usage");
      Napi::String sAccess5 = Napi::String::New(env, "sharingMode");
      Napi::String sAccess6 = Napi::String::New(env, "queueFamilyIndexCount");
      Napi::String sAccess7 = Napi::String::New(env, "pQueueFamilyIndices");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setsize(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setusage(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetsharingMode(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetqueueFamilyIndexCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpQueueFamilyIndices(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkBufferCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkBufferCreateInfo::~_VkBufferCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
}

Napi::Object _VkBufferCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBufferCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBufferCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBufferCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBufferCreateInfo::GetsType,
    &_VkBufferCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBufferCreateInfo::GetpNext,
    &_VkBufferCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkBufferCreateInfo::Getflags,
    &_VkBufferCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkBufferCreateInfo::Getsize,
    &_VkBufferCreateInfo::Setsize,
    napi_enumerable
  ),
  InstanceAccessor(
    "usage",
    &_VkBufferCreateInfo::Getusage,
    &_VkBufferCreateInfo::Setusage,
    napi_enumerable
  ),
  InstanceAccessor(
    "sharingMode",
    &_VkBufferCreateInfo::GetsharingMode,
    &_VkBufferCreateInfo::SetsharingMode,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyIndexCount",
    &_VkBufferCreateInfo::GetqueueFamilyIndexCount,
    &_VkBufferCreateInfo::SetqueueFamilyIndexCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pQueueFamilyIndices",
    &_VkBufferCreateInfo::GetpQueueFamilyIndices,
    &_VkBufferCreateInfo::SetpQueueFamilyIndices,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBufferCreateInfo", func);
  return exports;
}

Napi::Value _VkBufferCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBufferCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->size));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->usage));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->usage);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->sharingMode));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->sharingMode);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->queueFamilyIndexCount));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->queueFamilyIndexCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBufferCreateInfo *)0)->pQueueFamilyIndices));
    uint32_t byteLength = sizeof(((VkBufferCreateInfo *)0)->pQueueFamilyIndices);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBufferCreateInfo::flush() {
  _VkBufferCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV) {
      _VkDedicatedAllocationBufferCreateInfoNV* structExt = Napi::ObjectWrap<_VkDedicatedAllocationBufferCreateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO) {
      _VkExternalMemoryBufferCreateInfo* structExt = Napi::ObjectWrap<_VkExternalMemoryBufferCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkBufferCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBufferCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBufferCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBufferCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkBufferCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkBufferCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkBufferCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkBufferCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkBufferCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.flags", "Number");
  
    return;
  }
}// size
Napi::Value _VkBufferCreateInfo::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkBufferCreateInfo::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.size", "Number");
  
    return;
  }
}// usage
Napi::Value _VkBufferCreateInfo::Getusage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.usage);
}void _VkBufferCreateInfo::Setusage(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.usage = static_cast<VkBufferUsageFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.usage", "Number");
  
    return;
  }
}// sharingMode
Napi::Value _VkBufferCreateInfo::GetsharingMode(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sharingMode);
}void _VkBufferCreateInfo::SetsharingMode(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sharingMode = static_cast<VkSharingMode>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.sharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
Napi::Value _VkBufferCreateInfo::GetqueueFamilyIndexCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFamilyIndexCount);
}void _VkBufferCreateInfo::SetqueueFamilyIndexCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueFamilyIndexCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkBufferCreateInfo.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
Napi::Value _VkBufferCreateInfo::GetpQueueFamilyIndices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pQueueFamilyIndices.IsEmpty()) return env.Null();
  return this->pQueueFamilyIndices.Value().As<Napi::TypedArray>();
}void _VkBufferCreateInfo::SetpQueueFamilyIndices(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_uint32_array) {
        this->pQueueFamilyIndices.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkBufferCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pQueueFamilyIndices.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkBufferCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(value, nullptr);
  } else {
    this->instance.pQueueFamilyIndices = nullptr;
  }
}
/** ## END VkBufferCreateInfo ## **/

/** ## BEGIN VkCopyDescriptorSet ## **/

Napi::FunctionReference _VkCopyDescriptorSet::constructor;

_VkCopyDescriptorSet::_VkCopyDescriptorSet(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkCopyDescriptorSet>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "srcSet");
      Napi::String sAccess3 = Napi::String::New(env, "srcBinding");
      Napi::String sAccess4 = Napi::String::New(env, "srcArrayElement");
      Napi::String sAccess5 = Napi::String::New(env, "dstSet");
      Napi::String sAccess6 = Napi::String::New(env, "dstBinding");
      Napi::String sAccess7 = Napi::String::New(env, "dstArrayElement");
      Napi::String sAccess8 = Napi::String::New(env, "descriptorCount");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetsrcSet(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetsrcBinding(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetsrcArrayElement(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdstSet(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdstBinding(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetdstArrayElement(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetdescriptorCount(info, obj.Get(sAccess8));
      
    } else {
      Napi::Error::New(env, "VkCopyDescriptorSet constructor cannot be invoked without 'new'");
    }
  }
}

_VkCopyDescriptorSet::~_VkCopyDescriptorSet() {
  
  
  pNext.Reset();
  
  srcSet.Reset();
  
  
  
  dstSet.Reset();
  
  
  
  
}

Napi::Object _VkCopyDescriptorSet::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkCopyDescriptorSet", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkCopyDescriptorSet::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkCopyDescriptorSet::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkCopyDescriptorSet::GetsType,
    &_VkCopyDescriptorSet::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkCopyDescriptorSet::GetpNext,
    &_VkCopyDescriptorSet::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcSet",
    &_VkCopyDescriptorSet::GetsrcSet,
    &_VkCopyDescriptorSet::SetsrcSet,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcBinding",
    &_VkCopyDescriptorSet::GetsrcBinding,
    &_VkCopyDescriptorSet::SetsrcBinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "srcArrayElement",
    &_VkCopyDescriptorSet::GetsrcArrayElement,
    &_VkCopyDescriptorSet::SetsrcArrayElement,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSet",
    &_VkCopyDescriptorSet::GetdstSet,
    &_VkCopyDescriptorSet::SetdstSet,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstBinding",
    &_VkCopyDescriptorSet::GetdstBinding,
    &_VkCopyDescriptorSet::SetdstBinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstArrayElement",
    &_VkCopyDescriptorSet::GetdstArrayElement,
    &_VkCopyDescriptorSet::SetdstArrayElement,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorCount",
    &_VkCopyDescriptorSet::GetdescriptorCount,
    &_VkCopyDescriptorSet::SetdescriptorCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkCopyDescriptorSet", func);
  return exports;
}

Napi::Value _VkCopyDescriptorSet::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkCopyDescriptorSet::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->sType));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->pNext));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->srcSet));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->srcSet);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->srcBinding));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->srcBinding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->srcArrayElement));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->srcArrayElement);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->dstSet));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->dstSet);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->dstBinding));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->dstBinding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->dstArrayElement));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->dstArrayElement);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkCopyDescriptorSet *)0)->descriptorCount));
    uint32_t byteLength = sizeof(((VkCopyDescriptorSet *)0)->descriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkCopyDescriptorSet::flush() {
  _VkCopyDescriptorSet *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkCopyDescriptorSet::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkCopyDescriptorSet::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkCopyDescriptorSet::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkCopyDescriptorSet::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkCopyDescriptorSet.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkCopyDescriptorSet.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.pNext", "[object Object]");
  
    return;
  }
}// srcSet
Napi::Value _VkCopyDescriptorSet::GetsrcSet(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->srcSet.IsEmpty()) return env.Null();
  return this->srcSet.Value().As<Napi::Object>();
}void _VkCopyDescriptorSet::SetsrcSet(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorSet::constructor.Value())) {
      
      this->srcSet.Reset(value.ToObject(), 1);
      _VkDescriptorSet* inst = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      ;
      this->instance.srcSet = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCopyDescriptorSet.srcSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->srcSet.Reset();
    this->instance.srcSet = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.srcSet", "[object VkDescriptorSet]");
  
    return;
  }
}// srcBinding
Napi::Value _VkCopyDescriptorSet::GetsrcBinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcBinding);
}void _VkCopyDescriptorSet::SetsrcBinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcBinding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.srcBinding", "Number");
  
    return;
  }
}// srcArrayElement
Napi::Value _VkCopyDescriptorSet::GetsrcArrayElement(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.srcArrayElement);
}void _VkCopyDescriptorSet::SetsrcArrayElement(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.srcArrayElement = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.srcArrayElement", "Number");
  
    return;
  }
}// dstSet
Napi::Value _VkCopyDescriptorSet::GetdstSet(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstSet.IsEmpty()) return env.Null();
  return this->dstSet.Value().As<Napi::Object>();
}void _VkCopyDescriptorSet::SetdstSet(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorSet::constructor.Value())) {
      
      this->dstSet.Reset(value.ToObject(), 1);
      _VkDescriptorSet* inst = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      ;
      this->instance.dstSet = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkCopyDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstSet.Reset();
    this->instance.dstSet = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
    return;
  }
}// dstBinding
Napi::Value _VkCopyDescriptorSet::GetdstBinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstBinding);
}void _VkCopyDescriptorSet::SetdstBinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstBinding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
Napi::Value _VkCopyDescriptorSet::GetdstArrayElement(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstArrayElement);
}void _VkCopyDescriptorSet::SetdstArrayElement(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstArrayElement = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
Napi::Value _VkCopyDescriptorSet::GetdescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorCount);
}void _VkCopyDescriptorSet::SetdescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkCopyDescriptorSet.descriptorCount", "Number");
  
    return;
  }
}
/** ## END VkCopyDescriptorSet ## **/

/** ## BEGIN VkWriteDescriptorSet ## **/

Napi::FunctionReference _VkWriteDescriptorSet::constructor;

_VkWriteDescriptorSet::_VkWriteDescriptorSet(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkWriteDescriptorSet>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    vpImageInfo = new std::vector<VkDescriptorImageInfo>;
    vpBufferInfo = new std::vector<VkDescriptorBufferInfo>;
    vpTexelBufferView = new std::vector<VkBufferView>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "dstSet");
      Napi::String sAccess3 = Napi::String::New(env, "dstBinding");
      Napi::String sAccess4 = Napi::String::New(env, "dstArrayElement");
      Napi::String sAccess5 = Napi::String::New(env, "descriptorCount");
      Napi::String sAccess6 = Napi::String::New(env, "descriptorType");
      Napi::String sAccess7 = Napi::String::New(env, "pImageInfo");
      Napi::String sAccess8 = Napi::String::New(env, "pBufferInfo");
      Napi::String sAccess9 = Napi::String::New(env, "pTexelBufferView");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetdstSet(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetdstBinding(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetdstArrayElement(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetdescriptorCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetdescriptorType(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetpImageInfo(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetpBufferInfo(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpTexelBufferView(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkWriteDescriptorSet constructor cannot be invoked without 'new'");
    }
  }
}

_VkWriteDescriptorSet::~_VkWriteDescriptorSet() {
  
  
  pNext.Reset();
  
  dstSet.Reset();
  
  
  
  
  
  vpImageInfo->clear();
  delete vpImageInfo;
  
  pImageInfo.Reset();
  
  vpBufferInfo->clear();
  delete vpBufferInfo;
  
  pBufferInfo.Reset();
  
  vpTexelBufferView->clear();
  delete vpTexelBufferView;
  
  pTexelBufferView.Reset();
  
}

Napi::Object _VkWriteDescriptorSet::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkWriteDescriptorSet", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkWriteDescriptorSet::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkWriteDescriptorSet::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkWriteDescriptorSet::GetsType,
    &_VkWriteDescriptorSet::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkWriteDescriptorSet::GetpNext,
    &_VkWriteDescriptorSet::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstSet",
    &_VkWriteDescriptorSet::GetdstSet,
    &_VkWriteDescriptorSet::SetdstSet,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstBinding",
    &_VkWriteDescriptorSet::GetdstBinding,
    &_VkWriteDescriptorSet::SetdstBinding,
    napi_enumerable
  ),
  InstanceAccessor(
    "dstArrayElement",
    &_VkWriteDescriptorSet::GetdstArrayElement,
    &_VkWriteDescriptorSet::SetdstArrayElement,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorCount",
    &_VkWriteDescriptorSet::GetdescriptorCount,
    &_VkWriteDescriptorSet::SetdescriptorCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "descriptorType",
    &_VkWriteDescriptorSet::GetdescriptorType,
    &_VkWriteDescriptorSet::SetdescriptorType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pImageInfo",
    &_VkWriteDescriptorSet::GetpImageInfo,
    &_VkWriteDescriptorSet::SetpImageInfo,
    napi_enumerable
  ),
  InstanceAccessor(
    "pBufferInfo",
    &_VkWriteDescriptorSet::GetpBufferInfo,
    &_VkWriteDescriptorSet::SetpBufferInfo,
    napi_enumerable
  ),
  InstanceAccessor(
    "pTexelBufferView",
    &_VkWriteDescriptorSet::GetpTexelBufferView,
    &_VkWriteDescriptorSet::SetpTexelBufferView,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkWriteDescriptorSet", func);
  return exports;
}

Napi::Value _VkWriteDescriptorSet::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkWriteDescriptorSet::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->sType));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->pNext));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->dstSet));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->dstSet);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->dstBinding));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->dstBinding);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->dstArrayElement));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->dstArrayElement);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->descriptorCount));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->descriptorCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->descriptorType));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->descriptorType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->pImageInfo));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->pImageInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->pBufferInfo));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->pBufferInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkWriteDescriptorSet *)0)->pTexelBufferView));
    uint32_t byteLength = sizeof(((VkWriteDescriptorSet *)0)->pTexelBufferView);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkWriteDescriptorSet::flush() {
  _VkWriteDescriptorSet *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }if (!(self->pImageInfo.IsEmpty())) {
    Napi::Value value = self->pImageInfo.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorCount' for 'VkWriteDescriptorSet.pImageInfo'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorImageInfo>* data = this->vpImageInfo;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorImageInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pImageInfo", "[object VkDescriptorImageInfo]");
  
        return false;
      }
      _VkDescriptorImageInfo* result = Napi::ObjectWrap<_VkDescriptorImageInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pImageInfo = data->data();
  }if (!(self->pBufferInfo.IsEmpty())) {
    Napi::Value value = self->pBufferInfo.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorCount' for 'VkWriteDescriptorSet.pBufferInfo'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDescriptorBufferInfo>* data = this->vpBufferInfo;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDescriptorBufferInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pBufferInfo", "[object VkDescriptorBufferInfo]");
  
        return false;
      }
      _VkDescriptorBufferInfo* result = Napi::ObjectWrap<_VkDescriptorBufferInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBufferInfo = data->data();
  }if (!(self->pTexelBufferView.IsEmpty())) {
    Napi::Value value = self->pTexelBufferView.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.descriptorCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'descriptorCount' for 'VkWriteDescriptorSet.pTexelBufferView'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkBufferView>* data = this->vpTexelBufferView;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkBufferView::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pTexelBufferView", "[object VkBufferView]");
  
        return false;
      }
      _VkBufferView* result = Napi::ObjectWrap<_VkBufferView>::Unwrap(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pTexelBufferView = data->data();
  }
  return true;
}

// sType
Napi::Value _VkWriteDescriptorSet::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkWriteDescriptorSet::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkWriteDescriptorSet::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkWriteDescriptorSet::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkWriteDescriptorSet.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pNext", "[object Object]");
  
    return;
  }
}// dstSet
Napi::Value _VkWriteDescriptorSet::GetdstSet(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->dstSet.IsEmpty()) return env.Null();
  return this->dstSet.Value().As<Napi::Object>();
}void _VkWriteDescriptorSet::SetdstSet(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDescriptorSet::constructor.Value())) {
      
      this->dstSet.Reset(value.ToObject(), 1);
      _VkDescriptorSet* inst = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      ;
      this->instance.dstSet = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkWriteDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->dstSet.Reset();
    this->instance.dstSet = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
    return;
  }
}// dstBinding
Napi::Value _VkWriteDescriptorSet::GetdstBinding(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstBinding);
}void _VkWriteDescriptorSet::SetdstBinding(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstBinding = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
Napi::Value _VkWriteDescriptorSet::GetdstArrayElement(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.dstArrayElement);
}void _VkWriteDescriptorSet::SetdstArrayElement(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.dstArrayElement = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
Napi::Value _VkWriteDescriptorSet::GetdescriptorCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorCount);
}void _VkWriteDescriptorSet::SetdescriptorCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.descriptorCount", "Number");
  
    return;
  }
}// descriptorType
Napi::Value _VkWriteDescriptorSet::GetdescriptorType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.descriptorType);
}void _VkWriteDescriptorSet::SetdescriptorType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.descriptorType = static_cast<VkDescriptorType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.descriptorType", "Number");
  
    return;
  }
}// pImageInfo
Napi::Value _VkWriteDescriptorSet::GetpImageInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pImageInfo.IsEmpty()) return env.Null();
  return this->pImageInfo.Value().As<Napi::Array>();
}void _VkWriteDescriptorSet::SetpImageInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pImageInfo.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pImageInfo.Reset();
      this->instance.pImageInfo = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pImageInfo", "[object VkDescriptorImageInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pImageInfo = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pImageInfo", "[object VkDescriptorImageInfo]");
  
    return;
  }
}// pBufferInfo
Napi::Value _VkWriteDescriptorSet::GetpBufferInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pBufferInfo.IsEmpty()) return env.Null();
  return this->pBufferInfo.Value().As<Napi::Array>();
}void _VkWriteDescriptorSet::SetpBufferInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pBufferInfo.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pBufferInfo.Reset();
      this->instance.pBufferInfo = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pBufferInfo", "[object VkDescriptorBufferInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pBufferInfo = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pBufferInfo", "[object VkDescriptorBufferInfo]");
  
    return;
  }
}// pTexelBufferView
Napi::Value _VkWriteDescriptorSet::GetpTexelBufferView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pTexelBufferView.IsEmpty()) return env.Null();
  return this->pTexelBufferView.Value().As<Napi::Array>();
}void _VkWriteDescriptorSet::SetpTexelBufferView(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pTexelBufferView.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pTexelBufferView.Reset();
      this->instance.pTexelBufferView = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pTexelBufferView", "[object VkBufferView]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pTexelBufferView = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkWriteDescriptorSet.pTexelBufferView", "[object VkBufferView]");
  
    return;
  }
}
/** ## END VkWriteDescriptorSet ## **/

/** ## BEGIN VkDescriptorImageInfo ## **/

Napi::FunctionReference _VkDescriptorImageInfo::constructor;

_VkDescriptorImageInfo::_VkDescriptorImageInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorImageInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sampler");
      Napi::String sAccess1 = Napi::String::New(env, "imageView");
      Napi::String sAccess2 = Napi::String::New(env, "imageLayout");
      if (obj.Has(sAccess0)) this->Setsampler(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetimageView(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetimageLayout(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDescriptorImageInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorImageInfo::~_VkDescriptorImageInfo() {
  
  sampler.Reset();
  
  imageView.Reset();
  
  
}

Napi::Object _VkDescriptorImageInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorImageInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorImageInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorImageInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sampler",
    &_VkDescriptorImageInfo::Getsampler,
    &_VkDescriptorImageInfo::Setsampler,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageView",
    &_VkDescriptorImageInfo::GetimageView,
    &_VkDescriptorImageInfo::SetimageView,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageLayout",
    &_VkDescriptorImageInfo::GetimageLayout,
    &_VkDescriptorImageInfo::SetimageLayout,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorImageInfo", func);
  return exports;
}

Napi::Value _VkDescriptorImageInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorImageInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorImageInfo *)0)->sampler));
    uint32_t byteLength = sizeof(((VkDescriptorImageInfo *)0)->sampler);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorImageInfo *)0)->imageView));
    uint32_t byteLength = sizeof(((VkDescriptorImageInfo *)0)->imageView);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorImageInfo *)0)->imageLayout));
    uint32_t byteLength = sizeof(((VkDescriptorImageInfo *)0)->imageLayout);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorImageInfo::flush() {
  _VkDescriptorImageInfo *self = this;
  
  return true;
}

// sampler
Napi::Value _VkDescriptorImageInfo::Getsampler(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sampler.IsEmpty()) return env.Null();
  return this->sampler.Value().As<Napi::Object>();
}void _VkDescriptorImageInfo::Setsampler(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkSampler::constructor.Value())) {
      
      this->sampler.Reset(value.ToObject(), 1);
      _VkSampler* inst = Napi::ObjectWrap<_VkSampler>::Unwrap(obj);
      ;
      this->instance.sampler = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorImageInfo.sampler", "[object VkSampler]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->sampler.Reset();
    this->instance.sampler = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorImageInfo.sampler", "[object VkSampler]");
  
    return;
  }
}// imageView
Napi::Value _VkDescriptorImageInfo::GetimageView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageView.IsEmpty()) return env.Null();
  return this->imageView.Value().As<Napi::Object>();
}void _VkDescriptorImageInfo::SetimageView(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkImageView::constructor.Value())) {
      
      this->imageView.Reset(value.ToObject(), 1);
      _VkImageView* inst = Napi::ObjectWrap<_VkImageView>::Unwrap(obj);
      ;
      this->instance.imageView = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorImageInfo.imageView", "[object VkImageView]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->imageView.Reset();
    this->instance.imageView = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorImageInfo.imageView", "[object VkImageView]");
  
    return;
  }
}// imageLayout
Napi::Value _VkDescriptorImageInfo::GetimageLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageLayout);
}void _VkDescriptorImageInfo::SetimageLayout(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.imageLayout = static_cast<VkImageLayout>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorImageInfo.imageLayout", "Number");
  
    return;
  }
}
/** ## END VkDescriptorImageInfo ## **/

/** ## BEGIN VkDescriptorBufferInfo ## **/

Napi::FunctionReference _VkDescriptorBufferInfo::constructor;

_VkDescriptorBufferInfo::_VkDescriptorBufferInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDescriptorBufferInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "buffer");
      Napi::String sAccess1 = Napi::String::New(env, "offset");
      Napi::String sAccess2 = Napi::String::New(env, "range");
      if (obj.Has(sAccess0)) this->Setbuffer(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setoffset(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setrange(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkDescriptorBufferInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDescriptorBufferInfo::~_VkDescriptorBufferInfo() {
  
  buffer.Reset();
  
  
  
}

Napi::Object _VkDescriptorBufferInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDescriptorBufferInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDescriptorBufferInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDescriptorBufferInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "buffer",
    &_VkDescriptorBufferInfo::Getbuffer,
    &_VkDescriptorBufferInfo::Setbuffer,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkDescriptorBufferInfo::Getoffset,
    &_VkDescriptorBufferInfo::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "range",
    &_VkDescriptorBufferInfo::Getrange,
    &_VkDescriptorBufferInfo::Setrange,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDescriptorBufferInfo", func);
  return exports;
}

Napi::Value _VkDescriptorBufferInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDescriptorBufferInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorBufferInfo *)0)->buffer));
    uint32_t byteLength = sizeof(((VkDescriptorBufferInfo *)0)->buffer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorBufferInfo *)0)->offset));
    uint32_t byteLength = sizeof(((VkDescriptorBufferInfo *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDescriptorBufferInfo *)0)->range));
    uint32_t byteLength = sizeof(((VkDescriptorBufferInfo *)0)->range);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDescriptorBufferInfo::flush() {
  _VkDescriptorBufferInfo *self = this;
  
  return true;
}

// buffer
Napi::Value _VkDescriptorBufferInfo::Getbuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->buffer.IsEmpty()) return env.Null();
  return this->buffer.Value().As<Napi::Object>();
}void _VkDescriptorBufferInfo::Setbuffer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBuffer::constructor.Value())) {
      
      this->buffer.Reset(value.ToObject(), 1);
      _VkBuffer* inst = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      ;
      this->instance.buffer = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDescriptorBufferInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->buffer.Reset();
    this->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorBufferInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
Napi::Value _VkDescriptorBufferInfo::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkDescriptorBufferInfo::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorBufferInfo.offset", "Number");
  
    return;
  }
}// range
Napi::Value _VkDescriptorBufferInfo::Getrange(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.range);
}void _VkDescriptorBufferInfo::Setrange(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.range = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDescriptorBufferInfo.range", "Number");
  
    return;
  }
}
/** ## END VkDescriptorBufferInfo ## **/

/** ## BEGIN VkImageFormatProperties ## **/

Napi::FunctionReference _VkImageFormatProperties::constructor;

_VkImageFormatProperties::_VkImageFormatProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkImageFormatProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkImageFormatProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkImageFormatProperties::~_VkImageFormatProperties() {
  
  maxExtent.Reset();
  
  
  
  
  
}

Napi::Object _VkImageFormatProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkImageFormatProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkImageFormatProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkImageFormatProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "maxExtent",
    &_VkImageFormatProperties::GetmaxExtent,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxMipLevels",
    &_VkImageFormatProperties::GetmaxMipLevels,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxArrayLayers",
    &_VkImageFormatProperties::GetmaxArrayLayers,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sampleCounts",
    &_VkImageFormatProperties::GetsampleCounts,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxResourceSize",
    &_VkImageFormatProperties::GetmaxResourceSize,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkImageFormatProperties", func);
  return exports;
}

Napi::Value _VkImageFormatProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkImageFormatProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties *)0)->maxExtent));
    uint32_t byteLength = sizeof(((VkImageFormatProperties *)0)->maxExtent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties *)0)->maxMipLevels));
    uint32_t byteLength = sizeof(((VkImageFormatProperties *)0)->maxMipLevels);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties *)0)->maxArrayLayers));
    uint32_t byteLength = sizeof(((VkImageFormatProperties *)0)->maxArrayLayers);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties *)0)->sampleCounts));
    uint32_t byteLength = sizeof(((VkImageFormatProperties *)0)->sampleCounts);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkImageFormatProperties *)0)->maxResourceSize));
    uint32_t byteLength = sizeof(((VkImageFormatProperties *)0)->maxResourceSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkImageFormatProperties::flush() {
  _VkImageFormatProperties *self = this;
  if (!(self->maxExtent.IsEmpty())) {
    Napi::Value value = self->maxExtent.Value();
    
  }
  return true;
}

// maxExtent
Napi::Value _VkImageFormatProperties::GetmaxExtent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->maxExtent.IsEmpty()) return env.Null();
  return this->maxExtent.Value().As<Napi::Object>();
}// maxMipLevels
Napi::Value _VkImageFormatProperties::GetmaxMipLevels(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxMipLevels);
}// maxArrayLayers
Napi::Value _VkImageFormatProperties::GetmaxArrayLayers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxArrayLayers);
}// sampleCounts
Napi::Value _VkImageFormatProperties::GetsampleCounts(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sampleCounts);
}// maxResourceSize
Napi::Value _VkImageFormatProperties::GetmaxResourceSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxResourceSize);
}
/** ## END VkImageFormatProperties ## **/

/** ## BEGIN VkFormatProperties ## **/

Napi::FunctionReference _VkFormatProperties::constructor;

_VkFormatProperties::_VkFormatProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkFormatProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkFormatProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkFormatProperties::~_VkFormatProperties() {
  
  
  
  
}

Napi::Object _VkFormatProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkFormatProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkFormatProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkFormatProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "linearTilingFeatures",
    &_VkFormatProperties::GetlinearTilingFeatures,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "optimalTilingFeatures",
    &_VkFormatProperties::GetoptimalTilingFeatures,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "bufferFeatures",
    &_VkFormatProperties::GetbufferFeatures,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkFormatProperties", func);
  return exports;
}

Napi::Value _VkFormatProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkFormatProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties *)0)->linearTilingFeatures));
    uint32_t byteLength = sizeof(((VkFormatProperties *)0)->linearTilingFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties *)0)->optimalTilingFeatures));
    uint32_t byteLength = sizeof(((VkFormatProperties *)0)->optimalTilingFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkFormatProperties *)0)->bufferFeatures));
    uint32_t byteLength = sizeof(((VkFormatProperties *)0)->bufferFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkFormatProperties::flush() {
  _VkFormatProperties *self = this;
  
  return true;
}

// linearTilingFeatures
Napi::Value _VkFormatProperties::GetlinearTilingFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.linearTilingFeatures);
}// optimalTilingFeatures
Napi::Value _VkFormatProperties::GetoptimalTilingFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.optimalTilingFeatures);
}// bufferFeatures
Napi::Value _VkFormatProperties::GetbufferFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.bufferFeatures);
}
/** ## END VkFormatProperties ## **/

/** ## BEGIN VkMappedMemoryRange ## **/

Napi::FunctionReference _VkMappedMemoryRange::constructor;

_VkMappedMemoryRange::_VkMappedMemoryRange(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMappedMemoryRange>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "memory");
      Napi::String sAccess3 = Napi::String::New(env, "offset");
      Napi::String sAccess4 = Napi::String::New(env, "size");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setmemory(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setoffset(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->Setsize(info, obj.Get(sAccess4));
      
    } else {
      Napi::Error::New(env, "VkMappedMemoryRange constructor cannot be invoked without 'new'");
    }
  }
}

_VkMappedMemoryRange::~_VkMappedMemoryRange() {
  
  
  pNext.Reset();
  
  memory.Reset();
  
  
  
}

Napi::Object _VkMappedMemoryRange::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMappedMemoryRange", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMappedMemoryRange::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMappedMemoryRange::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMappedMemoryRange::GetsType,
    &_VkMappedMemoryRange::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMappedMemoryRange::GetpNext,
    &_VkMappedMemoryRange::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "memory",
    &_VkMappedMemoryRange::Getmemory,
    &_VkMappedMemoryRange::Setmemory,
    napi_enumerable
  ),
  InstanceAccessor(
    "offset",
    &_VkMappedMemoryRange::Getoffset,
    &_VkMappedMemoryRange::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "size",
    &_VkMappedMemoryRange::Getsize,
    &_VkMappedMemoryRange::Setsize,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMappedMemoryRange", func);
  return exports;
}

Napi::Value _VkMappedMemoryRange::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMappedMemoryRange::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMappedMemoryRange *)0)->sType));
    uint32_t byteLength = sizeof(((VkMappedMemoryRange *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMappedMemoryRange *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMappedMemoryRange *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMappedMemoryRange *)0)->memory));
    uint32_t byteLength = sizeof(((VkMappedMemoryRange *)0)->memory);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMappedMemoryRange *)0)->offset));
    uint32_t byteLength = sizeof(((VkMappedMemoryRange *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMappedMemoryRange *)0)->size));
    uint32_t byteLength = sizeof(((VkMappedMemoryRange *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMappedMemoryRange::flush() {
  _VkMappedMemoryRange *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkMappedMemoryRange::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMappedMemoryRange::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMappedMemoryRange.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMappedMemoryRange::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMappedMemoryRange::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkMappedMemoryRange.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkMappedMemoryRange.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMappedMemoryRange.pNext", "[object Object]");
  
    return;
  }
}// memory
Napi::Value _VkMappedMemoryRange::Getmemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memory.IsEmpty()) return env.Null();
  return this->memory.Value().As<Napi::Object>();
}void _VkMappedMemoryRange::Setmemory(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkDeviceMemory::constructor.Value())) {
      
      this->memory.Reset(value.ToObject(), 1);
      _VkDeviceMemory* inst = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
      ;
      this->instance.memory = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkMappedMemoryRange.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->memory.Reset();
    this->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NapiObjectTypeError(value, "VkMappedMemoryRange.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// offset
Napi::Value _VkMappedMemoryRange::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.offset);
}void _VkMappedMemoryRange::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.offset = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMappedMemoryRange.offset", "Number");
  
    return;
  }
}// size
Napi::Value _VkMappedMemoryRange::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}void _VkMappedMemoryRange::Setsize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.size = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMappedMemoryRange.size", "Number");
  
    return;
  }
}
/** ## END VkMappedMemoryRange ## **/

/** ## BEGIN VkMemoryHeap ## **/

Napi::FunctionReference _VkMemoryHeap::constructor;

_VkMemoryHeap::_VkMemoryHeap(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryHeap>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkMemoryHeap constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryHeap::~_VkMemoryHeap() {
  
  
  
}

Napi::Object _VkMemoryHeap::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryHeap", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryHeap::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryHeap::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "size",
    &_VkMemoryHeap::Getsize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkMemoryHeap::Getflags,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryHeap", func);
  return exports;
}

Napi::Value _VkMemoryHeap::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryHeap::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryHeap *)0)->size));
    uint32_t byteLength = sizeof(((VkMemoryHeap *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryHeap *)0)->flags));
    uint32_t byteLength = sizeof(((VkMemoryHeap *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryHeap::flush() {
  _VkMemoryHeap *self = this;
  
  return true;
}

// size
Napi::Value _VkMemoryHeap::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}// flags
Napi::Value _VkMemoryHeap::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}
/** ## END VkMemoryHeap ## **/

/** ## BEGIN VkMemoryType ## **/

Napi::FunctionReference _VkMemoryType::constructor;

_VkMemoryType::_VkMemoryType(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryType>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkMemoryType constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryType::~_VkMemoryType() {
  
  
  
}

Napi::Object _VkMemoryType::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryType", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryType::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryType::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "propertyFlags",
    &_VkMemoryType::GetpropertyFlags,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "heapIndex",
    &_VkMemoryType::GetheapIndex,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryType", func);
  return exports;
}

Napi::Value _VkMemoryType::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryType::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryType *)0)->propertyFlags));
    uint32_t byteLength = sizeof(((VkMemoryType *)0)->propertyFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryType *)0)->heapIndex));
    uint32_t byteLength = sizeof(((VkMemoryType *)0)->heapIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryType::flush() {
  _VkMemoryType *self = this;
  
  return true;
}

// propertyFlags
Napi::Value _VkMemoryType::GetpropertyFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.propertyFlags);
}// heapIndex
Napi::Value _VkMemoryType::GetheapIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.heapIndex);
}
/** ## END VkMemoryType ## **/

/** ## BEGIN VkSparseImageMemoryRequirements ## **/

Napi::FunctionReference _VkSparseImageMemoryRequirements::constructor;

_VkSparseImageMemoryRequirements::_VkSparseImageMemoryRequirements(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageMemoryRequirements>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkSparseImageMemoryRequirements constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageMemoryRequirements::~_VkSparseImageMemoryRequirements() {
  
  formatProperties.Reset();
  
  
  
  
  
}

Napi::Object _VkSparseImageMemoryRequirements::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageMemoryRequirements", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageMemoryRequirements::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageMemoryRequirements::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "formatProperties",
    &_VkSparseImageMemoryRequirements::GetformatProperties,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageMipTailFirstLod",
    &_VkSparseImageMemoryRequirements::GetimageMipTailFirstLod,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageMipTailSize",
    &_VkSparseImageMemoryRequirements::GetimageMipTailSize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageMipTailOffset",
    &_VkSparseImageMemoryRequirements::GetimageMipTailOffset,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageMipTailStride",
    &_VkSparseImageMemoryRequirements::GetimageMipTailStride,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageMemoryRequirements", func);
  return exports;
}

Napi::Value _VkSparseImageMemoryRequirements::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageMemoryRequirements::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements *)0)->formatProperties));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements *)0)->formatProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements *)0)->imageMipTailFirstLod));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements *)0)->imageMipTailFirstLod);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements *)0)->imageMipTailSize));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements *)0)->imageMipTailSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements *)0)->imageMipTailOffset));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements *)0)->imageMipTailOffset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageMemoryRequirements *)0)->imageMipTailStride));
    uint32_t byteLength = sizeof(((VkSparseImageMemoryRequirements *)0)->imageMipTailStride);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageMemoryRequirements::flush() {
  _VkSparseImageMemoryRequirements *self = this;
  if (!(self->formatProperties.IsEmpty())) {
    Napi::Value value = self->formatProperties.Value();
    
  }
  return true;
}

// formatProperties
Napi::Value _VkSparseImageMemoryRequirements::GetformatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->formatProperties.IsEmpty()) return env.Null();
  return this->formatProperties.Value().As<Napi::Object>();
}// imageMipTailFirstLod
Napi::Value _VkSparseImageMemoryRequirements::GetimageMipTailFirstLod(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageMipTailFirstLod);
}// imageMipTailSize
Napi::Value _VkSparseImageMemoryRequirements::GetimageMipTailSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageMipTailSize);
}// imageMipTailOffset
Napi::Value _VkSparseImageMemoryRequirements::GetimageMipTailOffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageMipTailOffset);
}// imageMipTailStride
Napi::Value _VkSparseImageMemoryRequirements::GetimageMipTailStride(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.imageMipTailStride);
}
/** ## END VkSparseImageMemoryRequirements ## **/

/** ## BEGIN VkSparseImageFormatProperties ## **/

Napi::FunctionReference _VkSparseImageFormatProperties::constructor;

_VkSparseImageFormatProperties::_VkSparseImageFormatProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkSparseImageFormatProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkSparseImageFormatProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkSparseImageFormatProperties::~_VkSparseImageFormatProperties() {
  
  
  imageGranularity.Reset();
  
  
}

Napi::Object _VkSparseImageFormatProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkSparseImageFormatProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkSparseImageFormatProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkSparseImageFormatProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "aspectMask",
    &_VkSparseImageFormatProperties::GetaspectMask,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "imageGranularity",
    &_VkSparseImageFormatProperties::GetimageGranularity,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkSparseImageFormatProperties::Getflags,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkSparseImageFormatProperties", func);
  return exports;
}

Napi::Value _VkSparseImageFormatProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkSparseImageFormatProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties *)0)->aspectMask));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties *)0)->aspectMask);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties *)0)->imageGranularity));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties *)0)->imageGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkSparseImageFormatProperties *)0)->flags));
    uint32_t byteLength = sizeof(((VkSparseImageFormatProperties *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkSparseImageFormatProperties::flush() {
  _VkSparseImageFormatProperties *self = this;
  if (!(self->imageGranularity.IsEmpty())) {
    Napi::Value value = self->imageGranularity.Value();
    
  }
  return true;
}

// aspectMask
Napi::Value _VkSparseImageFormatProperties::GetaspectMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.aspectMask);
}// imageGranularity
Napi::Value _VkSparseImageFormatProperties::GetimageGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->imageGranularity.IsEmpty()) return env.Null();
  return this->imageGranularity.Value().As<Napi::Object>();
}// flags
Napi::Value _VkSparseImageFormatProperties::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}
/** ## END VkSparseImageFormatProperties ## **/

/** ## BEGIN VkMemoryRequirements ## **/

Napi::FunctionReference _VkMemoryRequirements::constructor;

_VkMemoryRequirements::_VkMemoryRequirements(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryRequirements>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkMemoryRequirements constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryRequirements::~_VkMemoryRequirements() {
  
  
  
  
}

Napi::Object _VkMemoryRequirements::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryRequirements", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryRequirements::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryRequirements::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "size",
    &_VkMemoryRequirements::Getsize,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "alignment",
    &_VkMemoryRequirements::Getalignment,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryTypeBits",
    &_VkMemoryRequirements::GetmemoryTypeBits,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryRequirements", func);
  return exports;
}

Napi::Value _VkMemoryRequirements::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryRequirements::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements *)0)->size));
    uint32_t byteLength = sizeof(((VkMemoryRequirements *)0)->size);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements *)0)->alignment));
    uint32_t byteLength = sizeof(((VkMemoryRequirements *)0)->alignment);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryRequirements *)0)->memoryTypeBits));
    uint32_t byteLength = sizeof(((VkMemoryRequirements *)0)->memoryTypeBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryRequirements::flush() {
  _VkMemoryRequirements *self = this;
  
  return true;
}

// size
Napi::Value _VkMemoryRequirements::Getsize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.size);
}// alignment
Napi::Value _VkMemoryRequirements::Getalignment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.alignment);
}// memoryTypeBits
Napi::Value _VkMemoryRequirements::GetmemoryTypeBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryTypeBits);
}
/** ## END VkMemoryRequirements ## **/

/** ## BEGIN VkMemoryAllocateInfo ## **/

Napi::FunctionReference _VkMemoryAllocateInfo::constructor;

_VkMemoryAllocateInfo::_VkMemoryAllocateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkMemoryAllocateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "allocationSize");
      Napi::String sAccess3 = Napi::String::New(env, "memoryTypeIndex");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetallocationSize(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetmemoryTypeIndex(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkMemoryAllocateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkMemoryAllocateInfo::~_VkMemoryAllocateInfo() {
  
  
  pNext.Reset();
  
  
  
}

Napi::Object _VkMemoryAllocateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkMemoryAllocateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkMemoryAllocateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkMemoryAllocateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkMemoryAllocateInfo::GetsType,
    &_VkMemoryAllocateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkMemoryAllocateInfo::GetpNext,
    &_VkMemoryAllocateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "allocationSize",
    &_VkMemoryAllocateInfo::GetallocationSize,
    &_VkMemoryAllocateInfo::SetallocationSize,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryTypeIndex",
    &_VkMemoryAllocateInfo::GetmemoryTypeIndex,
    &_VkMemoryAllocateInfo::SetmemoryTypeIndex,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkMemoryAllocateInfo", func);
  return exports;
}

Napi::Value _VkMemoryAllocateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkMemoryAllocateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkMemoryAllocateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkMemoryAllocateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateInfo *)0)->allocationSize));
    uint32_t byteLength = sizeof(((VkMemoryAllocateInfo *)0)->allocationSize);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkMemoryAllocateInfo *)0)->memoryTypeIndex));
    uint32_t byteLength = sizeof(((VkMemoryAllocateInfo *)0)->memoryTypeIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkMemoryAllocateInfo::flush() {
  _VkMemoryAllocateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV) {
      _VkDedicatedAllocationMemoryAllocateInfoNV* structExt = Napi::ObjectWrap<_VkDedicatedAllocationMemoryAllocateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV) {
      _VkExportMemoryAllocateInfoNV* structExt = Napi::ObjectWrap<_VkExportMemoryAllocateInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV) {
      _VkImportMemoryWin32HandleInfoNV* structExt = Napi::ObjectWrap<_VkImportMemoryWin32HandleInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV) {
      _VkExportMemoryWin32HandleInfoNV* structExt = Napi::ObjectWrap<_VkExportMemoryWin32HandleInfoNV>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO) {
      _VkExportMemoryAllocateInfo* structExt = Napi::ObjectWrap<_VkExportMemoryAllocateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR) {
      _VkImportMemoryWin32HandleInfoKHR* structExt = Napi::ObjectWrap<_VkImportMemoryWin32HandleInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR) {
      _VkExportMemoryWin32HandleInfoKHR* structExt = Napi::ObjectWrap<_VkExportMemoryWin32HandleInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR) {
      _VkImportMemoryFdInfoKHR* structExt = Napi::ObjectWrap<_VkImportMemoryFdInfoKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO) {
      _VkMemoryAllocateFlagsInfo* structExt = Napi::ObjectWrap<_VkMemoryAllocateFlagsInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO) {
      _VkMemoryDedicatedAllocateInfo* structExt = Napi::ObjectWrap<_VkMemoryDedicatedAllocateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT) {
      _VkImportMemoryHostPointerInfoEXT* structExt = Napi::ObjectWrap<_VkImportMemoryHostPointerInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkMemoryAllocateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkMemoryAllocateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkMemoryAllocateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkMemoryAllocateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV &&
        sType != VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO &&
        sType != VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR &&
        sType != VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO &&
        sType != VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO &&
        sType != VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT &&
        sType != VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkMemoryAllocateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkMemoryAllocateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateInfo.pNext", "[object Object]");
  
    return;
  }
}// allocationSize
Napi::Value _VkMemoryAllocateInfo::GetallocationSize(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.allocationSize);
}void _VkMemoryAllocateInfo::SetallocationSize(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.allocationSize = static_cast<uint64_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateInfo.allocationSize", "Number");
  
    return;
  }
}// memoryTypeIndex
Napi::Value _VkMemoryAllocateInfo::GetmemoryTypeIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryTypeIndex);
}void _VkMemoryAllocateInfo::SetmemoryTypeIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.memoryTypeIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkMemoryAllocateInfo.memoryTypeIndex", "Number");
  
    return;
  }
}
/** ## END VkMemoryAllocateInfo ## **/

/** ## BEGIN VkPhysicalDeviceMemoryProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceMemoryProperties::constructor;

_VkPhysicalDeviceMemoryProperties::_VkPhysicalDeviceMemoryProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceMemoryProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vmemoryTypes = new std::vector<VkMemoryType>;
    vmemoryHeaps = new std::vector<VkMemoryHeap>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceMemoryProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceMemoryProperties::~_VkPhysicalDeviceMemoryProperties() {
  
  
  vmemoryTypes->clear();
  delete vmemoryTypes;
  
  memoryTypes.Reset();
  
  
  vmemoryHeaps->clear();
  delete vmemoryHeaps;
  
  memoryHeaps.Reset();
  
}

Napi::Object _VkPhysicalDeviceMemoryProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceMemoryProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceMemoryProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceMemoryProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "memoryTypeCount",
    &_VkPhysicalDeviceMemoryProperties::GetmemoryTypeCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryTypes",
    &_VkPhysicalDeviceMemoryProperties::GetmemoryTypes,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryHeapCount",
    &_VkPhysicalDeviceMemoryProperties::GetmemoryHeapCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "memoryHeaps",
    &_VkPhysicalDeviceMemoryProperties::GetmemoryHeaps,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceMemoryProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceMemoryProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceMemoryProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties *)0)->memoryTypeCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties *)0)->memoryTypeCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties *)0)->memoryTypes));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties *)0)->memoryTypes);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties *)0)->memoryHeapCount));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties *)0)->memoryHeapCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceMemoryProperties *)0)->memoryHeaps));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceMemoryProperties *)0)->memoryHeaps);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceMemoryProperties::flush() {
  _VkPhysicalDeviceMemoryProperties *self = this;
  if (!(self->memoryTypes.IsEmpty())) {
    Napi::Value value = self->memoryTypes.Value();
    
  }if (!(self->memoryHeaps.IsEmpty())) {
    Napi::Value value = self->memoryHeaps.Value();
    
  }
  return true;
}

// memoryTypeCount
Napi::Value _VkPhysicalDeviceMemoryProperties::GetmemoryTypeCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryTypeCount);
}// memoryTypes
Napi::Value _VkPhysicalDeviceMemoryProperties::GetmemoryTypes(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryTypes.IsEmpty()) return env.Null();
  return this->memoryTypes.Value().As<Napi::Array>();
}// memoryHeapCount
Napi::Value _VkPhysicalDeviceMemoryProperties::GetmemoryHeapCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.memoryHeapCount);
}// memoryHeaps
Napi::Value _VkPhysicalDeviceMemoryProperties::GetmemoryHeaps(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->memoryHeaps.IsEmpty()) return env.Null();
  return this->memoryHeaps.Value().As<Napi::Array>();
}
/** ## END VkPhysicalDeviceMemoryProperties ## **/

/** ## BEGIN VkQueueFamilyProperties ## **/

Napi::FunctionReference _VkQueueFamilyProperties::constructor;

_VkQueueFamilyProperties::_VkQueueFamilyProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkQueueFamilyProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkQueueFamilyProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkQueueFamilyProperties::~_VkQueueFamilyProperties() {
  
  
  
  
  minImageTransferGranularity.Reset();
  
}

Napi::Object _VkQueueFamilyProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkQueueFamilyProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkQueueFamilyProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkQueueFamilyProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "queueFlags",
    &_VkQueueFamilyProperties::GetqueueFlags,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueCount",
    &_VkQueueFamilyProperties::GetqueueCount,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "timestampValidBits",
    &_VkQueueFamilyProperties::GettimestampValidBits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "minImageTransferGranularity",
    &_VkQueueFamilyProperties::GetminImageTransferGranularity,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkQueueFamilyProperties", func);
  return exports;
}

Napi::Value _VkQueueFamilyProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkQueueFamilyProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties *)0)->queueFlags));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties *)0)->queueFlags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties *)0)->queueCount));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties *)0)->queueCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties *)0)->timestampValidBits));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties *)0)->timestampValidBits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkQueueFamilyProperties *)0)->minImageTransferGranularity));
    uint32_t byteLength = sizeof(((VkQueueFamilyProperties *)0)->minImageTransferGranularity);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkQueueFamilyProperties::flush() {
  _VkQueueFamilyProperties *self = this;
  if (!(self->minImageTransferGranularity.IsEmpty())) {
    Napi::Value value = self->minImageTransferGranularity.Value();
    
  }
  return true;
}

// queueFlags
Napi::Value _VkQueueFamilyProperties::GetqueueFlags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFlags);
}// queueCount
Napi::Value _VkQueueFamilyProperties::GetqueueCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueCount);
}// timestampValidBits
Napi::Value _VkQueueFamilyProperties::GettimestampValidBits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.timestampValidBits);
}// minImageTransferGranularity
Napi::Value _VkQueueFamilyProperties::GetminImageTransferGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->minImageTransferGranularity.IsEmpty()) return env.Null();
  return this->minImageTransferGranularity.Value().As<Napi::Object>();
}
/** ## END VkQueueFamilyProperties ## **/

/** ## BEGIN VkInstanceCreateInfo ## **/

Napi::FunctionReference _VkInstanceCreateInfo::constructor;

_VkInstanceCreateInfo::_VkInstanceCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkInstanceCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    vppEnabledLayerNames = new std::vector<char*>;
    vppEnabledExtensionNames = new std::vector<char*>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "pApplicationInfo");
      Napi::String sAccess4 = Napi::String::New(env, "enabledLayerCount");
      Napi::String sAccess5 = Napi::String::New(env, "ppEnabledLayerNames");
      Napi::String sAccess6 = Napi::String::New(env, "enabledExtensionCount");
      Napi::String sAccess7 = Napi::String::New(env, "ppEnabledExtensionNames");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetpApplicationInfo(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetenabledLayerCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetppEnabledLayerNames(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetenabledExtensionCount(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetppEnabledExtensionNames(info, obj.Get(sAccess7));
      
    } else {
      Napi::Error::New(env, "VkInstanceCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkInstanceCreateInfo::~_VkInstanceCreateInfo() {
  
  
  pNext.Reset();
  
  
  pApplicationInfo.Reset();
  
  
  for (int ii = 0; ii < vppEnabledLayerNames->size(); ++ii) {
    delete ((char*) vppEnabledLayerNames->at(ii));
  };
  vppEnabledLayerNames->clear();
  delete vppEnabledLayerNames;
  
  ppEnabledLayerNames.Reset();
  
  
  for (int ii = 0; ii < vppEnabledExtensionNames->size(); ++ii) {
    delete ((char*) vppEnabledExtensionNames->at(ii));
  };
  vppEnabledExtensionNames->clear();
  delete vppEnabledExtensionNames;
  
  ppEnabledExtensionNames.Reset();
  
}

Napi::Object _VkInstanceCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkInstanceCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkInstanceCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkInstanceCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkInstanceCreateInfo::GetsType,
    &_VkInstanceCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkInstanceCreateInfo::GetpNext,
    &_VkInstanceCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkInstanceCreateInfo::Getflags,
    &_VkInstanceCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "pApplicationInfo",
    &_VkInstanceCreateInfo::GetpApplicationInfo,
    &_VkInstanceCreateInfo::SetpApplicationInfo,
    napi_enumerable
  ),
  InstanceAccessor(
    "enabledLayerCount",
    &_VkInstanceCreateInfo::GetenabledLayerCount,
    &_VkInstanceCreateInfo::SetenabledLayerCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "ppEnabledLayerNames",
    &_VkInstanceCreateInfo::GetppEnabledLayerNames,
    &_VkInstanceCreateInfo::SetppEnabledLayerNames,
    napi_enumerable
  ),
  InstanceAccessor(
    "enabledExtensionCount",
    &_VkInstanceCreateInfo::GetenabledExtensionCount,
    &_VkInstanceCreateInfo::SetenabledExtensionCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "ppEnabledExtensionNames",
    &_VkInstanceCreateInfo::GetppEnabledExtensionNames,
    &_VkInstanceCreateInfo::SetppEnabledExtensionNames,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkInstanceCreateInfo", func);
  return exports;
}

Napi::Value _VkInstanceCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkInstanceCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->pApplicationInfo));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->pApplicationInfo);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->enabledLayerCount));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->enabledLayerCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->ppEnabledLayerNames));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->ppEnabledLayerNames);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->enabledExtensionCount));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->enabledExtensionCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkInstanceCreateInfo *)0)->ppEnabledExtensionNames));
    uint32_t byteLength = sizeof(((VkInstanceCreateInfo *)0)->ppEnabledExtensionNames);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkInstanceCreateInfo::flush() {
  _VkInstanceCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT) {
      _VkDebugReportCallbackCreateInfoEXT* structExt = Napi::ObjectWrap<_VkDebugReportCallbackCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT) {
      _VkValidationFlagsEXT* structExt = Napi::ObjectWrap<_VkValidationFlagsEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT) {
      _VkDebugUtilsMessengerCreateInfoEXT* structExt = Napi::ObjectWrap<_VkDebugUtilsMessengerCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->ppEnabledLayerNames.IsEmpty())) {
    Napi::Value value = self->ppEnabledLayerNames.Value();
    
    std::vector<char*>* data = self->vppEnabledLayerNames;
    data->clear();
    Napi::Array array = value.As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      if (!item.IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledLayerNames = data->data();
  }if (!(self->ppEnabledExtensionNames.IsEmpty())) {
    Napi::Value value = self->ppEnabledExtensionNames.Value();
    
    std::vector<char*>* data = self->vppEnabledExtensionNames;
    data->clear();
    Napi::Array array = value.As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      if (!item.IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledExtensionNames = data->data();
  }
  return true;
}

// sType
Napi::Value _VkInstanceCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkInstanceCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkInstanceCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkInstanceCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkInstanceCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT &&
        sType != VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT &&
        sType != VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkInstanceCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkInstanceCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkInstanceCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkInstanceCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkInstanceCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkInstanceCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkInstanceCreateInfo.flags", "Number");
  
    return;
  }
}// pApplicationInfo
Napi::Value _VkInstanceCreateInfo::GetpApplicationInfo(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pApplicationInfo.IsEmpty()) return env.Null();
  return this->pApplicationInfo.Value().As<Napi::Object>();
}void _VkInstanceCreateInfo::SetpApplicationInfo(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkApplicationInfo::constructor.Value())) {
      
      this->pApplicationInfo.Reset(value.ToObject(), 1);
      _VkApplicationInfo* inst = Napi::ObjectWrap<_VkApplicationInfo>::Unwrap(obj);
      inst->flush();
      this->instance.pApplicationInfo = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkInstanceCreateInfo.pApplicationInfo", "[object VkApplicationInfo]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pApplicationInfo.Reset();
    this->instance.pApplicationInfo = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkInstanceCreateInfo.pApplicationInfo", "[object VkApplicationInfo]");
  
    return;
  }
}// enabledLayerCount
Napi::Value _VkInstanceCreateInfo::GetenabledLayerCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.enabledLayerCount);
}void _VkInstanceCreateInfo::SetenabledLayerCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.enabledLayerCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkInstanceCreateInfo.enabledLayerCount", "Number");
  
    return;
  }
}// ppEnabledLayerNames
Napi::Value _VkInstanceCreateInfo::GetppEnabledLayerNames(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->ppEnabledLayerNames.IsEmpty()) return env.Null();
  return this->ppEnabledLayerNames.Value().As<Napi::TypedArray>();
}void _VkInstanceCreateInfo::SetppEnabledLayerNames(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->ppEnabledLayerNames.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->ppEnabledLayerNames.Reset();
      this->instance.ppEnabledLayerNames = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkInstanceCreateInfo.ppEnabledLayerNames", "Array");
  
      return;
    }
  
}// enabledExtensionCount
Napi::Value _VkInstanceCreateInfo::GetenabledExtensionCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.enabledExtensionCount);
}void _VkInstanceCreateInfo::SetenabledExtensionCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.enabledExtensionCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkInstanceCreateInfo.enabledExtensionCount", "Number");
  
    return;
  }
}// ppEnabledExtensionNames
Napi::Value _VkInstanceCreateInfo::GetppEnabledExtensionNames(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->ppEnabledExtensionNames.IsEmpty()) return env.Null();
  return this->ppEnabledExtensionNames.Value().As<Napi::TypedArray>();
}void _VkInstanceCreateInfo::SetppEnabledExtensionNames(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->ppEnabledExtensionNames.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->ppEnabledExtensionNames.Reset();
      this->instance.ppEnabledExtensionNames = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkInstanceCreateInfo.ppEnabledExtensionNames", "Array");
  
      return;
    }
  
}
/** ## END VkInstanceCreateInfo ## **/

/** ## BEGIN VkDeviceCreateInfo ## **/

Napi::FunctionReference _VkDeviceCreateInfo::constructor;

_VkDeviceCreateInfo::_VkDeviceCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    vpQueueCreateInfos = new std::vector<VkDeviceQueueCreateInfo>;
    vppEnabledLayerNames = new std::vector<char*>;
    vppEnabledExtensionNames = new std::vector<char*>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "queueCreateInfoCount");
      Napi::String sAccess4 = Napi::String::New(env, "pQueueCreateInfos");
      Napi::String sAccess5 = Napi::String::New(env, "enabledLayerCount");
      Napi::String sAccess6 = Napi::String::New(env, "ppEnabledLayerNames");
      Napi::String sAccess7 = Napi::String::New(env, "enabledExtensionCount");
      Napi::String sAccess8 = Napi::String::New(env, "ppEnabledExtensionNames");
      Napi::String sAccess9 = Napi::String::New(env, "pEnabledFeatures");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetqueueCreateInfoCount(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpQueueCreateInfos(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetenabledLayerCount(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetppEnabledLayerNames(info, obj.Get(sAccess6));
      if (obj.Has(sAccess7)) this->SetenabledExtensionCount(info, obj.Get(sAccess7));
      if (obj.Has(sAccess8)) this->SetppEnabledExtensionNames(info, obj.Get(sAccess8));
      if (obj.Has(sAccess9)) this->SetpEnabledFeatures(info, obj.Get(sAccess9));
      
    } else {
      Napi::Error::New(env, "VkDeviceCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceCreateInfo::~_VkDeviceCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  vpQueueCreateInfos->clear();
  delete vpQueueCreateInfos;
  
  pQueueCreateInfos.Reset();
  
  
  for (int ii = 0; ii < vppEnabledLayerNames->size(); ++ii) {
    delete ((char*) vppEnabledLayerNames->at(ii));
  };
  vppEnabledLayerNames->clear();
  delete vppEnabledLayerNames;
  
  ppEnabledLayerNames.Reset();
  
  
  for (int ii = 0; ii < vppEnabledExtensionNames->size(); ++ii) {
    delete ((char*) vppEnabledExtensionNames->at(ii));
  };
  vppEnabledExtensionNames->clear();
  delete vppEnabledExtensionNames;
  
  ppEnabledExtensionNames.Reset();
  
  pEnabledFeatures.Reset();
  
}

Napi::Object _VkDeviceCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceCreateInfo::GetsType,
    &_VkDeviceCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceCreateInfo::GetpNext,
    &_VkDeviceCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDeviceCreateInfo::Getflags,
    &_VkDeviceCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueCreateInfoCount",
    &_VkDeviceCreateInfo::GetqueueCreateInfoCount,
    &_VkDeviceCreateInfo::SetqueueCreateInfoCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pQueueCreateInfos",
    &_VkDeviceCreateInfo::GetpQueueCreateInfos,
    &_VkDeviceCreateInfo::SetpQueueCreateInfos,
    napi_enumerable
  ),
  InstanceAccessor(
    "enabledLayerCount",
    &_VkDeviceCreateInfo::GetenabledLayerCount,
    &_VkDeviceCreateInfo::SetenabledLayerCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "ppEnabledLayerNames",
    &_VkDeviceCreateInfo::GetppEnabledLayerNames,
    &_VkDeviceCreateInfo::SetppEnabledLayerNames,
    napi_enumerable
  ),
  InstanceAccessor(
    "enabledExtensionCount",
    &_VkDeviceCreateInfo::GetenabledExtensionCount,
    &_VkDeviceCreateInfo::SetenabledExtensionCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "ppEnabledExtensionNames",
    &_VkDeviceCreateInfo::GetppEnabledExtensionNames,
    &_VkDeviceCreateInfo::SetppEnabledExtensionNames,
    napi_enumerable
  ),
  InstanceAccessor(
    "pEnabledFeatures",
    &_VkDeviceCreateInfo::GetpEnabledFeatures,
    &_VkDeviceCreateInfo::SetpEnabledFeatures,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceCreateInfo", func);
  return exports;
}

Napi::Value _VkDeviceCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->queueCreateInfoCount));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->queueCreateInfoCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->pQueueCreateInfos));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->pQueueCreateInfos);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->enabledLayerCount));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->enabledLayerCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->ppEnabledLayerNames));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->ppEnabledLayerNames);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->enabledExtensionCount));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->enabledExtensionCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->ppEnabledExtensionNames));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->ppEnabledExtensionNames);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceCreateInfo *)0)->pEnabledFeatures));
    uint32_t byteLength = sizeof(((VkDeviceCreateInfo *)0)->pEnabledFeatures);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceCreateInfo::flush() {
  _VkDeviceCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2) {
      _VkPhysicalDeviceFeatures2* structExt = Napi::ObjectWrap<_VkPhysicalDeviceFeatures2>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES) {
      _VkPhysicalDeviceVariablePointerFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceVariablePointerFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES) {
      _VkPhysicalDeviceMultiviewFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceMultiviewFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO) {
      _VkDeviceGroupDeviceCreateInfo* structExt = Napi::ObjectWrap<_VkDeviceGroupDeviceCreateInfo>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES) {
      _VkPhysicalDevice16BitStorageFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDevice16BitStorageFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES) {
      _VkPhysicalDeviceSamplerYcbcrConversionFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES) {
      _VkPhysicalDeviceProtectedMemoryFeatures* structExt = Napi::ObjectWrap<_VkPhysicalDeviceProtectedMemoryFeatures>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT) {
      _VkPhysicalDeviceDescriptorIndexingFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR) {
      _VkPhysicalDevice8BitStorageFeaturesKHR* structExt = Napi::ObjectWrap<_VkPhysicalDevice8BitStorageFeaturesKHR>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
    else if (sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT) {
      _VkPhysicalDeviceConditionalRenderingFeaturesEXT* structExt = Napi::ObjectWrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }if (!(self->pQueueCreateInfos.IsEmpty())) {
    Napi::Value value = self->pQueueCreateInfos.Value();
    
    Napi::Array array = value.As<Napi::Array>();
    // validate length
    if (array.Length() != this->instance.queueCreateInfoCount) {
      Napi::RangeError::New(value.Env(), "Invalid array length, expected array length of 'queueCreateInfoCount' for 'VkDeviceCreateInfo.pQueueCreateInfos'").ThrowAsJavaScriptException();
      return false;
    }
    std::vector<VkDeviceQueueCreateInfo>* data = this->vpQueueCreateInfos;
    data->clear();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Object obj = array.Get(ii).As<Napi::Object>();
      if (!(obj.InstanceOf(_VkDeviceQueueCreateInfo::constructor.Value()))) {
        
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pQueueCreateInfos", "[object VkDeviceQueueCreateInfo]");
  
        return false;
      }
      _VkDeviceQueueCreateInfo* result = Napi::ObjectWrap<_VkDeviceQueueCreateInfo>::Unwrap(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pQueueCreateInfos = data->data();
  }if (!(self->ppEnabledLayerNames.IsEmpty())) {
    Napi::Value value = self->ppEnabledLayerNames.Value();
    
    std::vector<char*>* data = self->vppEnabledLayerNames;
    data->clear();
    Napi::Array array = value.As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      if (!item.IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledLayerNames = data->data();
  }if (!(self->ppEnabledExtensionNames.IsEmpty())) {
    Napi::Value value = self->ppEnabledExtensionNames.Value();
    
    std::vector<char*>* data = self->vppEnabledExtensionNames;
    data->clear();
    Napi::Array array = value.As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      if (!item.IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledExtensionNames = data->data();
  }
  return true;
}

// sType
Napi::Value _VkDeviceCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES &&
        sType != VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR &&
        sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkDeviceCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDeviceCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDeviceCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDeviceCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.flags", "Number");
  
    return;
  }
}// queueCreateInfoCount
Napi::Value _VkDeviceCreateInfo::GetqueueCreateInfoCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueCreateInfoCount);
}void _VkDeviceCreateInfo::SetqueueCreateInfoCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueCreateInfoCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.queueCreateInfoCount", "Number");
  
    return;
  }
}// pQueueCreateInfos
Napi::Value _VkDeviceCreateInfo::GetpQueueCreateInfos(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pQueueCreateInfos.IsEmpty()) return env.Null();
  return this->pQueueCreateInfos.Value().As<Napi::Array>();
}void _VkDeviceCreateInfo::SetpQueueCreateInfos(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->pQueueCreateInfos.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->pQueueCreateInfos.Reset();
      this->instance.pQueueCreateInfos = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pQueueCreateInfos", "[object VkDeviceQueueCreateInfo]");
  
      return;
    }
  
  // vulkan
  if (value.IsArray()) {
    
  } else if (value.IsNull()) {
    this->instance.pQueueCreateInfos = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pQueueCreateInfos", "[object VkDeviceQueueCreateInfo]");
  
    return;
  }
}// enabledLayerCount
Napi::Value _VkDeviceCreateInfo::GetenabledLayerCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.enabledLayerCount);
}void _VkDeviceCreateInfo::SetenabledLayerCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.enabledLayerCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.enabledLayerCount", "Number");
  
    return;
  }
}// ppEnabledLayerNames
Napi::Value _VkDeviceCreateInfo::GetppEnabledLayerNames(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->ppEnabledLayerNames.IsEmpty()) return env.Null();
  return this->ppEnabledLayerNames.Value().As<Napi::TypedArray>();
}void _VkDeviceCreateInfo::SetppEnabledLayerNames(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->ppEnabledLayerNames.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->ppEnabledLayerNames.Reset();
      this->instance.ppEnabledLayerNames = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceCreateInfo.ppEnabledLayerNames", "Array");
  
      return;
    }
  
}// enabledExtensionCount
Napi::Value _VkDeviceCreateInfo::GetenabledExtensionCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.enabledExtensionCount);
}void _VkDeviceCreateInfo::SetenabledExtensionCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.enabledExtensionCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.enabledExtensionCount", "Number");
  
    return;
  }
}// ppEnabledExtensionNames
Napi::Value _VkDeviceCreateInfo::GetppEnabledExtensionNames(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->ppEnabledExtensionNames.IsEmpty()) return env.Null();
  return this->ppEnabledExtensionNames.Value().As<Napi::TypedArray>();
}void _VkDeviceCreateInfo::SetppEnabledExtensionNames(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsArray()) {
      this->ppEnabledExtensionNames.Reset(value.ToObject(), 1);
    } else if (value.IsNull()) {
      this->ppEnabledExtensionNames.Reset();
      this->instance.ppEnabledExtensionNames = nullptr;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceCreateInfo.ppEnabledExtensionNames", "Array");
  
      return;
    }
  
}// pEnabledFeatures
Napi::Value _VkDeviceCreateInfo::GetpEnabledFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pEnabledFeatures.IsEmpty()) return env.Null();
  return this->pEnabledFeatures.Value().As<Napi::Object>();
}void _VkDeviceCreateInfo::SetpEnabledFeatures(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkPhysicalDeviceFeatures::constructor.Value())) {
      
      this->pEnabledFeatures.Reset(value.ToObject(), 1);
      _VkPhysicalDeviceFeatures* inst = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(obj);
      inst->flush();
      this->instance.pEnabledFeatures = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pEnabledFeatures", "[object VkPhysicalDeviceFeatures]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pEnabledFeatures.Reset();
    this->instance.pEnabledFeatures = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceCreateInfo.pEnabledFeatures", "[object VkPhysicalDeviceFeatures]");
  
    return;
  }
}
/** ## END VkDeviceCreateInfo ## **/

/** ## BEGIN VkDeviceQueueCreateInfo ## **/

Napi::FunctionReference _VkDeviceQueueCreateInfo::constructor;

_VkDeviceQueueCreateInfo::_VkDeviceQueueCreateInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkDeviceQueueCreateInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "flags");
      Napi::String sAccess3 = Napi::String::New(env, "queueFamilyIndex");
      Napi::String sAccess4 = Napi::String::New(env, "queueCount");
      Napi::String sAccess5 = Napi::String::New(env, "pQueuePriorities");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setflags(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetqueueFamilyIndex(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetqueueCount(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetpQueuePriorities(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkDeviceQueueCreateInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkDeviceQueueCreateInfo::~_VkDeviceQueueCreateInfo() {
  
  
  pNext.Reset();
  
  
  
  
  pQueuePriorities.Reset();
  
}

Napi::Object _VkDeviceQueueCreateInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkDeviceQueueCreateInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkDeviceQueueCreateInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkDeviceQueueCreateInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkDeviceQueueCreateInfo::GetsType,
    &_VkDeviceQueueCreateInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkDeviceQueueCreateInfo::GetpNext,
    &_VkDeviceQueueCreateInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "flags",
    &_VkDeviceQueueCreateInfo::Getflags,
    &_VkDeviceQueueCreateInfo::Setflags,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueFamilyIndex",
    &_VkDeviceQueueCreateInfo::GetqueueFamilyIndex,
    &_VkDeviceQueueCreateInfo::SetqueueFamilyIndex,
    napi_enumerable
  ),
  InstanceAccessor(
    "queueCount",
    &_VkDeviceQueueCreateInfo::GetqueueCount,
    &_VkDeviceQueueCreateInfo::SetqueueCount,
    napi_enumerable
  ),
  InstanceAccessor(
    "pQueuePriorities",
    &_VkDeviceQueueCreateInfo::GetpQueuePriorities,
    &_VkDeviceQueueCreateInfo::SetpQueuePriorities,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkDeviceQueueCreateInfo", func);
  return exports;
}

Napi::Value _VkDeviceQueueCreateInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkDeviceQueueCreateInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueCreateInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkDeviceQueueCreateInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueCreateInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkDeviceQueueCreateInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueCreateInfo *)0)->flags));
    uint32_t byteLength = sizeof(((VkDeviceQueueCreateInfo *)0)->flags);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueCreateInfo *)0)->queueFamilyIndex));
    uint32_t byteLength = sizeof(((VkDeviceQueueCreateInfo *)0)->queueFamilyIndex);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueCreateInfo *)0)->queueCount));
    uint32_t byteLength = sizeof(((VkDeviceQueueCreateInfo *)0)->queueCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkDeviceQueueCreateInfo *)0)->pQueuePriorities));
    uint32_t byteLength = sizeof(((VkDeviceQueueCreateInfo *)0)->pQueuePriorities);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkDeviceQueueCreateInfo::flush() {
  _VkDeviceQueueCreateInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
    Napi::Object obj = value.As<Napi::Object>();
    VkStructureType sType = GetStructureTypeFromObject(obj);
    if (sType == VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT) {
      _VkDeviceQueueGlobalPriorityCreateInfoEXT* structExt = Napi::ObjectWrap<_VkDeviceQueueGlobalPriorityCreateInfoEXT>::Unwrap(obj);
      if (!structExt->flush()) return false;
    }
      
  }
  return true;
}

// sType
Napi::Value _VkDeviceQueueCreateInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkDeviceQueueCreateInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkDeviceQueueCreateInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkDeviceQueueCreateInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      if (
        sType != VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT 
      ) {
        Napi::TypeError::New(env, "Invalid type for 'VkDeviceQueueCreateInfo.pNext'").ThrowAsJavaScriptException();
      }
    } else {
      
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.pNext", "[object Object]");
  
    return;
  }
}// flags
Napi::Value _VkDeviceQueueCreateInfo::Getflags(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.flags);
}void _VkDeviceQueueCreateInfo::Setflags(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.flags = static_cast<VkDeviceQueueCreateFlags>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.flags", "Number");
  
    return;
  }
}// queueFamilyIndex
Napi::Value _VkDeviceQueueCreateInfo::GetqueueFamilyIndex(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueFamilyIndex);
}void _VkDeviceQueueCreateInfo::SetqueueFamilyIndex(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueFamilyIndex = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.queueFamilyIndex", "Number");
  
    return;
  }
}// queueCount
Napi::Value _VkDeviceQueueCreateInfo::GetqueueCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.queueCount);
}void _VkDeviceQueueCreateInfo::SetqueueCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.queueCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.queueCount", "Number");
  
    return;
  }
}// pQueuePriorities
Napi::Value _VkDeviceQueueCreateInfo::GetpQueuePriorities(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pQueuePriorities.IsEmpty()) return env.Null();
  return this->pQueuePriorities.Value().As<Napi::TypedArray>();
}void _VkDeviceQueueCreateInfo::SetpQueuePriorities(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  
    // js
    if (value.IsTypedArray()) {
      if (value.As<Napi::TypedArray>().TypedArrayType() == napi_float32_array) {
        this->pQueuePriorities.Reset(value.ToObject(), 1);
      } else {
        
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.pQueuePriorities", "Float32Array");
  
        return;
      }
    } else if (value.IsNull()) {
      this->pQueuePriorities.Reset();
    } else {
      
    NapiObjectTypeError(value, "VkDeviceQueueCreateInfo.pQueuePriorities", "Float32Array");
  
      return;
    }
  
  
  // vulkan
  if (value.IsTypedArray()) {
    this->instance.pQueuePriorities = getTypedArrayData<float>(value, nullptr);
  } else {
    this->instance.pQueuePriorities = nullptr;
  }
}
/** ## END VkDeviceQueueCreateInfo ## **/

/** ## BEGIN VkAllocationCallbacks ## **/

Napi::FunctionReference _VkAllocationCallbacks::constructor;

_VkAllocationCallbacks::_VkAllocationCallbacks(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkAllocationCallbacks>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "pUserData");
      if (obj.Has(sAccess0)) this->SetpUserData(info, obj.Get(sAccess0));
      
    } else {
      Napi::Error::New(env, "VkAllocationCallbacks constructor cannot be invoked without 'new'");
    }
  }
}

_VkAllocationCallbacks::~_VkAllocationCallbacks() {
  
  pUserData.Reset();
  
}

Napi::Object _VkAllocationCallbacks::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkAllocationCallbacks", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkAllocationCallbacks::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkAllocationCallbacks::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "pUserData",
    &_VkAllocationCallbacks::GetpUserData,
    &_VkAllocationCallbacks::SetpUserData,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkAllocationCallbacks", func);
  return exports;
}

Napi::Value _VkAllocationCallbacks::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkAllocationCallbacks::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkAllocationCallbacks *)0)->pUserData));
    uint32_t byteLength = sizeof(((VkAllocationCallbacks *)0)->pUserData);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkAllocationCallbacks::flush() {
  _VkAllocationCallbacks *self = this;
  
  return true;
}

// pUserData
Napi::Value _VkAllocationCallbacks::GetpUserData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pUserData.IsEmpty()) return env.Null();
  return this->pUserData.Value().As<Napi::Object>();
}void _VkAllocationCallbacks::SetpUserData(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsArrayBuffer()) {
    Napi::ArrayBuffer buffer = value.As<Napi::ArrayBuffer>();
    this->instance.pUserData = buffer.Data();
    this->pUserData.Reset(value.As<Napi::Object>(), 1);
  } else if (value.IsNull()) {
    this->instance.pUserData = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkAllocationCallbacks.pUserData", "ArrayBuffer");
  
    return;
  }
}
/** ## END VkAllocationCallbacks ## **/

/** ## BEGIN VkApplicationInfo ## **/

Napi::FunctionReference _VkApplicationInfo::constructor;

_VkApplicationInfo::_VkApplicationInfo(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkApplicationInfo>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    instance.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      Napi::String sAccess2 = Napi::String::New(env, "pApplicationName");
      Napi::String sAccess3 = Napi::String::New(env, "applicationVersion");
      Napi::String sAccess4 = Napi::String::New(env, "pEngineName");
      Napi::String sAccess5 = Napi::String::New(env, "engineVersion");
      Napi::String sAccess6 = Napi::String::New(env, "apiVersion");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetpApplicationName(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->SetapplicationVersion(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetpEngineName(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetengineVersion(info, obj.Get(sAccess5));
      if (obj.Has(sAccess6)) this->SetapiVersion(info, obj.Get(sAccess6));
      
    } else {
      Napi::Error::New(env, "VkApplicationInfo constructor cannot be invoked without 'new'");
    }
  }
}

_VkApplicationInfo::~_VkApplicationInfo() {
  
  
  pNext.Reset();
  
  pApplicationName.Reset();
  
  
  pEngineName.Reset();
  
  
  
}

Napi::Object _VkApplicationInfo::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkApplicationInfo", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkApplicationInfo::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkApplicationInfo::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkApplicationInfo::GetsType,
    &_VkApplicationInfo::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkApplicationInfo::GetpNext,
    &_VkApplicationInfo::SetpNext,
    napi_enumerable
  ),
  InstanceAccessor(
    "pApplicationName",
    &_VkApplicationInfo::GetpApplicationName,
    &_VkApplicationInfo::SetpApplicationName,
    napi_enumerable
  ),
  InstanceAccessor(
    "applicationVersion",
    &_VkApplicationInfo::GetapplicationVersion,
    &_VkApplicationInfo::SetapplicationVersion,
    napi_enumerable
  ),
  InstanceAccessor(
    "pEngineName",
    &_VkApplicationInfo::GetpEngineName,
    &_VkApplicationInfo::SetpEngineName,
    napi_enumerable
  ),
  InstanceAccessor(
    "engineVersion",
    &_VkApplicationInfo::GetengineVersion,
    &_VkApplicationInfo::SetengineVersion,
    napi_enumerable
  ),
  InstanceAccessor(
    "apiVersion",
    &_VkApplicationInfo::GetapiVersion,
    &_VkApplicationInfo::SetapiVersion,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkApplicationInfo", func);
  return exports;
}

Napi::Value _VkApplicationInfo::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkApplicationInfo::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->sType));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->pNext));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->pApplicationName));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->pApplicationName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->applicationVersion));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->applicationVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->pEngineName));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->pEngineName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->engineVersion));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->engineVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkApplicationInfo *)0)->apiVersion));
    uint32_t byteLength = sizeof(((VkApplicationInfo *)0)->apiVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkApplicationInfo::flush() {
  _VkApplicationInfo *self = this;
  if (!(self->pNext.IsEmpty())) {
    Napi::Value value = self->pNext.Value();
    
  }
  return true;
}

// sType
Napi::Value _VkApplicationInfo::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkApplicationInfo::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkApplicationInfo::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkApplicationInfo::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (IsValidStructureObject(obj)) {
      
      this->pNext.Reset(obj, 1);
      this->instance.pNext = (const void *) DynamicObjectUnwrapInstance(obj);
      VkStructureType sType = static_cast<VkStructureType>(((int*)(this->instance.pNext))[0]);
      Napi::TypeError::New(env, "'VkApplicationInfo.pNext' must be 'null'").ThrowAsJavaScriptException();
    } else {
      
    NapiObjectTypeError(value, "VkApplicationInfo.pNext", "[object Object]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.pNext", "[object Object]");
  
    return;
  }
}// pApplicationName
Napi::Value _VkApplicationInfo::GetpApplicationName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pApplicationName.IsEmpty()) return env.Null();
  return this->pApplicationName.Value().ToString();
}void _VkApplicationInfo::SetpApplicationName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pApplicationName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pApplicationName) delete[] this->instance.pApplicationName;
    this->instance.pApplicationName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pApplicationName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.pApplicationName", "String");
  
    return;
  }
}// applicationVersion
Napi::Value _VkApplicationInfo::GetapplicationVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.applicationVersion);
}void _VkApplicationInfo::SetapplicationVersion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.applicationVersion = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.applicationVersion", "Number");
  
    return;
  }
}// pEngineName
Napi::Value _VkApplicationInfo::GetpEngineName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pEngineName.IsEmpty()) return env.Null();
  return this->pEngineName.Value().ToString();
}void _VkApplicationInfo::SetpEngineName(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsString()) {
    this->pEngineName.Reset(value.ToObject(), 1);
    // free previous
    if (this->instance.pEngineName) delete[] this->instance.pEngineName;
    this->instance.pEngineName = copyV8String(value);
  } else if (value.IsNull()) {
    this->instance.pEngineName = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.pEngineName", "String");
  
    return;
  }
}// engineVersion
Napi::Value _VkApplicationInfo::GetengineVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.engineVersion);
}void _VkApplicationInfo::SetengineVersion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.engineVersion = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.engineVersion", "Number");
  
    return;
  }
}// apiVersion
Napi::Value _VkApplicationInfo::GetapiVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.apiVersion);
}void _VkApplicationInfo::SetapiVersion(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.apiVersion = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkApplicationInfo.apiVersion", "Number");
  
    return;
  }
}
/** ## END VkApplicationInfo ## **/

/** ## BEGIN VkLayerProperties ## **/

Napi::FunctionReference _VkLayerProperties::constructor;

_VkLayerProperties::_VkLayerProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkLayerProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkLayerProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkLayerProperties::~_VkLayerProperties() {
  
  layerName.Reset();
  
  
  
  description.Reset();
  
}

Napi::Object _VkLayerProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkLayerProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkLayerProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkLayerProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "layerName",
    &_VkLayerProperties::GetlayerName,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "specVersion",
    &_VkLayerProperties::GetspecVersion,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "implementationVersion",
    &_VkLayerProperties::GetimplementationVersion,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "description",
    &_VkLayerProperties::Getdescription,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkLayerProperties", func);
  return exports;
}

Napi::Value _VkLayerProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkLayerProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkLayerProperties *)0)->layerName));
    uint32_t byteLength = sizeof(((VkLayerProperties *)0)->layerName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkLayerProperties *)0)->specVersion));
    uint32_t byteLength = sizeof(((VkLayerProperties *)0)->specVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkLayerProperties *)0)->implementationVersion));
    uint32_t byteLength = sizeof(((VkLayerProperties *)0)->implementationVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkLayerProperties *)0)->description));
    uint32_t byteLength = sizeof(((VkLayerProperties *)0)->description);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkLayerProperties::flush() {
  _VkLayerProperties *self = this;
  
  return true;
}

// layerName
Napi::Value _VkLayerProperties::GetlayerName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->layerName.IsEmpty()) return env.Null();
  return this->layerName.Value().ToString();
}// specVersion
Napi::Value _VkLayerProperties::GetspecVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.specVersion);
}// implementationVersion
Napi::Value _VkLayerProperties::GetimplementationVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.implementationVersion);
}// description
Napi::Value _VkLayerProperties::Getdescription(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->description.IsEmpty()) return env.Null();
  return this->description.Value().ToString();
}
/** ## END VkLayerProperties ## **/

/** ## BEGIN VkExtensionProperties ## **/

Napi::FunctionReference _VkExtensionProperties::constructor;

_VkExtensionProperties::_VkExtensionProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExtensionProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkExtensionProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkExtensionProperties::~_VkExtensionProperties() {
  
  extensionName.Reset();
  
  
}

Napi::Object _VkExtensionProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExtensionProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExtensionProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExtensionProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "extensionName",
    &_VkExtensionProperties::GetextensionName,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "specVersion",
    &_VkExtensionProperties::GetspecVersion,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExtensionProperties", func);
  return exports;
}

Napi::Value _VkExtensionProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExtensionProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtensionProperties *)0)->extensionName));
    uint32_t byteLength = sizeof(((VkExtensionProperties *)0)->extensionName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtensionProperties *)0)->specVersion));
    uint32_t byteLength = sizeof(((VkExtensionProperties *)0)->specVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExtensionProperties::flush() {
  _VkExtensionProperties *self = this;
  
  return true;
}

// extensionName
Napi::Value _VkExtensionProperties::GetextensionName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extensionName.IsEmpty()) return env.Null();
  return this->extensionName.Value().ToString();
}// specVersion
Napi::Value _VkExtensionProperties::GetspecVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.specVersion);
}
/** ## END VkExtensionProperties ## **/

/** ## BEGIN VkPhysicalDeviceProperties ## **/

Napi::FunctionReference _VkPhysicalDeviceProperties::constructor;

_VkPhysicalDeviceProperties::_VkPhysicalDeviceProperties(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkPhysicalDeviceProperties>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    vpipelineCacheUUID = new std::vector<uint8_t>;
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      
    } else {
      Napi::Error::New(env, "VkPhysicalDeviceProperties constructor cannot be invoked without 'new'");
    }
  }
}

_VkPhysicalDeviceProperties::~_VkPhysicalDeviceProperties() {
  
  
  
  
  
  
  deviceName.Reset();
  
  vpipelineCacheUUID->clear();
  delete vpipelineCacheUUID;
  
  pipelineCacheUUID.Reset();
  
  limits.Reset();
  
  sparseProperties.Reset();
  
}

Napi::Object _VkPhysicalDeviceProperties::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkPhysicalDeviceProperties", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkPhysicalDeviceProperties::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkPhysicalDeviceProperties::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "apiVersion",
    &_VkPhysicalDeviceProperties::GetapiVersion,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "driverVersion",
    &_VkPhysicalDeviceProperties::GetdriverVersion,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "vendorID",
    &_VkPhysicalDeviceProperties::GetvendorID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceID",
    &_VkPhysicalDeviceProperties::GetdeviceID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceType",
    &_VkPhysicalDeviceProperties::GetdeviceType,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "deviceName",
    &_VkPhysicalDeviceProperties::GetdeviceName,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "pipelineCacheUUID",
    &_VkPhysicalDeviceProperties::GetpipelineCacheUUID,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "limits",
    &_VkPhysicalDeviceProperties::Getlimits,
    nullptr,
    napi_enumerable
  ),
  InstanceAccessor(
    "sparseProperties",
    &_VkPhysicalDeviceProperties::GetsparseProperties,
    nullptr,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkPhysicalDeviceProperties", func);
  return exports;
}

Napi::Value _VkPhysicalDeviceProperties::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkPhysicalDeviceProperties::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->apiVersion));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->apiVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->driverVersion));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->driverVersion);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->vendorID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->vendorID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->deviceID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->deviceID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->deviceType));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->deviceType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->deviceName));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->deviceName);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->pipelineCacheUUID));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->pipelineCacheUUID);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->limits));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->limits);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkPhysicalDeviceProperties *)0)->sparseProperties));
    uint32_t byteLength = sizeof(((VkPhysicalDeviceProperties *)0)->sparseProperties);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkPhysicalDeviceProperties::flush() {
  _VkPhysicalDeviceProperties *self = this;
  if (!(self->pipelineCacheUUID.IsEmpty())) {
    Napi::Value value = self->pipelineCacheUUID.Value();
    
  }if (!(self->limits.IsEmpty())) {
    Napi::Value value = self->limits.Value();
    
  }if (!(self->sparseProperties.IsEmpty())) {
    Napi::Value value = self->sparseProperties.Value();
    
  }
  return true;
}

// apiVersion
Napi::Value _VkPhysicalDeviceProperties::GetapiVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.apiVersion);
}// driverVersion
Napi::Value _VkPhysicalDeviceProperties::GetdriverVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.driverVersion);
}// vendorID
Napi::Value _VkPhysicalDeviceProperties::GetvendorID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.vendorID);
}// deviceID
Napi::Value _VkPhysicalDeviceProperties::GetdeviceID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceID);
}// deviceType
Napi::Value _VkPhysicalDeviceProperties::GetdeviceType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.deviceType);
}// deviceName
Napi::Value _VkPhysicalDeviceProperties::GetdeviceName(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->deviceName.IsEmpty()) return env.Null();
  return this->deviceName.Value().ToString();
}// pipelineCacheUUID
Napi::Value _VkPhysicalDeviceProperties::GetpipelineCacheUUID(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pipelineCacheUUID.IsEmpty()) return env.Null();
  return this->pipelineCacheUUID.Value().As<Napi::Array>();
}// limits
Napi::Value _VkPhysicalDeviceProperties::Getlimits(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->limits.IsEmpty()) return env.Null();
  return this->limits.Value().As<Napi::Object>();
}// sparseProperties
Napi::Value _VkPhysicalDeviceProperties::GetsparseProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->sparseProperties.IsEmpty()) return env.Null();
  return this->sparseProperties.Value().As<Napi::Object>();
}
/** ## END VkPhysicalDeviceProperties ## **/

/** ## BEGIN VkComponentMapping ## **/

Napi::FunctionReference _VkComponentMapping::constructor;

_VkComponentMapping::_VkComponentMapping(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkComponentMapping>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "r");
      Napi::String sAccess1 = Napi::String::New(env, "g");
      Napi::String sAccess2 = Napi::String::New(env, "b");
      Napi::String sAccess3 = Napi::String::New(env, "a");
      if (obj.Has(sAccess0)) this->Setr(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setg(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setb(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Seta(info, obj.Get(sAccess3));
      
    } else {
      Napi::Error::New(env, "VkComponentMapping constructor cannot be invoked without 'new'");
    }
  }
}

_VkComponentMapping::~_VkComponentMapping() {
  
  
  
  
  
}

Napi::Object _VkComponentMapping::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkComponentMapping", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkComponentMapping::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkComponentMapping::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "r",
    &_VkComponentMapping::Getr,
    &_VkComponentMapping::Setr,
    napi_enumerable
  ),
  InstanceAccessor(
    "g",
    &_VkComponentMapping::Getg,
    &_VkComponentMapping::Setg,
    napi_enumerable
  ),
  InstanceAccessor(
    "b",
    &_VkComponentMapping::Getb,
    &_VkComponentMapping::Setb,
    napi_enumerable
  ),
  InstanceAccessor(
    "a",
    &_VkComponentMapping::Geta,
    &_VkComponentMapping::Seta,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkComponentMapping", func);
  return exports;
}

Napi::Value _VkComponentMapping::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkComponentMapping::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComponentMapping *)0)->r));
    uint32_t byteLength = sizeof(((VkComponentMapping *)0)->r);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComponentMapping *)0)->g));
    uint32_t byteLength = sizeof(((VkComponentMapping *)0)->g);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComponentMapping *)0)->b));
    uint32_t byteLength = sizeof(((VkComponentMapping *)0)->b);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkComponentMapping *)0)->a));
    uint32_t byteLength = sizeof(((VkComponentMapping *)0)->a);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkComponentMapping::flush() {
  _VkComponentMapping *self = this;
  
  return true;
}

// r
Napi::Value _VkComponentMapping::Getr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.r);
}void _VkComponentMapping::Setr(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.r = static_cast<VkComponentSwizzle>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkComponentMapping.r", "Number");
  
    return;
  }
}// g
Napi::Value _VkComponentMapping::Getg(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.g);
}void _VkComponentMapping::Setg(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.g = static_cast<VkComponentSwizzle>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkComponentMapping.g", "Number");
  
    return;
  }
}// b
Napi::Value _VkComponentMapping::Getb(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.b);
}void _VkComponentMapping::Setb(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.b = static_cast<VkComponentSwizzle>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkComponentMapping.b", "Number");
  
    return;
  }
}// a
Napi::Value _VkComponentMapping::Geta(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.a);
}void _VkComponentMapping::Seta(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.a = static_cast<VkComponentSwizzle>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkComponentMapping.a", "Number");
  
    return;
  }
}
/** ## END VkComponentMapping ## **/

/** ## BEGIN VkClearRect ## **/

Napi::FunctionReference _VkClearRect::constructor;

_VkClearRect::_VkClearRect(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkClearRect>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "rect");
      Napi::String sAccess1 = Napi::String::New(env, "baseArrayLayer");
      Napi::String sAccess2 = Napi::String::New(env, "layerCount");
      if (obj.Has(sAccess0)) this->Setrect(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetbaseArrayLayer(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->SetlayerCount(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkClearRect constructor cannot be invoked without 'new'");
    }
  }
}

_VkClearRect::~_VkClearRect() {
  
  rect.Reset();
  
  
  
}

Napi::Object _VkClearRect::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkClearRect", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkClearRect::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkClearRect::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "rect",
    &_VkClearRect::Getrect,
    &_VkClearRect::Setrect,
    napi_enumerable
  ),
  InstanceAccessor(
    "baseArrayLayer",
    &_VkClearRect::GetbaseArrayLayer,
    &_VkClearRect::SetbaseArrayLayer,
    napi_enumerable
  ),
  InstanceAccessor(
    "layerCount",
    &_VkClearRect::GetlayerCount,
    &_VkClearRect::SetlayerCount,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkClearRect", func);
  return exports;
}

Napi::Value _VkClearRect::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkClearRect::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearRect *)0)->rect));
    uint32_t byteLength = sizeof(((VkClearRect *)0)->rect);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearRect *)0)->baseArrayLayer));
    uint32_t byteLength = sizeof(((VkClearRect *)0)->baseArrayLayer);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkClearRect *)0)->layerCount));
    uint32_t byteLength = sizeof(((VkClearRect *)0)->layerCount);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkClearRect::flush() {
  _VkClearRect *self = this;
  if (!(self->rect.IsEmpty())) {
    Napi::Value value = self->rect.Value();
    
    _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.rect = result->instance;
  }
  return true;
}

// rect
Napi::Value _VkClearRect::Getrect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->rect.IsEmpty()) return env.Null();
  return this->rect.Value().As<Napi::Object>();
}void _VkClearRect::Setrect(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkRect2D::constructor.Value())) {
      
      this->rect.Reset(value.ToObject(), 1);
      _VkRect2D* inst = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      inst->flush();
      this->instance.rect = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkClearRect.rect", "[object VkRect2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->rect.Reset();
    memset(&this->instance.rect, 0, sizeof(VkRect2D));
  } else {
    
    NapiObjectTypeError(value, "VkClearRect.rect", "[object VkRect2D]");
  
    return;
  }
}// baseArrayLayer
Napi::Value _VkClearRect::GetbaseArrayLayer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.baseArrayLayer);
}void _VkClearRect::SetbaseArrayLayer(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.baseArrayLayer = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkClearRect.baseArrayLayer", "Number");
  
    return;
  }
}// layerCount
Napi::Value _VkClearRect::GetlayerCount(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.layerCount);
}void _VkClearRect::SetlayerCount(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.layerCount = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkClearRect.layerCount", "Number");
  
    return;
  }
}
/** ## END VkClearRect ## **/

/** ## BEGIN VkRect2D ## **/

Napi::FunctionReference _VkRect2D::constructor;

_VkRect2D::_VkRect2D(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkRect2D>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "offset");
      Napi::String sAccess1 = Napi::String::New(env, "extent");
      if (obj.Has(sAccess0)) this->Setoffset(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setextent(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkRect2D constructor cannot be invoked without 'new'");
    }
  }
}

_VkRect2D::~_VkRect2D() {
  
  offset.Reset();
  
  extent.Reset();
  
}

Napi::Object _VkRect2D::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkRect2D", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkRect2D::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkRect2D::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "offset",
    &_VkRect2D::Getoffset,
    &_VkRect2D::Setoffset,
    napi_enumerable
  ),
  InstanceAccessor(
    "extent",
    &_VkRect2D::Getextent,
    &_VkRect2D::Setextent,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkRect2D", func);
  return exports;
}

Napi::Value _VkRect2D::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkRect2D::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRect2D *)0)->offset));
    uint32_t byteLength = sizeof(((VkRect2D *)0)->offset);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkRect2D *)0)->extent));
    uint32_t byteLength = sizeof(((VkRect2D *)0)->extent);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkRect2D::flush() {
  _VkRect2D *self = this;
  if (!(self->offset.IsEmpty())) {
    Napi::Value value = self->offset.Value();
    
    _VkOffset2D* result = Napi::ObjectWrap<_VkOffset2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.offset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    Napi::Value value = self->extent.Value();
    
    _VkExtent2D* result = Napi::ObjectWrap<_VkExtent2D>::Unwrap(value.As<Napi::Object>());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

// offset
Napi::Value _VkRect2D::Getoffset(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->offset.IsEmpty()) return env.Null();
  return this->offset.Value().As<Napi::Object>();
}void _VkRect2D::Setoffset(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkOffset2D::constructor.Value())) {
      
      this->offset.Reset(value.ToObject(), 1);
      _VkOffset2D* inst = Napi::ObjectWrap<_VkOffset2D>::Unwrap(obj);
      inst->flush();
      this->instance.offset = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRect2D.offset", "[object VkOffset2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->offset.Reset();
    memset(&this->instance.offset, 0, sizeof(VkOffset2D));
  } else {
    
    NapiObjectTypeError(value, "VkRect2D.offset", "[object VkOffset2D]");
  
    return;
  }
}// extent
Napi::Value _VkRect2D::Getextent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->extent.IsEmpty()) return env.Null();
  return this->extent.Value().As<Napi::Object>();
}void _VkRect2D::Setextent(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkExtent2D::constructor.Value())) {
      
      this->extent.Reset(value.ToObject(), 1);
      _VkExtent2D* inst = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
      inst->flush();
      this->instance.extent = inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkRect2D.extent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->extent.Reset();
    memset(&this->instance.extent, 0, sizeof(VkExtent2D));
  } else {
    
    NapiObjectTypeError(value, "VkRect2D.extent", "[object VkExtent2D]");
  
    return;
  }
}
/** ## END VkRect2D ## **/

/** ## BEGIN VkViewport ## **/

Napi::FunctionReference _VkViewport::constructor;

_VkViewport::_VkViewport(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkViewport>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      Napi::String sAccess2 = Napi::String::New(env, "width");
      Napi::String sAccess3 = Napi::String::New(env, "height");
      Napi::String sAccess4 = Napi::String::New(env, "minDepth");
      Napi::String sAccess5 = Napi::String::New(env, "maxDepth");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setwidth(info, obj.Get(sAccess2));
      if (obj.Has(sAccess3)) this->Setheight(info, obj.Get(sAccess3));
      if (obj.Has(sAccess4)) this->SetminDepth(info, obj.Get(sAccess4));
      if (obj.Has(sAccess5)) this->SetmaxDepth(info, obj.Get(sAccess5));
      
    } else {
      Napi::Error::New(env, "VkViewport constructor cannot be invoked without 'new'");
    }
  }
}

_VkViewport::~_VkViewport() {
  
  
  
  
  
  
  
}

Napi::Object _VkViewport::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkViewport", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkViewport::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkViewport::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkViewport::Getx,
    &_VkViewport::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkViewport::Gety,
    &_VkViewport::Sety,
    napi_enumerable
  ),
  InstanceAccessor(
    "width",
    &_VkViewport::Getwidth,
    &_VkViewport::Setwidth,
    napi_enumerable
  ),
  InstanceAccessor(
    "height",
    &_VkViewport::Getheight,
    &_VkViewport::Setheight,
    napi_enumerable
  ),
  InstanceAccessor(
    "minDepth",
    &_VkViewport::GetminDepth,
    &_VkViewport::SetminDepth,
    napi_enumerable
  ),
  InstanceAccessor(
    "maxDepth",
    &_VkViewport::GetmaxDepth,
    &_VkViewport::SetmaxDepth,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkViewport", func);
  return exports;
}

Napi::Value _VkViewport::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkViewport::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewport *)0)->x));
    uint32_t byteLength = sizeof(((VkViewport *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewport *)0)->y));
    uint32_t byteLength = sizeof(((VkViewport *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewport *)0)->width));
    uint32_t byteLength = sizeof(((VkViewport *)0)->width);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewport *)0)->height));
    uint32_t byteLength = sizeof(((VkViewport *)0)->height);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewport *)0)->minDepth));
    uint32_t byteLength = sizeof(((VkViewport *)0)->minDepth);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkViewport *)0)->maxDepth));
    uint32_t byteLength = sizeof(((VkViewport *)0)->maxDepth);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkViewport::flush() {
  _VkViewport *self = this;
  
  return true;
}

// x
Napi::Value _VkViewport::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkViewport::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewport.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkViewport::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkViewport::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewport.y", "Number");
  
    return;
  }
}// width
Napi::Value _VkViewport::Getwidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.width);
}void _VkViewport::Setwidth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.width = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewport.width", "Number");
  
    return;
  }
}// height
Napi::Value _VkViewport::Getheight(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.height);
}void _VkViewport::Setheight(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.height = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewport.height", "Number");
  
    return;
  }
}// minDepth
Napi::Value _VkViewport::GetminDepth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.minDepth);
}void _VkViewport::SetminDepth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.minDepth = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewport.minDepth", "Number");
  
    return;
  }
}// maxDepth
Napi::Value _VkViewport::GetmaxDepth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.maxDepth);
}void _VkViewport::SetmaxDepth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.maxDepth = static_cast<float>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkViewport.maxDepth", "Number");
  
    return;
  }
}
/** ## END VkViewport ## **/

/** ## BEGIN VkExtent3D ## **/

Napi::FunctionReference _VkExtent3D::constructor;

_VkExtent3D::_VkExtent3D(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExtent3D>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "width");
      Napi::String sAccess1 = Napi::String::New(env, "height");
      Napi::String sAccess2 = Napi::String::New(env, "depth");
      if (obj.Has(sAccess0)) this->Setwidth(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setheight(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setdepth(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkExtent3D constructor cannot be invoked without 'new'");
    }
  }
}

_VkExtent3D::~_VkExtent3D() {
  
  
  
  
}

Napi::Object _VkExtent3D::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExtent3D", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExtent3D::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExtent3D::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "width",
    &_VkExtent3D::Getwidth,
    &_VkExtent3D::Setwidth,
    napi_enumerable
  ),
  InstanceAccessor(
    "height",
    &_VkExtent3D::Getheight,
    &_VkExtent3D::Setheight,
    napi_enumerable
  ),
  InstanceAccessor(
    "depth",
    &_VkExtent3D::Getdepth,
    &_VkExtent3D::Setdepth,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExtent3D", func);
  return exports;
}

Napi::Value _VkExtent3D::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExtent3D::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtent3D *)0)->width));
    uint32_t byteLength = sizeof(((VkExtent3D *)0)->width);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtent3D *)0)->height));
    uint32_t byteLength = sizeof(((VkExtent3D *)0)->height);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtent3D *)0)->depth));
    uint32_t byteLength = sizeof(((VkExtent3D *)0)->depth);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExtent3D::flush() {
  _VkExtent3D *self = this;
  
  return true;
}

// width
Napi::Value _VkExtent3D::Getwidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.width);
}void _VkExtent3D::Setwidth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.width = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkExtent3D.width", "Number");
  
    return;
  }
}// height
Napi::Value _VkExtent3D::Getheight(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.height);
}void _VkExtent3D::Setheight(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.height = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkExtent3D.height", "Number");
  
    return;
  }
}// depth
Napi::Value _VkExtent3D::Getdepth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.depth);
}void _VkExtent3D::Setdepth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.depth = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkExtent3D.depth", "Number");
  
    return;
  }
}
/** ## END VkExtent3D ## **/

/** ## BEGIN VkExtent2D ## **/

Napi::FunctionReference _VkExtent2D::constructor;

_VkExtent2D::_VkExtent2D(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkExtent2D>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "width");
      Napi::String sAccess1 = Napi::String::New(env, "height");
      if (obj.Has(sAccess0)) this->Setwidth(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Setheight(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkExtent2D constructor cannot be invoked without 'new'");
    }
  }
}

_VkExtent2D::~_VkExtent2D() {
  
  
  
}

Napi::Object _VkExtent2D::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkExtent2D", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkExtent2D::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkExtent2D::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "width",
    &_VkExtent2D::Getwidth,
    &_VkExtent2D::Setwidth,
    napi_enumerable
  ),
  InstanceAccessor(
    "height",
    &_VkExtent2D::Getheight,
    &_VkExtent2D::Setheight,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkExtent2D", func);
  return exports;
}

Napi::Value _VkExtent2D::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkExtent2D::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtent2D *)0)->width));
    uint32_t byteLength = sizeof(((VkExtent2D *)0)->width);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkExtent2D *)0)->height));
    uint32_t byteLength = sizeof(((VkExtent2D *)0)->height);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkExtent2D::flush() {
  _VkExtent2D *self = this;
  
  return true;
}

// width
Napi::Value _VkExtent2D::Getwidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.width);
}void _VkExtent2D::Setwidth(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.width = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkExtent2D.width", "Number");
  
    return;
  }
}// height
Napi::Value _VkExtent2D::Getheight(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.height);
}void _VkExtent2D::Setheight(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.height = static_cast<uint32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkExtent2D.height", "Number");
  
    return;
  }
}
/** ## END VkExtent2D ## **/

/** ## BEGIN VkOffset3D ## **/

Napi::FunctionReference _VkOffset3D::constructor;

_VkOffset3D::_VkOffset3D(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkOffset3D>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      Napi::String sAccess2 = Napi::String::New(env, "z");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      if (obj.Has(sAccess2)) this->Setz(info, obj.Get(sAccess2));
      
    } else {
      Napi::Error::New(env, "VkOffset3D constructor cannot be invoked without 'new'");
    }
  }
}

_VkOffset3D::~_VkOffset3D() {
  
  
  
  
}

Napi::Object _VkOffset3D::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkOffset3D", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkOffset3D::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkOffset3D::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkOffset3D::Getx,
    &_VkOffset3D::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkOffset3D::Gety,
    &_VkOffset3D::Sety,
    napi_enumerable
  ),
  InstanceAccessor(
    "z",
    &_VkOffset3D::Getz,
    &_VkOffset3D::Setz,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkOffset3D", func);
  return exports;
}

Napi::Value _VkOffset3D::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkOffset3D::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkOffset3D *)0)->x));
    uint32_t byteLength = sizeof(((VkOffset3D *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkOffset3D *)0)->y));
    uint32_t byteLength = sizeof(((VkOffset3D *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkOffset3D *)0)->z));
    uint32_t byteLength = sizeof(((VkOffset3D *)0)->z);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkOffset3D::flush() {
  _VkOffset3D *self = this;
  
  return true;
}

// x
Napi::Value _VkOffset3D::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkOffset3D::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkOffset3D.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkOffset3D::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkOffset3D::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkOffset3D.y", "Number");
  
    return;
  }
}// z
Napi::Value _VkOffset3D::Getz(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.z);
}void _VkOffset3D::Setz(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.z = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkOffset3D.z", "Number");
  
    return;
  }
}
/** ## END VkOffset3D ## **/

/** ## BEGIN VkOffset2D ## **/

Napi::FunctionReference _VkOffset2D::constructor;

_VkOffset2D::_VkOffset2D(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkOffset2D>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "x");
      Napi::String sAccess1 = Napi::String::New(env, "y");
      if (obj.Has(sAccess0)) this->Setx(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->Sety(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkOffset2D constructor cannot be invoked without 'new'");
    }
  }
}

_VkOffset2D::~_VkOffset2D() {
  
  
  
}

Napi::Object _VkOffset2D::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkOffset2D", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkOffset2D::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkOffset2D::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "x",
    &_VkOffset2D::Getx,
    &_VkOffset2D::Setx,
    napi_enumerable
  ),
  InstanceAccessor(
    "y",
    &_VkOffset2D::Gety,
    &_VkOffset2D::Sety,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkOffset2D", func);
  return exports;
}

Napi::Value _VkOffset2D::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkOffset2D::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkOffset2D *)0)->x));
    uint32_t byteLength = sizeof(((VkOffset2D *)0)->x);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkOffset2D *)0)->y));
    uint32_t byteLength = sizeof(((VkOffset2D *)0)->y);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkOffset2D::flush() {
  _VkOffset2D *self = this;
  
  return true;
}

// x
Napi::Value _VkOffset2D::Getx(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.x);
}void _VkOffset2D::Setx(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.x = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkOffset2D.x", "Number");
  
    return;
  }
}// y
Napi::Value _VkOffset2D::Gety(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.y);
}void _VkOffset2D::Sety(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.y = static_cast<int32_t>(value.As<Napi::Number>().Int64Value());
  } else {
    
    NapiObjectTypeError(value, "VkOffset2D.y", "Number");
  
    return;
  }
}
/** ## END VkOffset2D ## **/

/** ## BEGIN VkBaseInStructure ## **/

Napi::FunctionReference _VkBaseInStructure::constructor;

_VkBaseInStructure::_VkBaseInStructure(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBaseInStructure>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkBaseInStructure constructor cannot be invoked without 'new'");
    }
  }
}

_VkBaseInStructure::~_VkBaseInStructure() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkBaseInStructure::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBaseInStructure", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBaseInStructure::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBaseInStructure::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBaseInStructure::GetsType,
    &_VkBaseInStructure::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBaseInStructure::GetpNext,
    &_VkBaseInStructure::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBaseInStructure", func);
  return exports;
}

Napi::Value _VkBaseInStructure::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBaseInStructure::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBaseInStructure *)0)->sType));
    uint32_t byteLength = sizeof(((VkBaseInStructure *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBaseInStructure *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBaseInStructure *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBaseInStructure::flush() {
  _VkBaseInStructure *self = this;
  
  return true;
}

// sType
Napi::Value _VkBaseInStructure::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBaseInStructure::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBaseInStructure.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBaseInStructure::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBaseInStructure::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBaseInStructure::constructor.Value())) {
      
      this->pNext.Reset(value.ToObject(), 1);
      _VkBaseInStructure* inst = Napi::ObjectWrap<_VkBaseInStructure>::Unwrap(obj);
      inst->flush();
      this->instance.pNext = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBaseInStructure.pNext", "[object VkBaseInStructure]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBaseInStructure.pNext", "[object VkBaseInStructure]");
  
    return;
  }
}
/** ## END VkBaseInStructure ## **/

/** ## BEGIN VkBaseOutStructure ## **/

Napi::FunctionReference _VkBaseOutStructure::constructor;

_VkBaseOutStructure::_VkBaseOutStructure(const Napi::CallbackInfo& info) : Napi::ObjectWrap<_VkBaseOutStructure>(info) {
  Napi::Env env = info.Env();
  if (info.IsConstructCall()) {
    
    
    if (info[0].IsObject()) {
      Napi::Object obj = info[0].As<Napi::Object>();
      Napi::String sAccess0 = Napi::String::New(env, "sType");
      Napi::String sAccess1 = Napi::String::New(env, "pNext");
      if (obj.Has(sAccess0)) this->SetsType(info, obj.Get(sAccess0));
      if (obj.Has(sAccess1)) this->SetpNext(info, obj.Get(sAccess1));
      
    } else {
      Napi::Error::New(env, "VkBaseOutStructure constructor cannot be invoked without 'new'");
    }
  }
}

_VkBaseOutStructure::~_VkBaseOutStructure() {
  
  
  pNext.Reset();
  
}

Napi::Object _VkBaseOutStructure::Initialize(Napi::Env env, Napi::Object exports) {
  Napi::HandleScope scope(env);

  Napi::Function func = DefineClass(env, "VkBaseOutStructure", {
    InstanceAccessor(
      "memoryBuffer",
      &_VkBaseOutStructure::GetmemoryBuffer,
      nullptr,
      napi_enumerable
    ),
    StaticAccessor(
      "memoryLayout",
      &_VkBaseOutStructure::GetmemoryLayout,
      nullptr,
      napi_enumerable
    ),
    
  InstanceAccessor(
    "sType",
    &_VkBaseOutStructure::GetsType,
    &_VkBaseOutStructure::SetsType,
    napi_enumerable
  ),
  InstanceAccessor(
    "pNext",
    &_VkBaseOutStructure::GetpNext,
    &_VkBaseOutStructure::SetpNext,
    napi_enumerable
  ),
  });

  constructor = Napi::Persistent(func);

  constructor.SuppressDestruct();
  exports.Set("VkBaseOutStructure", func);
  return exports;
}

Napi::Value _VkBaseOutStructure::GetmemoryBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  void * addr = reinterpret_cast<void *>(&this->instance);
  uint32_t size = sizeof(this->instance);
  Napi::ArrayBuffer buffer = Napi::ArrayBuffer::New(
    env,
    addr,
    size
  );
  return buffer;
}

Napi::Value _VkBaseOutStructure::GetmemoryLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  Napi::Object out = Napi::Object::New(env);
  
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBaseOutStructure *)0)->sType));
    uint32_t byteLength = sizeof(((VkBaseOutStructure *)0)->sType);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  {
    Napi::Object obj = Napi::Object::New(env);
    uint32_t byteOffset = ((size_t)&(((VkBaseOutStructure *)0)->pNext));
    uint32_t byteLength = sizeof(((VkBaseOutStructure *)0)->pNext);
    obj.Set(Napi::String::New(env, "byteOffset"), Napi::Number::New(env, byteOffset));
    obj.Set(Napi::String::New(env, "byteLength"), Napi::Number::New(env, byteLength));
    out.Set(Napi::String::New(env, "sType"), obj);
  }
  return out;
}

bool _VkBaseOutStructure::flush() {
  _VkBaseOutStructure *self = this;
  
  return true;
}

// sType
Napi::Value _VkBaseOutStructure::GetsType(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  return Napi::Number::New(env, this->instance.sType);
}void _VkBaseOutStructure::SetsType(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  if (value.IsNumber()) {
    this->instance.sType = static_cast<VkStructureType>(value.As<Napi::Number>().Int32Value());
  } else {
    
    NapiObjectTypeError(value, "VkBaseOutStructure.sType", "Number");
  
    return;
  }
}// pNext
Napi::Value _VkBaseOutStructure::GetpNext(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (this->pNext.IsEmpty()) return env.Null();
  return this->pNext.Value().As<Napi::Object>();
}void _VkBaseOutStructure::SetpNext(const Napi::CallbackInfo& info, const Napi::Value& value) {
  Napi::Env env = info.Env();
  // js
  if (!value.IsNull()) {
    Napi::Object obj = value.As<Napi::Object>();
    if (obj.InstanceOf(_VkBaseOutStructure::constructor.Value())) {
      
      this->pNext.Reset(value.ToObject(), 1);
      _VkBaseOutStructure* inst = Napi::ObjectWrap<_VkBaseOutStructure>::Unwrap(obj);
      inst->flush();
      this->instance.pNext = &inst->instance;
    } else {
      
    NapiObjectTypeError(value, "VkBaseOutStructure.pNext", "[object VkBaseOutStructure]");
  
      return;
    }
  } else if (value.IsNull()) {
    this->pNext.Reset();
    this->instance.pNext = nullptr;
  } else {
    
    NapiObjectTypeError(value, "VkBaseOutStructure.pNext", "[object VkBaseOutStructure]");
  
    return;
  }
}
/** ## END VkBaseOutStructure ## **/

#endif