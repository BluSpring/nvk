/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.6.7
 */
"use strict";

const {platform} = process;
const nvk = require("./build/Release/addon-" + platform + ".node");

let ENABLE_SHARED_MEMORY_HINTS = !!process.env.npm_config_enable_shared_memory_hints;
if (!ENABLE_SHARED_MEMORY_HINTS) {
  process.argv.map(arg => {
    if (arg.match("enable-shared-memory-hints")) ENABLE_SHARED_MEMORY_HINTS = true;
  });
}

const getAddressFromArrayBuffer = nvk.getAddressFromArrayBuffer;
const getArrayBufferFromAddress = nvk.getArrayBufferFromAddress;

global.ArrayBuffer.prototype.getAddress = function() {
  return getAddressFromArrayBuffer(this);
};

global.ArrayBuffer.fromAddress = function(address, byteLength) {
  return getArrayBufferFromAddress(address, BigInt(byteLength));
};

const BI0 = BigInt(0);
const NULLT = String.fromCharCode(0x0);
const VK_ENUMERATIONS = nvk.$getVulkanEnumerations();

const textEncoder = new (typeof TextEncoder === "undefined" ? require("util").TextEncoder : TextEncoder);
const textDecoder = new (typeof TextDecoder === "undefined" ? require("util").TextDecoder : TextDecoder);

function decodeNullTerminatedUTF8String(view) {
  let terminator = view.indexOf(0x0);
  let subview = view.subarray(0, terminator > -1 ? terminator : view.length);
  return textDecoder.decode(subview);
};

function typeToString(value) {
  return ((value === void 0 || value === null) ? String(value) : value.constructor.name);
};

class NativeStringArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let stringBuffers = [];
    let addressView = new BigInt64Array(array.length);
    let addressBuffer = addressView.buffer;
    let addressBufferAddress = getAddressFromArrayBuffer(addressBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let strBuffer = textEncoder.encode(array[ii] + NULLT).buffer;
      addressView[ii] = getAddressFromArrayBuffer(strBuffer);
      stringBuffers.push(strBuffer);
    };
    this.address = addressBufferAddress;
    // keep references to prevent deallocation
    this.addressBuffer = addressBuffer;
    this.stringBuffers = stringBuffers;
  }
};

class NativeObjectArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let byteStride = array[0].memoryBuffer.byteLength;
    let objectBuffer = new ArrayBuffer(array.length * byteStride);
    let objectBufferView = new Uint8Array(objectBuffer);
    let objectBufferAddress = getAddressFromArrayBuffer(objectBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let byteOffset = ii * byteStride;
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      let dstView = objectBufferView.subarray(byteOffset, byteOffset + byteStride);
      dstView.set(srcView, 0x0);
    };
    this.address = objectBufferAddress;
    // keep reference to prevent deallocation
    this.objectBuffer = objectBuffer;
  }
};

class NativeObjectReferenceArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let addressView = new BigInt64Array(array.length);
    let addressBuffer = addressView.buffer;
    let addressBufferAddress = getAddressFromArrayBuffer(addressBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let object = array[ii];
      let objectAddress = object.address;
      addressView[ii] = objectAddress;
    };
    this.address = addressBufferAddress;
    // keep reference to prevent deallocation
    this.addressBuffer = addressBuffer;
  }
};

const STRUCT_RESET_CACHE = {
  "0x10": new Uint8Array(0x10),
  "0x8": new Uint8Array(0x8),
  "0xC": new Uint8Array(0xC),
  "0x18": new Uint8Array(0x18),
  "0x338": new Uint8Array(0x338),
  "0x104": new Uint8Array(0x104),
  "0x208": new Uint8Array(0x208),
  "0x30": new Uint8Array(0x30),
  "0x28": new Uint8Array(0x28),
  "0x48": new Uint8Array(0x48),
  "0x40": new Uint8Array(0x40),
  "0x20": new Uint8Array(0x20),
  "0x14": new Uint8Array(0x14),
  "0x38": new Uint8Array(0x38),
  "0x58": new Uint8Array(0x58),
  "0x50": new Uint8Array(0x50),
  "0x60": new Uint8Array(0x60),
  "0x44": new Uint8Array(0x44),
  "0x1C": new Uint8Array(0x1C),
  "0x68": new Uint8Array(0x68),
  "0x90": new Uint8Array(0x90),
  "0x24": new Uint8Array(0x24),
  "0xDC": new Uint8Array(0xDC),
  "0x1F8": new Uint8Array(0x1F8),
  "0x34": new Uint8Array(0x34),
  "0xF0": new Uint8Array(0xF0),
  "0x348": new Uint8Array(0x348),
  "0x218": new Uint8Array(0x218),
  "0x4": new Uint8Array(0x4),
  "0x120": new Uint8Array(0x120),
  "0x98": new Uint8Array(0x98),
  "0x70": new Uint8Array(0x70),
  "0x88": new Uint8Array(0x88),
  "0xA8": new Uint8Array(0xA8),
  "0x110": new Uint8Array(0x110),
};

function $VAL_R_API_Extensions(value) {
  switch (value) {
    case 0x1: case 0x0: case 0x2: case 0x3: case 0xB: case 0x5: case 0x4: case 0x9: case 0x6: case 0x15: case 0x19: case 0x46: 
      return true;
  };
  return false;
};

function $VAL_R_API_Constants(value) {
  switch (value) {
    case -0x1: case 0x0: case 0x3E8: case 0x8: case 0x100: case 0x20: case 0x10: case -0x2: case -0x3: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageLayout(value) {
  switch (value) {
    case 0x2: case 0x3B9C9309: case 0x3B9C9308: case 0x3: case 0x4: case 0x3B9E1D90: case 0x1: case 0x8: case 0x3B9ACDEA: case 0x5: case 0x3B9D4AA3: case 0x3B9C7B98: case 0x7: case 0x6: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkAttachmentLoadOp(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkAttachmentStoreOp(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageType(value) {
  switch (value) {
    case 0x0: case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageTiling(value) {
  switch (value) {
    case 0x3B9D3330: case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageViewType(value) {
  switch (value) {
    case 0x0: case 0x4: case 0x1: case 0x5: case 0x2: case 0x3: case 0x6: 
      return true;
  };
  return false;
};

function $VAL_R_VkCommandBufferLevel(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkComponentSwizzle(value) {
  switch (value) {
    case 0x6: case 0x5: case 0x4: case 0x0: case 0x2: case 0x3: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkDescriptorType(value) {
  switch (value) {
    case 0x3B9D4E88: case 0x1: case 0x3B9CE510: case 0xA: case 0x2: case 0x0: case 0x7: case 0x9: case 0x3: case 0x5: case 0x6: case 0x8: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueryType(value) {
  switch (value) {
    case 0x3B9D4E88: case 0x0: case 0x3B9DFE50: case 0x1: case 0x3B9B27C4: case 0x3B9B23E0: case 0x2: case 0x3B9B3764: 
      return true;
  };
  return false;
};

function $VAL_R_VkBorderColor(value) {
  switch (value) {
    case 0x2: case 0x4: case 0x0: case 0x3: case 0x5: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPipelineBindPoint(value) {
  switch (value) {
    case 0x1: case 0x0: case 0x3B9D4E88: 
      return true;
  };
  return false;
};

function $VAL_R_VkPipelineCacheHeaderVersion(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPrimitiveTopology(value) {
  switch (value) {
    case 0x1: case 0x6: case 0x2: case 0x7: case 0xA: case 0x0: case 0x5: case 0x3: case 0x8: case 0x4: case 0x9: 
      return true;
  };
  return false;
};

function $VAL_R_VkSharingMode(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkIndexType(value) {
  switch (value) {
    case 0x3B9D4E88: case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkFilter(value) {
  switch (value) {
    case 0x3B9B0498: case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkSamplerMipmapMode(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkSamplerAddressMode(value) {
  switch (value) {
    case 0x3: case 0x2: case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkCompareOp(value) {
  switch (value) {
    case 0x7: case 0x2: case 0x4: case 0x6: case 0x1: case 0x3: case 0x0: case 0x5: 
      return true;
  };
  return false;
};

function $VAL_R_VkPolygonMode(value) {
  switch (value) {
    case 0x0: case 0x3B9D1FA8: case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkFrontFace(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkBlendFactor(value) {
  switch (value) {
    case 0xC: case 0xA: case 0x8: case 0x4: case 0x1: case 0xD: case 0xB: case 0x9: case 0x5: case 0x12: case 0x10: case 0x7: case 0x3: case 0x11: case 0xF: case 0x6: case 0xE: case 0x2: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkBlendOp(value) {
  switch (value) {
    case 0x0: case 0x3B9D0C4D: case 0x3B9D0C32: case 0x3B9D0C31: case 0x3B9D0C49: case 0x3B9D0C2F: case 0x3B9D0C35: case 0x3B9D0C2A: case 0x3B9D0C22: case 0x3B9D0C26: case 0x3B9D0C28: case 0x3B9D0C24: case 0x3B9D0C36: case 0x3B9D0C4C: case 0x3B9D0C33: case 0x3B9D0C3E: case 0x3B9D0C41: case 0x3B9D0C3F: case 0x3B9D0C42: case 0x3B9D0C40: case 0x3B9D0C37: case 0x3B9D0C4A: case 0x3B9D0C38: case 0x3B9D0C30: case 0x3B9D0C3A: case 0x3B9D0C39: case 0x3B9D0C3C: case 0x4: case 0x3: case 0x3B9D0C48: case 0x3B9D0C47: case 0x3B9D0C2C: case 0x3B9D0C2E: case 0x3B9D0C3D: case 0x3B9D0C45: case 0x3B9D0C44: case 0x3B9D0C46: case 0x3B9D0C43: case 0x3B9D0C4B: case 0x2: case 0x3B9D0C2D: case 0x3B9D0C34: case 0x3B9D0C29: case 0x3B9D0C21: case 0x3B9D0C25: case 0x3B9D0C27: case 0x3B9D0C23: case 0x1: case 0x3B9D0C3B: case 0x3B9D0C2B: case 0x3B9D0C20: 
      return true;
  };
  return false;
};

function $VAL_R_VkStencilOp(value) {
  switch (value) {
    case 0x4: case 0x7: case 0x3: case 0x6: case 0x5: case 0x0: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkLogicOp(value) {
  switch (value) {
    case 0x1: case 0x4: case 0x2: case 0x0: case 0x3: case 0xC: case 0x9: case 0xA: case 0xE: case 0x8: case 0x5: case 0x7: case 0xD: case 0xB: case 0xF: case 0x6: 
      return true;
  };
  return false;
};

function $VAL_R_VkInternalAllocationType(value) {
  switch (value) {
    case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkSystemAllocationScope(value) {
  switch (value) {
    case 0x2: case 0x0: case 0x3: case 0x4: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPhysicalDeviceType(value) {
  switch (value) {
    case 0x4: case 0x2: case 0x1: case 0x0: case 0x3: 
      return true;
  };
  return false;
};

function $VAL_R_VkVertexInputRate(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkFormat(value) {
  switch (value) {
    case 0x8: case 0x45: case 0x41: case 0x43: case 0x44: case 0x40: case 0x42: case 0x3F: case 0x3B: case 0x3D: case 0x3E: case 0x3A: case 0x3C: case 0x38: case 0x34: case 0x39: case 0x36: case 0x37: case 0x33: case 0x35: case 0xB4: case 0xB3: case 0xAE: case 0xAD: case 0xB0: case 0xAF: case 0xB2: case 0xB1: case 0xB6: case 0xB5: case 0xB8: case 0xB7: case 0x9E: case 0x9D: case 0xA0: case 0x9F: case 0xA2: case 0xA1: case 0xA4: case 0xA3: case 0xA6: case 0xA5: case 0xA8: case 0xA7: case 0xAA: case 0xA9: case 0xAC: case 0xAB: case 0x7A: case 0x3B9D2B6B: case 0x3B9D2B75: case 0x3B9D2B7C: case 0x3: case 0x7: case 0x5: case 0x31: case 0x2D: case 0x32: case 0x2F: case 0x30: case 0x2C: case 0x2E: case 0x3B9D2B61: case 0x23: case 0x1F: case 0x24: case 0x21: case 0x22: case 0x1E: case 0x20: case 0x86: case 0x85: case 0x84: case 0x83: case 0x88: case 0x87: case 0x8A: case 0x89: case 0x8C: case 0x8B: case 0x8E: case 0x8D: case 0x90: case 0x8F: case 0x92: case 0x91: case 0x7C: case 0x80: case 0x81: case 0x7E: case 0x82: case 0x7B: case 0x9C: case 0x9B: case 0x9A: case 0x99: case 0x96: case 0x95: case 0x98: case 0x97: case 0x94: case 0x93: case 0x3B9D2B6A: case 0x3B9D2B6D: case 0x3B9D2B6F: case 0x3B9D2B6C: case 0x3B9D2B6E: case 0x3B9D2B70: case 0x3B9D2B74: case 0x3B9D2B77: case 0x3B9D2B79: case 0x3B9D2B76: case 0x3B9D2B78: case 0x3B9D2B7A: case 0x3B9D2B7B: case 0x3B9D2B7E: case 0x3B9D2B80: case 0x3B9D2B7D: case 0x3B9D2B7F: case 0x3B9D2B81: case 0x3B9D2B60: case 0x3B9D2B63: case 0x3B9D2B65: case 0x3B9D2B62: case 0x3B9D2B64: case 0x3B9D2B66: case 0x3B9B9CF4: case 0x3B9B9CF0: case 0x3B9B9CF5: case 0x3B9B9CF1: case 0x3B9B9CF6: case 0x3B9B9CF2: case 0x3B9B9CF7: case 0x3B9B9CF3: case 0x3B9D2B69: case 0x3B9D2B68: case 0x3B9D2B67: case 0x3B9D2B73: case 0x3B9D2B72: case 0x3B9D2B71: case 0x61: case 0x60: case 0x5C: case 0x5E: case 0x5F: case 0x5B: case 0x5D: case 0x5A: case 0x59: case 0x55: case 0x57: case 0x58: case 0x54: case 0x56: case 0x53: case 0x52: case 0x4E: case 0x50: case 0x51: case 0x4D: case 0x4F: case 0x4C: case 0x4B: case 0x47: case 0x49: case 0x4A: case 0x46: case 0x48: case 0x6D: case 0x6C: case 0x6B: case 0x6A: case 0x69: case 0x68: case 0x67: case 0x66: case 0x65: case 0x64: case 0x63: case 0x62: case 0x2: case 0x1: case 0x6: case 0x4: case 0x79: case 0x78: case 0x77: case 0x76: case 0x75: case 0x74: case 0x73: case 0x72: case 0x71: case 0x70: case 0x6F: case 0x6E: case 0x2A: case 0x26: case 0x2B: case 0x28: case 0x29: case 0x25: case 0x27: case 0x1C: case 0x18: case 0x1D: case 0x1A: case 0x1B: case 0x17: case 0x19: case 0x15: case 0x11: case 0x16: case 0x13: case 0x14: case 0x10: case 0x12: case 0xE: case 0xA: case 0xF: case 0xC: case 0xD: case 0x9: case 0xB: case 0x7F: case 0x0: case 0x7D: 
      return true;
  };
  return false;
};

function $VAL_R_VkStructureType(value) {
  switch (value) {
    case 0x3B9D4E89: case 0x3B9D4E94: case 0x3B9D4E90: case 0x3B9BB46A: case 0x3B9CC1EA: case 0x3B9CC1E9: case 0x3B9CC1E8: case 0x3B9AE940: case 0x0: case 0x3B9C73C8: case 0x3B9C73C9: case 0x3B9D4E8E: case 0x3B9BB46D: case 0x3B9D2F48: case 0x3B9BB46E: case 0x3B9D2F49: case 0x3B9BB469: case 0x3B9D2B62: case 0x7: case 0xC: case 0x3B9E8322: case 0x3B9E8321: case 0x2C: case 0x3B9D0450: case 0xD: case 0x3B9D98C0: case 0x3B9DEEB0: case 0x3B9C19F2: case 0x3B9C19F3: case 0x28: case 0x2A: case 0x3B9C0668: case 0x29: case 0x27: case 0x1D: case 0x3B9C066A: case 0x3B9E96A9: case 0x24: case 0x3B9BFAB2: case 0x3B9B1FF2: case 0x3B9B1FF0: case 0x3B9B1FF1: case 0x3B9AF4F8: case 0x3B9CBE02: case 0x3B9CBE03: case 0x3B9CBE04: case 0x3B9CBE00: case 0x3B9CBE01: case 0x3B9B2F91: case 0x3B9B2F90: case 0x3B9B2F92: case 0x21: case 0x3B9CE513: case 0x22: case 0x3B9D3EE8: case 0x20: case 0x3B9D5A41: case 0x3B9D3EEB: case 0x3B9D3EEC: case 0x3B9C1608: case 0x3: case 0x3B9C2D79: case 0x3B9C19F5: case 0x3B9C19F4: case 0x3B9BB466: case 0x3B9BB464: case 0x3B9BDB71: case 0x3B9BB467: case 0x3B9BB46B: case 0x3B9BB463: case 0x3B9BB465: case 0x3B9BB46C: case 0x3B9DAC48: case 0x2: case 0x3B9D71B0: case 0x3B9D006B: case 0x3B9C2D7A: case 0x3B9AD1D0: case 0x3B9CA2AA: case 0x3B9E0A08: case 0x3B9CA2AC: case 0x3B9CA2AB: case 0x3B9CA2A9: case 0x3B9C2D78: case 0x3B9AD5B8: case 0x3B9CA2A8: case 0x3B9AD1D1: case 0x3B9D3331: case 0x3B9D3330: case 0xA: case 0x3B9C8368: case 0x3B9C8751: case 0x3B9BE342: case 0x3B9BA4C1: case 0x3B9BE729: case 0x3B9BA8A9: case 0x3B9BF6C8: case 0x3B9BFAB1: case 0x3B9BDF5B: case 0x3B9C7F81: case 0x3B9CC1ED: case 0x3B9BDF59: case 0x3B9BE340: case 0x3B9BE341: case 0x3B9BA4C0: case 0x3B9BF2E1: case 0x8: case 0x3B9C8B39: case 0x3B9C8752: case 0x3B9D6211: case 0x3B9BB07A: case 0x3B9C6FE1: case 0x3B9C6FE2: case 0x25: case 0x3B9E9A92: case 0x3B9D4E8D: case 0x3B9D4E8B: case 0x3B9D4E8C: case 0x1C: case 0x3B9C6428: case 0x3B9EB200: case 0x3B9E0DF0: case 0xE: case 0x3B9D3334: case 0x3B9D3333: case 0x3B9D3335: case 0x3B9D0838: case 0x3B9BB07B: case 0x2D: case 0x3B9D0451: case 0x3B9D2B63: case 0x3B9D0452: case 0x3B9E8AF0: case 0x3B9BB468: case 0x3B9BCFB8: case 0xF: case 0x3B9B3F30: case 0x3B9C930A: case 0x3B9CC1EB: case 0x3B9C8B38: case 0x3B9C8750: case 0x3B9BEB10: case 0x3B9D8150: case 0x3B9BE728: case 0x3B9BA8A8: case 0x3B9BFE98: case 0x3B9BFAB0: case 0x3B9C19F1: case 0x3B9DFE51: case 0x1: case 0x3B9CA690: case 0x30: case 0x2F: case 0x3B9CAA78: case 0x6: case 0x3B9BB460: case 0x5: case 0x2E: case 0x3B9CBA19: case 0x3B9CBA18: case 0x3B9BEB11: case 0x3B9CC1EC: case 0x3B9BEB12: case 0x3B9BE72B: case 0x3B9D8151: case 0x3B9E6BB1: case 0x3B9D0453: case 0x3B9BE72A: case 0x3B9E19A8: case 0x3B9CF89C: case 0x3B9AF110: case 0x3B9C19F0: case 0x3B9DFE55: case 0x3B9DFE52: case 0x3B9DFE54: case 0x3B9DFE53: case 0x3B9C0E38: case 0x3B9D7D68: case 0x3B9BCFB9: case 0x3B9D0C20: case 0x3B9D0C21: case 0x3B9E8320: case 0x3B9DDB28: case 0x3B9C0669: case 0x3B9C5488: case 0x3B9E96A8: case 0x3B9E96AA: case 0x3B9B8D50: case 0x3B9E9A90: case 0x3B9E7380: case 0x3B9C5870: case 0x3B9DD358: case 0x3B9D3EE9: case 0x3B9D3EEA: case 0x3B9C4CB8: case 0x3B9DC7A0: case 0x3B9DEACA: case 0x3B9BDF5A: case 0x3B9C7F80: case 0x3B9BDF58: case 0x3B9D8152: case 0x3B9BF2E0: case 0x3B9BB078: case 0x3B9C0A50: case 0x3B9DCB88: case 0x3B9E1D90: case 0x3B9E1D91: case 0x3B9DE2F8: case 0x3B9E9E78: case 0x3B9BDB70: case 0x3B9EC588: case 0x3B9BDF5C: case 0x3B9C6FE0: case 0x3B9D3332: case 0x3B9BB07C: case 0x3B9D6210: case 0x3B9CE510: case 0x3B9CE511: case 0x3B9D5A40: case 0x3B9E67C8: case 0x3B9E6BB0: case 0x3B9BB07E: case 0x3B9DDF10: case 0x3B9DDF11: case 0x3B9B9909: case 0x3B9C44E8: case 0x3B9B990A: case 0x3B9E0620: case 0x3B9C9308: case 0x3B9BB079: case 0x3B9D0069: case 0x3B9D006A: case 0x3B9C0280: case 0x3B9D4E91: case 0x3B9D5270: case 0x3B9CC5D0: case 0x3B9D2B64: case 0x3B9CF89B: case 0x3B9E2948: case 0x3B9D8920: case 0x3B9D9CA8: case 0x3B9F0020: case 0x3B9BC018: case 0x3B9DE6E0: case 0x3B9DFA68: case 0x3B9D2390: case 0x3B9D2391: case 0x3B9D4AA1: case 0x3B9D4AA2: case 0x3B9BB080: case 0x3B9C3930: case 0x3B9C9AD8: case 0x3B9F13A8: case 0x3B9F13A9: case 0x3B9B3760: case 0x3B9B3761: case 0x3B9EA648: case 0x3B9C9EC0: case 0x3B9DB032: case 0x3B9DB030: case 0x3B9E0238: case 0x3B9EA260: case 0x11: case 0x3B9D0C22: case 0x1A: case 0x3B9D1BC0: case 0x3B9E9A91: case 0x3B9D1008: case 0x3B9DB800: case 0x19: case 0x3B9C4CB9: case 0x1B: case 0x14: case 0x1E: case 0x18: case 0x3B9C5489: case 0x3B9C5871: case 0x17: case 0x3B9B1050: case 0x3B9B3762: case 0x3B9D5271: case 0x3B9CF89A: case 0x12: case 0x3B9C930B: case 0x15: case 0x3B9DB031: case 0x13: case 0x3B9D4AA5: case 0x3B9DEAC8: case 0x3B9D4AA0: case 0x16: case 0x3B9C48D0: case 0x3B9C1DD8: case 0x3B9DB418: case 0x3B9ACDE9: case 0x3B9C1220: case 0x3B9C3160: case 0x3B9D0068: case 0xB: case 0x3B9DFE50: case 0x3B9DEEB1: case 0x3B9BB07D: case 0x3B9D4E88: case 0x3B9D4E93: case 0x3B9C6FE3: case 0x2B: case 0x26: case 0x3B9C73CC: case 0x3B9E1D92: case 0x3B9C9309: case 0x3B9B9908: case 0x3B9CF899: case 0x1F: case 0x3B9CC5D1: case 0x3B9D2B60: case 0x3B9D2B65: case 0x3B9D2B61: case 0x3B9CF898: case 0x9: case 0x3B9BFE99: case 0x3B9BFAB3: case 0x10: case 0x3B9D3B01: case 0x3B9C7B98: case 0x3B9BB07F: case 0x3B9D0454: case 0x3B9B8968: case 0x4: case 0x3B9C73CD: case 0x3B9C73CB: case 0x3B9C73CA: case 0x3B9DD359: case 0x3B9C73CE: case 0x3B9C2990: case 0x3B9C9AD9: case 0x3B9EAE1A: case 0x3B9C9ADA: case 0x3B9EAE18: case 0x3B9EAE19: case 0x3B9E6F98: case 0x3B9C2D7B: case 0x3B9ACDE8: case 0x3B9E0A09: case 0x3B9B6A28: case 0x3B9D3B00: case 0x3B9E8ED8: case 0x3B9BB848: case 0x3B9BBC30: case 0x3B9AE170: case 0x3B9BEEF8: case 0x3B9BAC90: case 0x3B9AED28: case 0x23: case 0x3B9D4E8F: case 0x3B9CE512: case 0x3B9ADD88: case 0x3B9AD9A0: 
      return true;
  };
  return false;
};

function $VAL_R_VkSubpassContents(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkResult(value) {
  switch (value) {
    case -0x4: case -0x7: case -0x8: case -0xB: case -0x3B9D3EE8: case -0xC: case -0x3B9EAE18: case -0x3B9AD5B9: case -0x9: case -0x3: case -0x3B9E8320: case -0x3B9D3330: case -0x3B9BE343: case -0x3B9AF8E0: case -0x6: case -0x5: case -0x3B9ACA01: case -0x3B9D71B1: case -0x3B9ACDEC: case -0x2: case -0x1: case -0x3B9BD788: case -0x3B9ACA00: case -0xA: case -0x3B9AF4F9: case 0x4: case 0x3: case 0x5: case 0x1: case 0x3B9ACDEB: case 0x0: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkDynamicState(value) {
  switch (value) {
    case 0x4: case 0x3: case 0x5: case 0x3B9C4CB8: case 0x3B9DEAC9: case 0x2: case 0x3B9CF898: case 0x1: case 0x6: case 0x8: case 0x7: case 0x0: case 0x3B9D4AA6: case 0x3B9D4AA4: case 0x3B9C1DD8: 
      return true;
  };
  return false;
};

function $VAL_R_VkDescriptorUpdateTemplateType(value) {
  switch (value) {
    case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkObjectType(value) {
  switch (value) {
    case 0x3B9D4E88: case 0x9: case 0xD: case 0x6: case 0x19: case 0x3B9AF4F8: case 0x3B9CBE00: case 0x16: case 0x17: case 0x14: case 0x3B9C1608: case 0x3: case 0x8: case 0x3B9AD1D0: case 0x3B9AD1D1: case 0xB: case 0x7: case 0x18: case 0xA: case 0xE: case 0x3B9C19F1: case 0x1: case 0x3B9C19F0: case 0x3B9DFE50: case 0x2: case 0x13: case 0x10: case 0x11: case 0xC: case 0x4: case 0x12: case 0x15: case 0x3B9D2B60: case 0x5: case 0xF: case 0x3B9ACA00: case 0x3B9ACDE8: case 0x0: case 0x3B9D3B00: 
      return true;
  };
  return false;
};

function $VAL_R_VkPresentModeKHR(value) {
  switch (value) {
    case 0x2: case 0x3: case 0x0: case 0x1: case 0x3B9C7B99: case 0x3B9C7B98: 
      return true;
  };
  return false;
};

function $VAL_R_VkColorSpaceKHR(value) {
  switch (value) {
    case 0x0: case 0x3B9C604B: case 0x3B9C604C: case 0x3B9C6047: case 0x3B9C6045: case 0x3B9C6046: case 0x3B9C6043: case 0x3B9C6044: case 0x3B9E0A08: case 0x3B9C6041: case 0x3B9C6049: case 0x3B9C6042: case 0x3B9C604E: case 0x3B9C604A: case 0x3B9C6048: case 0x3B9C604D: 
      return true;
  };
  return false;
};

function $VAL_R_VkTimeDomainEXT(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x0: case 0x3: 
      return true;
  };
  return false;
};

function $VAL_R_VkDebugReportObjectTypeEXT(value) {
  switch (value) {
    case 0x3B9D4E88: case 0x9: case 0xD: case 0x6: case 0x19: case 0x1C: case 0x16: case 0x17: case 0x14: case 0x3B9C1608: case 0x3: case 0x8: case 0x1D: case 0x1E: case 0xB: case 0x7: case 0x18: case 0xA: case 0xE: case 0x20: case 0x1: case 0x1F: case 0x2: case 0x10: case 0x13: case 0x11: case 0xC: case 0x4: case 0x12: case 0x15: case 0x3B9D2B60: case 0x5: case 0xF: case 0x1A: case 0x1B: case 0x0: case 0x21: 
      return true;
  };
  return false;
};

function $VAL_R_VkRasterizationOrderAMD(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkValidationCheckEXT(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkValidationFeatureEnableEXT(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkValidationFeatureDisableEXT(value) {
  switch (value) {
    case 0x0: case 0x3: case 0x5: case 0x4: case 0x1: case 0x2: case 0x6: 
      return true;
  };
  return false;
};

function $VAL_R_VkIndirectCommandsTokenTypeNVX(value) {
  switch (value) {
    case 0x1: case 0x7: case 0x5: case 0x6: case 0x2: case 0x0: case 0x4: case 0x3: 
      return true;
  };
  return false;
};

function $VAL_R_VkObjectEntryTypeNVX(value) {
  switch (value) {
    case 0x0: case 0x2: case 0x1: case 0x4: case 0x3: 
      return true;
  };
  return false;
};

function $VAL_R_VkDisplayPowerStateEXT(value) {
  switch (value) {
    case 0x0: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkDeviceEventTypeEXT(value) {
  switch (value) {
    case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkDisplayEventTypeEXT(value) {
  switch (value) {
    case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkViewportCoordinateSwizzleNV(value) {
  switch (value) {
    case 0x7: case 0x1: case 0x3: case 0x5: case 0x6: case 0x0: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkDiscardRectangleModeEXT(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkPointClippingBehavior(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSamplerReductionModeEXT(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkTessellationDomainOrigin(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkSamplerYcbcrModelConversion(value) {
  switch (value) {
    case 0x0: case 0x4: case 0x3: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSamplerYcbcrRange(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkChromaLocation(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkBlendOverlapEXT(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkCoverageModulationModeNV(value) {
  switch (value) {
    case 0x2: case 0x0: case 0x3: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkCoverageReductionModeNV(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkValidationCacheHeaderVersionEXT(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkShaderInfoTypeAMD(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueueGlobalPriorityEXT(value) {
  switch (value) {
    case 0x200: case 0x80: case 0x100: case 0x400: 
      return true;
  };
  return false;
};

function $VAL_R_VkConservativeRasterizationModeEXT(value) {
  switch (value) {
    case 0x0: case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkVendorId(value) {
  switch (value) {
    case 0x10003: case 0x10001: case 0x10002: 
      return true;
  };
  return false;
};

function $VAL_R_VkDriverIdKHR(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x9: case 0xC: case 0xB: case 0xA: case 0x7: case 0x6: case 0x5: case 0x3: case 0x4: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkShadingRatePaletteEntryNV(value) {
  switch (value) {
    case 0x1: case 0x7: case 0x6: case 0x8: case 0xA: case 0x9: case 0xB: case 0x5: case 0x4: case 0x3: case 0x2: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkCoarseSampleOrderTypeNV(value) {
  switch (value) {
    case 0x1: case 0x0: case 0x2: case 0x3: 
      return true;
  };
  return false;
};

function $VAL_R_VkCopyAccelerationStructureModeNV(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkAccelerationStructureTypeNV(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkGeometryTypeNV(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkAccelerationStructureMemoryRequirementsTypeNV(value) {
  switch (value) {
    case 0x1: case 0x0: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkRayTracingShaderGroupTypeNV(value) {
  switch (value) {
    case 0x0: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkMemoryOverallocationBehaviorAMD(value) {
  switch (value) {
    case 0x1: case 0x0: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkScopeNV(value) {
  switch (value) {
    case 0x1: case 0x5: case 0x3: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkComponentTypeNV(value) {
  switch (value) {
    case 0x0: case 0x1: case 0x2: case 0x4: case 0x5: case 0x6: case 0x3: case 0x8: case 0x9: case 0xA: case 0x7: 
      return true;
  };
  return false;
};

function $VAL_R_VkFullScreenExclusiveEXT(value) {
  switch (value) {
    case 0x1: case 0x3: case 0x0: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkPerformanceConfigurationTypeINTEL(value) {
  switch (value) {
    case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueryPoolSamplingModeINTEL(value) {
  switch (value) {
    case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkPerformanceOverrideTypeINTEL(value) {
  switch (value) {
    case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkPerformanceParameterTypeINTEL(value) {
  switch (value) {
    case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPerformanceValueTypeINTEL(value) {
  switch (value) {
    case 0x3: case 0x2: case 0x4: case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkCullModeFlagBits(value) {
  switch (value) {
    case 0x2: case 0x3: case 0x1: case 0x0: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueueFlagBits(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x10: case 0x20: case 0x40: case 0x8: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkRenderPassCreateFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkDeviceQueueCreateFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkMemoryPropertyFlagBits(value) {
  switch (value) {
    case 0x1: case 0x8: case 0x4: case 0x2: case 0x10: case 0x20: 
      return true;
  };
  return false;
};

function $VAL_R_VkMemoryHeapFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkAccessFlagBits(value) {
  switch (value) {
    case 0x200000: case 0x400000: case 0x80: case 0x80000: case 0x100: case 0x20000: case 0x40000: case 0x100000: case 0x200: case 0x400: case 0x1000000: case 0x2000: case 0x4000: case 0x2: case 0x1: case 0x10: case 0x8000: case 0x10000: case 0x10000000: case 0x20000000: case 0x40000000: case -0x80000000: case 0x20: case 0x40: case 0x800000: case 0x800: case 0x1000: case 0x4000000: case 0x8000000: case 0x2000000: case 0x8: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkBufferUsageFlagBits(value) {
  switch (value) {
    case 0x200: case 0x40: case 0x100: case 0x400: case 0x2000: case 0x4000: case 0x8000: case 0x10000: case 0x20000: case 0x20: case 0x8: case 0x2: case 0x1: case 0x800: case 0x1000: case 0x10: case 0x4: case 0x80: 
      return true;
  };
  return false;
};

function $VAL_R_VkBufferCreateFlagBits(value) {
  switch (value) {
    case 0x10: case 0x8: case 0x4: case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkShaderStageFlagBits(value) {
  switch (value) {
    case 0x7FFFFFFF: case 0x1F: case 0x200: case 0x2000: case 0x400: case 0x20: case 0x10: case 0x8: case 0x1000: case 0x80: case 0x800: case 0x100: case 0x40: case 0x2: case 0x4: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageUsageFlagBits(value) {
  switch (value) {
    case 0x10: case 0x20: case 0x200: case 0x80: case 0x400: case 0x800: case 0x1000: case 0x2000: case 0x4000: case 0x8000: case 0x4: case 0x100: case 0x8: case 0x2: case 0x1: case 0x40: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageCreateFlagBits(value) {
  switch (value) {
    case 0x20: case 0x400: case 0x80: case 0x2000: case 0x10: case 0x200: case 0x100: case 0x8: case 0x800: case 0x1000: case 0x4: case 0x1: case 0x2: case 0x40: case 0x4000: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageViewCreateFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSamplerCreateFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkPipelineCreateFlagBits(value) {
  switch (value) {
    case 0x2: case 0x20: case 0x4: case 0x1: case 0x10: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkColorComponentFlagBits(value) {
  switch (value) {
    case 0x8: case 0x4: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkFenceCreateFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkFormatFeatureFlagBits(value) {
  switch (value) {
    case 0x800: case 0x400: case 0x80: case 0x100: case 0x800000: case 0x200: case 0x400000: case 0x1000000: case 0x20000: case 0x2000000: case 0x4000000: case 0x8000000: case 0x10000000: case 0x1: case 0x2000: case 0x1000: case 0x10000: case 0x100000: case 0x200000: case 0x40000: case 0x80000: case 0x4: case 0x2: case 0x20: case 0x10: case 0x8000: case 0x4000: case 0x8: case 0x40: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueryControlFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueryResultFlagBits(value) {
  switch (value) {
    case 0x1: case 0x8: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkCommandBufferUsageFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkQueryPipelineStatisticFlagBits(value) {
  switch (value) {
    case 0x20: case 0x40: case 0x400: case 0x80: case 0x8: case 0x10: case 0x2: case 0x1: case 0x100: case 0x200: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkImageAspectFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x80: case 0x100: case 0x200: case 0x400: case 0x8: case 0x10: case 0x20: case 0x40: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkSparseImageFormatFlagBits(value) {
  switch (value) {
    case 0x2: case 0x4: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSparseMemoryBindFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPipelineStageFlagBits(value) {
  switch (value) {
    case 0x2000000: case 0x10000: case 0x8000: case 0x2000: case 0x400: case 0x20000: case 0x800: case 0x40000: case 0x2: case 0x100: case 0x800000: case 0x80: case 0x40: case 0x4000: case 0x200: case 0x100000: case 0x200000: case 0x4000000: case 0x8000000: case 0x400000: case 0x80000: case 0x10: case 0x20: case 0x1: case 0x1000: case 0x1000000: case 0x4: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkCommandPoolCreateFlagBits(value) {
  switch (value) {
    case 0x4: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkCommandPoolResetFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkCommandBufferResetFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSampleCountFlagBits(value) {
  switch (value) {
    case 0x10: case 0x1: case 0x2: case 0x20: case 0x4: case 0x40: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkAttachmentDescriptionFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkStencilFaceFlagBits(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x3: 
      return true;
  };
  return false;
};

function $VAL_R_VkDescriptorPoolCreateFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkDependencyFlagBits(value) {
  switch (value) {
    case 0x1: case 0x4: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkDisplayPlaneAlphaFlagBitsKHR(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x4: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkCompositeAlphaFlagBitsKHR(value) {
  switch (value) {
    case 0x8: case 0x1: case 0x4: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkSurfaceTransformFlagBitsKHR(value) {
  switch (value) {
    case 0x10: case 0x40: case 0x80: case 0x20: case 0x1: case 0x100: case 0x4: case 0x8: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkDebugReportFlagBitsEXT(value) {
  switch (value) {
    case 0x10: case 0x8: case 0x1: case 0x4: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalMemoryHandleTypeFlagBitsNV(value) {
  switch (value) {
    case 0x4: case 0x8: case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalMemoryFeatureFlagBitsNV(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkSubgroupFeatureFlagBits(value) {
  switch (value) {
    case 0x4: case 0x8: case 0x1: case 0x40: case 0x100: case 0x80: case 0x10: case 0x20: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkIndirectCommandsLayoutUsageFlagBitsNVX(value) {
  switch (value) {
    case 0x4: case 0x8: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkObjectEntryUsageFlagBitsNVX(value) {
  switch (value) {
    case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkDescriptorSetLayoutCreateFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalMemoryHandleTypeFlagBits(value) {
  switch (value) {
    case 0x400: case 0x8: case 0x10: case 0x20: case 0x40: case 0x200: case 0x80: case 0x100: case 0x1: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalMemoryFeatureFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalSemaphoreHandleTypeFlagBits(value) {
  switch (value) {
    case 0x8: case 0x1: case 0x2: case 0x4: case 0x10: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalSemaphoreFeatureFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkSemaphoreImportFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalFenceHandleTypeFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x4: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkExternalFenceFeatureFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkFenceImportFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSurfaceCounterFlagBitsEXT(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPeerMemoryFeatureFlagBits(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x8: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkMemoryAllocateFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkDeviceGroupPresentModeFlagBitsKHR(value) {
  switch (value) {
    case 0x1: case 0x8: case 0x2: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkSwapchainCreateFlagBitsKHR(value) {
  switch (value) {
    case 0x4: case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkSubpassDescriptionFlagBits(value) {
  switch (value) {
    case 0x1: case 0x2: case 0x4: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkDebugUtilsMessageSeverityFlagBitsEXT(value) {
  switch (value) {
    case 0x1000: case 0x10: case 0x1: case 0x100: 
      return true;
  };
  return false;
};

function $VAL_R_VkDebugUtilsMessageTypeFlagBitsEXT(value) {
  switch (value) {
    case 0x1: case 0x4: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkDescriptorBindingFlagBitsEXT(value) {
  switch (value) {
    case 0x4: case 0x1: case 0x2: case 0x8: 
      return true;
  };
  return false;
};

function $VAL_R_VkConditionalRenderingFlagBitsEXT(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkResolveModeFlagBitsKHR(value) {
  switch (value) {
    case 0x2: case 0x8: case 0x4: case 0x0: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkGeometryInstanceFlagBitsNV(value) {
  switch (value) {
    case 0x8: case 0x4: case 0x1: case 0x2: 
      return true;
  };
  return false;
};

function $VAL_R_VkGeometryFlagBitsNV(value) {
  switch (value) {
    case 0x2: case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkBuildAccelerationStructureFlagBitsNV(value) {
  switch (value) {
    case 0x2: case 0x1: case 0x10: case 0x8: case 0x4: 
      return true;
  };
  return false;
};

function $VAL_R_VkFramebufferCreateFlagBits(value) {
  switch (value) {
    case 0x1: 
      return true;
  };
  return false;
};

function $VAL_R_VkPipelineCreationFeedbackFlagBitsEXT(value) {
  switch (value) {
    case 0x2: case 0x4: case 0x1: 
      return true;
  };
  return false;
};
/** VkInstance **/
class VkInstance {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkInstance' doesn't take any arguments");
    }
  }
};

VkInstance.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkInstance"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkInstance.byteLength = 0x8;
/** VkPhysicalDevice **/
class VkPhysicalDevice {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPhysicalDevice' doesn't take any arguments");
    }
  }
};

VkPhysicalDevice.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPhysicalDevice"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPhysicalDevice.byteLength = 0x8;
/** VkDevice **/
class VkDevice {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDevice' doesn't take any arguments");
    }
  }
};

VkDevice.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDevice"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDevice.byteLength = 0x8;
/** VkQueue **/
class VkQueue {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkQueue' doesn't take any arguments");
    }
  }
};

VkQueue.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkQueue"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkQueue.byteLength = 0x8;
/** VkCommandBuffer **/
class VkCommandBuffer {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkCommandBuffer' doesn't take any arguments");
    }
  }
};

VkCommandBuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkCommandBuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkCommandBuffer.byteLength = 0x8;
/** VkDeviceMemory **/
class VkDeviceMemory {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDeviceMemory' doesn't take any arguments");
    }
  }
};

VkDeviceMemory.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDeviceMemory"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDeviceMemory.byteLength = 0x8;
/** VkCommandPool **/
class VkCommandPool {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkCommandPool' doesn't take any arguments");
    }
  }
};

VkCommandPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkCommandPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkCommandPool.byteLength = 0x8;
/** VkBuffer **/
class VkBuffer {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkBuffer' doesn't take any arguments");
    }
  }
};

VkBuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkBuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkBuffer.byteLength = 0x8;
/** VkBufferView **/
class VkBufferView {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkBufferView' doesn't take any arguments");
    }
  }
};

VkBufferView.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkBufferView"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkBufferView.byteLength = 0x8;
/** VkImage **/
class VkImage {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkImage' doesn't take any arguments");
    }
  }
};

VkImage.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkImage"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkImage.byteLength = 0x8;
/** VkImageView **/
class VkImageView {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkImageView' doesn't take any arguments");
    }
  }
};

VkImageView.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkImageView"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkImageView.byteLength = 0x8;
/** VkShaderModule **/
class VkShaderModule {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkShaderModule' doesn't take any arguments");
    }
  }
};

VkShaderModule.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkShaderModule"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkShaderModule.byteLength = 0x8;
/** VkPipeline **/
class VkPipeline {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPipeline' doesn't take any arguments");
    }
  }
};

VkPipeline.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipeline"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipeline.byteLength = 0x8;
/** VkPipelineLayout **/
class VkPipelineLayout {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPipelineLayout' doesn't take any arguments");
    }
  }
};

VkPipelineLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipelineLayout"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipelineLayout.byteLength = 0x8;
/** VkSampler **/
class VkSampler {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSampler' doesn't take any arguments");
    }
  }
};

VkSampler.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSampler"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSampler.byteLength = 0x8;
/** VkDescriptorSet **/
class VkDescriptorSet {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorSet' doesn't take any arguments");
    }
  }
};

VkDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorSet"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorSet.byteLength = 0x8;
/** VkDescriptorSetLayout **/
class VkDescriptorSetLayout {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorSetLayout' doesn't take any arguments");
    }
  }
};

VkDescriptorSetLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorSetLayout"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorSetLayout.byteLength = 0x8;
/** VkDescriptorPool **/
class VkDescriptorPool {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorPool' doesn't take any arguments");
    }
  }
};

VkDescriptorPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorPool.byteLength = 0x8;
/** VkFence **/
class VkFence {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkFence' doesn't take any arguments");
    }
  }
};

VkFence.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkFence"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkFence.byteLength = 0x8;
/** VkSemaphore **/
class VkSemaphore {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSemaphore' doesn't take any arguments");
    }
  }
};

VkSemaphore.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSemaphore"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSemaphore.byteLength = 0x8;
/** VkEvent **/
class VkEvent {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkEvent' doesn't take any arguments");
    }
  }
};

VkEvent.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkEvent"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkEvent.byteLength = 0x8;
/** VkQueryPool **/
class VkQueryPool {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkQueryPool' doesn't take any arguments");
    }
  }
};

VkQueryPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkQueryPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkQueryPool.byteLength = 0x8;
/** VkFramebuffer **/
class VkFramebuffer {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkFramebuffer' doesn't take any arguments");
    }
  }
};

VkFramebuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkFramebuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkFramebuffer.byteLength = 0x8;
/** VkRenderPass **/
class VkRenderPass {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkRenderPass' doesn't take any arguments");
    }
  }
};

VkRenderPass.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkRenderPass"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkRenderPass.byteLength = 0x8;
/** VkPipelineCache **/
class VkPipelineCache {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPipelineCache' doesn't take any arguments");
    }
  }
};

VkPipelineCache.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipelineCache"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipelineCache.byteLength = 0x8;
/** VkObjectTableNVX **/
class VkObjectTableNVX {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkObjectTableNVX' doesn't take any arguments");
    }
  }
};

VkObjectTableNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkObjectTableNVX"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkObjectTableNVX.byteLength = 0x8;
/** VkIndirectCommandsLayoutNVX **/
class VkIndirectCommandsLayoutNVX {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkIndirectCommandsLayoutNVX' doesn't take any arguments");
    }
  }
};

VkIndirectCommandsLayoutNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkIndirectCommandsLayoutNVX"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkIndirectCommandsLayoutNVX.byteLength = 0x8;
/** VkDescriptorUpdateTemplate **/
class VkDescriptorUpdateTemplate {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorUpdateTemplate' doesn't take any arguments");
    }
  }
};

VkDescriptorUpdateTemplate.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorUpdateTemplate"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorUpdateTemplate.byteLength = 0x8;
/** VkSamplerYcbcrConversion **/
class VkSamplerYcbcrConversion {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSamplerYcbcrConversion' doesn't take any arguments");
    }
  }
};

VkSamplerYcbcrConversion.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSamplerYcbcrConversion"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSamplerYcbcrConversion.byteLength = 0x8;
/** VkValidationCacheEXT **/
class VkValidationCacheEXT {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkValidationCacheEXT' doesn't take any arguments");
    }
  }
};

VkValidationCacheEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkValidationCacheEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkValidationCacheEXT.byteLength = 0x8;
/** VkAccelerationStructureNV **/
class VkAccelerationStructureNV {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkAccelerationStructureNV' doesn't take any arguments");
    }
  }
};

VkAccelerationStructureNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkAccelerationStructureNV"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkAccelerationStructureNV.byteLength = 0x8;
/** VkPerformanceConfigurationINTEL **/
class VkPerformanceConfigurationINTEL {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPerformanceConfigurationINTEL' doesn't take any arguments");
    }
  }
};

VkPerformanceConfigurationINTEL.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPerformanceConfigurationINTEL"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPerformanceConfigurationINTEL.byteLength = 0x8;
/** VkDisplayKHR **/
class VkDisplayKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDisplayKHR' doesn't take any arguments");
    }
  }
};

VkDisplayKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDisplayKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDisplayKHR.byteLength = 0x8;
/** VkDisplayModeKHR **/
class VkDisplayModeKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDisplayModeKHR' doesn't take any arguments");
    }
  }
};

VkDisplayModeKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDisplayModeKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDisplayModeKHR.byteLength = 0x8;
/** VkSurfaceKHR **/
class VkSurfaceKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSurfaceKHR' doesn't take any arguments");
    }
  }
};

VkSurfaceKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSurfaceKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSurfaceKHR.byteLength = 0x8;
/** VkSwapchainKHR **/
class VkSwapchainKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSwapchainKHR' doesn't take any arguments");
    }
  }
};

VkSwapchainKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSwapchainKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSwapchainKHR.byteLength = 0x8;
/** VkDebugReportCallbackEXT **/
class VkDebugReportCallbackEXT {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDebugReportCallbackEXT' doesn't take any arguments");
    }
  }
};

VkDebugReportCallbackEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDebugReportCallbackEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDebugReportCallbackEXT.byteLength = 0x8;
/** VkDebugUtilsMessengerEXT **/
class VkDebugUtilsMessengerEXT {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDebugUtilsMessengerEXT' doesn't take any arguments");
    }
  }
};

VkDebugUtilsMessengerEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDebugUtilsMessengerEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDebugUtilsMessengerEXT.byteLength = 0x8;
/** VkBaseOutStructure **/
function VkBaseOutStructure(opts) {
  if (new.target !== VkBaseOutStructure) {
    _VkBaseOutStructure.reset();
    return _VkBaseOutStructure;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkBaseOutStructure.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBaseOutStructure.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBaseOutStructure.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && value.constructor === VkBaseOutStructure) {
      value.flush();
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
      
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBaseOutStructure.pNext': Expected 'VkBaseOutStructure' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBaseOutStructure.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  this._pNext = null;
  
};

VkBaseOutStructure.prototype.flush = function flush() {
  
  return true;
};

VkBaseOutStructure.prototype.reflect = function reflect(memoryAddress) {
  
};

VkBaseOutStructure.byteLength = 0x10;

VkBaseOutStructure.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkBaseInStructure **/
function VkBaseInStructure(opts) {
  if (new.target !== VkBaseInStructure) {
    _VkBaseInStructure.reset();
    return _VkBaseInStructure;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkBaseInStructure.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBaseInStructure.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBaseInStructure.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && value.constructor === VkBaseInStructure) {
      value.flush();
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
      
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBaseInStructure.pNext': Expected 'VkBaseInStructure' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBaseInStructure.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  this._pNext = null;
  
};

VkBaseInStructure.prototype.flush = function flush() {
  
  return true;
};

VkBaseInStructure.prototype.reflect = function reflect(memoryAddress) {
  
};

VkBaseInStructure.byteLength = 0x10;

VkBaseInStructure.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkOffset2D **/
function VkOffset2D(opts) {
  if (new.target !== VkOffset2D) {
    _VkOffset2D.reset();
    return _VkOffset2D;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

Object.defineProperties(VkOffset2D.prototype, {
  "x": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset2D.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset2D.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  
});

VkOffset2D.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkOffset2D.prototype.flush = function flush() {
  
  return true;
};

VkOffset2D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkOffset2D.byteLength = 0x8;

VkOffset2D.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkOffset3D **/
function VkOffset3D(opts) {
  if (new.target !== VkOffset3D) {
    _VkOffset3D.reset();
    return _VkOffset3D;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    
  }
};

Object.defineProperties(VkOffset3D.prototype, {
  "x": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset3D.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset3D.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "z": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset3D.z': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  
});

VkOffset3D.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkOffset3D.prototype.flush = function flush() {
  
  return true;
};

VkOffset3D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkOffset3D.byteLength = 0xC;

VkOffset3D.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  z: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkExtent2D **/
function VkExtent2D(opts) {
  if (new.target !== VkExtent2D) {
    _VkExtent2D.reset();
    return _VkExtent2D;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    
  }
};

Object.defineProperties(VkExtent2D.prototype, {
  "width": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent2D.width': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "height": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent2D.height': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  
});

VkExtent2D.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkExtent2D.prototype.flush = function flush() {
  
  return true;
};

VkExtent2D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkExtent2D.byteLength = 0x8;

VkExtent2D.memoryLayout = {
  width: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  height: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkExtent3D **/
function VkExtent3D(opts) {
  if (new.target !== VkExtent3D) {
    _VkExtent3D.reset();
    return _VkExtent3D;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.depth !== void 0) this.depth = opts.depth;
    
  }
};

Object.defineProperties(VkExtent3D.prototype, {
  "width": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent3D.width': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "height": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent3D.height': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "depth": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent3D.depth': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  
});

VkExtent3D.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkExtent3D.prototype.flush = function flush() {
  
  return true;
};

VkExtent3D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkExtent3D.byteLength = 0xC;

VkExtent3D.memoryLayout = {
  width: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  height: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  depth: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkViewport **/
function VkViewport(opts) {
  if (new.target !== VkViewport) {
    _VkViewport.reset();
    return _VkViewport;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.minDepth !== void 0) this.minDepth = opts.minDepth;
    if (opts.maxDepth !== void 0) this.maxDepth = opts.maxDepth;
    
  }
};

Object.defineProperties(VkViewport.prototype, {
  "x": {
    get() {
    return this.memoryViewFloat32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewFloat32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x1] = value;
    }
    },
  "width": {
    get() {
    return this.memoryViewFloat32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.width': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x2] = value;
    }
    },
  "height": {
    get() {
    return this.memoryViewFloat32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.height': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x3] = value;
    }
    },
  "minDepth": {
    get() {
    return this.memoryViewFloat32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.minDepth': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x4] = value;
    }
    },
  "maxDepth": {
    get() {
    return this.memoryViewFloat32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.maxDepth': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x5] = value;
    }
    },
  
});

VkViewport.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  
  
  
  
  
};

VkViewport.prototype.flush = function flush() {
  
  return true;
};

VkViewport.prototype.reflect = function reflect(memoryAddress) {
  
};

VkViewport.byteLength = 0x18;

VkViewport.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  width: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  height: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  minDepth: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxDepth: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkRect2D **/
function VkRect2D(opts) {
  if (new.target !== VkRect2D) {
    _VkRect2D.reset();
    return _VkRect2D;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  if (typeof opts === "object") {
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkRect2D.prototype, {
  "offset": {
    get() {
    return this._offset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset2D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRect2D.offset': Expected 'VkOffset2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRect2D.extent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRect2D.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  this._offset = null;
  this._extent = null;
  
};

VkRect2D.prototype.flush = function flush() {
  
  
  if (this._offset !== null) {
    let offset = this._offset;
    offset.flush();
    if (this.memoryBuffer !== offset.memoryBuffer) {
      let srcView = new Uint8Array(offset.memoryBuffer).subarray(offset.$memoryOffset, offset.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRect2D.offset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer).subarray(extent.$memoryOffset, extent.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRect2D.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkRect2D.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRect2D.byteLength = 0x10;

VkRect2D.memoryLayout = {
  offset: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  extent: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkClearRect **/
function VkClearRect(opts) {
  if (new.target !== VkClearRect) {
    _VkClearRect.reset();
    return _VkClearRect;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._rect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  if (typeof opts === "object") {
    if (opts.rect !== void 0) this.rect = opts.rect;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

Object.defineProperties(VkClearRect.prototype, {
  "rect": {
    get() {
    return this._rect;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._rect = value;
      
      
    } else if (value === null) {
      this._rect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearRect.rect': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "baseArrayLayer": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearRect.baseArrayLayer': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "layerCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearRect.layerCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkClearRect.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._rect = null;
  
  
  
};

VkClearRect.prototype.flush = function flush() {
  
  
  if (this._rect !== null) {
    let rect = this._rect;
    rect.flush();
    if (this.memoryBuffer !== rect.memoryBuffer) {
      let srcView = new Uint8Array(rect.memoryBuffer).subarray(rect.$memoryOffset, rect.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearRect.rect' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkClearRect.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkClearRect.byteLength = 0x18;

VkClearRect.memoryLayout = {
  rect: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  baseArrayLayer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  layerCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkComponentMapping **/
function VkComponentMapping(opts) {
  if (new.target !== VkComponentMapping) {
    _VkComponentMapping.reset();
    return _VkComponentMapping;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.r !== void 0) this.r = opts.r;
    if (opts.g !== void 0) this.g = opts.g;
    if (opts.b !== void 0) this.b = opts.b;
    if (opts.a !== void 0) this.a = opts.a;
    
  }
};

Object.defineProperties(VkComponentMapping.prototype, {
  "r": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.r': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentSwizzle(value)) {
      throw new RangeError("Invalid value for 'VkComponentMapping.r': '" + value + "' is not a value of 'VkComponentSwizzle'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "g": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.g': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentSwizzle(value)) {
      throw new RangeError("Invalid value for 'VkComponentMapping.g': '" + value + "' is not a value of 'VkComponentSwizzle'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "b": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.b': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentSwizzle(value)) {
      throw new RangeError("Invalid value for 'VkComponentMapping.b': '" + value + "' is not a value of 'VkComponentSwizzle'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "a": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.a': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentSwizzle(value)) {
      throw new RangeError("Invalid value for 'VkComponentMapping.a': '" + value + "' is not a value of 'VkComponentSwizzle'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  
});

VkComponentMapping.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
  
};

VkComponentMapping.prototype.flush = function flush() {
  
  return true;
};

VkComponentMapping.prototype.reflect = function reflect(memoryAddress) {
  
};

VkComponentMapping.byteLength = 0x10;

VkComponentMapping.memoryLayout = {
  r: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  g: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  b: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  a: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceProperties **/
function VkPhysicalDeviceProperties(opts) {
  if (new.target !== VkPhysicalDeviceProperties) {
    _VkPhysicalDeviceProperties.reset();
    return _VkPhysicalDeviceProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x338) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x338) / 0x4);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x338) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x338);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  this._pipelineCacheUUID = [...Array(16)].fill(0x0);
  this._limits = new VkPhysicalDeviceLimits({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x128 });
  this._sparseProperties = new VkPhysicalDeviceSparseProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x320 });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceProperties.prototype, {
  "apiVersion": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    },
  "driverVersion": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    },
  "vendorID": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    },
  "deviceID": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    },
  "deviceType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "deviceName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x14, 0x128)
    ) || null;
    },
    },
  "pipelineCacheUUID": {
    get() {
    return [
      this.memoryViewUint8[0x114],
      this.memoryViewUint8[0x115],
      this.memoryViewUint8[0x116],
      this.memoryViewUint8[0x117],
      this.memoryViewUint8[0x118],
      this.memoryViewUint8[0x119],
      this.memoryViewUint8[0x11A],
      this.memoryViewUint8[0x11B],
      this.memoryViewUint8[0x11C],
      this.memoryViewUint8[0x11D],
      this.memoryViewUint8[0x11E],
      this.memoryViewUint8[0x11F],
      this.memoryViewUint8[0x120],
      this.memoryViewUint8[0x121],
      this.memoryViewUint8[0x122],
      this.memoryViewUint8[0x123]
    ];
    },
    },
  "limits": {
    get() {
    return this._limits;
    },
    },
  "sparseProperties": {
    get() {
    return this._sparseProperties;
    },
    },
  
});

VkPhysicalDeviceProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x338], 0x0);
  
  
  
  
  
  
  this._pipelineCacheUUID = null;
  this._limits = null;
  this._sparseProperties = null;
  
};

VkPhysicalDeviceProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x338));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x338), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceProperties.byteLength = 0x338;

VkPhysicalDeviceProperties.memoryLayout = {
  apiVersion: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  driverVersion: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  vendorID: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  deviceID: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  deviceType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  deviceName: {
    byteOffset: 0x14,
    byteLength: 0x100
  },
  pipelineCacheUUID: {
    byteOffset: 0x114,
    byteLength: 0x10
  },
  limits: {
    byteOffset: 0x128,
    byteLength: 0x1F8
  },
  sparseProperties: {
    byteOffset: 0x320,
    byteLength: 0x14
  },
};
/** VkExtensionProperties **/
function VkExtensionProperties(opts) {
  if (new.target !== VkExtensionProperties) {
    _VkExtensionProperties.reset();
    return _VkExtensionProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x104) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x104) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x104);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExtensionProperties.prototype, {
  "extensionName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x100)
    ) || null;
    },
    },
  "specVersion": {
    get() {
    return this.memoryViewUint32[0x40];
    },
    },
  
});

VkExtensionProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x104], 0x0);
  
  
  
};

VkExtensionProperties.prototype.flush = function flush() {
  
  return true;
};

VkExtensionProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x104));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x104), 0x0);
};

VkExtensionProperties.byteLength = 0x104;

VkExtensionProperties.memoryLayout = {
  extensionName: {
    byteOffset: 0x0,
    byteLength: 0x100
  },
  specVersion: {
    byteOffset: 0x100,
    byteLength: 0x4
  },
};
/** VkLayerProperties **/
function VkLayerProperties(opts) {
  if (new.target !== VkLayerProperties) {
    _VkLayerProperties.reset();
    return _VkLayerProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x208) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x208) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x208);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkLayerProperties.prototype, {
  "layerName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x100)
    ) || null;
    },
    },
  "specVersion": {
    get() {
    return this.memoryViewUint32[0x40];
    },
    },
  "implementationVersion": {
    get() {
    return this.memoryViewUint32[0x41];
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x108, 0x310)
    ) || null;
    },
    },
  
});

VkLayerProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x208], 0x0);
  
  
  
  
  
};

VkLayerProperties.prototype.flush = function flush() {
  
  return true;
};

VkLayerProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x208));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x208), 0x0);
};

VkLayerProperties.byteLength = 0x208;

VkLayerProperties.memoryLayout = {
  layerName: {
    byteOffset: 0x0,
    byteLength: 0x100
  },
  specVersion: {
    byteOffset: 0x100,
    byteLength: 0x4
  },
  implementationVersion: {
    byteOffset: 0x104,
    byteLength: 0x4
  },
  description: {
    byteOffset: 0x108,
    byteLength: 0x100
  },
};
/** VkApplicationInfo **/
function VkApplicationInfo(opts) {
  if (new.target !== VkApplicationInfo) {
    _VkApplicationInfo.reset();
    return _VkApplicationInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._pApplicationName = null;
  
  this._pEngineName = null;
  
  
  this.sType = 0x0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pApplicationName !== void 0) this.pApplicationName = opts.pApplicationName;
    if (opts.applicationVersion !== void 0) this.applicationVersion = opts.applicationVersion;
    if (opts.pEngineName !== void 0) this.pEngineName = opts.pEngineName;
    if (opts.engineVersion !== void 0) this.engineVersion = opts.engineVersion;
    if (opts.apiVersion !== void 0) this.apiVersion = opts.apiVersion;
    
  }
};

Object.defineProperties(VkApplicationInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkApplicationInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkApplicationInfo.pNext' isn't allowed to be filled");
    }
    },
  "pApplicationName": {
    get() {
    if (this._pApplicationName !== null) {
      let str = textDecoder.decode(this._pApplicationName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pApplicationName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(this._pApplicationName);
    } else if (value === null) {
      this._pApplicationName = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkApplicationInfo.pApplicationName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "applicationVersion": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.applicationVersion': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pEngineName": {
    get() {
    if (this._pEngineName !== null) {
      let str = textDecoder.decode(this._pEngineName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pEngineName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pEngineName);
    } else if (value === null) {
      this._pEngineName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkApplicationInfo.pEngineName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "engineVersion": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.engineVersion': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "apiVersion": {
    get() {
    return this.memoryViewUint32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.apiVersion': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xB] = value;
    }
    },
  
});

VkApplicationInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  this._pApplicationName = null;
  
  this._pEngineName = null;
  
  
  this.sType = 0x0;
};

VkApplicationInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkApplicationInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkApplicationInfo.byteLength = 0x30;

VkApplicationInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pApplicationName: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  applicationVersion: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pEngineName: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  engineVersion: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  apiVersion: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
};
/** VkAllocationCallbacks **/
function VkAllocationCallbacks(opts) {
  if (new.target !== VkAllocationCallbacks) {
    _VkAllocationCallbacks.reset();
    return _VkAllocationCallbacks;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  this._pUserData = null;
  this._pfnAllocation = null;
  this._pfnReallocation = null;
  this._pfnFree = null;
  this._pfnInternalAllocation = null;
  this._pfnInternalFree = null;
  
  if (typeof opts === "object") {
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    if (opts.pfnAllocation !== void 0) this.pfnAllocation = opts.pfnAllocation;
    if (opts.pfnReallocation !== void 0) this.pfnReallocation = opts.pfnReallocation;
    if (opts.pfnFree !== void 0) this.pfnFree = opts.pfnFree;
    if (opts.pfnInternalAllocation !== void 0) this.pfnInternalAllocation = opts.pfnInternalAllocation;
    if (opts.pfnInternalFree !== void 0) this.pfnInternalFree = opts.pfnInternalFree;
    
  }
};

Object.defineProperties(VkAllocationCallbacks.prototype, {
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x0] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnAllocation": {
    get() {
    return this._pfnAllocation;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnAllocation = value;
    } else if (value === null) {
      this._pfnAllocation = null;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnAllocation': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnReallocation": {
    get() {
    return this._pfnReallocation;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnReallocation = value;
    } else if (value === null) {
      this._pfnReallocation = null;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnReallocation': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnFree": {
    get() {
    return this._pfnFree;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnFree = value;
    } else if (value === null) {
      this._pfnFree = null;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnFree': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnInternalAllocation": {
    get() {
    return this._pfnInternalAllocation;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnInternalAllocation = value;
    } else if (value === null) {
      this._pfnInternalAllocation = null;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnInternalAllocation': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnInternalFree": {
    get() {
    return this._pfnInternalFree;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnInternalFree = value;
    } else if (value === null) {
      this._pfnInternalFree = null;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnInternalFree': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAllocationCallbacks.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  this._pUserData = null;
  this._pfnAllocation = null;
  this._pfnReallocation = null;
  this._pfnFree = null;
  this._pfnInternalAllocation = null;
  this._pfnInternalFree = null;
  
};

VkAllocationCallbacks.prototype.flush = function flush() {
  
  return true;
};

VkAllocationCallbacks.prototype.reflect = function reflect(memoryAddress) {
  
};

VkAllocationCallbacks.byteLength = 0x30;

VkAllocationCallbacks.memoryLayout = {
  pUserData: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  pfnAllocation: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pfnReallocation: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  pfnFree: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pfnInternalAllocation: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pfnInternalFree: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkDeviceQueueCreateInfo **/
function VkDeviceQueueCreateInfo(opts) {
  if (new.target !== VkDeviceQueueCreateInfo) {
    _VkDeviceQueueCreateInfo.reset();
    return _VkDeviceQueueCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._pQueuePriorities = null;
  this.sType = 0x2;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.queueCount !== void 0) this.queueCount = opts.queueCount;
    if (opts.pQueuePriorities !== void 0) this.pQueuePriorities = opts.pQueuePriorities;
    
  }
};

Object.defineProperties(VkDeviceQueueCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceQueueCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D71B0:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.queueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "queueCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.queueCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pQueuePriorities": {
    get() {
    return this._pQueuePriorities;
    },
    set(value) {
    if (value !== null && value.constructor === Float32Array) {
      this._pQueuePriorities = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueuePriorities = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pQueuePriorities': Expected 'Float32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceQueueCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  this._pQueuePriorities = null;
  this.sType = 0x2;
};

VkDeviceQueueCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceQueueCreateInfo.byteLength = 0x28;

VkDeviceQueueCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  queueFamilyIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  queueCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pQueuePriorities: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkDeviceCreateInfo **/
function VkDeviceCreateInfo(opts) {
  if (new.target !== VkDeviceCreateInfo) {
    _VkDeviceCreateInfo.reset();
    return _VkDeviceCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pQueueCreateInfos = null;
    this._pQueueCreateInfosNative = null;
  
  this._ppEnabledLayerNames = null;
    this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
    this._ppEnabledExtensionNamesNative = null;
  this._pEnabledFeatures = null;
  this.sType = 0x3;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueCreateInfoCount !== void 0) this.queueCreateInfoCount = opts.queueCreateInfoCount;
    if (opts.pQueueCreateInfos !== void 0) this.pQueueCreateInfos = opts.pQueueCreateInfos;
    if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
    if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
    if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
    if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
    if (opts.pEnabledFeatures !== void 0) this.pEnabledFeatures = opts.pEnabledFeatures;
    
  }
};

Object.defineProperties(VkDeviceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB078:
        case 0x3B9C9EC0:
        case 0x3B9B9909:
        case 0x3B9BDB71:
        case 0x3B9C0E38:
        case 0x3B9D2B64:
        case 0x3B9D0069:
        case 0x3B9D0C20:
        case 0x3B9CE510:
        case 0x3B9BC018:
        case 0x3B9C0A50:
        case 0x3B9EC588:
        case 0x3B9D3EE9:
        case 0x3B9D7D68:
        case 0x3B9C0669:
        case 0x3B9E0238:
        case 0x3B9D8920:
        case 0x3B9DB032:
        case 0x3B9BCFB9:
        case 0x3B9B3760:
        case 0x3B9D5270:
        case 0x3B9DEACA:
        case 0x3B9B8D50:
        case 0x3B9DDB28:
        case 0x3B9DE2F8:
        case 0x3B9DE6E0:
        case 0x3B9E7380:
        case 0x3B9D4AA1:
        case 0x3B9DDF10:
        case 0x3B9DAC48:
        case 0x3B9E1D90:
        case 0x3B9E2948:
        case 0x3B9EA648:
        case 0x3B9C5870:
        case 0x3B9E6BB0:
        case 0x3B9E8320:
        case 0x3B9C6FE0:
        case 0x3B9E96A8:
        case 0x3B9EA260:
        case 0x3B9E9A90:
        case 0x3B9DFA68:
        case 0x3B9D2390:
        case 0x3B9E9E78:
        case 0x3B9F0020:
        case 0x3B9F13A8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "queueCreateInfoCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.queueCreateInfoCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pQueueCreateInfos": {
    get() {
    return this._pQueueCreateInfos;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pQueueCreateInfos = value;
    } else if (value === null) {
      this._pQueueCreateInfos = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pQueueCreateInfos': Expected 'Array VkDeviceQueueCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "enabledLayerCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.enabledLayerCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "ppEnabledLayerNames": {
    get() {
    return this._ppEnabledLayerNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledLayerNames = value;
    } else if (value === null) {
      this._ppEnabledLayerNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledLayerNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "enabledExtensionCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.enabledExtensionCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "ppEnabledExtensionNames": {
    get() {
    return this._ppEnabledExtensionNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledExtensionNames = value;
    } else if (value === null) {
      this._ppEnabledExtensionNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledExtensionNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pEnabledFeatures": {
    get() {
    return this._pEnabledFeatures;
    },
    set(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._pEnabledFeatures = value;
      this.memoryViewBigInt64[0x8] = value.memoryAddress;
      
    } else if (value === null) {
      this._pEnabledFeatures = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pEnabledFeatures': Expected 'VkPhysicalDeviceFeatures' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  
  this._pQueueCreateInfos = null;
    this._pQueueCreateInfosNative = null;
  
  this._ppEnabledLayerNames = null;
    this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
    this._ppEnabledExtensionNamesNative = null;
  this._pEnabledFeatures = null;
  this.sType = 0x3;
};

VkDeviceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pQueueCreateInfos !== null) {
    let array = this._pQueueCreateInfos;
    
    if (array.length !== this.queueCreateInfoCount) {
      throw new RangeError("Invalid array length, expected length of 'queueCreateInfoCount' for 'VkDeviceCreateInfo.pQueueCreateInfos'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceQueueCreateInfo)) {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pQueueCreateInfos[" + ii + "]': Expected 'VkDeviceQueueCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pQueueCreateInfosNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pQueueCreateInfosNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._ppEnabledLayerNames !== null) {
    let array = this._ppEnabledLayerNames;
    
    // validate length
    if (array.length !== this.enabledLayerCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledLayerCount' for 'VkDeviceCreateInfo.ppEnabledLayerNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledLayerNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledLayerNames);
    this._ppEnabledLayerNamesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x5] = BI0;
  }
  
  
  if (this._ppEnabledExtensionNames !== null) {
    let array = this._ppEnabledExtensionNames;
    
    // validate length
    if (array.length !== this.enabledExtensionCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledExtensionCount' for 'VkDeviceCreateInfo.ppEnabledExtensionNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledExtensionNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledExtensionNames);
    this._ppEnabledExtensionNamesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x7] = BI0;
  }
  
  return true;
};

VkDeviceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkDeviceCreateInfo.byteLength = 0x48;

VkDeviceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  queueCreateInfoCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pQueueCreateInfos: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  enabledLayerCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  ppEnabledLayerNames: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  enabledExtensionCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  ppEnabledExtensionNames: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  pEnabledFeatures: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
};
/** VkInstanceCreateInfo **/
function VkInstanceCreateInfo(opts) {
  if (new.target !== VkInstanceCreateInfo) {
    _VkInstanceCreateInfo.reset();
    return _VkInstanceCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pApplicationInfo = null;
  
  this._ppEnabledLayerNames = null;
    this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
    this._ppEnabledExtensionNamesNative = null;
  this.sType = 0x1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pApplicationInfo !== void 0) this.pApplicationInfo = opts.pApplicationInfo;
    if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
    if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
    if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
    if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
    
  }
};

Object.defineProperties(VkInstanceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkInstanceCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9AF4F8:
        case 0x3B9BB848:
        case 0x3B9E8ED8:
        case 0x3B9CBE04:
          break;
        default:
          throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "pApplicationInfo": {
    get() {
    return this._pApplicationInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkApplicationInfo) {
      value.flush();
      this._pApplicationInfo = value;
      this.memoryViewBigInt64[0x3] = value.memoryAddress;
      
    } else if (value === null) {
      this._pApplicationInfo = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pApplicationInfo': Expected 'VkApplicationInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "enabledLayerCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.enabledLayerCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "ppEnabledLayerNames": {
    get() {
    return this._ppEnabledLayerNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledLayerNames = value;
    } else if (value === null) {
      this._ppEnabledLayerNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledLayerNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "enabledExtensionCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.enabledExtensionCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "ppEnabledExtensionNames": {
    get() {
    return this._ppEnabledExtensionNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledExtensionNames = value;
    } else if (value === null) {
      this._ppEnabledExtensionNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledExtensionNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkInstanceCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._pApplicationInfo = null;
  
  this._ppEnabledLayerNames = null;
    this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
    this._ppEnabledExtensionNamesNative = null;
  this.sType = 0x1;
};

VkInstanceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._ppEnabledLayerNames !== null) {
    let array = this._ppEnabledLayerNames;
    
    // validate length
    if (array.length !== this.enabledLayerCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledLayerCount' for 'VkInstanceCreateInfo.ppEnabledLayerNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledLayerNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledLayerNames);
    this._ppEnabledLayerNamesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x5] = BI0;
  }
  
  
  if (this._ppEnabledExtensionNames !== null) {
    let array = this._ppEnabledExtensionNames;
    
    // validate length
    if (array.length !== this.enabledExtensionCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledExtensionCount' for 'VkInstanceCreateInfo.ppEnabledExtensionNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledExtensionNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledExtensionNames);
    this._ppEnabledExtensionNamesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x7] = BI0;
  }
  
  return true;
};

VkInstanceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkInstanceCreateInfo.byteLength = 0x40;

VkInstanceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pApplicationInfo: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  enabledLayerCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  ppEnabledLayerNames: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  enabledExtensionCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  ppEnabledExtensionNames: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkQueueFamilyProperties **/
function VkQueueFamilyProperties(opts) {
  if (new.target !== VkQueueFamilyProperties) {
    _VkQueueFamilyProperties.reset();
    return _VkQueueFamilyProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  this._minImageTransferGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0xC });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkQueueFamilyProperties.prototype, {
  "queueFlags": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "queueCount": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    },
  "timestampValidBits": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    },
  "minImageTransferGranularity": {
    get() {
    return this._minImageTransferGranularity;
    },
    },
  
});

VkQueueFamilyProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  
  this._minImageTransferGranularity = null;
  
};

VkQueueFamilyProperties.prototype.flush = function flush() {
  
  return true;
};

VkQueueFamilyProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkQueueFamilyProperties.byteLength = 0x18;

VkQueueFamilyProperties.memoryLayout = {
  queueFlags: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  queueCount: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  timestampValidBits: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  minImageTransferGranularity: {
    byteOffset: 0xC,
    byteLength: 0xC
  },
};
/** VkPhysicalDeviceMemoryProperties **/
function VkPhysicalDeviceMemoryProperties(opts) {
  if (new.target !== VkPhysicalDeviceMemoryProperties) {
    _VkPhysicalDeviceMemoryProperties.reset();
    return _VkPhysicalDeviceMemoryProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x208) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x208) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x208);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._memoryTypes = [...Array(32)].map((v, i) => new VkMemoryType({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x4 + (i * 0x8) }));
  
  this._memoryHeaps = [...Array(16)].map((v, i) => new VkMemoryHeap({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x108 + (i * 0x10) }));
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryProperties.prototype, {
  "memoryTypeCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    },
  "memoryTypes": {
    get() {
    return this._memoryTypes;
    },
    },
  "memoryHeapCount": {
    get() {
    return this.memoryViewUint32[0x41];
    },
    },
  "memoryHeaps": {
    get() {
    return this._memoryHeaps;
    },
    },
  
});

VkPhysicalDeviceMemoryProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x208], 0x0);
  
  this._memoryTypes = null;
  
  this._memoryHeaps = null;
  
};

VkPhysicalDeviceMemoryProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x208));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x208), 0x0);
  
  
  
  
};

VkPhysicalDeviceMemoryProperties.byteLength = 0x208;

VkPhysicalDeviceMemoryProperties.memoryLayout = {
  memoryTypeCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  memoryTypes: {
    byteOffset: 0x4,
    byteLength: 0x100
  },
  memoryHeapCount: {
    byteOffset: 0x104,
    byteLength: 0x4
  },
  memoryHeaps: {
    byteOffset: 0x108,
    byteLength: 0x100
  },
};
/** VkMemoryAllocateInfo **/
function VkMemoryAllocateInfo(opts) {
  if (new.target !== VkMemoryAllocateInfo) {
    _VkMemoryAllocateInfo.reset();
    return _VkMemoryAllocateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x5;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.allocationSize !== void 0) this.allocationSize = opts.allocationSize;
    if (opts.memoryTypeIndex !== void 0) this.memoryTypeIndex = opts.memoryTypeIndex;
    
  }
};

Object.defineProperties(VkMemoryAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryAllocateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B2F92:
        case 0x3B9BA4C1:
        case 0x3B9BA8A8:
        case 0x3B9BA8A9:
        case 0x3B9BE342:
        case 0x3B9BE728:
        case 0x3B9BE729:
        case 0x3B9BEB10:
        case 0x3B9BB460:
        case 0x3B9CBA19:
        case 0x3B9D8150:
        case 0x3B9CC1EB:
        case 0x3B9E6BB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
    }
    
    }
    },
  "allocationSize": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.allocationSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  "memoryTypeIndex": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.memoryTypeIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  
});

VkMemoryAllocateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x5;
};

VkMemoryAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryAllocateInfo.byteLength = 0x20;

VkMemoryAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  allocationSize: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memoryTypeIndex: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkMemoryRequirements **/
function VkMemoryRequirements(opts) {
  if (new.target !== VkMemoryRequirements) {
    _VkMemoryRequirements.reset();
    return _VkMemoryRequirements;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkMemoryRequirements.prototype, {
  "size": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    },
  "alignment": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    },
  "memoryTypeBits": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkMemoryRequirements.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  
  
};

VkMemoryRequirements.prototype.flush = function flush() {
  
  return true;
};

VkMemoryRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
};

VkMemoryRequirements.byteLength = 0x18;

VkMemoryRequirements.memoryLayout = {
  size: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  alignment: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryTypeBits: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSparseImageFormatProperties **/
function VkSparseImageFormatProperties(opts) {
  if (new.target !== VkSparseImageFormatProperties) {
    _VkSparseImageFormatProperties.reset();
    return _VkSparseImageFormatProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x14) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x14);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  this._imageGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x4 });
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSparseImageFormatProperties.prototype, {
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "imageGranularity": {
    get() {
    return this._imageGranularity;
    },
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  
});

VkSparseImageFormatProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x14], 0x0);
  
  this._imageGranularity = null;
  
  
};

VkSparseImageFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkSparseImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x14));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x14), 0x0);
  
  
};

VkSparseImageFormatProperties.byteLength = 0x14;

VkSparseImageFormatProperties.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  imageGranularity: {
    byteOffset: 0x4,
    byteLength: 0xC
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSparseImageMemoryRequirements **/
function VkSparseImageMemoryRequirements(opts) {
  if (new.target !== VkSparseImageMemoryRequirements) {
    _VkSparseImageMemoryRequirements.reset();
    return _VkSparseImageMemoryRequirements;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  this._formatProperties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSparseImageMemoryRequirements.prototype, {
  "formatProperties": {
    get() {
    return this._formatProperties;
    },
    },
  "imageMipTailFirstLod": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "imageMipTailSize": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  "imageMipTailOffset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    },
  "imageMipTailStride": {
    get() {
    return this.memoryViewBigUint64[0x5];
    },
    },
  
});

VkSparseImageMemoryRequirements.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  this._formatProperties = null;
  
  
  
  
  
};

VkSparseImageMemoryRequirements.prototype.flush = function flush() {
  
  return true;
};

VkSparseImageMemoryRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
};

VkSparseImageMemoryRequirements.byteLength = 0x30;

VkSparseImageMemoryRequirements.memoryLayout = {
  formatProperties: {
    byteOffset: 0x0,
    byteLength: 0x14
  },
  imageMipTailFirstLod: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  imageMipTailSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  imageMipTailOffset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  imageMipTailStride: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkMemoryType **/
function VkMemoryType(opts) {
  if (new.target !== VkMemoryType) {
    _VkMemoryType.reset();
    return _VkMemoryType;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkMemoryType.prototype, {
  "propertyFlags": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "heapIndex": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    },
  
});

VkMemoryType.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkMemoryType.prototype.flush = function flush() {
  
  return true;
};

VkMemoryType.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x8), 0x0);
};

VkMemoryType.byteLength = 0x8;

VkMemoryType.memoryLayout = {
  propertyFlags: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  heapIndex: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkMemoryHeap **/
function VkMemoryHeap(opts) {
  if (new.target !== VkMemoryHeap) {
    _VkMemoryHeap.reset();
    return _VkMemoryHeap;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkMemoryHeap.prototype, {
  "size": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    },
  
});

VkMemoryHeap.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
};

VkMemoryHeap.prototype.flush = function flush() {
  
  return true;
};

VkMemoryHeap.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkMemoryHeap.byteLength = 0x10;

VkMemoryHeap.memoryLayout = {
  size: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkMappedMemoryRange **/
function VkMappedMemoryRange(opts) {
  if (new.target !== VkMappedMemoryRange) {
    _VkMappedMemoryRange.reset();
    return _VkMappedMemoryRange;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memory = null;
  
  
  this.sType = 0x6;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkMappedMemoryRange.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMappedMemoryRange.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMappedMemoryRange.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "size": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.size': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  
});

VkMappedMemoryRange.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._memory = null;
  
  
  this.sType = 0x6;
};

VkMappedMemoryRange.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMappedMemoryRange.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMappedMemoryRange.byteLength = 0x28;

VkMappedMemoryRange.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  offset: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  size: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkFormatProperties **/
function VkFormatProperties(opts) {
  if (new.target !== VkFormatProperties) {
    _VkFormatProperties.reset();
    return _VkFormatProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkFormatProperties.prototype, {
  "linearTilingFeatures": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "optimalTilingFeatures": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    },
  "bufferFeatures": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    },
  
});

VkFormatProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0xC));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0xC), 0x0);
};

VkFormatProperties.byteLength = 0xC;

VkFormatProperties.memoryLayout = {
  linearTilingFeatures: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  optimalTilingFeatures: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  bufferFeatures: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkImageFormatProperties **/
function VkImageFormatProperties(opts) {
  if (new.target !== VkImageFormatProperties) {
    _VkImageFormatProperties.reset();
    return _VkImageFormatProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  this._maxExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkImageFormatProperties.prototype, {
  "maxExtent": {
    get() {
    return this._maxExtent;
    },
    },
  "maxMipLevels": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    },
  "maxArrayLayers": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "sampleCounts": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "maxResourceSize": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  
});

VkImageFormatProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  this._maxExtent = null;
  
  
  
  
  
};

VkImageFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkImageFormatProperties.byteLength = 0x20;

VkImageFormatProperties.memoryLayout = {
  maxExtent: {
    byteOffset: 0x0,
    byteLength: 0xC
  },
  maxMipLevels: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  maxArrayLayers: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  sampleCounts: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  maxResourceSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorBufferInfo **/
function VkDescriptorBufferInfo(opts) {
  if (new.target !== VkDescriptorBufferInfo) {
    _VkDescriptorBufferInfo.reset();
    return _VkDescriptorBufferInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  this._buffer = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.range !== void 0) this.range = opts.range;
    
  }
};

Object.defineProperties(VkDescriptorBufferInfo.prototype, {
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x1] = BigInt(value);
    }
    },
  "range": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.range': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  
});

VkDescriptorBufferInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._buffer = null;
  
  
  
};

VkDescriptorBufferInfo.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorBufferInfo.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorBufferInfo.byteLength = 0x18;

VkDescriptorBufferInfo.memoryLayout = {
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  offset: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  range: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkDescriptorImageInfo **/
function VkDescriptorImageInfo(opts) {
  if (new.target !== VkDescriptorImageInfo) {
    _VkDescriptorImageInfo.reset();
    return _VkDescriptorImageInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  this._sampler = null;
  this._imageView = null;
  
  
  if (typeof opts === "object") {
    if (opts.sampler !== void 0) this.sampler = opts.sampler;
    if (opts.imageView !== void 0) this.imageView = opts.imageView;
    if (opts.imageLayout !== void 0) this.imageLayout = opts.imageLayout;
    
  }
};

Object.defineProperties(VkDescriptorImageInfo.prototype, {
  "sampler": {
    get() {
    return this._sampler;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampler) {
      
      this._sampler = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sampler = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.sampler': Expected 'VkSampler' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageView": {
    get() {
    return this._imageView;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageView) {
      
      this._imageView = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._imageView = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.imageView': Expected 'VkImageView' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageLayout": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.imageLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorImageInfo.imageLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDescriptorImageInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._sampler = null;
  this._imageView = null;
  
  
};

VkDescriptorImageInfo.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorImageInfo.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorImageInfo.byteLength = 0x18;

VkDescriptorImageInfo.memoryLayout = {
  sampler: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  imageView: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imageLayout: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkWriteDescriptorSet **/
function VkWriteDescriptorSet(opts) {
  if (new.target !== VkWriteDescriptorSet) {
    _VkWriteDescriptorSet.reset();
    return _VkWriteDescriptorSet;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._dstSet = null;
  
  
  
  
  this._pImageInfo = null;
    this._pImageInfoNative = null;
  this._pBufferInfo = null;
    this._pBufferInfoNative = null;
  this._pTexelBufferView = null;
    this._pTexelBufferViewNative = null;
  this.sType = 0x23;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.pImageInfo !== void 0) this.pImageInfo = opts.pImageInfo;
    if (opts.pBufferInfo !== void 0) this.pBufferInfo = opts.pBufferInfo;
    if (opts.pTexelBufferView !== void 0) this.pTexelBufferView = opts.pTexelBufferView;
    
  }
};

Object.defineProperties(VkWriteDescriptorSet.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkWriteDescriptorSet.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
      switch (sType) {
          
        case 0x3B9CE512:
        case 0x3B9D4E8F:
          break;
        default:
          throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
    }
    
    }
    },
  "dstSet": {
    get() {
    return this._dstSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._dstSet = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._dstSet = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstBinding": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstBinding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstArrayElement': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.descriptorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "descriptorType": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.descriptorType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorType(value)) {
      throw new RangeError("Invalid value for 'VkWriteDescriptorSet.descriptorType': '" + value + "' is not a value of 'VkDescriptorType'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "pImageInfo": {
    get() {
    return this._pImageInfo;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageInfo = value;
    } else if (value === null) {
      this._pImageInfo = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pImageInfo': Expected 'Array VkDescriptorImageInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pBufferInfo": {
    get() {
    return this._pBufferInfo;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBufferInfo = value;
    } else if (value === null) {
      this._pBufferInfo = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pBufferInfo': Expected 'Array VkDescriptorBufferInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pTexelBufferView": {
    get() {
    return this._pTexelBufferView;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pTexelBufferView = value;
    } else if (value === null) {
      this._pTexelBufferView = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pTexelBufferView': Expected 'Array VkBufferView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkWriteDescriptorSet.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._dstSet = null;
  
  
  
  
  this._pImageInfo = null;
    this._pImageInfoNative = null;
  this._pBufferInfo = null;
    this._pBufferInfoNative = null;
  this._pTexelBufferView = null;
    this._pTexelBufferViewNative = null;
  this.sType = 0x23;
};

VkWriteDescriptorSet.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pImageInfo !== null) {
    let array = this._pImageInfo;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pImageInfo'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorImageInfo)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pImageInfo[" + ii + "]': Expected 'VkDescriptorImageInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImageInfoNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pImageInfoNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  
  if (this._pBufferInfo !== null) {
    let array = this._pBufferInfo;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pBufferInfo'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorBufferInfo)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pBufferInfo[" + ii + "]': Expected 'VkDescriptorBufferInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBufferInfoNative = nativeArray;
      this.memoryViewBigInt64[0x6] = nativeArray.address;
    } else {
      this._pBufferInfoNative = null;
      this.memoryViewBigInt64[0x6] = BI0;
    }
  }
  
  
  if (this._pTexelBufferView !== null) {
    let array = this._pTexelBufferView;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pTexelBufferView'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkBufferView)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pTexelBufferView[" + ii + "]': Expected 'VkBufferView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pTexelBufferViewNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pTexelBufferViewNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkWriteDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkWriteDescriptorSet.byteLength = 0x40;

VkWriteDescriptorSet.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  dstSet: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  dstBinding: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  dstArrayElement: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  descriptorCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  descriptorType: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  pImageInfo: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pBufferInfo: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  pTexelBufferView: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkCopyDescriptorSet **/
function VkCopyDescriptorSet(opts) {
  if (new.target !== VkCopyDescriptorSet) {
    _VkCopyDescriptorSet.reset();
    return _VkCopyDescriptorSet;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._srcSet = null;
  
  
  this._dstSet = null;
  
  
  
  this.sType = 0x24;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSet !== void 0) this.srcSet = opts.srcSet;
    if (opts.srcBinding !== void 0) this.srcBinding = opts.srcBinding;
    if (opts.srcArrayElement !== void 0) this.srcArrayElement = opts.srcArrayElement;
    if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    
  }
};

Object.defineProperties(VkCopyDescriptorSet.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCopyDescriptorSet.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyDescriptorSet.pNext' isn't allowed to be filled");
    }
    },
  "srcSet": {
    get() {
    return this._srcSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._srcSet = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._srcSet = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcBinding": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcBinding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "srcArrayElement": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcArrayElement': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "dstSet": {
    get() {
    return this._dstSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._dstSet = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._dstSet = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstBinding": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstBinding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryViewUint32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstArrayElement': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xB] = value;
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.descriptorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  
});

VkCopyDescriptorSet.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  this._srcSet = null;
  
  
  this._dstSet = null;
  
  
  
  this.sType = 0x24;
};

VkCopyDescriptorSet.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCopyDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCopyDescriptorSet.byteLength = 0x38;

VkCopyDescriptorSet.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcSet: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  srcBinding: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  srcArrayElement: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  dstSet: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  dstBinding: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  dstArrayElement: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  descriptorCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkBufferCreateInfo **/
function VkBufferCreateInfo(opts) {
  if (new.target !== VkBufferCreateInfo) {
    _VkBufferCreateInfo.reset();
    return _VkBufferCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = 0xC;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    
  }
};

Object.defineProperties(VkBufferCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B2F91:
        case 0x3B9BE340:
        case 0x3B9E8322:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "size": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.size': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "sharingMode": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.sharingMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSharingMode(value)) {
      throw new RangeError("Invalid value for 'VkBufferCreateInfo.sharingMode': '" + value + "' is not a value of 'VkSharingMode'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.queueFamilyIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = 0xC;
};

VkBufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferCreateInfo.byteLength = 0x38;

VkBufferCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  size: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  usage: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  sharingMode: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  queueFamilyIndexCount: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  pQueueFamilyIndices: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
};
/** VkBufferViewCreateInfo **/
function VkBufferViewCreateInfo(opts) {
  if (new.target !== VkBufferViewCreateInfo) {
    _VkBufferViewCreateInfo.reset();
    return _VkBufferViewCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._buffer = null;
  
  
  
  this.sType = 0xD;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.range !== void 0) this.range = opts.range;
    
  }
};

Object.defineProperties(VkBufferViewCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferViewCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferViewCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkBufferViewCreateInfo.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x5];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x5] = BigInt(value);
    }
    },
  "range": {
    get() {
    return this.memoryViewBigUint64[0x6];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.range': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x6] = BigInt(value);
    }
    },
  
});

VkBufferViewCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  this._buffer = null;
  
  
  
  this.sType = 0xD;
};

VkBufferViewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferViewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferViewCreateInfo.byteLength = 0x38;

VkBufferViewCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  buffer: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  range: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
};
/** VkImageSubresource **/
function VkImageSubresource(opts) {
  if (new.target !== VkImageSubresource) {
    _VkImageSubresource.reset();
    return _VkImageSubresource;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
    if (opts.arrayLayer !== void 0) this.arrayLayer = opts.arrayLayer;
    
  }
};

Object.defineProperties(VkImageSubresource.prototype, {
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresource.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "mipLevel": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresource.mipLevel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "arrayLayer": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresource.arrayLayer': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  
});

VkImageSubresource.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkImageSubresource.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresource.prototype.reflect = function reflect(memoryAddress) {
  
};

VkImageSubresource.byteLength = 0xC;

VkImageSubresource.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  mipLevel: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  arrayLayer: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkImageSubresourceLayers **/
function VkImageSubresourceLayers(opts) {
  if (new.target !== VkImageSubresourceLayers) {
    _VkImageSubresourceLayers.reset();
    return _VkImageSubresourceLayers;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

Object.defineProperties(VkImageSubresourceLayers.prototype, {
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "mipLevel": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.mipLevel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "baseArrayLayer": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.baseArrayLayer': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "layerCount": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.layerCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x3] = value;
    }
    },
  
});

VkImageSubresourceLayers.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
  
};

VkImageSubresourceLayers.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresourceLayers.prototype.reflect = function reflect(memoryAddress) {
  
};

VkImageSubresourceLayers.byteLength = 0x10;

VkImageSubresourceLayers.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  mipLevel: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  baseArrayLayer: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  layerCount: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkImageSubresourceRange **/
function VkImageSubresourceRange(opts) {
  if (new.target !== VkImageSubresourceRange) {
    _VkImageSubresourceRange.reset();
    return _VkImageSubresourceRange;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x14) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x14);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.baseMipLevel !== void 0) this.baseMipLevel = opts.baseMipLevel;
    if (opts.levelCount !== void 0) this.levelCount = opts.levelCount;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

Object.defineProperties(VkImageSubresourceRange.prototype, {
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "baseMipLevel": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.baseMipLevel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "levelCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.levelCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "baseArrayLayer": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.baseArrayLayer': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x3] = value;
    }
    },
  "layerCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.layerCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkImageSubresourceRange.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x14], 0x0);
  
  
  
  
  
  
};

VkImageSubresourceRange.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresourceRange.prototype.reflect = function reflect(memoryAddress) {
  
};

VkImageSubresourceRange.byteLength = 0x14;

VkImageSubresourceRange.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  baseMipLevel: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  levelCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  baseArrayLayer: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  layerCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkMemoryBarrier **/
function VkMemoryBarrier(opts) {
  if (new.target !== VkMemoryBarrier) {
    _VkMemoryBarrier.reset();
    return _VkMemoryBarrier;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x2E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    
  }
};

Object.defineProperties(VkMemoryBarrier.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryBarrier.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryBarrier.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryBarrier.pNext' isn't allowed to be filled");
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryBarrier.srcAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryBarrier.dstAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  
});

VkMemoryBarrier.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x2E;
};

VkMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryBarrier.byteLength = 0x18;

VkMemoryBarrier.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcAccessMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstAccessMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkBufferMemoryBarrier **/
function VkBufferMemoryBarrier(opts) {
  if (new.target !== VkBufferMemoryBarrier) {
    _VkBufferMemoryBarrier.reset();
    return _VkBufferMemoryBarrier;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._buffer = null;
  
  
  this.sType = 0x2C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
    if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkBufferMemoryBarrier.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferMemoryBarrier.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferMemoryBarrier.pNext' isn't allowed to be filled");
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.srcAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.dstAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "srcQueueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.srcQueueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "dstQueueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.dstQueueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x5];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x5] = BigInt(value);
    }
    },
  "size": {
    get() {
    return this.memoryViewBigUint64[0x6];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.size': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x6] = BigInt(value);
    }
    },
  
});

VkBufferMemoryBarrier.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._buffer = null;
  
  
  this.sType = 0x2C;
};

VkBufferMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferMemoryBarrier.byteLength = 0x38;

VkBufferMemoryBarrier.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcAccessMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstAccessMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  srcQueueFamilyIndex: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  dstQueueFamilyIndex: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  buffer: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  offset: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  size: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
};
/** VkImageMemoryBarrier **/
function VkImageMemoryBarrier(opts) {
  if (new.target !== VkImageMemoryBarrier) {
    _VkImageMemoryBarrier.reset();
    return _VkImageMemoryBarrier;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._image = null;
  this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x30 });
  this.sType = 0x2D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.oldLayout !== void 0) this.oldLayout = opts.oldLayout;
    if (opts.newLayout !== void 0) this.newLayout = opts.newLayout;
    if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
    if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
    
  }
};

Object.defineProperties(VkImageMemoryBarrier.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageMemoryBarrier.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
      switch (sType) {
          
        case 0x3B9CF898:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
    }
    
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.srcAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.dstAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "oldLayout": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.oldLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkImageMemoryBarrier.oldLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "newLayout": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.newLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkImageMemoryBarrier.newLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "srcQueueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.srcQueueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "dstQueueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.dstQueueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x9] = value;
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subresourceRange": {
    get() {
    return this._subresourceRange;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceRange) {
      value.flush();
      this._subresourceRange = value;
      
      
    } else if (value === null) {
      this._subresourceRange = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.subresourceRange': Expected 'VkImageSubresourceRange' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageMemoryBarrier.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this._image = null;
  this._subresourceRange = null;
  this.sType = 0x2D;
};

VkImageMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._subresourceRange !== null) {
    let subresourceRange = this._subresourceRange;
    subresourceRange.flush();
    if (this.memoryBuffer !== subresourceRange.memoryBuffer) {
      let srcView = new Uint8Array(subresourceRange.memoryBuffer).subarray(subresourceRange.$memoryOffset, subresourceRange.$memoryOffset + 0x14);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x30);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageMemoryBarrier.subresourceRange' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkImageMemoryBarrier.byteLength = 0x48;

VkImageMemoryBarrier.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcAccessMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstAccessMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  oldLayout: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  newLayout: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  srcQueueFamilyIndex: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  dstQueueFamilyIndex: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  image: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  subresourceRange: {
    byteOffset: 0x30,
    byteLength: 0x14
  },
};
/** VkImageCreateInfo **/
function VkImageCreateInfo(opts) {
  if (new.target !== VkImageCreateInfo) {
    _VkImageCreateInfo.reset();
    return _VkImageCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x58) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x58);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x1C });
  
  
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  this.sType = 0xE;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.imageType !== void 0) this.imageType = opts.imageType;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.mipLevels !== void 0) this.mipLevels = opts.mipLevels;
    if (opts.arrayLayers !== void 0) this.arrayLayers = opts.arrayLayers;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    
  }
};

Object.defineProperties(VkImageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B2F90:
        case 0x3B9BA4C0:
        case 0x3B9BE341:
        case 0x3B9BB468:
        case 0x3B9D0838:
        case 0x3B9CC1ED:
        case 0x3B9D3333:
        case 0x3B9D3334:
        case 0x3B9E8AF0:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "imageType": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.imageType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageType(value)) {
      throw new RangeError("Invalid value for 'VkImageCreateInfo.imageType': '" + value + "' is not a value of 'VkImageType'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkImageCreateInfo.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mipLevels": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.mipLevels': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "arrayLayers": {
    get() {
    return this.memoryViewUint32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.arrayLayers': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xB] = value;
    }
    },
  "samples": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.samples': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "tiling": {
    get() {
    return this.memoryViewInt32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.tiling': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageTiling(value)) {
      throw new RangeError("Invalid value for 'VkImageCreateInfo.tiling': '" + value + "' is not a value of 'VkImageTiling'");
    }
    this.memoryViewInt32[0xD] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xE] = value;
    }
    },
  "sharingMode": {
    get() {
    return this.memoryViewInt32[0xF];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.sharingMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSharingMode(value)) {
      throw new RangeError("Invalid value for 'VkImageCreateInfo.sharingMode': '" + value + "' is not a value of 'VkSharingMode'");
    }
    this.memoryViewInt32[0xF] = value;
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.queueFamilyIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x9] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "initialLayout": {
    get() {
    return this.memoryViewInt32[0x14];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.initialLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkImageCreateInfo.initialLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x14] = value;
    }
    },
  
});

VkImageCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x58], 0x0);
  
  this._pNext = null;
  
  
  
  this._extent = null;
  
  
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  this.sType = 0xE;
};

VkImageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer).subarray(extent.$memoryOffset, extent.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCreateInfo.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkImageCreateInfo.byteLength = 0x58;

VkImageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  imageType: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  format: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  extent: {
    byteOffset: 0x1C,
    byteLength: 0xC
  },
  mipLevels: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  arrayLayers: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  samples: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  tiling: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  sharingMode: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  queueFamilyIndexCount: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  pQueueFamilyIndices: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  initialLayout: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
};
/** VkSubresourceLayout **/
function VkSubresourceLayout(opts) {
  if (new.target !== VkSubresourceLayout) {
    _VkSubresourceLayout.reset();
    return _VkSubresourceLayout;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSubresourceLayout.prototype, {
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    },
  "size": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    },
  "rowPitch": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    },
  "arrayPitch": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  "depthPitch": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    },
  
});

VkSubresourceLayout.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  
  
  
  
  
};

VkSubresourceLayout.prototype.flush = function flush() {
  
  return true;
};

VkSubresourceLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
};

VkSubresourceLayout.byteLength = 0x28;

VkSubresourceLayout.memoryLayout = {
  offset: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  size: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  rowPitch: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  arrayPitch: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  depthPitch: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkImageViewCreateInfo **/
function VkImageViewCreateInfo(opts) {
  if (new.target !== VkImageViewCreateInfo) {
    _VkImageViewCreateInfo.reset();
    return _VkImageViewCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x50) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x50);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._image = null;
  
  
  this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x28 });
  this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x38 });
  this.sType = 0xF;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.viewType !== void 0) this.viewType = opts.viewType;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
    
  }
};

Object.defineProperties(VkImageViewCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C930A:
        case 0x3B9D2B61:
        case 0x3B9BCFB8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "viewType": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.viewType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageViewType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewCreateInfo.viewType': '" + value + "' is not a value of 'VkImageViewType'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkImageViewCreateInfo.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "components": {
    get() {
    return this._components;
    },
    set(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.components': Expected 'VkComponentMapping' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subresourceRange": {
    get() {
    return this._subresourceRange;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceRange) {
      value.flush();
      this._subresourceRange = value;
      
      
    } else if (value === null) {
      this._subresourceRange = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.subresourceRange': Expected 'VkImageSubresourceRange' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageViewCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x50], 0x0);
  
  this._pNext = null;
  
  this._image = null;
  
  
  this._components = null;
  this._subresourceRange = null;
  this.sType = 0xF;
};

VkImageViewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    let components = this._components;
    components.flush();
    if (this.memoryBuffer !== components.memoryBuffer) {
      let srcView = new Uint8Array(components.memoryBuffer).subarray(components.$memoryOffset, components.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageViewCreateInfo.components' isn't used as shared-memory");
    }
  }
  
  
  if (this._subresourceRange !== null) {
    let subresourceRange = this._subresourceRange;
    subresourceRange.flush();
    if (this.memoryBuffer !== subresourceRange.memoryBuffer) {
      let srcView = new Uint8Array(subresourceRange.memoryBuffer).subarray(subresourceRange.$memoryOffset, subresourceRange.$memoryOffset + 0x14);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x38);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageViewCreateInfo.subresourceRange' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageViewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkImageViewCreateInfo.byteLength = 0x50;

VkImageViewCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  image: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  viewType: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  format: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  components: {
    byteOffset: 0x28,
    byteLength: 0x10
  },
  subresourceRange: {
    byteOffset: 0x38,
    byteLength: 0x14
  },
};
/** VkBufferCopy **/
function VkBufferCopy(opts) {
  if (new.target !== VkBufferCopy) {
    _VkBufferCopy.reset();
    return _VkBufferCopy;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkBufferCopy.prototype, {
  "srcOffset": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCopy.srcOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x0] = BigInt(value);
    }
    },
  "dstOffset": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCopy.dstOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x1] = BigInt(value);
    }
    },
  "size": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCopy.size': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  
});

VkBufferCopy.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  
  
};

VkBufferCopy.prototype.flush = function flush() {
  
  return true;
};

VkBufferCopy.prototype.reflect = function reflect(memoryAddress) {
  
};

VkBufferCopy.byteLength = 0x18;

VkBufferCopy.memoryLayout = {
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  dstOffset: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  size: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSparseMemoryBind **/
function VkSparseMemoryBind(opts) {
  if (new.target !== VkSparseMemoryBind) {
    _VkSparseMemoryBind.reset();
    return _VkSparseMemoryBind;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  this._memory = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.resourceOffset !== void 0) this.resourceOffset = opts.resourceOffset;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkSparseMemoryBind.prototype, {
  "resourceOffset": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.resourceOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x0] = BigInt(value);
    }
    },
  "size": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.size': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x1] = BigInt(value);
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkSparseMemoryBind.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  
  this._memory = null;
  
  
  
};

VkSparseMemoryBind.prototype.flush = function flush() {
  
  return true;
};

VkSparseMemoryBind.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSparseMemoryBind.byteLength = 0x28;

VkSparseMemoryBind.memoryLayout = {
  resourceOffset: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  size: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkSparseImageMemoryBind **/
function VkSparseImageMemoryBind(opts) {
  if (new.target !== VkSparseImageMemoryBind) {
    _VkSparseImageMemoryBind.reset();
    return _VkSparseImageMemoryBind;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  this._subresource = new VkImageSubresource({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._offset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0xC });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  this._memory = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.subresource !== void 0) this.subresource = opts.subresource;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkSparseImageMemoryBind.prototype, {
  "subresource": {
    get() {
    return this._subresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresource) {
      value.flush();
      this._subresource = value;
      
      
    } else if (value === null) {
      this._subresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.subresource': Expected 'VkImageSubresource' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this._offset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.offset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x6];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x6] = BigInt(value);
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xE] = value;
    }
    },
  
});

VkSparseImageMemoryBind.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  this._subresource = null;
  this._offset = null;
  this._extent = null;
  this._memory = null;
  
  
  
};

VkSparseImageMemoryBind.prototype.flush = function flush() {
  
  
  if (this._subresource !== null) {
    let subresource = this._subresource;
    subresource.flush();
    if (this.memoryBuffer !== subresource.memoryBuffer) {
      let srcView = new Uint8Array(subresource.memoryBuffer).subarray(subresource.$memoryOffset, subresource.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSparseImageMemoryBind.subresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._offset !== null) {
    let offset = this._offset;
    offset.flush();
    if (this.memoryBuffer !== offset.memoryBuffer) {
      let srcView = new Uint8Array(offset.memoryBuffer).subarray(offset.$memoryOffset, offset.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0xC);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSparseImageMemoryBind.offset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer).subarray(extent.$memoryOffset, extent.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSparseImageMemoryBind.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSparseImageMemoryBind.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkSparseImageMemoryBind.byteLength = 0x40;

VkSparseImageMemoryBind.memoryLayout = {
  subresource: {
    byteOffset: 0x0,
    byteLength: 0xC
  },
  offset: {
    byteOffset: 0xC,
    byteLength: 0xC
  },
  extent: {
    byteOffset: 0x18,
    byteLength: 0xC
  },
  memory: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkSparseBufferMemoryBindInfo **/
function VkSparseBufferMemoryBindInfo(opts) {
  if (new.target !== VkSparseBufferMemoryBindInfo) {
    _VkSparseBufferMemoryBindInfo.reset();
    return _VkSparseBufferMemoryBindInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._buffer = null;
  
  this._pBinds = null;
    this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

Object.defineProperties(VkSparseBufferMemoryBindInfo.prototype, {
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "bindCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.bindCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "pBinds": {
    get() {
    return this._pBinds;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.pBinds': Expected 'Array VkSparseMemoryBind' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSparseBufferMemoryBindInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._buffer = null;
  
  this._pBinds = null;
    this._pBindsNative = null;
  
};

VkSparseBufferMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseBufferMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseMemoryBind)) {
        throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseMemoryBind' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindsNative = nativeArray;
      this.memoryViewBigInt64[0x2] = nativeArray.address;
    } else {
      this._pBindsNative = null;
      this.memoryViewBigInt64[0x2] = BI0;
    }
  }
  
  return true;
};

VkSparseBufferMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSparseBufferMemoryBindInfo.byteLength = 0x18;

VkSparseBufferMemoryBindInfo.memoryLayout = {
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  bindCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  pBinds: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSparseImageOpaqueMemoryBindInfo **/
function VkSparseImageOpaqueMemoryBindInfo(opts) {
  if (new.target !== VkSparseImageOpaqueMemoryBindInfo) {
    _VkSparseImageOpaqueMemoryBindInfo.reset();
    return _VkSparseImageOpaqueMemoryBindInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._image = null;
  
  this._pBinds = null;
    this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

Object.defineProperties(VkSparseImageOpaqueMemoryBindInfo.prototype, {
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "bindCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.bindCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "pBinds": {
    get() {
    return this._pBinds;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.pBinds': Expected 'Array VkSparseMemoryBind' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSparseImageOpaqueMemoryBindInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._image = null;
  
  this._pBinds = null;
    this._pBindsNative = null;
  
};

VkSparseImageOpaqueMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseImageOpaqueMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseMemoryBind)) {
        throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseMemoryBind' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindsNative = nativeArray;
      this.memoryViewBigInt64[0x2] = nativeArray.address;
    } else {
      this._pBindsNative = null;
      this.memoryViewBigInt64[0x2] = BI0;
    }
  }
  
  return true;
};

VkSparseImageOpaqueMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSparseImageOpaqueMemoryBindInfo.byteLength = 0x18;

VkSparseImageOpaqueMemoryBindInfo.memoryLayout = {
  image: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  bindCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  pBinds: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSparseImageMemoryBindInfo **/
function VkSparseImageMemoryBindInfo(opts) {
  if (new.target !== VkSparseImageMemoryBindInfo) {
    _VkSparseImageMemoryBindInfo.reset();
    return _VkSparseImageMemoryBindInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._image = null;
  
  this._pBinds = null;
    this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

Object.defineProperties(VkSparseImageMemoryBindInfo.prototype, {
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "bindCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.bindCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "pBinds": {
    get() {
    return this._pBinds;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.pBinds': Expected 'Array VkSparseImageMemoryBind' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSparseImageMemoryBindInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._image = null;
  
  this._pBinds = null;
    this._pBindsNative = null;
  
};

VkSparseImageMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseImageMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseImageMemoryBind)) {
        throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseImageMemoryBind' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindsNative = nativeArray;
      this.memoryViewBigInt64[0x2] = nativeArray.address;
    } else {
      this._pBindsNative = null;
      this.memoryViewBigInt64[0x2] = BI0;
    }
  }
  
  return true;
};

VkSparseImageMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSparseImageMemoryBindInfo.byteLength = 0x18;

VkSparseImageMemoryBindInfo.memoryLayout = {
  image: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  bindCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  pBinds: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkBindSparseInfo **/
function VkBindSparseInfo(opts) {
  if (new.target !== VkBindSparseInfo) {
    _VkBindSparseInfo.reset();
    return _VkBindSparseInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x60) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x60);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
  
  this._pBufferBinds = null;
    this._pBufferBindsNative = null;
  
  this._pImageOpaqueBinds = null;
    this._pImageOpaqueBindsNative = null;
  
  this._pImageBinds = null;
    this._pImageBindsNative = null;
  
  this._pSignalSemaphores = null;
    this._pSignalSemaphoresNative = null;
  this.sType = 0x7;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.bufferBindCount !== void 0) this.bufferBindCount = opts.bufferBindCount;
    if (opts.pBufferBinds !== void 0) this.pBufferBinds = opts.pBufferBinds;
    if (opts.imageOpaqueBindCount !== void 0) this.imageOpaqueBindCount = opts.imageOpaqueBindCount;
    if (opts.pImageOpaqueBinds !== void 0) this.pImageOpaqueBinds = opts.pImageOpaqueBinds;
    if (opts.imageBindCount !== void 0) this.imageBindCount = opts.imageBindCount;
    if (opts.pImageBinds !== void 0) this.pImageBinds = opts.pImageBinds;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
    
  }
};

Object.defineProperties(VkBindSparseInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindSparseInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB466:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
    }
    
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.waitSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pWaitSemaphores": {
    get() {
    return this._pWaitSemaphores;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "bufferBindCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.bufferBindCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pBufferBinds": {
    get() {
    return this._pBufferBinds;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBufferBinds = value;
    } else if (value === null) {
      this._pBufferBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pBufferBinds': Expected 'Array VkSparseBufferMemoryBindInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "imageOpaqueBindCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.imageOpaqueBindCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pImageOpaqueBinds": {
    get() {
    return this._pImageOpaqueBinds;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageOpaqueBinds = value;
    } else if (value === null) {
      this._pImageOpaqueBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageOpaqueBinds': Expected 'Array VkSparseImageOpaqueMemoryBindInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "imageBindCount": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.imageBindCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  "pImageBinds": {
    get() {
    return this._pImageBinds;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageBinds = value;
    } else if (value === null) {
      this._pImageBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageBinds': Expected 'Array VkSparseImageMemoryBindInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0x14];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.signalSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x14] = value;
    }
    },
  "pSignalSemaphores": {
    get() {
    return this._pSignalSemaphores;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSignalSemaphores = value;
    } else if (value === null) {
      this._pSignalSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pSignalSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkBindSparseInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x60], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
  
  this._pBufferBinds = null;
    this._pBufferBindsNative = null;
  
  this._pImageOpaqueBinds = null;
    this._pImageOpaqueBindsNative = null;
  
  this._pImageBinds = null;
    this._pImageBindsNative = null;
  
  this._pSignalSemaphores = null;
    this._pSignalSemaphoresNative = null;
  this.sType = 0x7;
};

VkBindSparseInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkBindSparseInfo.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pWaitSemaphoresNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pWaitSemaphoresNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pBufferBinds !== null) {
    let array = this._pBufferBinds;
    
    if (array.length !== this.bufferBindCount) {
      throw new RangeError("Invalid array length, expected length of 'bufferBindCount' for 'VkBindSparseInfo.pBufferBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseBufferMemoryBindInfo)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pBufferBinds[" + ii + "]': Expected 'VkSparseBufferMemoryBindInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBufferBindsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pBufferBindsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  
  if (this._pImageOpaqueBinds !== null) {
    let array = this._pImageOpaqueBinds;
    
    if (array.length !== this.imageOpaqueBindCount) {
      throw new RangeError("Invalid array length, expected length of 'imageOpaqueBindCount' for 'VkBindSparseInfo.pImageOpaqueBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseImageOpaqueMemoryBindInfo)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageOpaqueBinds[" + ii + "]': Expected 'VkSparseImageOpaqueMemoryBindInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImageOpaqueBindsNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pImageOpaqueBindsNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  
  if (this._pImageBinds !== null) {
    let array = this._pImageBinds;
    
    if (array.length !== this.imageBindCount) {
      throw new RangeError("Invalid array length, expected length of 'imageBindCount' for 'VkBindSparseInfo.pImageBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseImageMemoryBindInfo)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageBinds[" + ii + "]': Expected 'VkSparseImageMemoryBindInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImageBindsNative = nativeArray;
      this.memoryViewBigInt64[0x9] = nativeArray.address;
    } else {
      this._pImageBindsNative = null;
      this.memoryViewBigInt64[0x9] = BI0;
    }
  }
  
  
  if (this._pSignalSemaphores !== null) {
    let array = this._pSignalSemaphores;
    
    if (array.length !== this.signalSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'signalSemaphoreCount' for 'VkBindSparseInfo.pSignalSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pSignalSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSignalSemaphoresNative = nativeArray;
      this.memoryViewBigInt64[0xB] = nativeArray.address;
    } else {
      this._pSignalSemaphoresNative = null;
      this.memoryViewBigInt64[0xB] = BI0;
    }
  }
  
  return true;
};

VkBindSparseInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
  
  
};

VkBindSparseInfo.byteLength = 0x60;

VkBindSparseInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  waitSemaphoreCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pWaitSemaphores: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  bufferBindCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pBufferBinds: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  imageOpaqueBindCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pImageOpaqueBinds: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  imageBindCount: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  pImageBinds: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  signalSemaphoreCount: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  pSignalSemaphores: {
    byteOffset: 0x58,
    byteLength: 0x8
  },
};
/** VkImageCopy **/
function VkImageCopy(opts) {
  if (new.target !== VkImageCopy) {
    _VkImageCopy.reset();
    return _VkImageCopy;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x44) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x44);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x1C });
  this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x2C });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x38 });
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkImageCopy.prototype, {
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffset": {
    get() {
    return this._srcOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.srcOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffset": {
    get() {
    return this._dstOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.dstOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageCopy.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x44], 0x0);
  this._srcSubresource = null;
  this._srcOffset = null;
  this._dstSubresource = null;
  this._dstOffset = null;
  this._extent = null;
  
};

VkImageCopy.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer).subarray(srcSubresource.$memoryOffset, srcSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffset !== null) {
    let srcOffset = this._srcOffset;
    srcOffset.flush();
    if (this.memoryBuffer !== srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(srcOffset.memoryBuffer).subarray(srcOffset.$memoryOffset, srcOffset.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.srcOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer).subarray(dstSubresource.$memoryOffset, dstSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffset !== null) {
    let dstOffset = this._dstOffset;
    dstOffset.flush();
    if (this.memoryBuffer !== dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(dstOffset.memoryBuffer).subarray(dstOffset.$memoryOffset, dstOffset.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.dstOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer).subarray(extent.$memoryOffset, extent.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x38);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageCopy.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
};

VkImageCopy.byteLength = 0x44;

VkImageCopy.memoryLayout = {
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  srcOffset: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
  dstSubresource: {
    byteOffset: 0x1C,
    byteLength: 0x10
  },
  dstOffset: {
    byteOffset: 0x2C,
    byteLength: 0xC
  },
  extent: {
    byteOffset: 0x38,
    byteLength: 0xC
  },
};
/** VkImageBlit **/
function VkImageBlit(opts) {
  if (new.target !== VkImageBlit) {
    _VkImageBlit.reset();
    return _VkImageBlit;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x50) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x50);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 + (i * 0xC) }));
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x28 });
  this._dstOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x38 + (i * 0xC) }));
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffsets !== void 0) this.srcOffsets = opts.srcOffsets;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffsets !== void 0) this.dstOffsets = opts.dstOffsets;
    
  }
};

Object.defineProperties(VkImageBlit.prototype, {
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffsets": {
    get() {
    return this._srcOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._srcOffsets = value;
    } else if (value === null) {
      this._srcOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.srcOffsets': Expected 'Array VkOffset3D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffsets": {
    get() {
    return this._dstOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._dstOffsets = value;
    } else if (value === null) {
      this._dstOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.dstOffsets': Expected 'Array VkOffset3D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkImageBlit.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x50], 0x0);
  this._srcSubresource = null;
  this._srcOffsets = null;
  this._dstSubresource = null;
  this._dstOffsets = null;
  
};

VkImageBlit.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer).subarray(srcSubresource.$memoryOffset, srcSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageBlit.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffsets !== null) {
    let array = this._srcOffsets;
    
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit.srcOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkOffset3D)) {
        throw new TypeError("Invalid type for 'VkImageBlit.srcOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x10;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer).subarray(dstSubresource.$memoryOffset, dstSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageBlit.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffsets !== null) {
    let array = this._dstOffsets;
    
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit.dstOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkOffset3D)) {
        throw new TypeError("Invalid type for 'VkImageBlit.dstOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x38;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  return true;
};

VkImageBlit.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkImageBlit.byteLength = 0x50;

VkImageBlit.memoryLayout = {
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  srcOffsets: {
    byteOffset: 0x10,
    byteLength: 0x18
  },
  dstSubresource: {
    byteOffset: 0x28,
    byteLength: 0x10
  },
  dstOffsets: {
    byteOffset: 0x38,
    byteLength: 0x18
  },
};
/** VkBufferImageCopy **/
function VkBufferImageCopy(opts) {
  if (new.target !== VkBufferImageCopy) {
    _VkBufferImageCopy.reset();
    return _VkBufferImageCopy;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  this._imageSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._imageOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x20 });
  this._imageExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x2C });
  
  if (typeof opts === "object") {
    if (opts.bufferOffset !== void 0) this.bufferOffset = opts.bufferOffset;
    if (opts.bufferRowLength !== void 0) this.bufferRowLength = opts.bufferRowLength;
    if (opts.bufferImageHeight !== void 0) this.bufferImageHeight = opts.bufferImageHeight;
    if (opts.imageSubresource !== void 0) this.imageSubresource = opts.imageSubresource;
    if (opts.imageOffset !== void 0) this.imageOffset = opts.imageOffset;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

Object.defineProperties(VkBufferImageCopy.prototype, {
  "bufferOffset": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.bufferOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x0] = BigInt(value);
    }
    },
  "bufferRowLength": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.bufferRowLength': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "bufferImageHeight": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.bufferImageHeight': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x3] = value;
    }
    },
  "imageSubresource": {
    get() {
    return this._imageSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._imageSubresource = value;
      
      
    } else if (value === null) {
      this._imageSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageOffset": {
    get() {
    return this._imageOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._imageOffset = value;
      
      
    } else if (value === null) {
      this._imageOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageExtent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferImageCopy.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  
  
  this._imageSubresource = null;
  this._imageOffset = null;
  this._imageExtent = null;
  
};

VkBufferImageCopy.prototype.flush = function flush() {
  
  
  if (this._imageSubresource !== null) {
    let imageSubresource = this._imageSubresource;
    imageSubresource.flush();
    if (this.memoryBuffer !== imageSubresource.memoryBuffer) {
      let srcView = new Uint8Array(imageSubresource.memoryBuffer).subarray(imageSubresource.$memoryOffset, imageSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy.imageSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._imageOffset !== null) {
    let imageOffset = this._imageOffset;
    imageOffset.flush();
    if (this.memoryBuffer !== imageOffset.memoryBuffer) {
      let srcView = new Uint8Array(imageOffset.memoryBuffer).subarray(imageOffset.$memoryOffset, imageOffset.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy.imageOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer).subarray(imageExtent.$memoryOffset, imageExtent.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkBufferImageCopy.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkBufferImageCopy.byteLength = 0x38;

VkBufferImageCopy.memoryLayout = {
  bufferOffset: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  bufferRowLength: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  bufferImageHeight: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  imageSubresource: {
    byteOffset: 0x10,
    byteLength: 0x10
  },
  imageOffset: {
    byteOffset: 0x20,
    byteLength: 0xC
  },
  imageExtent: {
    byteOffset: 0x2C,
    byteLength: 0xC
  },
};
/** VkImageResolve **/
function VkImageResolve(opts) {
  if (new.target !== VkImageResolve) {
    _VkImageResolve.reset();
    return _VkImageResolve;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x44) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x44);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x1C });
  this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x2C });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x38 });
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkImageResolve.prototype, {
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffset": {
    get() {
    return this._srcOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.srcOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffset": {
    get() {
    return this._dstOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.dstOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageResolve.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x44], 0x0);
  this._srcSubresource = null;
  this._srcOffset = null;
  this._dstSubresource = null;
  this._dstOffset = null;
  this._extent = null;
  
};

VkImageResolve.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer).subarray(srcSubresource.$memoryOffset, srcSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffset !== null) {
    let srcOffset = this._srcOffset;
    srcOffset.flush();
    if (this.memoryBuffer !== srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(srcOffset.memoryBuffer).subarray(srcOffset.$memoryOffset, srcOffset.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.srcOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer).subarray(dstSubresource.$memoryOffset, dstSubresource.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffset !== null) {
    let dstOffset = this._dstOffset;
    dstOffset.flush();
    if (this.memoryBuffer !== dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(dstOffset.memoryBuffer).subarray(dstOffset.$memoryOffset, dstOffset.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.dstOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer).subarray(extent.$memoryOffset, extent.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x38);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageResolve.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
};

VkImageResolve.byteLength = 0x44;

VkImageResolve.memoryLayout = {
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  srcOffset: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
  dstSubresource: {
    byteOffset: 0x1C,
    byteLength: 0x10
  },
  dstOffset: {
    byteOffset: 0x2C,
    byteLength: 0xC
  },
  extent: {
    byteOffset: 0x38,
    byteLength: 0xC
  },
};
/** VkShaderModuleCreateInfo **/
function VkShaderModuleCreateInfo(opts) {
  if (new.target !== VkShaderModuleCreateInfo) {
    _VkShaderModuleCreateInfo.reset();
    return _VkShaderModuleCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pCode = null;
  this.sType = 0x10;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.codeSize !== void 0) this.codeSize = opts.codeSize;
    if (opts.pCode !== void 0) this.pCode = opts.pCode;
    
  }
};

Object.defineProperties(VkShaderModuleCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkShaderModuleCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D3B01:
          break;
        default:
          throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "codeSize": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.codeSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  "pCode": {
    get() {
    return this._pCode;
    },
    set(value) {
    if (value !== null && value.constructor === Uint8Array) {
      this._pCode = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCode = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pCode': Expected 'Uint8Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkShaderModuleCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._pCode = null;
  this.sType = 0x10;
};

VkShaderModuleCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkShaderModuleCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkShaderModuleCreateInfo.byteLength = 0x28;

VkShaderModuleCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  codeSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pCode: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkDescriptorSetLayoutBinding **/
function VkDescriptorSetLayoutBinding(opts) {
  if (new.target !== VkDescriptorSetLayoutBinding) {
    _VkDescriptorSetLayoutBinding.reset();
    return _VkDescriptorSetLayoutBinding;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  this._pImmutableSamplers = null;
    this._pImmutableSamplersNative = null;
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    if (opts.pImmutableSamplers !== void 0) this.pImmutableSamplers = opts.pImmutableSamplers;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutBinding.prototype, {
  "binding": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.binding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "descriptorType": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.descriptorType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetLayoutBinding.descriptorType': '" + value + "' is not a value of 'VkDescriptorType'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.descriptorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "stageFlags": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.stageFlags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "pImmutableSamplers": {
    get() {
    return this._pImmutableSamplers;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImmutableSamplers = value;
    } else if (value === null) {
      this._pImmutableSamplers = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.pImmutableSamplers': Expected 'Array VkSampler' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorSetLayoutBinding.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  
  
  this._pImmutableSamplers = null;
    this._pImmutableSamplersNative = null;
  
};

VkDescriptorSetLayoutBinding.prototype.flush = function flush() {
  
  
  if (this._pImmutableSamplers !== null) {
    let array = this._pImmutableSamplers;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkDescriptorSetLayoutBinding.pImmutableSamplers'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSampler)) {
        throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.pImmutableSamplers[" + ii + "]': Expected 'VkSampler' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImmutableSamplersNative = nativeArray;
      this.memoryViewBigInt64[0x2] = nativeArray.address;
    } else {
      this._pImmutableSamplersNative = null;
      this.memoryViewBigInt64[0x2] = BI0;
    }
  }
  
  return true;
};

VkDescriptorSetLayoutBinding.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorSetLayoutBinding.byteLength = 0x18;

VkDescriptorSetLayoutBinding.memoryLayout = {
  binding: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  descriptorType: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  descriptorCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  stageFlags: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  pImmutableSamplers: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkDescriptorSetLayoutCreateInfo **/
function VkDescriptorSetLayoutCreateInfo(opts) {
  if (new.target !== VkDescriptorSetLayoutCreateInfo) {
    _VkDescriptorSetLayoutCreateInfo.reset();
    return _VkDescriptorSetLayoutCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pBindings = null;
    this._pBindingsNative = null;
  this.sType = 0x20;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindings !== void 0) this.pBindings = opts.pBindings;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetLayoutCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D3EE8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "bindingCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.bindingCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pBindings": {
    get() {
    return this._pBindings;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBindings = value;
    } else if (value === null) {
      this._pBindings = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pBindings': Expected 'Array VkDescriptorSetLayoutBinding' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorSetLayoutCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pBindings = null;
    this._pBindingsNative = null;
  this.sType = 0x20;
};

VkDescriptorSetLayoutCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pBindings !== null) {
    let array = this._pBindings;
    
    if (array.length !== this.bindingCount) {
      throw new RangeError("Invalid array length, expected length of 'bindingCount' for 'VkDescriptorSetLayoutCreateInfo.pBindings'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorSetLayoutBinding)) {
        throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pBindings[" + ii + "]': Expected 'VkDescriptorSetLayoutBinding' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindingsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pBindingsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDescriptorSetLayoutCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorSetLayoutCreateInfo.byteLength = 0x20;

VkDescriptorSetLayoutCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  bindingCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pBindings: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorPoolSize **/
function VkDescriptorPoolSize(opts) {
  if (new.target !== VkDescriptorPoolSize) {
    _VkDescriptorPoolSize.reset();
    return _VkDescriptorPoolSize;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    
  }
};

Object.defineProperties(VkDescriptorPoolSize.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolSize.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorPoolSize.type': '" + value + "' is not a value of 'VkDescriptorType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolSize.descriptorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  
});

VkDescriptorPoolSize.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkDescriptorPoolSize.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorPoolSize.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorPoolSize.byteLength = 0x8;

VkDescriptorPoolSize.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  descriptorCount: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkDescriptorPoolCreateInfo **/
function VkDescriptorPoolCreateInfo(opts) {
  if (new.target !== VkDescriptorPoolCreateInfo) {
    _VkDescriptorPoolCreateInfo.reset();
    return _VkDescriptorPoolCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._pPoolSizes = null;
    this._pPoolSizesNative = null;
  this.sType = 0x21;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.maxSets !== void 0) this.maxSets = opts.maxSets;
    if (opts.poolSizeCount !== void 0) this.poolSizeCount = opts.poolSizeCount;
    if (opts.pPoolSizes !== void 0) this.pPoolSizes = opts.pPoolSizes;
    
  }
};

Object.defineProperties(VkDescriptorPoolCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorPoolCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9CE513:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "maxSets": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.maxSets': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "poolSizeCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.poolSizeCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pPoolSizes": {
    get() {
    return this._pPoolSizes;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPoolSizes = value;
    } else if (value === null) {
      this._pPoolSizes = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pPoolSizes': Expected 'Array VkDescriptorPoolSize' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorPoolCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  this._pPoolSizes = null;
    this._pPoolSizesNative = null;
  this.sType = 0x21;
};

VkDescriptorPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPoolSizes !== null) {
    let array = this._pPoolSizes;
    
    if (array.length !== this.poolSizeCount) {
      throw new RangeError("Invalid array length, expected length of 'poolSizeCount' for 'VkDescriptorPoolCreateInfo.pPoolSizes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorPoolSize)) {
        throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pPoolSizes[" + ii + "]': Expected 'VkDescriptorPoolSize' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPoolSizesNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pPoolSizesNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkDescriptorPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorPoolCreateInfo.byteLength = 0x28;

VkDescriptorPoolCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxSets: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  poolSizeCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pPoolSizes: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkDescriptorSetAllocateInfo **/
function VkDescriptorSetAllocateInfo(opts) {
  if (new.target !== VkDescriptorSetAllocateInfo) {
    _VkDescriptorSetAllocateInfo.reset();
    return _VkDescriptorSetAllocateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._descriptorPool = null;
  
  this._pSetLayouts = null;
    this._pSetLayoutsNative = null;
  this.sType = 0x22;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorPool !== void 0) this.descriptorPool = opts.descriptorPool;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
    
  }
};

Object.defineProperties(VkDescriptorSetAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetAllocateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D3EEB:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
    }
    
    }
    },
  "descriptorPool": {
    get() {
    return this._descriptorPool;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorPool) {
      
      this._descriptorPool = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorPool = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.descriptorPool': Expected 'VkDescriptorPool' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "descriptorSetCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.descriptorSetCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pSetLayouts": {
    get() {
    return this._pSetLayouts;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSetLayouts = value;
    } else if (value === null) {
      this._pSetLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pSetLayouts': Expected 'Array VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorSetAllocateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._descriptorPool = null;
  
  this._pSetLayouts = null;
    this._pSetLayoutsNative = null;
  this.sType = 0x22;
};

VkDescriptorSetAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSetLayouts !== null) {
    let array = this._pSetLayouts;
    
    if (array.length !== this.descriptorSetCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorSetCount' for 'VkDescriptorSetAllocateInfo.pSetLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorSetLayout)) {
        throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pSetLayouts[" + ii + "]': Expected 'VkDescriptorSetLayout' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSetLayoutsNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pSetLayoutsNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkDescriptorSetAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorSetAllocateInfo.byteLength = 0x28;

VkDescriptorSetAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  descriptorPool: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  descriptorSetCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pSetLayouts: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkSpecializationMapEntry **/
function VkSpecializationMapEntry(opts) {
  if (new.target !== VkSpecializationMapEntry) {
    _VkSpecializationMapEntry.reset();
    return _VkSpecializationMapEntry;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.constantID !== void 0) this.constantID = opts.constantID;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkSpecializationMapEntry.prototype, {
  "constantID": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationMapEntry.constantID': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationMapEntry.offset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "size": {
    get() {
    return this.memoryViewBigInt64[0x1];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationMapEntry.size': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x1] = BigInt(value);
    }
    },
  
});

VkSpecializationMapEntry.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
};

VkSpecializationMapEntry.prototype.flush = function flush() {
  
  return true;
};

VkSpecializationMapEntry.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSpecializationMapEntry.byteLength = 0x10;

VkSpecializationMapEntry.memoryLayout = {
  constantID: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  size: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkSpecializationInfo **/
function VkSpecializationInfo(opts) {
  if (new.target !== VkSpecializationInfo) {
    _VkSpecializationInfo.reset();
    return _VkSpecializationInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pMapEntries = null;
    this._pMapEntriesNative = null;
  
  this._pData = null;
  
  if (typeof opts === "object") {
    if (opts.mapEntryCount !== void 0) this.mapEntryCount = opts.mapEntryCount;
    if (opts.pMapEntries !== void 0) this.pMapEntries = opts.pMapEntries;
    if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

Object.defineProperties(VkSpecializationInfo.prototype, {
  "mapEntryCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.mapEntryCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "pMapEntries": {
    get() {
    return this._pMapEntries;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pMapEntries = value;
    } else if (value === null) {
      this._pMapEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.pMapEntries': Expected 'Array VkSpecializationMapEntry' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dataSize": {
    get() {
    return this.memoryViewBigInt64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.dataSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x2] = BigInt(value);
    }
    },
  "pData": {
    get() {
    return this._pData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pData = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.pData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSpecializationInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pMapEntries = null;
    this._pMapEntriesNative = null;
  
  this._pData = null;
  
};

VkSpecializationInfo.prototype.flush = function flush() {
  
  
  if (this._pMapEntries !== null) {
    let array = this._pMapEntries;
    
    if (array.length !== this.mapEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'mapEntryCount' for 'VkSpecializationInfo.pMapEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSpecializationMapEntry)) {
        throw new TypeError("Invalid type for 'VkSpecializationInfo.pMapEntries[" + ii + "]': Expected 'VkSpecializationMapEntry' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pMapEntriesNative = nativeArray;
      this.memoryViewBigInt64[0x1] = nativeArray.address;
    } else {
      this._pMapEntriesNative = null;
      this.memoryViewBigInt64[0x1] = BI0;
    }
  }
  
  return true;
};

VkSpecializationInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSpecializationInfo.byteLength = 0x20;

VkSpecializationInfo.memoryLayout = {
  mapEntryCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pMapEntries: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  dataSize: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  pData: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPipelineShaderStageCreateInfo **/
function VkPipelineShaderStageCreateInfo(opts) {
  if (new.target !== VkPipelineShaderStageCreateInfo) {
    _VkPipelineShaderStageCreateInfo.reset();
    return _VkPipelineShaderStageCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._module = null;
  this._pName = null;
  this._pSpecializationInfo = null;
  this.sType = 0x12;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stage !== void 0) this.stage = opts.stage;
    if (opts.module !== void 0) this.module = opts.module;
    if (opts.pName !== void 0) this.pName = opts.pName;
    if (opts.pSpecializationInfo !== void 0) this.pSpecializationInfo = opts.pSpecializationInfo;
    
  }
};

Object.defineProperties(VkPipelineShaderStageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineShaderStageCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineShaderStageCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "stage": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.stage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "module": {
    get() {
    return this._module;
    },
    set(value) {
    if (value !== null && value.constructor === VkShaderModule) {
      
      this._module = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._module = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.module': Expected 'VkShaderModule' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pName": {
    get() {
    if (this._pName !== null) {
      let str = textDecoder.decode(this._pName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pName);
    } else if (value === null) {
      this._pName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pSpecializationInfo": {
    get() {
    return this._pSpecializationInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSpecializationInfo) {
      value.flush();
      this._pSpecializationInfo = value;
      this.memoryViewBigInt64[0x5] = value.memoryAddress;
      
    } else if (value === null) {
      this._pSpecializationInfo = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pSpecializationInfo': Expected 'VkSpecializationInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineShaderStageCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  this._module = null;
  this._pName = null;
  this._pSpecializationInfo = null;
  this.sType = 0x12;
};

VkPipelineShaderStageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineShaderStageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineShaderStageCreateInfo.byteLength = 0x30;

VkPipelineShaderStageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  stage: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  module: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pName: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pSpecializationInfo: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkComputePipelineCreateInfo **/
function VkComputePipelineCreateInfo(opts) {
  if (new.target !== VkComputePipelineCreateInfo) {
    _VkComputePipelineCreateInfo.reset();
    return _VkComputePipelineCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x60) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x60);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._stage = new VkPipelineShaderStageCreateInfo({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = 0x1D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stage !== void 0) this.stage = opts.stage;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkComputePipelineCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkComputePipelineCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9DB800:
          break;
        default:
          throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "stage": {
    get() {
    return this._stage;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineShaderStageCreateInfo) {
      value.flush();
      this._stage = value;
      
      
    } else if (value === null) {
      this._stage = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.stage': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryViewBigInt64[0x9] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._layout = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryViewBigInt64[0xA] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryViewInt32[0x16];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.basePipelineIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x16] = value;
    }
    },
  
});

VkComputePipelineCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x60], 0x0);
  
  this._pNext = null;
  
  this._stage = null;
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = 0x1D;
};

VkComputePipelineCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._stage !== null) {
    let stage = this._stage;
    stage.flush();
    if (this.memoryBuffer !== stage.memoryBuffer) {
      let srcView = new Uint8Array(stage.memoryBuffer).subarray(stage.$memoryOffset, stage.$memoryOffset + 0x30);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkComputePipelineCreateInfo.stage' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkComputePipelineCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkComputePipelineCreateInfo.byteLength = 0x60;

VkComputePipelineCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  stage: {
    byteOffset: 0x18,
    byteLength: 0x30
  },
  layout: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  basePipelineHandle: {
    byteOffset: 0x50,
    byteLength: 0x8
  },
  basePipelineIndex: {
    byteOffset: 0x58,
    byteLength: 0x4
  },
};
/** VkVertexInputBindingDescription **/
function VkVertexInputBindingDescription(opts) {
  if (new.target !== VkVertexInputBindingDescription) {
    _VkVertexInputBindingDescription.reset();
    return _VkVertexInputBindingDescription;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.inputRate !== void 0) this.inputRate = opts.inputRate;
    
  }
};

Object.defineProperties(VkVertexInputBindingDescription.prototype, {
  "binding": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDescription.binding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "stride": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDescription.stride': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "inputRate": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDescription.inputRate': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkVertexInputRate(value)) {
      throw new RangeError("Invalid value for 'VkVertexInputBindingDescription.inputRate': '" + value + "' is not a value of 'VkVertexInputRate'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  
});

VkVertexInputBindingDescription.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkVertexInputBindingDescription.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputBindingDescription.prototype.reflect = function reflect(memoryAddress) {
  
};

VkVertexInputBindingDescription.byteLength = 0xC;

VkVertexInputBindingDescription.memoryLayout = {
  binding: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  stride: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  inputRate: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkVertexInputAttributeDescription **/
function VkVertexInputAttributeDescription(opts) {
  if (new.target !== VkVertexInputAttributeDescription) {
    _VkVertexInputAttributeDescription.reset();
    return _VkVertexInputAttributeDescription;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.location !== void 0) this.location = opts.location;
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

Object.defineProperties(VkVertexInputAttributeDescription.prototype, {
  "location": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.location': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "binding": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.binding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkVertexInputAttributeDescription.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.offset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x3] = value;
    }
    },
  
});

VkVertexInputAttributeDescription.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
  
};

VkVertexInputAttributeDescription.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputAttributeDescription.prototype.reflect = function reflect(memoryAddress) {
  
};

VkVertexInputAttributeDescription.byteLength = 0x10;

VkVertexInputAttributeDescription.memoryLayout = {
  location: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  binding: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  format: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkPipelineVertexInputStateCreateInfo **/
function VkPipelineVertexInputStateCreateInfo(opts) {
  if (new.target !== VkPipelineVertexInputStateCreateInfo) {
    _VkPipelineVertexInputStateCreateInfo.reset();
    return _VkPipelineVertexInputStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pVertexBindingDescriptions = null;
    this._pVertexBindingDescriptionsNative = null;
  
  this._pVertexAttributeDescriptions = null;
    this._pVertexAttributeDescriptionsNative = null;
  this.sType = 0x13;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.vertexBindingDescriptionCount !== void 0) this.vertexBindingDescriptionCount = opts.vertexBindingDescriptionCount;
    if (opts.pVertexBindingDescriptions !== void 0) this.pVertexBindingDescriptions = opts.pVertexBindingDescriptions;
    if (opts.vertexAttributeDescriptionCount !== void 0) this.vertexAttributeDescriptionCount = opts.vertexAttributeDescriptionCount;
    if (opts.pVertexAttributeDescriptions !== void 0) this.pVertexAttributeDescriptions = opts.pVertexAttributeDescriptions;
    
  }
};

Object.defineProperties(VkPipelineVertexInputStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineVertexInputStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9DB031:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "vertexBindingDescriptionCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pVertexBindingDescriptions": {
    get() {
    return this._pVertexBindingDescriptions;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexBindingDescriptions = value;
    } else if (value === null) {
      this._pVertexBindingDescriptions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions': Expected 'Array VkVertexInputBindingDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "vertexAttributeDescriptionCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pVertexAttributeDescriptions": {
    get() {
    return this._pVertexAttributeDescriptions;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexAttributeDescriptions = value;
    } else if (value === null) {
      this._pVertexAttributeDescriptions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions': Expected 'Array VkVertexInputAttributeDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineVertexInputStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  this._pVertexBindingDescriptions = null;
    this._pVertexBindingDescriptionsNative = null;
  
  this._pVertexAttributeDescriptions = null;
    this._pVertexAttributeDescriptionsNative = null;
  this.sType = 0x13;
};

VkPipelineVertexInputStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pVertexBindingDescriptions !== null) {
    let array = this._pVertexBindingDescriptions;
    
    if (array.length !== this.vertexBindingDescriptionCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexBindingDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkVertexInputBindingDescription)) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions[" + ii + "]': Expected 'VkVertexInputBindingDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pVertexBindingDescriptionsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pVertexBindingDescriptionsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pVertexAttributeDescriptions !== null) {
    let array = this._pVertexAttributeDescriptions;
    
    if (array.length !== this.vertexAttributeDescriptionCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexAttributeDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkVertexInputAttributeDescription)) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions[" + ii + "]': Expected 'VkVertexInputAttributeDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pVertexAttributeDescriptionsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pVertexAttributeDescriptionsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkPipelineVertexInputStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineVertexInputStateCreateInfo.byteLength = 0x30;

VkPipelineVertexInputStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  vertexBindingDescriptionCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pVertexBindingDescriptions: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  vertexAttributeDescriptionCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pVertexAttributeDescriptions: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkPipelineInputAssemblyStateCreateInfo **/
function VkPipelineInputAssemblyStateCreateInfo(opts) {
  if (new.target !== VkPipelineInputAssemblyStateCreateInfo) {
    _VkPipelineInputAssemblyStateCreateInfo.reset();
    return _VkPipelineInputAssemblyStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x14;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.topology !== void 0) this.topology = opts.topology;
    if (opts.primitiveRestartEnable !== void 0) this.primitiveRestartEnable = opts.primitiveRestartEnable;
    
  }
};

Object.defineProperties(VkPipelineInputAssemblyStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineInputAssemblyStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineInputAssemblyStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineInputAssemblyStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineInputAssemblyStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "topology": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineInputAssemblyStateCreateInfo.topology': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPrimitiveTopology(value)) {
      throw new RangeError("Invalid value for 'VkPipelineInputAssemblyStateCreateInfo.topology': '" + value + "' is not a value of 'VkPrimitiveTopology'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "primitiveRestartEnable": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPipelineInputAssemblyStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x14;
};

VkPipelineInputAssemblyStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineInputAssemblyStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineInputAssemblyStateCreateInfo.byteLength = 0x20;

VkPipelineInputAssemblyStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  topology: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  primitiveRestartEnable: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPipelineTessellationStateCreateInfo **/
function VkPipelineTessellationStateCreateInfo(opts) {
  if (new.target !== VkPipelineTessellationStateCreateInfo) {
    _VkPipelineTessellationStateCreateInfo.reset();
    return _VkPipelineTessellationStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x15;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.patchControlPoints !== void 0) this.patchControlPoints = opts.patchControlPoints;
    
  }
};

Object.defineProperties(VkPipelineTessellationStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineTessellationStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C930B:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "patchControlPoints": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.patchControlPoints': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkPipelineTessellationStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x15;
};

VkPipelineTessellationStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineTessellationStateCreateInfo.byteLength = 0x18;

VkPipelineTessellationStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  patchControlPoints: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPipelineViewportStateCreateInfo **/
function VkPipelineViewportStateCreateInfo(opts) {
  if (new.target !== VkPipelineViewportStateCreateInfo) {
    _VkPipelineViewportStateCreateInfo.reset();
    return _VkPipelineViewportStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pViewports = null;
    this._pViewportsNative = null;
  
  this._pScissors = null;
    this._pScissorsNative = null;
  this.sType = 0x16;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewports !== void 0) this.pViewports = opts.pViewports;
    if (opts.scissorCount !== void 0) this.scissorCount = opts.scissorCount;
    if (opts.pScissors !== void 0) this.pScissors = opts.pScissors;
    
  }
};

Object.defineProperties(VkPipelineViewportStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C1DD8:
        case 0x3B9C48D0:
        case 0x3B9DEAC8:
        case 0x3B9D4AA0:
        case 0x3B9D4AA5:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "viewportCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.viewportCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pViewports": {
    get() {
    return this._pViewports;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewports = value;
    } else if (value === null) {
      this._pViewports = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pViewports': Expected 'Array VkViewport' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "scissorCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.scissorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pScissors": {
    get() {
    return this._pScissors;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pScissors = value;
    } else if (value === null) {
      this._pScissors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pScissors': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  this._pViewports = null;
    this._pViewportsNative = null;
  
  this._pScissors = null;
    this._pScissorsNative = null;
  this.sType = 0x16;
};

VkPipelineViewportStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewports !== null) {
    let array = this._pViewports;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportStateCreateInfo.pViewports'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkViewport)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pViewports[" + ii + "]': Expected 'VkViewport' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pViewportsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pViewportsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pScissors !== null) {
    let array = this._pScissors;
    
    if (array.length !== this.scissorCount) {
      throw new RangeError("Invalid array length, expected length of 'scissorCount' for 'VkPipelineViewportStateCreateInfo.pScissors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pScissors[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pScissorsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pScissorsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkPipelineViewportStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineViewportStateCreateInfo.byteLength = 0x30;

VkPipelineViewportStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  viewportCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pViewports: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  scissorCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pScissors: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkPipelineRasterizationStateCreateInfo **/
function VkPipelineRasterizationStateCreateInfo(opts) {
  if (new.target !== VkPipelineRasterizationStateCreateInfo) {
    _VkPipelineRasterizationStateCreateInfo.reset();
    return _VkPipelineRasterizationStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x17;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthClampEnable !== void 0) this.depthClampEnable = opts.depthClampEnable;
    if (opts.rasterizerDiscardEnable !== void 0) this.rasterizerDiscardEnable = opts.rasterizerDiscardEnable;
    if (opts.polygonMode !== void 0) this.polygonMode = opts.polygonMode;
    if (opts.cullMode !== void 0) this.cullMode = opts.cullMode;
    if (opts.frontFace !== void 0) this.frontFace = opts.frontFace;
    if (opts.depthBiasEnable !== void 0) this.depthBiasEnable = opts.depthBiasEnable;
    if (opts.depthBiasConstantFactor !== void 0) this.depthBiasConstantFactor = opts.depthBiasConstantFactor;
    if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
    if (opts.depthBiasSlopeFactor !== void 0) this.depthBiasSlopeFactor = opts.depthBiasSlopeFactor;
    if (opts.lineWidth !== void 0) this.lineWidth = opts.lineWidth;
    
  }
};

Object.defineProperties(VkPipelineRasterizationStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B1050:
        case 0x3B9C5489:
        case 0x3B9B3762:
        case 0x3B9C5871:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "depthClampEnable": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "rasterizerDiscardEnable": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "polygonMode": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.polygonMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPolygonMode(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationStateCreateInfo.polygonMode': '" + value + "' is not a value of 'VkPolygonMode'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "cullMode": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.cullMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "frontFace": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.frontFace': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFrontFace(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationStateCreateInfo.frontFace': '" + value + "' is not a value of 'VkFrontFace'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "depthBiasEnable": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xA] = value | 0;
    }
    },
  "depthBiasConstantFactor": {
    get() {
    return this.memoryViewFloat32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xB] = value;
    }
    },
  "depthBiasClamp": {
    get() {
    return this.memoryViewFloat32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.depthBiasClamp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xC] = value;
    }
    },
  "depthBiasSlopeFactor": {
    get() {
    return this.memoryViewFloat32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xD] = value;
    }
    },
  "lineWidth": {
    get() {
    return this.memoryViewFloat32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.lineWidth': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xE] = value;
    }
    },
  
});

VkPipelineRasterizationStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x17;
};

VkPipelineRasterizationStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationStateCreateInfo.byteLength = 0x40;

VkPipelineRasterizationStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  depthClampEnable: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  rasterizerDiscardEnable: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  polygonMode: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  cullMode: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  frontFace: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  depthBiasEnable: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  depthBiasConstantFactor: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  depthBiasClamp: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  depthBiasSlopeFactor: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  lineWidth: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkPipelineMultisampleStateCreateInfo **/
function VkPipelineMultisampleStateCreateInfo(opts) {
  if (new.target !== VkPipelineMultisampleStateCreateInfo) {
    _VkPipelineMultisampleStateCreateInfo.reset();
    return _VkPipelineMultisampleStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pSampleMask = null;
  
  
  this.sType = 0x18;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.rasterizationSamples !== void 0) this.rasterizationSamples = opts.rasterizationSamples;
    if (opts.sampleShadingEnable !== void 0) this.sampleShadingEnable = opts.sampleShadingEnable;
    if (opts.minSampleShading !== void 0) this.minSampleShading = opts.minSampleShading;
    if (opts.pSampleMask !== void 0) this.pSampleMask = opts.pSampleMask;
    if (opts.alphaToCoverageEnable !== void 0) this.alphaToCoverageEnable = opts.alphaToCoverageEnable;
    if (opts.alphaToOneEnable !== void 0) this.alphaToOneEnable = opts.alphaToOneEnable;
    
  }
};

Object.defineProperties(VkPipelineMultisampleStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineMultisampleStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D1008:
        case 0x3B9CF89A:
        case 0x3B9D1BC0:
        case 0x3B9E9A91:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "rasterizationSamples": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.rasterizationSamples': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "sampleShadingEnable": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "minSampleShading": {
    get() {
    return this.memoryViewFloat32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.minSampleShading': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x7] = value;
    }
    },
  "pSampleMask": {
    get() {
    return this._pSampleMask;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSampleMask = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSampleMask = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pSampleMask': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "alphaToCoverageEnable": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xA] = value | 0;
    }
    },
  "alphaToOneEnable": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xB] = value | 0;
    }
    },
  
});

VkPipelineMultisampleStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pSampleMask = null;
  
  
  this.sType = 0x18;
};

VkPipelineMultisampleStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineMultisampleStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineMultisampleStateCreateInfo.byteLength = 0x30;

VkPipelineMultisampleStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  rasterizationSamples: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  sampleShadingEnable: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  minSampleShading: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pSampleMask: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  alphaToCoverageEnable: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  alphaToOneEnable: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
};
/** VkPipelineColorBlendAttachmentState **/
function VkPipelineColorBlendAttachmentState(opts) {
  if (new.target !== VkPipelineColorBlendAttachmentState) {
    _VkPipelineColorBlendAttachmentState.reset();
    return _VkPipelineColorBlendAttachmentState;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.blendEnable !== void 0) this.blendEnable = opts.blendEnable;
    if (opts.srcColorBlendFactor !== void 0) this.srcColorBlendFactor = opts.srcColorBlendFactor;
    if (opts.dstColorBlendFactor !== void 0) this.dstColorBlendFactor = opts.dstColorBlendFactor;
    if (opts.colorBlendOp !== void 0) this.colorBlendOp = opts.colorBlendOp;
    if (opts.srcAlphaBlendFactor !== void 0) this.srcAlphaBlendFactor = opts.srcAlphaBlendFactor;
    if (opts.dstAlphaBlendFactor !== void 0) this.dstAlphaBlendFactor = opts.dstAlphaBlendFactor;
    if (opts.alphaBlendOp !== void 0) this.alphaBlendOp = opts.alphaBlendOp;
    if (opts.colorWriteMask !== void 0) this.colorWriteMask = opts.colorWriteMask;
    
  }
};

Object.defineProperties(VkPipelineColorBlendAttachmentState.prototype, {
  "blendEnable": {
    get() {
    return this.memoryViewUint32[0x0] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x0] = value | 0;
    }
    },
  "srcColorBlendFactor": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.srcColorBlendFactor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendFactor(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAttachmentState.srcColorBlendFactor': '" + value + "' is not a value of 'VkBlendFactor'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "dstColorBlendFactor": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.dstColorBlendFactor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendFactor(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAttachmentState.dstColorBlendFactor': '" + value + "' is not a value of 'VkBlendFactor'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "colorBlendOp": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.colorBlendOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendOp(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAttachmentState.colorBlendOp': '" + value + "' is not a value of 'VkBlendOp'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "srcAlphaBlendFactor": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendFactor(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor': '" + value + "' is not a value of 'VkBlendFactor'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "dstAlphaBlendFactor": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendFactor(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor': '" + value + "' is not a value of 'VkBlendFactor'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "alphaBlendOp": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.alphaBlendOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendOp(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAttachmentState.alphaBlendOp': '" + value + "' is not a value of 'VkBlendOp'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "colorWriteMask": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.colorWriteMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  
});

VkPipelineColorBlendAttachmentState.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  
  
  
  
  
  
  
  
};

VkPipelineColorBlendAttachmentState.prototype.flush = function flush() {
  
  return true;
};

VkPipelineColorBlendAttachmentState.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPipelineColorBlendAttachmentState.byteLength = 0x20;

VkPipelineColorBlendAttachmentState.memoryLayout = {
  blendEnable: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  srcColorBlendFactor: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  dstColorBlendFactor: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  colorBlendOp: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  srcAlphaBlendFactor: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstAlphaBlendFactor: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  alphaBlendOp: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  colorWriteMask: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkPipelineColorBlendStateCreateInfo **/
function VkPipelineColorBlendStateCreateInfo(opts) {
  if (new.target !== VkPipelineColorBlendStateCreateInfo) {
    _VkPipelineColorBlendStateCreateInfo.reset();
    return _VkPipelineColorBlendStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  this._blendConstants = [...Array(4)].fill(0x0);
  this.sType = 0x1A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.logicOpEnable !== void 0) this.logicOpEnable = opts.logicOpEnable;
    if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.blendConstants !== void 0) this.blendConstants = opts.blendConstants;
    
  }
};

Object.defineProperties(VkPipelineColorBlendStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D0C22:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "logicOpEnable": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "logicOp": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.logicOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkLogicOp(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendStateCreateInfo.logicOp': '" + value + "' is not a value of 'VkLogicOp'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.attachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "pAttachments": {
    get() {
    return this._pAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pAttachments': Expected 'Array VkPipelineColorBlendAttachmentState' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "blendConstants": {
    get() {
    return this._blendConstants;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._blendConstants = value;
    } else if (value === null) {
      this._blendConstants = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.blendConstants': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineColorBlendStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  this._blendConstants = null;
  this.sType = 0x1A;
};

VkPipelineColorBlendStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkPipelineColorBlendStateCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineColorBlendAttachmentState)) {
        throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pAttachments[" + ii + "]': Expected 'VkPipelineColorBlendAttachmentState' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pAttachmentsNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  
  if (this._blendConstants !== null) {
    let array = this._blendConstants;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkPipelineColorBlendStateCreateInfo.blendConstants'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.blendConstants[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0xA + ii] = array[ii];
    };
  } else {
    this.memoryViewFloat32[0xA] = 0x0;
  }
  
  return true;
};

VkPipelineColorBlendStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineColorBlendStateCreateInfo.byteLength = 0x38;

VkPipelineColorBlendStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  logicOpEnable: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  logicOp: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  attachmentCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pAttachments: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  blendConstants: {
    byteOffset: 0x28,
    byteLength: 0x10
  },
};
/** VkPipelineDynamicStateCreateInfo **/
function VkPipelineDynamicStateCreateInfo(opts) {
  if (new.target !== VkPipelineDynamicStateCreateInfo) {
    _VkPipelineDynamicStateCreateInfo.reset();
    return _VkPipelineDynamicStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pDynamicStates = null;
  this.sType = 0x1B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.dynamicStateCount !== void 0) this.dynamicStateCount = opts.dynamicStateCount;
    if (opts.pDynamicStates !== void 0) this.pDynamicStates = opts.pDynamicStates;
    
  }
};

Object.defineProperties(VkPipelineDynamicStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineDynamicStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineDynamicStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "dynamicStateCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.dynamicStateCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pDynamicStates": {
    get() {
    return this._pDynamicStates;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDynamicStates = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDynamicStates = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.pDynamicStates': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineDynamicStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pDynamicStates = null;
  this.sType = 0x1B;
};

VkPipelineDynamicStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineDynamicStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineDynamicStateCreateInfo.byteLength = 0x20;

VkPipelineDynamicStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dynamicStateCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pDynamicStates: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkStencilOpState **/
function VkStencilOpState(opts) {
  if (new.target !== VkStencilOpState) {
    _VkStencilOpState.reset();
    return _VkStencilOpState;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x1C) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x1C);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.failOp !== void 0) this.failOp = opts.failOp;
    if (opts.passOp !== void 0) this.passOp = opts.passOp;
    if (opts.depthFailOp !== void 0) this.depthFailOp = opts.depthFailOp;
    if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
    if (opts.compareMask !== void 0) this.compareMask = opts.compareMask;
    if (opts.writeMask !== void 0) this.writeMask = opts.writeMask;
    if (opts.reference !== void 0) this.reference = opts.reference;
    
  }
};

Object.defineProperties(VkStencilOpState.prototype, {
  "failOp": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.failOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStencilOp(value)) {
      throw new RangeError("Invalid value for 'VkStencilOpState.failOp': '" + value + "' is not a value of 'VkStencilOp'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "passOp": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.passOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStencilOp(value)) {
      throw new RangeError("Invalid value for 'VkStencilOpState.passOp': '" + value + "' is not a value of 'VkStencilOp'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "depthFailOp": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.depthFailOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStencilOp(value)) {
      throw new RangeError("Invalid value for 'VkStencilOpState.depthFailOp': '" + value + "' is not a value of 'VkStencilOp'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "compareOp": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.compareOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCompareOp(value)) {
      throw new RangeError("Invalid value for 'VkStencilOpState.compareOp': '" + value + "' is not a value of 'VkCompareOp'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "compareMask": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.compareMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "writeMask": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.writeMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "reference": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.reference': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  
});

VkStencilOpState.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x1C], 0x0);
  
  
  
  
  
  
  
  
};

VkStencilOpState.prototype.flush = function flush() {
  
  return true;
};

VkStencilOpState.prototype.reflect = function reflect(memoryAddress) {
  
};

VkStencilOpState.byteLength = 0x1C;

VkStencilOpState.memoryLayout = {
  failOp: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  passOp: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  depthFailOp: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  compareOp: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  compareMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  writeMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  reference: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPipelineDepthStencilStateCreateInfo **/
function VkPipelineDepthStencilStateCreateInfo(opts) {
  if (new.target !== VkPipelineDepthStencilStateCreateInfo) {
    _VkPipelineDepthStencilStateCreateInfo.reset();
    return _VkPipelineDepthStencilStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x68) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x68) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x68);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._front = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x28 });
  this._back = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x44 });
  
  
  this.sType = 0x19;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthTestEnable !== void 0) this.depthTestEnable = opts.depthTestEnable;
    if (opts.depthWriteEnable !== void 0) this.depthWriteEnable = opts.depthWriteEnable;
    if (opts.depthCompareOp !== void 0) this.depthCompareOp = opts.depthCompareOp;
    if (opts.depthBoundsTestEnable !== void 0) this.depthBoundsTestEnable = opts.depthBoundsTestEnable;
    if (opts.stencilTestEnable !== void 0) this.stencilTestEnable = opts.stencilTestEnable;
    if (opts.front !== void 0) this.front = opts.front;
    if (opts.back !== void 0) this.back = opts.back;
    if (opts.minDepthBounds !== void 0) this.minDepthBounds = opts.minDepthBounds;
    if (opts.maxDepthBounds !== void 0) this.maxDepthBounds = opts.maxDepthBounds;
    
  }
};

Object.defineProperties(VkPipelineDepthStencilStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineDepthStencilStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineDepthStencilStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "depthTestEnable": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "depthWriteEnable": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "depthCompareOp": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.depthCompareOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCompareOp(value)) {
      throw new RangeError("Invalid value for 'VkPipelineDepthStencilStateCreateInfo.depthCompareOp': '" + value + "' is not a value of 'VkCompareOp'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "depthBoundsTestEnable": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x8] = value | 0;
    }
    },
  "stencilTestEnable": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x9] = value | 0;
    }
    },
  "front": {
    get() {
    return this._front;
    },
    set(value) {
    if (value !== null && value.constructor === VkStencilOpState) {
      value.flush();
      this._front = value;
      
      
    } else if (value === null) {
      this._front = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.front': Expected 'VkStencilOpState' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "back": {
    get() {
    return this._back;
    },
    set(value) {
    if (value !== null && value.constructor === VkStencilOpState) {
      value.flush();
      this._back = value;
      
      
    } else if (value === null) {
      this._back = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.back': Expected 'VkStencilOpState' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "minDepthBounds": {
    get() {
    return this.memoryViewFloat32[0x18];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.minDepthBounds': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x18] = value;
    }
    },
  "maxDepthBounds": {
    get() {
    return this.memoryViewFloat32[0x19];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.maxDepthBounds': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x19] = value;
    }
    },
  
});

VkPipelineDepthStencilStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x68], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this._front = null;
  this._back = null;
  
  
  this.sType = 0x19;
};

VkPipelineDepthStencilStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._front !== null) {
    let front = this._front;
    front.flush();
    if (this.memoryBuffer !== front.memoryBuffer) {
      let srcView = new Uint8Array(front.memoryBuffer).subarray(front.$memoryOffset, front.$memoryOffset + 0x1C);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineDepthStencilStateCreateInfo.front' isn't used as shared-memory");
    }
  }
  
  
  if (this._back !== null) {
    let back = this._back;
    back.flush();
    if (this.memoryBuffer !== back.memoryBuffer) {
      let srcView = new Uint8Array(back.memoryBuffer).subarray(back.$memoryOffset, back.$memoryOffset + 0x1C);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x44);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineDepthStencilStateCreateInfo.back' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPipelineDepthStencilStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineDepthStencilStateCreateInfo.byteLength = 0x68;

VkPipelineDepthStencilStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  depthTestEnable: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  depthWriteEnable: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  depthCompareOp: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  depthBoundsTestEnable: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  stencilTestEnable: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  front: {
    byteOffset: 0x28,
    byteLength: 0x1C
  },
  back: {
    byteOffset: 0x44,
    byteLength: 0x1C
  },
  minDepthBounds: {
    byteOffset: 0x60,
    byteLength: 0x4
  },
  maxDepthBounds: {
    byteOffset: 0x64,
    byteLength: 0x4
  },
};
/** VkGraphicsPipelineCreateInfo **/
function VkGraphicsPipelineCreateInfo(opts) {
  if (new.target !== VkGraphicsPipelineCreateInfo) {
    _VkGraphicsPipelineCreateInfo.reset();
    return _VkGraphicsPipelineCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x90) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x90) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x90) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x90) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x90);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pStages = null;
    this._pStagesNative = null;
  this._pVertexInputState = null;
  this._pInputAssemblyState = null;
  this._pTessellationState = null;
  this._pViewportState = null;
  this._pRasterizationState = null;
  this._pMultisampleState = null;
  this._pDepthStencilState = null;
  this._pColorBlendState = null;
  this._pDynamicState = null;
  this._layout = null;
  this._renderPass = null;
  
  this._basePipelineHandle = null;
  
  this.sType = 0x1C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.pVertexInputState !== void 0) this.pVertexInputState = opts.pVertexInputState;
    if (opts.pInputAssemblyState !== void 0) this.pInputAssemblyState = opts.pInputAssemblyState;
    if (opts.pTessellationState !== void 0) this.pTessellationState = opts.pTessellationState;
    if (opts.pViewportState !== void 0) this.pViewportState = opts.pViewportState;
    if (opts.pRasterizationState !== void 0) this.pRasterizationState = opts.pRasterizationState;
    if (opts.pMultisampleState !== void 0) this.pMultisampleState = opts.pMultisampleState;
    if (opts.pDepthStencilState !== void 0) this.pDepthStencilState = opts.pDepthStencilState;
    if (opts.pColorBlendState !== void 0) this.pColorBlendState = opts.pColorBlendState;
    if (opts.pDynamicState !== void 0) this.pDynamicState = opts.pDynamicState;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkGraphicsPipelineCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkGraphicsPipelineCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C4CB9:
        case 0x3B9D5271:
        case 0x3B9DB800:
          break;
        default:
          throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "stageCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.stageCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pStages": {
    get() {
    return this._pStages;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pVertexInputState": {
    get() {
    return this._pVertexInputState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineVertexInputStateCreateInfo) {
      value.flush();
      this._pVertexInputState = value;
      this.memoryViewBigInt64[0x4] = value.memoryAddress;
      
    } else if (value === null) {
      this._pVertexInputState = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pVertexInputState': Expected 'VkPipelineVertexInputStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pInputAssemblyState": {
    get() {
    return this._pInputAssemblyState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineInputAssemblyStateCreateInfo) {
      value.flush();
      this._pInputAssemblyState = value;
      this.memoryViewBigInt64[0x5] = value.memoryAddress;
      
    } else if (value === null) {
      this._pInputAssemblyState = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pInputAssemblyState': Expected 'VkPipelineInputAssemblyStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pTessellationState": {
    get() {
    return this._pTessellationState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineTessellationStateCreateInfo) {
      value.flush();
      this._pTessellationState = value;
      this.memoryViewBigInt64[0x6] = value.memoryAddress;
      
    } else if (value === null) {
      this._pTessellationState = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pTessellationState': Expected 'VkPipelineTessellationStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pViewportState": {
    get() {
    return this._pViewportState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineViewportStateCreateInfo) {
      value.flush();
      this._pViewportState = value;
      this.memoryViewBigInt64[0x7] = value.memoryAddress;
      
    } else if (value === null) {
      this._pViewportState = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pViewportState': Expected 'VkPipelineViewportStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pRasterizationState": {
    get() {
    return this._pRasterizationState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineRasterizationStateCreateInfo) {
      value.flush();
      this._pRasterizationState = value;
      this.memoryViewBigInt64[0x8] = value.memoryAddress;
      
    } else if (value === null) {
      this._pRasterizationState = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pRasterizationState': Expected 'VkPipelineRasterizationStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pMultisampleState": {
    get() {
    return this._pMultisampleState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineMultisampleStateCreateInfo) {
      value.flush();
      this._pMultisampleState = value;
      this.memoryViewBigInt64[0x9] = value.memoryAddress;
      
    } else if (value === null) {
      this._pMultisampleState = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pMultisampleState': Expected 'VkPipelineMultisampleStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pDepthStencilState": {
    get() {
    return this._pDepthStencilState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineDepthStencilStateCreateInfo) {
      value.flush();
      this._pDepthStencilState = value;
      this.memoryViewBigInt64[0xA] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilState = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pDepthStencilState': Expected 'VkPipelineDepthStencilStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pColorBlendState": {
    get() {
    return this._pColorBlendState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineColorBlendStateCreateInfo) {
      value.flush();
      this._pColorBlendState = value;
      this.memoryViewBigInt64[0xB] = value.memoryAddress;
      
    } else if (value === null) {
      this._pColorBlendState = null;
      this.memoryViewBigInt64[0xB] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pColorBlendState': Expected 'VkPipelineColorBlendStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pDynamicState": {
    get() {
    return this._pDynamicState;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineDynamicStateCreateInfo) {
      value.flush();
      this._pDynamicState = value;
      this.memoryViewBigInt64[0xC] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDynamicState = null;
      this.memoryViewBigInt64[0xC] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pDynamicState': Expected 'VkPipelineDynamicStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryViewBigInt64[0xD] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._layout = null;
      this.memoryViewBigInt64[0xD] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0xE] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0xE] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subpass": {
    get() {
    return this.memoryViewUint32[0x1E];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.subpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1E] = value;
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryViewBigInt64[0x10] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryViewBigInt64[0x10] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryViewInt32[0x22];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.basePipelineIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x22] = value;
    }
    },
  
});

VkGraphicsPipelineCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x90], 0x0);
  
  this._pNext = null;
  
  
  this._pStages = null;
    this._pStagesNative = null;
  this._pVertexInputState = null;
  this._pInputAssemblyState = null;
  this._pTessellationState = null;
  this._pViewportState = null;
  this._pRasterizationState = null;
  this._pMultisampleState = null;
  this._pDepthStencilState = null;
  this._pColorBlendState = null;
  this._pDynamicState = null;
  this._layout = null;
  this._renderPass = null;
  
  this._basePipelineHandle = null;
  
  this.sType = 0x1C;
};

VkGraphicsPipelineCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkGraphicsPipelineCreateInfo.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineShaderStageCreateInfo)) {
        throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStagesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pStagesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkGraphicsPipelineCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkGraphicsPipelineCreateInfo.byteLength = 0x90;

VkGraphicsPipelineCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  stageCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pStages: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pVertexInputState: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pInputAssemblyState: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pTessellationState: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  pViewportState: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  pRasterizationState: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
  pMultisampleState: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  pDepthStencilState: {
    byteOffset: 0x50,
    byteLength: 0x8
  },
  pColorBlendState: {
    byteOffset: 0x58,
    byteLength: 0x8
  },
  pDynamicState: {
    byteOffset: 0x60,
    byteLength: 0x8
  },
  layout: {
    byteOffset: 0x68,
    byteLength: 0x8
  },
  renderPass: {
    byteOffset: 0x70,
    byteLength: 0x8
  },
  subpass: {
    byteOffset: 0x78,
    byteLength: 0x4
  },
  basePipelineHandle: {
    byteOffset: 0x80,
    byteLength: 0x8
  },
  basePipelineIndex: {
    byteOffset: 0x88,
    byteLength: 0x4
  },
};
/** VkPipelineCacheCreateInfo **/
function VkPipelineCacheCreateInfo(opts) {
  if (new.target !== VkPipelineCacheCreateInfo) {
    _VkPipelineCacheCreateInfo.reset();
    return _VkPipelineCacheCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = 0x11;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
    if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
    
  }
};

Object.defineProperties(VkPipelineCacheCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCacheCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCacheCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "initialDataSize": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.initialDataSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  "pInitialData": {
    get() {
    return this._pInitialData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pInitialData = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pInitialData = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.pInitialData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineCacheCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = 0x11;
};

VkPipelineCacheCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCacheCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCacheCreateInfo.byteLength = 0x28;

VkPipelineCacheCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  initialDataSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pInitialData: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkPushConstantRange **/
function VkPushConstantRange(opts) {
  if (new.target !== VkPushConstantRange) {
    _VkPushConstantRange.reset();
    return _VkPushConstantRange;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkPushConstantRange.prototype, {
  "stageFlags": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPushConstantRange.stageFlags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPushConstantRange.offset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "size": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPushConstantRange.size': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  
});

VkPushConstantRange.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkPushConstantRange.prototype.flush = function flush() {
  
  return true;
};

VkPushConstantRange.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPushConstantRange.byteLength = 0xC;

VkPushConstantRange.memoryLayout = {
  stageFlags: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  size: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkPipelineLayoutCreateInfo **/
function VkPipelineLayoutCreateInfo(opts) {
  if (new.target !== VkPipelineLayoutCreateInfo) {
    _VkPipelineLayoutCreateInfo.reset();
    return _VkPipelineLayoutCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pSetLayouts = null;
    this._pSetLayoutsNative = null;
  
  this._pPushConstantRanges = null;
    this._pPushConstantRangesNative = null;
  this.sType = 0x1E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.setLayoutCount !== void 0) this.setLayoutCount = opts.setLayoutCount;
    if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
    if (opts.pushConstantRangeCount !== void 0) this.pushConstantRangeCount = opts.pushConstantRangeCount;
    if (opts.pPushConstantRanges !== void 0) this.pPushConstantRanges = opts.pPushConstantRanges;
    
  }
};

Object.defineProperties(VkPipelineLayoutCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineLayoutCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineLayoutCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "setLayoutCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.setLayoutCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pSetLayouts": {
    get() {
    return this._pSetLayouts;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSetLayouts = value;
    } else if (value === null) {
      this._pSetLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pSetLayouts': Expected 'Array VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pushConstantRangeCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pushConstantRangeCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pPushConstantRanges": {
    get() {
    return this._pPushConstantRanges;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPushConstantRanges = value;
    } else if (value === null) {
      this._pPushConstantRanges = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pPushConstantRanges': Expected 'Array VkPushConstantRange' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineLayoutCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  this._pSetLayouts = null;
    this._pSetLayoutsNative = null;
  
  this._pPushConstantRanges = null;
    this._pPushConstantRangesNative = null;
  this.sType = 0x1E;
};

VkPipelineLayoutCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSetLayouts !== null) {
    let array = this._pSetLayouts;
    
    if (array.length !== this.setLayoutCount) {
      throw new RangeError("Invalid array length, expected length of 'setLayoutCount' for 'VkPipelineLayoutCreateInfo.pSetLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorSetLayout)) {
        throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pSetLayouts[" + ii + "]': Expected 'VkDescriptorSetLayout' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSetLayoutsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pSetLayoutsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pPushConstantRanges !== null) {
    let array = this._pPushConstantRanges;
    
    if (array.length !== this.pushConstantRangeCount) {
      throw new RangeError("Invalid array length, expected length of 'pushConstantRangeCount' for 'VkPipelineLayoutCreateInfo.pPushConstantRanges'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPushConstantRange)) {
        throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pPushConstantRanges[" + ii + "]': Expected 'VkPushConstantRange' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPushConstantRangesNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pPushConstantRangesNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkPipelineLayoutCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineLayoutCreateInfo.byteLength = 0x30;

VkPipelineLayoutCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  setLayoutCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pSetLayouts: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pushConstantRangeCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pPushConstantRanges: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkSamplerCreateInfo **/
function VkSamplerCreateInfo(opts) {
  if (new.target !== VkSamplerCreateInfo) {
    _VkSamplerCreateInfo.reset();
    return _VkSamplerCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x50) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x50);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x1F;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.magFilter !== void 0) this.magFilter = opts.magFilter;
    if (opts.minFilter !== void 0) this.minFilter = opts.minFilter;
    if (opts.mipmapMode !== void 0) this.mipmapMode = opts.mipmapMode;
    if (opts.addressModeU !== void 0) this.addressModeU = opts.addressModeU;
    if (opts.addressModeV !== void 0) this.addressModeV = opts.addressModeV;
    if (opts.addressModeW !== void 0) this.addressModeW = opts.addressModeW;
    if (opts.mipLodBias !== void 0) this.mipLodBias = opts.mipLodBias;
    if (opts.anisotropyEnable !== void 0) this.anisotropyEnable = opts.anisotropyEnable;
    if (opts.maxAnisotropy !== void 0) this.maxAnisotropy = opts.maxAnisotropy;
    if (opts.compareEnable !== void 0) this.compareEnable = opts.compareEnable;
    if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
    if (opts.minLod !== void 0) this.minLod = opts.minLod;
    if (opts.maxLod !== void 0) this.maxLod = opts.maxLod;
    if (opts.borderColor !== void 0) this.borderColor = opts.borderColor;
    if (opts.unnormalizedCoordinates !== void 0) this.unnormalizedCoordinates = opts.unnormalizedCoordinates;
    
  }
};

Object.defineProperties(VkSamplerCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D2B61:
        case 0x3B9CC5D1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "magFilter": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.magFilter': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFilter(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.magFilter': '" + value + "' is not a value of 'VkFilter'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "minFilter": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.minFilter': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFilter(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.minFilter': '" + value + "' is not a value of 'VkFilter'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "mipmapMode": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.mipmapMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerMipmapMode(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.mipmapMode': '" + value + "' is not a value of 'VkSamplerMipmapMode'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "addressModeU": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.addressModeU': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerAddressMode(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.addressModeU': '" + value + "' is not a value of 'VkSamplerAddressMode'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "addressModeV": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.addressModeV': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerAddressMode(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.addressModeV': '" + value + "' is not a value of 'VkSamplerAddressMode'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "addressModeW": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.addressModeW': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerAddressMode(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.addressModeW': '" + value + "' is not a value of 'VkSamplerAddressMode'");
    }
    this.memoryViewInt32[0xA] = value;
    }
    },
  "mipLodBias": {
    get() {
    return this.memoryViewFloat32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.mipLodBias': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xB] = value;
    }
    },
  "anisotropyEnable": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xC] = value | 0;
    }
    },
  "maxAnisotropy": {
    get() {
    return this.memoryViewFloat32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.maxAnisotropy': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xD] = value;
    }
    },
  "compareEnable": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xE] = value | 0;
    }
    },
  "compareOp": {
    get() {
    return this.memoryViewInt32[0xF];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.compareOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCompareOp(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.compareOp': '" + value + "' is not a value of 'VkCompareOp'");
    }
    this.memoryViewInt32[0xF] = value;
    }
    },
  "minLod": {
    get() {
    return this.memoryViewFloat32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.minLod': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x10] = value;
    }
    },
  "maxLod": {
    get() {
    return this.memoryViewFloat32[0x11];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.maxLod': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x11] = value;
    }
    },
  "borderColor": {
    get() {
    return this.memoryViewInt32[0x12];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.borderColor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBorderColor(value)) {
      throw new RangeError("Invalid value for 'VkSamplerCreateInfo.borderColor': '" + value + "' is not a value of 'VkBorderColor'");
    }
    this.memoryViewInt32[0x12] = value;
    }
    },
  "unnormalizedCoordinates": {
    get() {
    return this.memoryViewUint32[0x13] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x13] = value | 0;
    }
    },
  
});

VkSamplerCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x50], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x1F;
};

VkSamplerCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerCreateInfo.byteLength = 0x50;

VkSamplerCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  magFilter: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  minFilter: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  mipmapMode: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  addressModeU: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  addressModeV: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  addressModeW: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  mipLodBias: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  anisotropyEnable: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  maxAnisotropy: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  compareEnable: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  compareOp: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  minLod: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  maxLod: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  borderColor: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  unnormalizedCoordinates: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
};
/** VkCommandPoolCreateInfo **/
function VkCommandPoolCreateInfo(opts) {
  if (new.target !== VkCommandPoolCreateInfo) {
    _VkCommandPoolCreateInfo.reset();
    return _VkCommandPoolCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x27;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    
  }
};

Object.defineProperties(VkCommandPoolCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandPoolCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCommandPoolCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandPoolCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandPoolCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandPoolCreateInfo.queueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkCommandPoolCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x27;
};

VkCommandPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandPoolCreateInfo.byteLength = 0x18;

VkCommandPoolCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  queueFamilyIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkCommandBufferAllocateInfo **/
function VkCommandBufferAllocateInfo(opts) {
  if (new.target !== VkCommandBufferAllocateInfo) {
    _VkCommandBufferAllocateInfo.reset();
    return _VkCommandBufferAllocateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._commandPool = null;
  
  
  this.sType = 0x28;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.commandPool !== void 0) this.commandPool = opts.commandPool;
    if (opts.level !== void 0) this.level = opts.level;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    
  }
};

Object.defineProperties(VkCommandBufferAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCommandBufferAllocateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandBufferAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "commandPool": {
    get() {
    return this._commandPool;
    },
    set(value) {
    if (value !== null && value.constructor === VkCommandPool) {
      
      this._commandPool = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._commandPool = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.commandPool': Expected 'VkCommandPool' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "level": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.level': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCommandBufferLevel(value)) {
      throw new RangeError("Invalid value for 'VkCommandBufferAllocateInfo.level': '" + value + "' is not a value of 'VkCommandBufferLevel'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.commandBufferCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  
});

VkCommandBufferAllocateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._commandPool = null;
  
  
  this.sType = 0x28;
};

VkCommandBufferAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferAllocateInfo.byteLength = 0x20;

VkCommandBufferAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  commandPool: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  level: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  commandBufferCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkCommandBufferInheritanceInfo **/
function VkCommandBufferInheritanceInfo(opts) {
  if (new.target !== VkCommandBufferInheritanceInfo) {
    _VkCommandBufferInheritanceInfo.reset();
    return _VkCommandBufferInheritanceInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._renderPass = null;
  
  this._framebuffer = null;
  
  
  
  this.sType = 0x29;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
    if (opts.occlusionQueryEnable !== void 0) this.occlusionQueryEnable = opts.occlusionQueryEnable;
    if (opts.queryFlags !== void 0) this.queryFlags = opts.queryFlags;
    if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
    
  }
};

Object.defineProperties(VkCommandBufferInheritanceInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCommandBufferInheritanceInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C0668:
          break;
        default:
          throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
    }
    
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subpass": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.subpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "framebuffer": {
    get() {
    return this._framebuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkFramebuffer) {
      
      this._framebuffer = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._framebuffer = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.framebuffer': Expected 'VkFramebuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "occlusionQueryEnable": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xA] = value | 0;
    }
    },
  "queryFlags": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.queryFlags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xB] = value;
    }
    },
  "pipelineStatistics": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pipelineStatistics': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  
});

VkCommandBufferInheritanceInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  this._renderPass = null;
  
  this._framebuffer = null;
  
  
  
  this.sType = 0x29;
};

VkCommandBufferInheritanceInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferInheritanceInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferInheritanceInfo.byteLength = 0x38;

VkCommandBufferInheritanceInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  renderPass: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  subpass: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  framebuffer: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  occlusionQueryEnable: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  queryFlags: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  pipelineStatistics: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkCommandBufferBeginInfo **/
function VkCommandBufferBeginInfo(opts) {
  if (new.target !== VkCommandBufferBeginInfo) {
    _VkCommandBufferBeginInfo.reset();
    return _VkCommandBufferBeginInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pInheritanceInfo = null;
  this.sType = 0x2A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pInheritanceInfo !== void 0) this.pInheritanceInfo = opts.pInheritanceInfo;
    
  }
};

Object.defineProperties(VkCommandBufferBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCommandBufferBeginInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB464:
          break;
        default:
          throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "pInheritanceInfo": {
    get() {
    return this._pInheritanceInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkCommandBufferInheritanceInfo) {
      value.flush();
      this._pInheritanceInfo = value;
      this.memoryViewBigInt64[0x3] = value.memoryAddress;
      
    } else if (value === null) {
      this._pInheritanceInfo = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pInheritanceInfo': Expected 'VkCommandBufferInheritanceInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkCommandBufferBeginInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pInheritanceInfo = null;
  this.sType = 0x2A;
};

VkCommandBufferBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferBeginInfo.byteLength = 0x20;

VkCommandBufferBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pInheritanceInfo: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkRenderPassBeginInfo **/
function VkRenderPassBeginInfo(opts) {
  if (new.target !== VkRenderPassBeginInfo) {
    _VkRenderPassBeginInfo.reset();
    return _VkRenderPassBeginInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._renderPass = null;
  this._framebuffer = null;
  this._renderArea = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x20 });
  
  this._pClearValues = null;
    this._pClearValuesNative = null;
  this.sType = 0x2B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
    if (opts.renderArea !== void 0) this.renderArea = opts.renderArea;
    if (opts.clearValueCount !== void 0) this.clearValueCount = opts.clearValueCount;
    if (opts.pClearValues !== void 0) this.pClearValues = opts.pClearValues;
    
  }
};

Object.defineProperties(VkRenderPassBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassBeginInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB463:
        case 0x3B9CF899:
        case 0x3B9C6FE3:
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
    }
    
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "framebuffer": {
    get() {
    return this._framebuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkFramebuffer) {
      
      this._framebuffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._framebuffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.framebuffer': Expected 'VkFramebuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "renderArea": {
    get() {
    return this._renderArea;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._renderArea = value;
      
      
    } else if (value === null) {
      this._renderArea = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.renderArea': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "clearValueCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.clearValueCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pClearValues": {
    get() {
    return this._pClearValues;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pClearValues = value;
    } else if (value === null) {
      this._pClearValues = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pClearValues': Expected 'Array VkClearValue' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassBeginInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._renderPass = null;
  this._framebuffer = null;
  this._renderArea = null;
  
  this._pClearValues = null;
    this._pClearValuesNative = null;
  this.sType = 0x2B;
};

VkRenderPassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._renderArea !== null) {
    let renderArea = this._renderArea;
    renderArea.flush();
    if (this.memoryBuffer !== renderArea.memoryBuffer) {
      let srcView = new Uint8Array(renderArea.memoryBuffer).subarray(renderArea.$memoryOffset, renderArea.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRenderPassBeginInfo.renderArea' isn't used as shared-memory");
    }
  }
  
  
  if (this._pClearValues !== null) {
    let array = this._pClearValues;
    
    if (array.length !== this.clearValueCount) {
      throw new RangeError("Invalid array length, expected length of 'clearValueCount' for 'VkRenderPassBeginInfo.pClearValues'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkClearValue)) {
        throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pClearValues[" + ii + "]': Expected 'VkClearValue' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pClearValuesNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pClearValuesNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkRenderPassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkRenderPassBeginInfo.byteLength = 0x40;

VkRenderPassBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  renderPass: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  framebuffer: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  renderArea: {
    byteOffset: 0x20,
    byteLength: 0x10
  },
  clearValueCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pClearValues: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkClearDepthStencilValue **/
function VkClearDepthStencilValue(opts) {
  if (new.target !== VkClearDepthStencilValue) {
    _VkClearDepthStencilValue.reset();
    return _VkClearDepthStencilValue;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.depth !== void 0) this.depth = opts.depth;
    if (opts.stencil !== void 0) this.stencil = opts.stencil;
    
  }
};

Object.defineProperties(VkClearDepthStencilValue.prototype, {
  "depth": {
    get() {
    return this.memoryViewFloat32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearDepthStencilValue.depth': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x0] = value;
    }
    },
  "stencil": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearDepthStencilValue.stencil': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  
});

VkClearDepthStencilValue.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkClearDepthStencilValue.prototype.flush = function flush() {
  
  return true;
};

VkClearDepthStencilValue.prototype.reflect = function reflect(memoryAddress) {
  
};

VkClearDepthStencilValue.byteLength = 0x8;

VkClearDepthStencilValue.memoryLayout = {
  depth: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  stencil: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkClearAttachment **/
function VkClearAttachment(opts) {
  if (new.target !== VkClearAttachment) {
    _VkClearAttachment.reset();
    return _VkClearAttachment;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  this._clearValue = new VkClearValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.colorAttachment !== void 0) this.colorAttachment = opts.colorAttachment;
    if (opts.clearValue !== void 0) this.clearValue = opts.clearValue;
    
  }
};

Object.defineProperties(VkClearAttachment.prototype, {
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearAttachment.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "colorAttachment": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearAttachment.colorAttachment': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "clearValue": {
    get() {
    return this._clearValue;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearValue) {
      value.flush();
      this._clearValue = value;
      
      
    } else if (value === null) {
      this._clearValue = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearAttachment.clearValue': Expected 'VkClearValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkClearAttachment.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  this._clearValue = null;
  
};

VkClearAttachment.prototype.flush = function flush() {
  
  
  if (this._clearValue !== null) {
    let clearValue = this._clearValue;
    clearValue.flush();
    if (this.memoryBuffer !== clearValue.memoryBuffer) {
      let srcView = new Uint8Array(clearValue.memoryBuffer).subarray(clearValue.$memoryOffset, clearValue.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearAttachment.clearValue' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkClearAttachment.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkClearAttachment.byteLength = 0x18;

VkClearAttachment.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  colorAttachment: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  clearValue: {
    byteOffset: 0x8,
    byteLength: 0x10
  },
};
/** VkAttachmentDescription **/
function VkAttachmentDescription(opts) {
  if (new.target !== VkAttachmentDescription) {
    _VkAttachmentDescription.reset();
    return _VkAttachmentDescription;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x24) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x24) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x24);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescription.prototype, {
  "flags": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "samples": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.samples': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "loadOp": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.loadOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentLoadOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.loadOp': '" + value + "' is not a value of 'VkAttachmentLoadOp'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "storeOp": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.storeOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentStoreOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.storeOp': '" + value + "' is not a value of 'VkAttachmentStoreOp'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "stencilLoadOp": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.stencilLoadOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentLoadOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.stencilLoadOp': '" + value + "' is not a value of 'VkAttachmentLoadOp'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "stencilStoreOp": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.stencilStoreOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentStoreOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.stencilStoreOp': '" + value + "' is not a value of 'VkAttachmentStoreOp'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "initialLayout": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.initialLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.initialLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "finalLayout": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.finalLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription.finalLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkAttachmentDescription.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x24], 0x0);
  
  
  
  
  
  
  
  
  
  
};

VkAttachmentDescription.prototype.flush = function flush() {
  
  return true;
};

VkAttachmentDescription.prototype.reflect = function reflect(memoryAddress) {
  
};

VkAttachmentDescription.byteLength = 0x24;

VkAttachmentDescription.memoryLayout = {
  flags: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  format: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  samples: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  loadOp: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  storeOp: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  stencilLoadOp: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  stencilStoreOp: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  initialLayout: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  finalLayout: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkAttachmentReference **/
function VkAttachmentReference(opts) {
  if (new.target !== VkAttachmentReference) {
    _VkAttachmentReference.reset();
    return _VkAttachmentReference;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    
  }
};

Object.defineProperties(VkAttachmentReference.prototype, {
  "attachment": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference.attachment': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "layout": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference.layout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentReference.layout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  
});

VkAttachmentReference.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkAttachmentReference.prototype.flush = function flush() {
  
  return true;
};

VkAttachmentReference.prototype.reflect = function reflect(memoryAddress) {
  
};

VkAttachmentReference.byteLength = 0x8;

VkAttachmentReference.memoryLayout = {
  attachment: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  layout: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkSubpassDescription **/
function VkSubpassDescription(opts) {
  if (new.target !== VkSubpassDescription) {
    _VkSubpassDescription.reset();
    return _VkSubpassDescription;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  
  this._pInputAttachments = null;
    this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
    this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
    this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  
  if (typeof opts === "object") {
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

Object.defineProperties(VkSubpassDescription.prototype, {
  "flags": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pipelineBindPoint': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPipelineBindPoint(value)) {
      throw new RangeError("Invalid value for 'VkSubpassDescription.pipelineBindPoint': '" + value + "' is not a value of 'VkPipelineBindPoint'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "inputAttachmentCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.inputAttachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "pInputAttachments": {
    get() {
    return this._pInputAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pInputAttachments': Expected 'Array VkAttachmentReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "colorAttachmentCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.colorAttachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pColorAttachments": {
    get() {
    return this._pColorAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pColorAttachments': Expected 'Array VkAttachmentReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pResolveAttachments": {
    get() {
    return this._pResolveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pResolveAttachments': Expected 'Array VkAttachmentReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pDepthStencilAttachment": {
    get() {
    return this._pDepthStencilAttachment;
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryViewBigInt64[0x6] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pDepthStencilAttachment': Expected 'VkAttachmentReference' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preserveAttachmentCount": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.preserveAttachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xE] = value;
    }
    },
  "pPreserveAttachments": {
    get() {
    return this._pPreserveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryViewBigInt64[0x8] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pPreserveAttachments': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescription.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  
  
  this._pInputAttachments = null;
    this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
    this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
    this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  
};

VkSubpassDescription.prototype.flush = function flush() {
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pInputAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x2] = nativeArray.address;
    } else {
      this._pInputAttachmentsNative = null;
      this.memoryViewBigInt64[0x2] = BI0;
    }
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pColorAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pColorAttachmentsNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pResolveAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pResolveAttachmentsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkSubpassDescription.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkSubpassDescription.byteLength = 0x48;

VkSubpassDescription.memoryLayout = {
  flags: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pipelineBindPoint: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  inputAttachmentCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  pInputAttachments: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  colorAttachmentCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pColorAttachments: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pResolveAttachments: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pDepthStencilAttachment: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  preserveAttachmentCount: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  pPreserveAttachments: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
};
/** VkSubpassDependency **/
function VkSubpassDependency(opts) {
  if (new.target !== VkSubpassDependency) {
    _VkSubpassDependency.reset();
    return _VkSubpassDependency;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x1C) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x1C);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    
  }
};

Object.defineProperties(VkSubpassDependency.prototype, {
  "srcSubpass": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.srcSubpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "dstSubpass": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dstSubpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "srcStageMask": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.srcStageMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "dstStageMask": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dstStageMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.srcAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dstAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "dependencyFlags": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dependencyFlags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkSubpassDependency.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x1C], 0x0);
  
  
  
  
  
  
  
  
};

VkSubpassDependency.prototype.flush = function flush() {
  
  return true;
};

VkSubpassDependency.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSubpassDependency.byteLength = 0x1C;

VkSubpassDependency.memoryLayout = {
  srcSubpass: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  dstSubpass: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  srcStageMask: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  dstStageMask: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  srcAccessMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstAccessMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  dependencyFlags: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkRenderPassCreateInfo **/
function VkRenderPassCreateInfo(opts) {
  if (new.target !== VkRenderPassCreateInfo) {
    _VkRenderPassCreateInfo.reset();
    return _VkRenderPassCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
    this._pSubpassesNative = null;
  
  this._pDependencies = null;
    this._pDependenciesNative = null;
  this.sType = 0x26;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    
  }
};

Object.defineProperties(VkRenderPassCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B9908:
        case 0x3B9C9309:
        case 0x3B9E1D92:
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.attachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pAttachments": {
    get() {
    return this._pAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pAttachments': Expected 'Array VkAttachmentDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "subpassCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.subpassCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pSubpasses": {
    get() {
    return this._pSubpasses;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pSubpasses': Expected 'Array VkSubpassDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.dependencyCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pDependencies": {
    get() {
    return this._pDependencies;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pDependencies': Expected 'Array VkSubpassDependency' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
    this._pSubpassesNative = null;
  
  this._pDependencies = null;
    this._pDependenciesNative = null;
  this.sType = 0x26;
};

VkRenderPassCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentDescription)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAttachmentsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDescription)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSubpassesNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pSubpassesNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDependency)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pDependencies[" + ii + "]': Expected 'VkSubpassDependency' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDependenciesNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pDependenciesNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkRenderPassCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkRenderPassCreateInfo.byteLength = 0x40;

VkRenderPassCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  attachmentCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pAttachments: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  subpassCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pSubpasses: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  dependencyCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pDependencies: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkEventCreateInfo **/
function VkEventCreateInfo(opts) {
  if (new.target !== VkEventCreateInfo) {
    _VkEventCreateInfo.reset();
    return _VkEventCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0xA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkEventCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkEventCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkEventCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkEventCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkEventCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkEventCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0xA;
};

VkEventCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkEventCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkEventCreateInfo.byteLength = 0x18;

VkEventCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkFenceCreateInfo **/
function VkFenceCreateInfo(opts) {
  if (new.target !== VkFenceCreateInfo) {
    _VkFenceCreateInfo.reset();
    return _VkFenceCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkFenceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFenceCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C8368:
        case 0x3B9C8751:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkFenceCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x8;
};

VkFenceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkFenceCreateInfo.byteLength = 0x18;

VkFenceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFeatures **/
function VkPhysicalDeviceFeatures(opts) {
  if (new.target !== VkPhysicalDeviceFeatures) {
    _VkPhysicalDeviceFeatures.reset();
    return _VkPhysicalDeviceFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xDC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xDC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xDC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.robustBufferAccess !== void 0) this.robustBufferAccess = opts.robustBufferAccess;
    if (opts.fullDrawIndexUint32 !== void 0) this.fullDrawIndexUint32 = opts.fullDrawIndexUint32;
    if (opts.imageCubeArray !== void 0) this.imageCubeArray = opts.imageCubeArray;
    if (opts.independentBlend !== void 0) this.independentBlend = opts.independentBlend;
    if (opts.geometryShader !== void 0) this.geometryShader = opts.geometryShader;
    if (opts.tessellationShader !== void 0) this.tessellationShader = opts.tessellationShader;
    if (opts.sampleRateShading !== void 0) this.sampleRateShading = opts.sampleRateShading;
    if (opts.dualSrcBlend !== void 0) this.dualSrcBlend = opts.dualSrcBlend;
    if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
    if (opts.multiDrawIndirect !== void 0) this.multiDrawIndirect = opts.multiDrawIndirect;
    if (opts.drawIndirectFirstInstance !== void 0) this.drawIndirectFirstInstance = opts.drawIndirectFirstInstance;
    if (opts.depthClamp !== void 0) this.depthClamp = opts.depthClamp;
    if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
    if (opts.fillModeNonSolid !== void 0) this.fillModeNonSolid = opts.fillModeNonSolid;
    if (opts.depthBounds !== void 0) this.depthBounds = opts.depthBounds;
    if (opts.wideLines !== void 0) this.wideLines = opts.wideLines;
    if (opts.largePoints !== void 0) this.largePoints = opts.largePoints;
    if (opts.alphaToOne !== void 0) this.alphaToOne = opts.alphaToOne;
    if (opts.multiViewport !== void 0) this.multiViewport = opts.multiViewport;
    if (opts.samplerAnisotropy !== void 0) this.samplerAnisotropy = opts.samplerAnisotropy;
    if (opts.textureCompressionETC2 !== void 0) this.textureCompressionETC2 = opts.textureCompressionETC2;
    if (opts.textureCompressionASTC_LDR !== void 0) this.textureCompressionASTC_LDR = opts.textureCompressionASTC_LDR;
    if (opts.textureCompressionBC !== void 0) this.textureCompressionBC = opts.textureCompressionBC;
    if (opts.occlusionQueryPrecise !== void 0) this.occlusionQueryPrecise = opts.occlusionQueryPrecise;
    if (opts.pipelineStatisticsQuery !== void 0) this.pipelineStatisticsQuery = opts.pipelineStatisticsQuery;
    if (opts.vertexPipelineStoresAndAtomics !== void 0) this.vertexPipelineStoresAndAtomics = opts.vertexPipelineStoresAndAtomics;
    if (opts.fragmentStoresAndAtomics !== void 0) this.fragmentStoresAndAtomics = opts.fragmentStoresAndAtomics;
    if (opts.shaderTessellationAndGeometryPointSize !== void 0) this.shaderTessellationAndGeometryPointSize = opts.shaderTessellationAndGeometryPointSize;
    if (opts.shaderImageGatherExtended !== void 0) this.shaderImageGatherExtended = opts.shaderImageGatherExtended;
    if (opts.shaderStorageImageExtendedFormats !== void 0) this.shaderStorageImageExtendedFormats = opts.shaderStorageImageExtendedFormats;
    if (opts.shaderStorageImageMultisample !== void 0) this.shaderStorageImageMultisample = opts.shaderStorageImageMultisample;
    if (opts.shaderStorageImageReadWithoutFormat !== void 0) this.shaderStorageImageReadWithoutFormat = opts.shaderStorageImageReadWithoutFormat;
    if (opts.shaderStorageImageWriteWithoutFormat !== void 0) this.shaderStorageImageWriteWithoutFormat = opts.shaderStorageImageWriteWithoutFormat;
    if (opts.shaderUniformBufferArrayDynamicIndexing !== void 0) this.shaderUniformBufferArrayDynamicIndexing = opts.shaderUniformBufferArrayDynamicIndexing;
    if (opts.shaderSampledImageArrayDynamicIndexing !== void 0) this.shaderSampledImageArrayDynamicIndexing = opts.shaderSampledImageArrayDynamicIndexing;
    if (opts.shaderStorageBufferArrayDynamicIndexing !== void 0) this.shaderStorageBufferArrayDynamicIndexing = opts.shaderStorageBufferArrayDynamicIndexing;
    if (opts.shaderStorageImageArrayDynamicIndexing !== void 0) this.shaderStorageImageArrayDynamicIndexing = opts.shaderStorageImageArrayDynamicIndexing;
    if (opts.shaderClipDistance !== void 0) this.shaderClipDistance = opts.shaderClipDistance;
    if (opts.shaderCullDistance !== void 0) this.shaderCullDistance = opts.shaderCullDistance;
    if (opts.shaderFloat64 !== void 0) this.shaderFloat64 = opts.shaderFloat64;
    if (opts.shaderInt64 !== void 0) this.shaderInt64 = opts.shaderInt64;
    if (opts.shaderInt16 !== void 0) this.shaderInt16 = opts.shaderInt16;
    if (opts.shaderResourceResidency !== void 0) this.shaderResourceResidency = opts.shaderResourceResidency;
    if (opts.shaderResourceMinLod !== void 0) this.shaderResourceMinLod = opts.shaderResourceMinLod;
    if (opts.sparseBinding !== void 0) this.sparseBinding = opts.sparseBinding;
    if (opts.sparseResidencyBuffer !== void 0) this.sparseResidencyBuffer = opts.sparseResidencyBuffer;
    if (opts.sparseResidencyImage2D !== void 0) this.sparseResidencyImage2D = opts.sparseResidencyImage2D;
    if (opts.sparseResidencyImage3D !== void 0) this.sparseResidencyImage3D = opts.sparseResidencyImage3D;
    if (opts.sparseResidency2Samples !== void 0) this.sparseResidency2Samples = opts.sparseResidency2Samples;
    if (opts.sparseResidency4Samples !== void 0) this.sparseResidency4Samples = opts.sparseResidency4Samples;
    if (opts.sparseResidency8Samples !== void 0) this.sparseResidency8Samples = opts.sparseResidency8Samples;
    if (opts.sparseResidency16Samples !== void 0) this.sparseResidency16Samples = opts.sparseResidency16Samples;
    if (opts.sparseResidencyAliased !== void 0) this.sparseResidencyAliased = opts.sparseResidencyAliased;
    if (opts.variableMultisampleRate !== void 0) this.variableMultisampleRate = opts.variableMultisampleRate;
    if (opts.inheritedQueries !== void 0) this.inheritedQueries = opts.inheritedQueries;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFeatures.prototype, {
  "robustBufferAccess": {
    get() {
    return this.memoryViewUint32[0x0] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x0] = value | 0;
    }
    },
  "fullDrawIndexUint32": {
    get() {
    return this.memoryViewUint32[0x1] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1] = value | 0;
    }
    },
  "imageCubeArray": {
    get() {
    return this.memoryViewUint32[0x2] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2] = value | 0;
    }
    },
  "independentBlend": {
    get() {
    return this.memoryViewUint32[0x3] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x3] = value | 0;
    }
    },
  "geometryShader": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "tessellationShader": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "sampleRateShading": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "dualSrcBlend": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x7] = value | 0;
    }
    },
  "logicOp": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x8] = value | 0;
    }
    },
  "multiDrawIndirect": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x9] = value | 0;
    }
    },
  "drawIndirectFirstInstance": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xA] = value | 0;
    }
    },
  "depthClamp": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xB] = value | 0;
    }
    },
  "depthBiasClamp": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xC] = value | 0;
    }
    },
  "fillModeNonSolid": {
    get() {
    return this.memoryViewUint32[0xD] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xD] = value | 0;
    }
    },
  "depthBounds": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xE] = value | 0;
    }
    },
  "wideLines": {
    get() {
    return this.memoryViewUint32[0xF] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xF] = value | 0;
    }
    },
  "largePoints": {
    get() {
    return this.memoryViewUint32[0x10] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x10] = value | 0;
    }
    },
  "alphaToOne": {
    get() {
    return this.memoryViewUint32[0x11] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x11] = value | 0;
    }
    },
  "multiViewport": {
    get() {
    return this.memoryViewUint32[0x12] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x12] = value | 0;
    }
    },
  "samplerAnisotropy": {
    get() {
    return this.memoryViewUint32[0x13] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x13] = value | 0;
    }
    },
  "textureCompressionETC2": {
    get() {
    return this.memoryViewUint32[0x14] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x14] = value | 0;
    }
    },
  "textureCompressionASTC_LDR": {
    get() {
    return this.memoryViewUint32[0x15] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x15] = value | 0;
    }
    },
  "textureCompressionBC": {
    get() {
    return this.memoryViewUint32[0x16] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x16] = value | 0;
    }
    },
  "occlusionQueryPrecise": {
    get() {
    return this.memoryViewUint32[0x17] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x17] = value | 0;
    }
    },
  "pipelineStatisticsQuery": {
    get() {
    return this.memoryViewUint32[0x18] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x18] = value | 0;
    }
    },
  "vertexPipelineStoresAndAtomics": {
    get() {
    return this.memoryViewUint32[0x19] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x19] = value | 0;
    }
    },
  "fragmentStoresAndAtomics": {
    get() {
    return this.memoryViewUint32[0x1A] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1A] = value | 0;
    }
    },
  "shaderTessellationAndGeometryPointSize": {
    get() {
    return this.memoryViewUint32[0x1B] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1B] = value | 0;
    }
    },
  "shaderImageGatherExtended": {
    get() {
    return this.memoryViewUint32[0x1C] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1C] = value | 0;
    }
    },
  "shaderStorageImageExtendedFormats": {
    get() {
    return this.memoryViewUint32[0x1D] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1D] = value | 0;
    }
    },
  "shaderStorageImageMultisample": {
    get() {
    return this.memoryViewUint32[0x1E] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1E] = value | 0;
    }
    },
  "shaderStorageImageReadWithoutFormat": {
    get() {
    return this.memoryViewUint32[0x1F] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x1F] = value | 0;
    }
    },
  "shaderStorageImageWriteWithoutFormat": {
    get() {
    return this.memoryViewUint32[0x20] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x20] = value | 0;
    }
    },
  "shaderUniformBufferArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x21] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x21] = value | 0;
    }
    },
  "shaderSampledImageArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x22] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x22] = value | 0;
    }
    },
  "shaderStorageBufferArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x23] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x23] = value | 0;
    }
    },
  "shaderStorageImageArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x24] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x24] = value | 0;
    }
    },
  "shaderClipDistance": {
    get() {
    return this.memoryViewUint32[0x25] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x25] = value | 0;
    }
    },
  "shaderCullDistance": {
    get() {
    return this.memoryViewUint32[0x26] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x26] = value | 0;
    }
    },
  "shaderFloat64": {
    get() {
    return this.memoryViewUint32[0x27] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x27] = value | 0;
    }
    },
  "shaderInt64": {
    get() {
    return this.memoryViewUint32[0x28] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x28] = value | 0;
    }
    },
  "shaderInt16": {
    get() {
    return this.memoryViewUint32[0x29] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x29] = value | 0;
    }
    },
  "shaderResourceResidency": {
    get() {
    return this.memoryViewUint32[0x2A] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2A] = value | 0;
    }
    },
  "shaderResourceMinLod": {
    get() {
    return this.memoryViewUint32[0x2B] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2B] = value | 0;
    }
    },
  "sparseBinding": {
    get() {
    return this.memoryViewUint32[0x2C] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2C] = value | 0;
    }
    },
  "sparseResidencyBuffer": {
    get() {
    return this.memoryViewUint32[0x2D] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2D] = value | 0;
    }
    },
  "sparseResidencyImage2D": {
    get() {
    return this.memoryViewUint32[0x2E] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2E] = value | 0;
    }
    },
  "sparseResidencyImage3D": {
    get() {
    return this.memoryViewUint32[0x2F] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x2F] = value | 0;
    }
    },
  "sparseResidency2Samples": {
    get() {
    return this.memoryViewUint32[0x30] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x30] = value | 0;
    }
    },
  "sparseResidency4Samples": {
    get() {
    return this.memoryViewUint32[0x31] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x31] = value | 0;
    }
    },
  "sparseResidency8Samples": {
    get() {
    return this.memoryViewUint32[0x32] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x32] = value | 0;
    }
    },
  "sparseResidency16Samples": {
    get() {
    return this.memoryViewUint32[0x33] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x33] = value | 0;
    }
    },
  "sparseResidencyAliased": {
    get() {
    return this.memoryViewUint32[0x34] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x34] = value | 0;
    }
    },
  "variableMultisampleRate": {
    get() {
    return this.memoryViewUint32[0x35] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x35] = value | 0;
    }
    },
  "inheritedQueries": {
    get() {
    return this.memoryViewUint32[0x36] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x36] = value | 0;
    }
    },
  
});

VkPhysicalDeviceFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xDC], 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceFeatures.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceFeatures.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPhysicalDeviceFeatures.byteLength = 0xDC;

VkPhysicalDeviceFeatures.memoryLayout = {
  robustBufferAccess: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  fullDrawIndexUint32: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  imageCubeArray: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  independentBlend: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  geometryShader: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  tessellationShader: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  sampleRateShading: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  dualSrcBlend: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  logicOp: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  multiDrawIndirect: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  drawIndirectFirstInstance: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  depthClamp: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  depthBiasClamp: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  fillModeNonSolid: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  depthBounds: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  wideLines: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  largePoints: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  alphaToOne: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  multiViewport: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  samplerAnisotropy: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  textureCompressionETC2: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  textureCompressionASTC_LDR: {
    byteOffset: 0x54,
    byteLength: 0x4
  },
  textureCompressionBC: {
    byteOffset: 0x58,
    byteLength: 0x4
  },
  occlusionQueryPrecise: {
    byteOffset: 0x5C,
    byteLength: 0x4
  },
  pipelineStatisticsQuery: {
    byteOffset: 0x60,
    byteLength: 0x4
  },
  vertexPipelineStoresAndAtomics: {
    byteOffset: 0x64,
    byteLength: 0x4
  },
  fragmentStoresAndAtomics: {
    byteOffset: 0x68,
    byteLength: 0x4
  },
  shaderTessellationAndGeometryPointSize: {
    byteOffset: 0x6C,
    byteLength: 0x4
  },
  shaderImageGatherExtended: {
    byteOffset: 0x70,
    byteLength: 0x4
  },
  shaderStorageImageExtendedFormats: {
    byteOffset: 0x74,
    byteLength: 0x4
  },
  shaderStorageImageMultisample: {
    byteOffset: 0x78,
    byteLength: 0x4
  },
  shaderStorageImageReadWithoutFormat: {
    byteOffset: 0x7C,
    byteLength: 0x4
  },
  shaderStorageImageWriteWithoutFormat: {
    byteOffset: 0x80,
    byteLength: 0x4
  },
  shaderUniformBufferArrayDynamicIndexing: {
    byteOffset: 0x84,
    byteLength: 0x4
  },
  shaderSampledImageArrayDynamicIndexing: {
    byteOffset: 0x88,
    byteLength: 0x4
  },
  shaderStorageBufferArrayDynamicIndexing: {
    byteOffset: 0x8C,
    byteLength: 0x4
  },
  shaderStorageImageArrayDynamicIndexing: {
    byteOffset: 0x90,
    byteLength: 0x4
  },
  shaderClipDistance: {
    byteOffset: 0x94,
    byteLength: 0x4
  },
  shaderCullDistance: {
    byteOffset: 0x98,
    byteLength: 0x4
  },
  shaderFloat64: {
    byteOffset: 0x9C,
    byteLength: 0x4
  },
  shaderInt64: {
    byteOffset: 0xA0,
    byteLength: 0x4
  },
  shaderInt16: {
    byteOffset: 0xA4,
    byteLength: 0x4
  },
  shaderResourceResidency: {
    byteOffset: 0xA8,
    byteLength: 0x4
  },
  shaderResourceMinLod: {
    byteOffset: 0xAC,
    byteLength: 0x4
  },
  sparseBinding: {
    byteOffset: 0xB0,
    byteLength: 0x4
  },
  sparseResidencyBuffer: {
    byteOffset: 0xB4,
    byteLength: 0x4
  },
  sparseResidencyImage2D: {
    byteOffset: 0xB8,
    byteLength: 0x4
  },
  sparseResidencyImage3D: {
    byteOffset: 0xBC,
    byteLength: 0x4
  },
  sparseResidency2Samples: {
    byteOffset: 0xC0,
    byteLength: 0x4
  },
  sparseResidency4Samples: {
    byteOffset: 0xC4,
    byteLength: 0x4
  },
  sparseResidency8Samples: {
    byteOffset: 0xC8,
    byteLength: 0x4
  },
  sparseResidency16Samples: {
    byteOffset: 0xCC,
    byteLength: 0x4
  },
  sparseResidencyAliased: {
    byteOffset: 0xD0,
    byteLength: 0x4
  },
  variableMultisampleRate: {
    byteOffset: 0xD4,
    byteLength: 0x4
  },
  inheritedQueries: {
    byteOffset: 0xD8,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceSparseProperties **/
function VkPhysicalDeviceSparseProperties(opts) {
  if (new.target !== VkPhysicalDeviceSparseProperties) {
    _VkPhysicalDeviceSparseProperties.reset();
    return _VkPhysicalDeviceSparseProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x14) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x14);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceSparseProperties.prototype, {
  "residencyStandard2DBlockShape": {
    get() {
    return this.memoryViewUint32[0x0] !== 0;
    },
    },
  "residencyStandard2DMultisampleBlockShape": {
    get() {
    return this.memoryViewUint32[0x1] !== 0;
    },
    },
  "residencyStandard3DBlockShape": {
    get() {
    return this.memoryViewUint32[0x2] !== 0;
    },
    },
  "residencyAlignedMipSize": {
    get() {
    return this.memoryViewUint32[0x3] !== 0;
    },
    },
  "residencyNonResidentStrict": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkPhysicalDeviceSparseProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x14], 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceSparseProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceSparseProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x14));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x14), 0x0);
};

VkPhysicalDeviceSparseProperties.byteLength = 0x14;

VkPhysicalDeviceSparseProperties.memoryLayout = {
  residencyStandard2DBlockShape: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  residencyStandard2DMultisampleBlockShape: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  residencyStandard3DBlockShape: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  residencyAlignedMipSize: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  residencyNonResidentStrict: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceLimits **/
function VkPhysicalDeviceLimits(opts) {
  if (new.target !== VkPhysicalDeviceLimits) {
    _VkPhysicalDeviceLimits.reset();
    return _VkPhysicalDeviceLimits;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x1F8) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1F8) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x1F8) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1F8) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x1F8) / 0x8);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1F8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x1F8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this._maxComputeWorkGroupCount = [...Array(3)].fill(0x0);
  
  this._maxComputeWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  
  
  
  
  
  this._maxViewportDimensions = [...Array(2)].fill(0x0);
  this._viewportBoundsRange = [...Array(2)].fill(0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this._pointSizeRange = [...Array(2)].fill(0x0);
  this._lineWidthRange = [...Array(2)].fill(0x0);
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceLimits.prototype, {
  "maxImageDimension1D": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    },
  "maxImageDimension2D": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    },
  "maxImageDimension3D": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    },
  "maxImageDimensionCube": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    },
  "maxImageArrayLayers": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxTexelBufferElements": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "maxUniformBufferRange": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    },
  "maxStorageBufferRange": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    },
  "maxPushConstantsSize": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    },
  "maxMemoryAllocationCount": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    },
  "maxSamplerAllocationCount": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    },
  "bufferImageGranularity": {
    get() {
    return this.memoryViewBigUint64[0x6];
    },
    },
  "sparseAddressSpaceSize": {
    get() {
    return this.memoryViewBigUint64[0x7];
    },
    },
  "maxBoundDescriptorSets": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    },
  "maxPerStageDescriptorSamplers": {
    get() {
    return this.memoryViewUint32[0x11];
    },
    },
  "maxPerStageDescriptorUniformBuffers": {
    get() {
    return this.memoryViewUint32[0x12];
    },
    },
  "maxPerStageDescriptorStorageBuffers": {
    get() {
    return this.memoryViewUint32[0x13];
    },
    },
  "maxPerStageDescriptorSampledImages": {
    get() {
    return this.memoryViewUint32[0x14];
    },
    },
  "maxPerStageDescriptorStorageImages": {
    get() {
    return this.memoryViewUint32[0x15];
    },
    },
  "maxPerStageDescriptorInputAttachments": {
    get() {
    return this.memoryViewUint32[0x16];
    },
    },
  "maxPerStageResources": {
    get() {
    return this.memoryViewUint32[0x17];
    },
    },
  "maxDescriptorSetSamplers": {
    get() {
    return this.memoryViewUint32[0x18];
    },
    },
  "maxDescriptorSetUniformBuffers": {
    get() {
    return this.memoryViewUint32[0x19];
    },
    },
  "maxDescriptorSetUniformBuffersDynamic": {
    get() {
    return this.memoryViewUint32[0x1A];
    },
    },
  "maxDescriptorSetStorageBuffers": {
    get() {
    return this.memoryViewUint32[0x1B];
    },
    },
  "maxDescriptorSetStorageBuffersDynamic": {
    get() {
    return this.memoryViewUint32[0x1C];
    },
    },
  "maxDescriptorSetSampledImages": {
    get() {
    return this.memoryViewUint32[0x1D];
    },
    },
  "maxDescriptorSetStorageImages": {
    get() {
    return this.memoryViewUint32[0x1E];
    },
    },
  "maxDescriptorSetInputAttachments": {
    get() {
    return this.memoryViewUint32[0x1F];
    },
    },
  "maxVertexInputAttributes": {
    get() {
    return this.memoryViewUint32[0x20];
    },
    },
  "maxVertexInputBindings": {
    get() {
    return this.memoryViewUint32[0x21];
    },
    },
  "maxVertexInputAttributeOffset": {
    get() {
    return this.memoryViewUint32[0x22];
    },
    },
  "maxVertexInputBindingStride": {
    get() {
    return this.memoryViewUint32[0x23];
    },
    },
  "maxVertexOutputComponents": {
    get() {
    return this.memoryViewUint32[0x24];
    },
    },
  "maxTessellationGenerationLevel": {
    get() {
    return this.memoryViewUint32[0x25];
    },
    },
  "maxTessellationPatchSize": {
    get() {
    return this.memoryViewUint32[0x26];
    },
    },
  "maxTessellationControlPerVertexInputComponents": {
    get() {
    return this.memoryViewUint32[0x27];
    },
    },
  "maxTessellationControlPerVertexOutputComponents": {
    get() {
    return this.memoryViewUint32[0x28];
    },
    },
  "maxTessellationControlPerPatchOutputComponents": {
    get() {
    return this.memoryViewUint32[0x29];
    },
    },
  "maxTessellationControlTotalOutputComponents": {
    get() {
    return this.memoryViewUint32[0x2A];
    },
    },
  "maxTessellationEvaluationInputComponents": {
    get() {
    return this.memoryViewUint32[0x2B];
    },
    },
  "maxTessellationEvaluationOutputComponents": {
    get() {
    return this.memoryViewUint32[0x2C];
    },
    },
  "maxGeometryShaderInvocations": {
    get() {
    return this.memoryViewUint32[0x2D];
    },
    },
  "maxGeometryInputComponents": {
    get() {
    return this.memoryViewUint32[0x2E];
    },
    },
  "maxGeometryOutputComponents": {
    get() {
    return this.memoryViewUint32[0x2F];
    },
    },
  "maxGeometryOutputVertices": {
    get() {
    return this.memoryViewUint32[0x30];
    },
    },
  "maxGeometryTotalOutputComponents": {
    get() {
    return this.memoryViewUint32[0x31];
    },
    },
  "maxFragmentInputComponents": {
    get() {
    return this.memoryViewUint32[0x32];
    },
    },
  "maxFragmentOutputAttachments": {
    get() {
    return this.memoryViewUint32[0x33];
    },
    },
  "maxFragmentDualSrcAttachments": {
    get() {
    return this.memoryViewUint32[0x34];
    },
    },
  "maxFragmentCombinedOutputResources": {
    get() {
    return this.memoryViewUint32[0x35];
    },
    },
  "maxComputeSharedMemorySize": {
    get() {
    return this.memoryViewUint32[0x36];
    },
    },
  "maxComputeWorkGroupCount": {
    get() {
    return [
      this.memoryViewUint32[0x37],
      this.memoryViewUint32[0x38],
      this.memoryViewUint32[0x39]
    ];
    },
    },
  "maxComputeWorkGroupInvocations": {
    get() {
    return this.memoryViewUint32[0x3A];
    },
    },
  "maxComputeWorkGroupSize": {
    get() {
    return [
      this.memoryViewUint32[0x3B],
      this.memoryViewUint32[0x3C],
      this.memoryViewUint32[0x3D]
    ];
    },
    },
  "subPixelPrecisionBits": {
    get() {
    return this.memoryViewUint32[0x3E];
    },
    },
  "subTexelPrecisionBits": {
    get() {
    return this.memoryViewUint32[0x3F];
    },
    },
  "mipmapPrecisionBits": {
    get() {
    return this.memoryViewUint32[0x40];
    },
    },
  "maxDrawIndexedIndexValue": {
    get() {
    return this.memoryViewUint32[0x41];
    },
    },
  "maxDrawIndirectCount": {
    get() {
    return this.memoryViewUint32[0x42];
    },
    },
  "maxSamplerLodBias": {
    get() {
    return this.memoryViewFloat32[0x43];
    },
    },
  "maxSamplerAnisotropy": {
    get() {
    return this.memoryViewFloat32[0x44];
    },
    },
  "maxViewports": {
    get() {
    return this.memoryViewUint32[0x45];
    },
    },
  "maxViewportDimensions": {
    get() {
    return [
      this.memoryViewUint32[0x46],
      this.memoryViewUint32[0x47]
    ];
    },
    },
  "viewportBoundsRange": {
    get() {
    return [
      this.memoryViewFloat32[0x48],
      this.memoryViewFloat32[0x49]
    ];
    },
    },
  "viewportSubPixelBits": {
    get() {
    return this.memoryViewUint32[0x4A];
    },
    },
  "minMemoryMapAlignment": {
    get() {
    return this.memoryViewBigInt64[0x26];
    },
    },
  "minTexelBufferOffsetAlignment": {
    get() {
    return this.memoryViewBigUint64[0x27];
    },
    },
  "minUniformBufferOffsetAlignment": {
    get() {
    return this.memoryViewBigUint64[0x28];
    },
    },
  "minStorageBufferOffsetAlignment": {
    get() {
    return this.memoryViewBigUint64[0x29];
    },
    },
  "minTexelOffset": {
    get() {
    return this.memoryViewInt32[0x54];
    },
    },
  "maxTexelOffset": {
    get() {
    return this.memoryViewUint32[0x55];
    },
    },
  "minTexelGatherOffset": {
    get() {
    return this.memoryViewInt32[0x56];
    },
    },
  "maxTexelGatherOffset": {
    get() {
    return this.memoryViewUint32[0x57];
    },
    },
  "minInterpolationOffset": {
    get() {
    return this.memoryViewFloat32[0x58];
    },
    },
  "maxInterpolationOffset": {
    get() {
    return this.memoryViewFloat32[0x59];
    },
    },
  "subPixelInterpolationOffsetBits": {
    get() {
    return this.memoryViewUint32[0x5A];
    },
    },
  "maxFramebufferWidth": {
    get() {
    return this.memoryViewUint32[0x5B];
    },
    },
  "maxFramebufferHeight": {
    get() {
    return this.memoryViewUint32[0x5C];
    },
    },
  "maxFramebufferLayers": {
    get() {
    return this.memoryViewUint32[0x5D];
    },
    },
  "framebufferColorSampleCounts": {
    get() {
    return this.memoryViewInt32[0x5E];
    },
    },
  "framebufferDepthSampleCounts": {
    get() {
    return this.memoryViewInt32[0x5F];
    },
    },
  "framebufferStencilSampleCounts": {
    get() {
    return this.memoryViewInt32[0x60];
    },
    },
  "framebufferNoAttachmentsSampleCounts": {
    get() {
    return this.memoryViewInt32[0x61];
    },
    },
  "maxColorAttachments": {
    get() {
    return this.memoryViewUint32[0x62];
    },
    },
  "sampledImageColorSampleCounts": {
    get() {
    return this.memoryViewInt32[0x63];
    },
    },
  "sampledImageIntegerSampleCounts": {
    get() {
    return this.memoryViewInt32[0x64];
    },
    },
  "sampledImageDepthSampleCounts": {
    get() {
    return this.memoryViewInt32[0x65];
    },
    },
  "sampledImageStencilSampleCounts": {
    get() {
    return this.memoryViewInt32[0x66];
    },
    },
  "storageImageSampleCounts": {
    get() {
    return this.memoryViewInt32[0x67];
    },
    },
  "maxSampleMaskWords": {
    get() {
    return this.memoryViewUint32[0x68];
    },
    },
  "timestampComputeAndGraphics": {
    get() {
    return this.memoryViewUint32[0x69] !== 0;
    },
    },
  "timestampPeriod": {
    get() {
    return this.memoryViewFloat32[0x6A];
    },
    },
  "maxClipDistances": {
    get() {
    return this.memoryViewUint32[0x6B];
    },
    },
  "maxCullDistances": {
    get() {
    return this.memoryViewUint32[0x6C];
    },
    },
  "maxCombinedClipAndCullDistances": {
    get() {
    return this.memoryViewUint32[0x6D];
    },
    },
  "discreteQueuePriorities": {
    get() {
    return this.memoryViewUint32[0x6E];
    },
    },
  "pointSizeRange": {
    get() {
    return [
      this.memoryViewFloat32[0x6F],
      this.memoryViewFloat32[0x70]
    ];
    },
    },
  "lineWidthRange": {
    get() {
    return [
      this.memoryViewFloat32[0x71],
      this.memoryViewFloat32[0x72]
    ];
    },
    },
  "pointSizeGranularity": {
    get() {
    return this.memoryViewFloat32[0x73];
    },
    },
  "lineWidthGranularity": {
    get() {
    return this.memoryViewFloat32[0x74];
    },
    },
  "strictLines": {
    get() {
    return this.memoryViewUint32[0x75] !== 0;
    },
    },
  "standardSampleLocations": {
    get() {
    return this.memoryViewUint32[0x76] !== 0;
    },
    },
  "optimalBufferCopyOffsetAlignment": {
    get() {
    return this.memoryViewBigUint64[0x3C];
    },
    },
  "optimalBufferCopyRowPitchAlignment": {
    get() {
    return this.memoryViewBigUint64[0x3D];
    },
    },
  "nonCoherentAtomSize": {
    get() {
    return this.memoryViewBigUint64[0x3E];
    },
    },
  
});

VkPhysicalDeviceLimits.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x1F8], 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this._maxComputeWorkGroupCount = null;
  
  this._maxComputeWorkGroupSize = null;
  
  
  
  
  
  
  
  
  this._maxViewportDimensions = null;
  this._viewportBoundsRange = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this._pointSizeRange = null;
  this._lineWidthRange = null;
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceLimits.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceLimits.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x1F8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x1F8), 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceLimits.byteLength = 0x1F8;

VkPhysicalDeviceLimits.memoryLayout = {
  maxImageDimension1D: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  maxImageDimension2D: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  maxImageDimension3D: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  maxImageDimensionCube: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  maxImageArrayLayers: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxTexelBufferElements: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  maxUniformBufferRange: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  maxStorageBufferRange: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  maxPushConstantsSize: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  maxMemoryAllocationCount: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  maxSamplerAllocationCount: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  bufferImageGranularity: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  sparseAddressSpaceSize: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  maxBoundDescriptorSets: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  maxPerStageDescriptorSamplers: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  maxPerStageDescriptorUniformBuffers: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  maxPerStageDescriptorStorageBuffers: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  maxPerStageDescriptorSampledImages: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  maxPerStageDescriptorStorageImages: {
    byteOffset: 0x54,
    byteLength: 0x4
  },
  maxPerStageDescriptorInputAttachments: {
    byteOffset: 0x58,
    byteLength: 0x4
  },
  maxPerStageResources: {
    byteOffset: 0x5C,
    byteLength: 0x4
  },
  maxDescriptorSetSamplers: {
    byteOffset: 0x60,
    byteLength: 0x4
  },
  maxDescriptorSetUniformBuffers: {
    byteOffset: 0x64,
    byteLength: 0x4
  },
  maxDescriptorSetUniformBuffersDynamic: {
    byteOffset: 0x68,
    byteLength: 0x4
  },
  maxDescriptorSetStorageBuffers: {
    byteOffset: 0x6C,
    byteLength: 0x4
  },
  maxDescriptorSetStorageBuffersDynamic: {
    byteOffset: 0x70,
    byteLength: 0x4
  },
  maxDescriptorSetSampledImages: {
    byteOffset: 0x74,
    byteLength: 0x4
  },
  maxDescriptorSetStorageImages: {
    byteOffset: 0x78,
    byteLength: 0x4
  },
  maxDescriptorSetInputAttachments: {
    byteOffset: 0x7C,
    byteLength: 0x4
  },
  maxVertexInputAttributes: {
    byteOffset: 0x80,
    byteLength: 0x4
  },
  maxVertexInputBindings: {
    byteOffset: 0x84,
    byteLength: 0x4
  },
  maxVertexInputAttributeOffset: {
    byteOffset: 0x88,
    byteLength: 0x4
  },
  maxVertexInputBindingStride: {
    byteOffset: 0x8C,
    byteLength: 0x4
  },
  maxVertexOutputComponents: {
    byteOffset: 0x90,
    byteLength: 0x4
  },
  maxTessellationGenerationLevel: {
    byteOffset: 0x94,
    byteLength: 0x4
  },
  maxTessellationPatchSize: {
    byteOffset: 0x98,
    byteLength: 0x4
  },
  maxTessellationControlPerVertexInputComponents: {
    byteOffset: 0x9C,
    byteLength: 0x4
  },
  maxTessellationControlPerVertexOutputComponents: {
    byteOffset: 0xA0,
    byteLength: 0x4
  },
  maxTessellationControlPerPatchOutputComponents: {
    byteOffset: 0xA4,
    byteLength: 0x4
  },
  maxTessellationControlTotalOutputComponents: {
    byteOffset: 0xA8,
    byteLength: 0x4
  },
  maxTessellationEvaluationInputComponents: {
    byteOffset: 0xAC,
    byteLength: 0x4
  },
  maxTessellationEvaluationOutputComponents: {
    byteOffset: 0xB0,
    byteLength: 0x4
  },
  maxGeometryShaderInvocations: {
    byteOffset: 0xB4,
    byteLength: 0x4
  },
  maxGeometryInputComponents: {
    byteOffset: 0xB8,
    byteLength: 0x4
  },
  maxGeometryOutputComponents: {
    byteOffset: 0xBC,
    byteLength: 0x4
  },
  maxGeometryOutputVertices: {
    byteOffset: 0xC0,
    byteLength: 0x4
  },
  maxGeometryTotalOutputComponents: {
    byteOffset: 0xC4,
    byteLength: 0x4
  },
  maxFragmentInputComponents: {
    byteOffset: 0xC8,
    byteLength: 0x4
  },
  maxFragmentOutputAttachments: {
    byteOffset: 0xCC,
    byteLength: 0x4
  },
  maxFragmentDualSrcAttachments: {
    byteOffset: 0xD0,
    byteLength: 0x4
  },
  maxFragmentCombinedOutputResources: {
    byteOffset: 0xD4,
    byteLength: 0x4
  },
  maxComputeSharedMemorySize: {
    byteOffset: 0xD8,
    byteLength: 0x4
  },
  maxComputeWorkGroupCount: {
    byteOffset: 0xDC,
    byteLength: 0xC
  },
  maxComputeWorkGroupInvocations: {
    byteOffset: 0xE8,
    byteLength: 0x4
  },
  maxComputeWorkGroupSize: {
    byteOffset: 0xEC,
    byteLength: 0xC
  },
  subPixelPrecisionBits: {
    byteOffset: 0xF8,
    byteLength: 0x4
  },
  subTexelPrecisionBits: {
    byteOffset: 0xFC,
    byteLength: 0x4
  },
  mipmapPrecisionBits: {
    byteOffset: 0x100,
    byteLength: 0x4
  },
  maxDrawIndexedIndexValue: {
    byteOffset: 0x104,
    byteLength: 0x4
  },
  maxDrawIndirectCount: {
    byteOffset: 0x108,
    byteLength: 0x4
  },
  maxSamplerLodBias: {
    byteOffset: 0x10C,
    byteLength: 0x4
  },
  maxSamplerAnisotropy: {
    byteOffset: 0x110,
    byteLength: 0x4
  },
  maxViewports: {
    byteOffset: 0x114,
    byteLength: 0x4
  },
  maxViewportDimensions: {
    byteOffset: 0x118,
    byteLength: 0x8
  },
  viewportBoundsRange: {
    byteOffset: 0x120,
    byteLength: 0x8
  },
  viewportSubPixelBits: {
    byteOffset: 0x128,
    byteLength: 0x4
  },
  minMemoryMapAlignment: {
    byteOffset: 0x130,
    byteLength: 0x8
  },
  minTexelBufferOffsetAlignment: {
    byteOffset: 0x138,
    byteLength: 0x8
  },
  minUniformBufferOffsetAlignment: {
    byteOffset: 0x140,
    byteLength: 0x8
  },
  minStorageBufferOffsetAlignment: {
    byteOffset: 0x148,
    byteLength: 0x8
  },
  minTexelOffset: {
    byteOffset: 0x150,
    byteLength: 0x4
  },
  maxTexelOffset: {
    byteOffset: 0x154,
    byteLength: 0x4
  },
  minTexelGatherOffset: {
    byteOffset: 0x158,
    byteLength: 0x4
  },
  maxTexelGatherOffset: {
    byteOffset: 0x15C,
    byteLength: 0x4
  },
  minInterpolationOffset: {
    byteOffset: 0x160,
    byteLength: 0x4
  },
  maxInterpolationOffset: {
    byteOffset: 0x164,
    byteLength: 0x4
  },
  subPixelInterpolationOffsetBits: {
    byteOffset: 0x168,
    byteLength: 0x4
  },
  maxFramebufferWidth: {
    byteOffset: 0x16C,
    byteLength: 0x4
  },
  maxFramebufferHeight: {
    byteOffset: 0x170,
    byteLength: 0x4
  },
  maxFramebufferLayers: {
    byteOffset: 0x174,
    byteLength: 0x4
  },
  framebufferColorSampleCounts: {
    byteOffset: 0x178,
    byteLength: 0x4
  },
  framebufferDepthSampleCounts: {
    byteOffset: 0x17C,
    byteLength: 0x4
  },
  framebufferStencilSampleCounts: {
    byteOffset: 0x180,
    byteLength: 0x4
  },
  framebufferNoAttachmentsSampleCounts: {
    byteOffset: 0x184,
    byteLength: 0x4
  },
  maxColorAttachments: {
    byteOffset: 0x188,
    byteLength: 0x4
  },
  sampledImageColorSampleCounts: {
    byteOffset: 0x18C,
    byteLength: 0x4
  },
  sampledImageIntegerSampleCounts: {
    byteOffset: 0x190,
    byteLength: 0x4
  },
  sampledImageDepthSampleCounts: {
    byteOffset: 0x194,
    byteLength: 0x4
  },
  sampledImageStencilSampleCounts: {
    byteOffset: 0x198,
    byteLength: 0x4
  },
  storageImageSampleCounts: {
    byteOffset: 0x19C,
    byteLength: 0x4
  },
  maxSampleMaskWords: {
    byteOffset: 0x1A0,
    byteLength: 0x4
  },
  timestampComputeAndGraphics: {
    byteOffset: 0x1A4,
    byteLength: 0x4
  },
  timestampPeriod: {
    byteOffset: 0x1A8,
    byteLength: 0x4
  },
  maxClipDistances: {
    byteOffset: 0x1AC,
    byteLength: 0x4
  },
  maxCullDistances: {
    byteOffset: 0x1B0,
    byteLength: 0x4
  },
  maxCombinedClipAndCullDistances: {
    byteOffset: 0x1B4,
    byteLength: 0x4
  },
  discreteQueuePriorities: {
    byteOffset: 0x1B8,
    byteLength: 0x4
  },
  pointSizeRange: {
    byteOffset: 0x1BC,
    byteLength: 0x8
  },
  lineWidthRange: {
    byteOffset: 0x1C4,
    byteLength: 0x8
  },
  pointSizeGranularity: {
    byteOffset: 0x1CC,
    byteLength: 0x4
  },
  lineWidthGranularity: {
    byteOffset: 0x1D0,
    byteLength: 0x4
  },
  strictLines: {
    byteOffset: 0x1D4,
    byteLength: 0x4
  },
  standardSampleLocations: {
    byteOffset: 0x1D8,
    byteLength: 0x4
  },
  optimalBufferCopyOffsetAlignment: {
    byteOffset: 0x1E0,
    byteLength: 0x8
  },
  optimalBufferCopyRowPitchAlignment: {
    byteOffset: 0x1E8,
    byteLength: 0x8
  },
  nonCoherentAtomSize: {
    byteOffset: 0x1F0,
    byteLength: 0x8
  },
};
/** VkSemaphoreCreateInfo **/
function VkSemaphoreCreateInfo(opts) {
  if (new.target !== VkSemaphoreCreateInfo) {
    _VkSemaphoreCreateInfo.reset();
    return _VkSemaphoreCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkSemaphoreCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSemaphoreCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BF6C8:
        case 0x3B9BFAB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkSemaphoreCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x9;
};

VkSemaphoreCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSemaphoreCreateInfo.byteLength = 0x18;

VkSemaphoreCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkQueryPoolCreateInfo **/
function VkQueryPoolCreateInfo(opts) {
  if (new.target !== VkQueryPoolCreateInfo) {
    _VkQueryPoolCreateInfo.reset();
    return _VkQueryPoolCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0xB;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queryType !== void 0) this.queryType = opts.queryType;
    if (opts.queryCount !== void 0) this.queryCount = opts.queryCount;
    if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
    
  }
};

Object.defineProperties(VkQueryPoolCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkQueryPoolCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueryPoolCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "queryType": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.queryType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkQueryType(value)) {
      throw new RangeError("Invalid value for 'VkQueryPoolCreateInfo.queryType': '" + value + "' is not a value of 'VkQueryType'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "queryCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.queryCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pipelineStatistics": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.pipelineStatistics': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  
});

VkQueryPoolCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0xB;
};

VkQueryPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkQueryPoolCreateInfo.byteLength = 0x20;

VkQueryPoolCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  queryType: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  queryCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pipelineStatistics: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkFramebufferCreateInfo **/
function VkFramebufferCreateInfo(opts) {
  if (new.target !== VkFramebufferCreateInfo) {
    _VkFramebufferCreateInfo.reset();
    return _VkFramebufferCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._renderPass = null;
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  
  
  
  this.sType = 0x25;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layers !== void 0) this.layers = opts.layers;
    
  }
};

Object.defineProperties(VkFramebufferCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFramebufferCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C6FE1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.attachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pAttachments": {
    get() {
    return this._pAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pAttachments': Expected 'Array VkImageView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "width": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.width': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "height": {
    get() {
    return this.memoryViewUint32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.height': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xD] = value;
    }
    },
  "layers": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.layers': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xE] = value;
    }
    },
  
});

VkFramebufferCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._renderPass = null;
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  
  
  
  this.sType = 0x25;
};

VkFramebufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkFramebufferCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageView)) {
        throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pAttachments[" + ii + "]': Expected 'VkImageView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pAttachmentsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkFramebufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkFramebufferCreateInfo.byteLength = 0x40;

VkFramebufferCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  renderPass: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  attachmentCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pAttachments: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  width: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  height: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  layers: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkDrawIndirectCommand **/
function VkDrawIndirectCommand(opts) {
  if (new.target !== VkDrawIndirectCommand) {
    _VkDrawIndirectCommand.reset();
    return _VkDrawIndirectCommand;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.firstVertex !== void 0) this.firstVertex = opts.firstVertex;
    if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
    
  }
};

Object.defineProperties(VkDrawIndirectCommand.prototype, {
  "vertexCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.vertexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "instanceCount": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.instanceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "firstVertex": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.firstVertex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "firstInstance": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.firstInstance': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x3] = value;
    }
    },
  
});

VkDrawIndirectCommand.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
  
};

VkDrawIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDrawIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDrawIndirectCommand.byteLength = 0x10;

VkDrawIndirectCommand.memoryLayout = {
  vertexCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  instanceCount: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  firstVertex: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  firstInstance: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkDrawIndexedIndirectCommand **/
function VkDrawIndexedIndirectCommand(opts) {
  if (new.target !== VkDrawIndexedIndirectCommand) {
    _VkDrawIndexedIndirectCommand.reset();
    return _VkDrawIndexedIndirectCommand;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x14) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x14);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.firstIndex !== void 0) this.firstIndex = opts.firstIndex;
    if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
    if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
    
  }
};

Object.defineProperties(VkDrawIndexedIndirectCommand.prototype, {
  "indexCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.indexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "instanceCount": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.instanceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "firstIndex": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.firstIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "vertexOffset": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.vertexOffset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "firstInstance": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.firstInstance': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkDrawIndexedIndirectCommand.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x14], 0x0);
  
  
  
  
  
  
};

VkDrawIndexedIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDrawIndexedIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDrawIndexedIndirectCommand.byteLength = 0x14;

VkDrawIndexedIndirectCommand.memoryLayout = {
  indexCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  instanceCount: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  firstIndex: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  vertexOffset: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  firstInstance: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDispatchIndirectCommand **/
function VkDispatchIndirectCommand(opts) {
  if (new.target !== VkDispatchIndirectCommand) {
    _VkDispatchIndirectCommand.reset();
    return _VkDispatchIndirectCommand;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    
  }
};

Object.defineProperties(VkDispatchIndirectCommand.prototype, {
  "x": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDispatchIndirectCommand.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDispatchIndirectCommand.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "z": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDispatchIndirectCommand.z': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  
});

VkDispatchIndirectCommand.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkDispatchIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDispatchIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDispatchIndirectCommand.byteLength = 0xC;

VkDispatchIndirectCommand.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  z: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkSubmitInfo **/
function VkSubmitInfo(opts) {
  if (new.target !== VkSubmitInfo) {
    _VkSubmitInfo.reset();
    return _VkSubmitInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
  this._pWaitDstStageMask = null;
  
  this._pCommandBuffers = null;
    this._pCommandBuffersNative = null;
  
  this._pSignalSemaphores = null;
    this._pSignalSemaphoresNative = null;
  this.sType = 0x4;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.pWaitDstStageMask !== void 0) this.pWaitDstStageMask = opts.pWaitDstStageMask;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBuffers !== void 0) this.pCommandBuffers = opts.pCommandBuffers;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
    
  }
};

Object.defineProperties(VkSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSubmitInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BAC90:
        case 0x3B9BEEF8:
        case 0x3B9BFAB2:
        case 0x3B9BB465:
        case 0x3B9D0068:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
    }
    
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.waitSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pWaitSemaphores": {
    get() {
    return this._pWaitSemaphores;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pWaitDstStageMask": {
    get() {
    return this._pWaitDstStageMask;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pWaitDstStageMask = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitDstStageMask = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitDstStageMask': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.commandBufferCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "pCommandBuffers": {
    get() {
    return this._pCommandBuffers;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pCommandBuffers = value;
    } else if (value === null) {
      this._pCommandBuffers = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pCommandBuffers': Expected 'Array VkCommandBuffer' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.signalSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xE] = value;
    }
    },
  "pSignalSemaphores": {
    get() {
    return this._pSignalSemaphores;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSignalSemaphores = value;
    } else if (value === null) {
      this._pSignalSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pSignalSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSubmitInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
  this._pWaitDstStageMask = null;
  
  this._pCommandBuffers = null;
    this._pCommandBuffersNative = null;
  
  this._pSignalSemaphores = null;
    this._pSignalSemaphoresNative = null;
  this.sType = 0x4;
};

VkSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkSubmitInfo.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pWaitSemaphoresNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pWaitSemaphoresNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pCommandBuffers !== null) {
    let array = this._pCommandBuffers;
    
    if (array.length !== this.commandBufferCount) {
      throw new RangeError("Invalid array length, expected length of 'commandBufferCount' for 'VkSubmitInfo.pCommandBuffers'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkCommandBuffer)) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pCommandBuffers[" + ii + "]': Expected 'VkCommandBuffer' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pCommandBuffersNative = nativeArray;
      this.memoryViewBigInt64[0x6] = nativeArray.address;
    } else {
      this._pCommandBuffersNative = null;
      this.memoryViewBigInt64[0x6] = BI0;
    }
  }
  
  
  if (this._pSignalSemaphores !== null) {
    let array = this._pSignalSemaphores;
    
    if (array.length !== this.signalSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'signalSemaphoreCount' for 'VkSubmitInfo.pSignalSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pSignalSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSignalSemaphoresNative = nativeArray;
      this.memoryViewBigInt64[0x8] = nativeArray.address;
    } else {
      this._pSignalSemaphoresNative = null;
      this.memoryViewBigInt64[0x8] = BI0;
    }
  }
  
  return true;
};

VkSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkSubmitInfo.byteLength = 0x48;

VkSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  waitSemaphoreCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pWaitSemaphores: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pWaitDstStageMask: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  commandBufferCount: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  pCommandBuffers: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  signalSemaphoreCount: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  pSignalSemaphores: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
};
/** VkDisplayPropertiesKHR **/
function VkDisplayPropertiesKHR(opts) {
  if (new.target !== VkDisplayPropertiesKHR) {
    _VkDisplayPropertiesKHR.reset();
    return _VkDisplayPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._display = null;
  this._displayName = null;
  this._physicalDimensions = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._physicalResolution = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayPropertiesKHR.prototype, {
  "display": {
    get() {
    return this._display;
    },
    },
  "displayName": {
    get() {
    if (this._displayName !== null) {
      let str = textDecoder.decode(this._displayName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    },
  "physicalDimensions": {
    get() {
    return this._physicalDimensions;
    },
    },
  "physicalResolution": {
    get() {
    return this._physicalResolution;
    },
    },
  "supportedTransforms": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    },
  "planeReorderPossible": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    },
  "persistentContent": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    },
  
});

VkDisplayPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  this._display = null;
  this._displayName = null;
  this._physicalDimensions = null;
  this._physicalResolution = null;
  
  
  
  
};

VkDisplayPropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
};

VkDisplayPropertiesKHR.byteLength = 0x30;

VkDisplayPropertiesKHR.memoryLayout = {
  display: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  displayName: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  physicalDimensions: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  physicalResolution: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  supportedTransforms: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  planeReorderPossible: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  persistentContent: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
};
/** VkDisplayPlanePropertiesKHR **/
function VkDisplayPlanePropertiesKHR(opts) {
  if (new.target !== VkDisplayPlanePropertiesKHR) {
    _VkDisplayPlanePropertiesKHR.reset();
    return _VkDisplayPlanePropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._currentDisplay = null;
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayPlanePropertiesKHR.prototype, {
  "currentDisplay": {
    get() {
    return this._currentDisplay;
    },
    },
  "currentStackIndex": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    },
  
});

VkDisplayPlanePropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  this._currentDisplay = null;
  
  
};

VkDisplayPlanePropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPlanePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkDisplayPlanePropertiesKHR.byteLength = 0x10;

VkDisplayPlanePropertiesKHR.memoryLayout = {
  currentDisplay: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  currentStackIndex: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkDisplayModeParametersKHR **/
function VkDisplayModeParametersKHR(opts) {
  if (new.target !== VkDisplayModeParametersKHR) {
    _VkDisplayModeParametersKHR.reset();
    return _VkDisplayModeParametersKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._visibleRegion = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  if (typeof opts === "object") {
    if (opts.visibleRegion !== void 0) this.visibleRegion = opts.visibleRegion;
    if (opts.refreshRate !== void 0) this.refreshRate = opts.refreshRate;
    
  }
};

Object.defineProperties(VkDisplayModeParametersKHR.prototype, {
  "visibleRegion": {
    get() {
    return this._visibleRegion;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._visibleRegion = value;
      
      
    } else if (value === null) {
      this._visibleRegion = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayModeParametersKHR.visibleRegion': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "refreshRate": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeParametersKHR.refreshRate': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  
});

VkDisplayModeParametersKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  this._visibleRegion = null;
  
  
};

VkDisplayModeParametersKHR.prototype.flush = function flush() {
  
  
  if (this._visibleRegion !== null) {
    let visibleRegion = this._visibleRegion;
    visibleRegion.flush();
    if (this.memoryBuffer !== visibleRegion.memoryBuffer) {
      let srcView = new Uint8Array(visibleRegion.memoryBuffer).subarray(visibleRegion.$memoryOffset, visibleRegion.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayModeParametersKHR.visibleRegion' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplayModeParametersKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayModeParametersKHR.byteLength = 0xC;

VkDisplayModeParametersKHR.memoryLayout = {
  visibleRegion: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  refreshRate: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkDisplayModePropertiesKHR **/
function VkDisplayModePropertiesKHR(opts) {
  if (new.target !== VkDisplayModePropertiesKHR) {
    _VkDisplayModePropertiesKHR.reset();
    return _VkDisplayModePropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._displayMode = null;
  this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayModePropertiesKHR.prototype, {
  "displayMode": {
    get() {
    return this._displayMode;
    },
    },
  "parameters": {
    get() {
    return this._parameters;
    },
    },
  
});

VkDisplayModePropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  this._displayMode = null;
  this._parameters = null;
  
};

VkDisplayModePropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayModePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDisplayModePropertiesKHR.byteLength = 0x18;

VkDisplayModePropertiesKHR.memoryLayout = {
  displayMode: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  parameters: {
    byteOffset: 0x8,
    byteLength: 0xC
  },
};
/** VkDisplayModeCreateInfoKHR **/
function VkDisplayModeCreateInfoKHR(opts) {
  if (new.target !== VkDisplayModeCreateInfoKHR) {
    _VkDisplayModeCreateInfoKHR.reset();
    return _VkDisplayModeCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x14 });
  this.sType = 0x3B9AD1D0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.parameters !== void 0) this.parameters = opts.parameters;
    
  }
};

Object.defineProperties(VkDisplayModeCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayModeCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayModeCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "parameters": {
    get() {
    return this._parameters;
    },
    set(value) {
    if (value !== null && value.constructor === VkDisplayModeParametersKHR) {
      value.flush();
      this._parameters = value;
      
      
    } else if (value === null) {
      this._parameters = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.parameters': Expected 'VkDisplayModeParametersKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDisplayModeCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._parameters = null;
  this.sType = 0x3B9AD1D0;
};

VkDisplayModeCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._parameters !== null) {
    let parameters = this._parameters;
    parameters.flush();
    if (this.memoryBuffer !== parameters.memoryBuffer) {
      let srcView = new Uint8Array(parameters.memoryBuffer).subarray(parameters.$memoryOffset, parameters.$memoryOffset + 0xC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x14);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayModeCreateInfoKHR.parameters' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplayModeCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDisplayModeCreateInfoKHR.byteLength = 0x20;

VkDisplayModeCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  parameters: {
    byteOffset: 0x14,
    byteLength: 0xC
  },
};
/** VkDisplayPlaneCapabilitiesKHR **/
function VkDisplayPlaneCapabilitiesKHR(opts) {
  if (new.target !== VkDisplayPlaneCapabilitiesKHR) {
    _VkDisplayPlaneCapabilitiesKHR.reset();
    return _VkDisplayPlaneCapabilitiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x44) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x44) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x44);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  this._minSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x4 });
  this._maxSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0xC });
  this._minSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x14 });
  this._maxSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x1C });
  this._minDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x24 });
  this._maxDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x2C });
  this._minDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x34 });
  this._maxDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x3C });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayPlaneCapabilitiesKHR.prototype, {
  "supportedAlpha": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "minSrcPosition": {
    get() {
    return this._minSrcPosition;
    },
    },
  "maxSrcPosition": {
    get() {
    return this._maxSrcPosition;
    },
    },
  "minSrcExtent": {
    get() {
    return this._minSrcExtent;
    },
    },
  "maxSrcExtent": {
    get() {
    return this._maxSrcExtent;
    },
    },
  "minDstPosition": {
    get() {
    return this._minDstPosition;
    },
    },
  "maxDstPosition": {
    get() {
    return this._maxDstPosition;
    },
    },
  "minDstExtent": {
    get() {
    return this._minDstExtent;
    },
    },
  "maxDstExtent": {
    get() {
    return this._maxDstExtent;
    },
    },
  
});

VkDisplayPlaneCapabilitiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x44], 0x0);
  
  this._minSrcPosition = null;
  this._maxSrcPosition = null;
  this._minSrcExtent = null;
  this._maxSrcExtent = null;
  this._minDstPosition = null;
  this._maxDstPosition = null;
  this._minDstExtent = null;
  this._maxDstExtent = null;
  
};

VkDisplayPlaneCapabilitiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPlaneCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x44));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x44), 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
};

VkDisplayPlaneCapabilitiesKHR.byteLength = 0x44;

VkDisplayPlaneCapabilitiesKHR.memoryLayout = {
  supportedAlpha: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  minSrcPosition: {
    byteOffset: 0x4,
    byteLength: 0x8
  },
  maxSrcPosition: {
    byteOffset: 0xC,
    byteLength: 0x8
  },
  minSrcExtent: {
    byteOffset: 0x14,
    byteLength: 0x8
  },
  maxSrcExtent: {
    byteOffset: 0x1C,
    byteLength: 0x8
  },
  minDstPosition: {
    byteOffset: 0x24,
    byteLength: 0x8
  },
  maxDstPosition: {
    byteOffset: 0x2C,
    byteLength: 0x8
  },
  minDstExtent: {
    byteOffset: 0x34,
    byteLength: 0x8
  },
  maxDstExtent: {
    byteOffset: 0x3C,
    byteLength: 0x8
  },
};
/** VkDisplaySurfaceCreateInfoKHR **/
function VkDisplaySurfaceCreateInfoKHR(opts) {
  if (new.target !== VkDisplaySurfaceCreateInfoKHR) {
    _VkDisplaySurfaceCreateInfoKHR.reset();
    return _VkDisplaySurfaceCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._displayMode = null;
  
  
  
  
  
  this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x34 });
  this.sType = 0x3B9AD1D1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.displayMode !== void 0) this.displayMode = opts.displayMode;
    if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
    if (opts.planeStackIndex !== void 0) this.planeStackIndex = opts.planeStackIndex;
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.globalAlpha !== void 0) this.globalAlpha = opts.globalAlpha;
    if (opts.alphaMode !== void 0) this.alphaMode = opts.alphaMode;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

Object.defineProperties(VkDisplaySurfaceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplaySurfaceCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplaySurfaceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "displayMode": {
    get() {
    return this._displayMode;
    },
    set(value) {
    if (value !== null && value.constructor === VkDisplayModeKHR) {
      
      this._displayMode = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._displayMode = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.displayMode': Expected 'VkDisplayModeKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "planeIndex": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.planeIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "planeStackIndex": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.planeStackIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x9] = value;
    }
    },
  "transform": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.transform': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xA] = value;
    }
    },
  "globalAlpha": {
    get() {
    return this.memoryViewFloat32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.globalAlpha': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xB] = value;
    }
    },
  "alphaMode": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.alphaMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.imageExtent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDisplaySurfaceCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._displayMode = null;
  
  
  
  
  
  this._imageExtent = null;
  this.sType = 0x3B9AD1D1;
};

VkDisplaySurfaceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer).subarray(imageExtent.$memoryOffset, imageExtent.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x34);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplaySurfaceCreateInfoKHR.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplaySurfaceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDisplaySurfaceCreateInfoKHR.byteLength = 0x40;

VkDisplaySurfaceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  displayMode: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  planeIndex: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  planeStackIndex: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  transform: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  globalAlpha: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  alphaMode: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  imageExtent: {
    byteOffset: 0x34,
    byteLength: 0x8
  },
};
/** VkDisplayPresentInfoKHR **/
function VkDisplayPresentInfoKHR(opts) {
  if (new.target !== VkDisplayPresentInfoKHR) {
    _VkDisplayPresentInfoKHR.reset();
    return _VkDisplayPresentInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._srcRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._dstRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x20 });
  
  this.sType = 0x3B9AD5B8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcRect !== void 0) this.srcRect = opts.srcRect;
    if (opts.dstRect !== void 0) this.dstRect = opts.dstRect;
    if (opts.persistent !== void 0) this.persistent = opts.persistent;
    
  }
};

Object.defineProperties(VkDisplayPresentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayPresentInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPresentInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "srcRect": {
    get() {
    return this._srcRect;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._srcRect = value;
      
      
    } else if (value === null) {
      this._srcRect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.srcRect': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstRect": {
    get() {
    return this._dstRect;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._dstRect = value;
      
      
    } else if (value === null) {
      this._dstRect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.dstRect': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "persistent": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xC] = value | 0;
    }
    },
  
});

VkDisplayPresentInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  this._srcRect = null;
  this._dstRect = null;
  
  this.sType = 0x3B9AD5B8;
};

VkDisplayPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._srcRect !== null) {
    let srcRect = this._srcRect;
    srcRect.flush();
    if (this.memoryBuffer !== srcRect.memoryBuffer) {
      let srcView = new Uint8Array(srcRect.memoryBuffer).subarray(srcRect.$memoryOffset, srcRect.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayPresentInfoKHR.srcRect' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstRect !== null) {
    let dstRect = this._dstRect;
    dstRect.flush();
    if (this.memoryBuffer !== dstRect.memoryBuffer) {
      let srcView = new Uint8Array(dstRect.memoryBuffer).subarray(dstRect.$memoryOffset, dstRect.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayPresentInfoKHR.dstRect' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplayPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkDisplayPresentInfoKHR.byteLength = 0x38;

VkDisplayPresentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcRect: {
    byteOffset: 0x10,
    byteLength: 0x10
  },
  dstRect: {
    byteOffset: 0x20,
    byteLength: 0x10
  },
  persistent: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkSurfaceCapabilitiesKHR **/
function VkSurfaceCapabilitiesKHR(opts) {
  if (new.target !== VkSurfaceCapabilitiesKHR) {
    _VkSurfaceCapabilitiesKHR.reset();
    return _VkSurfaceCapabilitiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x34) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x34) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x34) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x34);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSurfaceCapabilitiesKHR.prototype, {
  "minImageCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    },
  "maxImageCount": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    },
  "currentExtent": {
    get() {
    return this._currentExtent;
    },
    },
  "minImageExtent": {
    get() {
    return this._minImageExtent;
    },
    },
  "maxImageExtent": {
    get() {
    return this._maxImageExtent;
    },
    },
  "maxImageArrayLayers": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    },
  "supportedTransforms": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    },
  "currentTransform": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    },
  "supportedCompositeAlpha": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    },
  "supportedUsageFlags": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    },
  
});

VkSurfaceCapabilitiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x34], 0x0);
  
  
  this._currentExtent = null;
  this._minImageExtent = null;
  this._maxImageExtent = null;
  
  
  
  
  
  
};

VkSurfaceCapabilitiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkSurfaceCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x34));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x34), 0x0);
  
  
  
  
  
  
};

VkSurfaceCapabilitiesKHR.byteLength = 0x34;

VkSurfaceCapabilitiesKHR.memoryLayout = {
  minImageCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  maxImageCount: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  currentExtent: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  minImageExtent: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  maxImageExtent: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  maxImageArrayLayers: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  supportedTransforms: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  currentTransform: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  supportedCompositeAlpha: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  supportedUsageFlags: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkWin32SurfaceCreateInfoKHR **/
function VkWin32SurfaceCreateInfoKHR(opts) {
  if (new.target !== VkWin32SurfaceCreateInfoKHR) {
    _VkWin32SurfaceCreateInfoKHR.reset();
    return _VkWin32SurfaceCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9AED28;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.hinstance !== void 0) this.hinstance = opts.hinstance;
    if (opts.hwnd !== void 0) this.hwnd = opts.hwnd;
    
  }
};

Object.defineProperties(VkWin32SurfaceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32SurfaceCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkWin32SurfaceCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWin32SurfaceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32SurfaceCreateInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "hinstance": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32SurfaceCreateInfoKHR.hinstance': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  "hwnd": {
    get() {
    return this.memoryViewBigInt64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32SurfaceCreateInfoKHR.hwnd': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x4] = BigInt(value);
    }
    },
  
});

VkWin32SurfaceCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9AED28;
};

VkWin32SurfaceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkWin32SurfaceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkWin32SurfaceCreateInfoKHR.byteLength = 0x28;

VkWin32SurfaceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  hinstance: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  hwnd: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkSurfaceFormatKHR **/
function VkSurfaceFormatKHR(opts) {
  if (new.target !== VkSurfaceFormatKHR) {
    _VkSurfaceFormatKHR.reset();
    return _VkSurfaceFormatKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSurfaceFormatKHR.prototype, {
  "format": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "colorSpace": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    },
  
});

VkSurfaceFormatKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkSurfaceFormatKHR.prototype.flush = function flush() {
  
  return true;
};

VkSurfaceFormatKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x8), 0x0);
};

VkSurfaceFormatKHR.byteLength = 0x8;

VkSurfaceFormatKHR.memoryLayout = {
  format: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  colorSpace: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkSwapchainCreateInfoKHR **/
function VkSwapchainCreateInfoKHR(opts) {
  if (new.target !== VkSwapchainCreateInfoKHR) {
    _VkSwapchainCreateInfoKHR.reset();
    return _VkSwapchainCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x68) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x68) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x68);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._surface = null;
  
  
  
  this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x2C });
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  
  
  
  this._oldSwapchain = null;
  this.sType = 0x3B9ACDE8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.surface !== void 0) this.surface = opts.surface;
    if (opts.minImageCount !== void 0) this.minImageCount = opts.minImageCount;
    if (opts.imageFormat !== void 0) this.imageFormat = opts.imageFormat;
    if (opts.imageColorSpace !== void 0) this.imageColorSpace = opts.imageColorSpace;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    if (opts.imageArrayLayers !== void 0) this.imageArrayLayers = opts.imageArrayLayers;
    if (opts.imageUsage !== void 0) this.imageUsage = opts.imageUsage;
    if (opts.imageSharingMode !== void 0) this.imageSharingMode = opts.imageSharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    if (opts.preTransform !== void 0) this.preTransform = opts.preTransform;
    if (opts.compositeAlpha !== void 0) this.compositeAlpha = opts.compositeAlpha;
    if (opts.presentMode !== void 0) this.presentMode = opts.presentMode;
    if (opts.clipped !== void 0) this.clipped = opts.clipped;
    if (opts.oldSwapchain !== void 0) this.oldSwapchain = opts.oldSwapchain;
    
  }
};

Object.defineProperties(VkSwapchainCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9C2D7B:
        case 0x3B9BB46C:
        case 0x3B9E0A09:
        case 0x3B9D0838:
        case 0x3B9EAE18:
        case 0x3B9EAE19:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "surface": {
    get() {
    return this._surface;
    },
    set(value) {
    if (value !== null && value.constructor === VkSurfaceKHR) {
      
      this._surface = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._surface = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.surface': Expected 'VkSurfaceKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "minImageCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.minImageCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "imageFormat": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageFormat': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainCreateInfoKHR.imageFormat': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "imageColorSpace": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageColorSpace': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkColorSpaceKHR(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainCreateInfoKHR.imageColorSpace': '" + value + "' is not a value of 'VkColorSpaceKHR'");
    }
    this.memoryViewInt32[0xA] = value;
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageExtent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageArrayLayers": {
    get() {
    return this.memoryViewUint32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageArrayLayers': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xD] = value;
    }
    },
  "imageUsage": {
    get() {
    return this.memoryViewInt32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageUsage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xE] = value;
    }
    },
  "imageSharingMode": {
    get() {
    return this.memoryViewInt32[0xF];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageSharingMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSharingMode(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainCreateInfoKHR.imageSharingMode': '" + value + "' is not a value of 'VkSharingMode'");
    }
    this.memoryViewInt32[0xF] = value;
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.queueFamilyIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x9] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preTransform": {
    get() {
    return this.memoryViewInt32[0x14];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.preTransform': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x14] = value;
    }
    },
  "compositeAlpha": {
    get() {
    return this.memoryViewInt32[0x15];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.compositeAlpha': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x15] = value;
    }
    },
  "presentMode": {
    get() {
    return this.memoryViewInt32[0x16];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.presentMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPresentModeKHR(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainCreateInfoKHR.presentMode': '" + value + "' is not a value of 'VkPresentModeKHR'");
    }
    this.memoryViewInt32[0x16] = value;
    }
    },
  "clipped": {
    get() {
    return this.memoryViewUint32[0x17] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x17] = value | 0;
    }
    },
  "oldSwapchain": {
    get() {
    return this._oldSwapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._oldSwapchain = value;
      
      this.memoryViewBigInt64[0xC] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._oldSwapchain = null;
      this.memoryViewBigInt64[0xC] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.oldSwapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSwapchainCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x68], 0x0);
  
  this._pNext = null;
  
  this._surface = null;
  
  
  
  this._imageExtent = null;
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  
  
  
  this._oldSwapchain = null;
  this.sType = 0x3B9ACDE8;
};

VkSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer).subarray(imageExtent.$memoryOffset, imageExtent.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSwapchainCreateInfoKHR.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkSwapchainCreateInfoKHR.byteLength = 0x68;

VkSwapchainCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  surface: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  minImageCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  imageFormat: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  imageColorSpace: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  imageExtent: {
    byteOffset: 0x2C,
    byteLength: 0x8
  },
  imageArrayLayers: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  imageUsage: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  imageSharingMode: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  queueFamilyIndexCount: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  pQueueFamilyIndices: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  preTransform: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  compositeAlpha: {
    byteOffset: 0x54,
    byteLength: 0x4
  },
  presentMode: {
    byteOffset: 0x58,
    byteLength: 0x4
  },
  clipped: {
    byteOffset: 0x5C,
    byteLength: 0x4
  },
  oldSwapchain: {
    byteOffset: 0x60,
    byteLength: 0x8
  },
};
/** VkPresentInfoKHR **/
function VkPresentInfoKHR(opts) {
  if (new.target !== VkPresentInfoKHR) {
    _VkPresentInfoKHR.reset();
    return _VkPresentInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
  
  this._pSwapchains = null;
    this._pSwapchainsNative = null;
  this._pImageIndices = null;
  this._pResults = null;
  this.sType = 0x3B9ACDE9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pSwapchains !== void 0) this.pSwapchains = opts.pSwapchains;
    if (opts.pImageIndices !== void 0) this.pImageIndices = opts.pImageIndices;
    if (opts.pResults !== void 0) this.pResults = opts.pResults;
    
  }
};

Object.defineProperties(VkPresentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPresentInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9AD5B8:
        case 0x3B9C1220:
        case 0x3B9BB46B:
        case 0x3B9C3160:
        case 0x3B9DB418:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
    }
    
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.waitSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pWaitSemaphores": {
    get() {
    return this._pWaitSemaphores;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.swapchainCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pSwapchains": {
    get() {
    return this._pSwapchains;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSwapchains = value;
    } else if (value === null) {
      this._pSwapchains = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pSwapchains': Expected 'Array VkSwapchainKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pImageIndices": {
    get() {
    return this._pImageIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pImageIndices = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pImageIndices = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pImageIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pResults": {
    get() {
    return this._pResults;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pResults = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pResults = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pResults': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPresentInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
  
  this._pSwapchains = null;
    this._pSwapchainsNative = null;
  this._pImageIndices = null;
  this._pResults = null;
  this.sType = 0x3B9ACDE9;
};

VkPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkPresentInfoKHR.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkPresentInfoKHR.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pWaitSemaphoresNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pWaitSemaphoresNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pSwapchains !== null) {
    let array = this._pSwapchains;
    
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentInfoKHR.pSwapchains'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSwapchainKHR)) {
        throw new TypeError("Invalid type for 'VkPresentInfoKHR.pSwapchains[" + ii + "]': Expected 'VkSwapchainKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSwapchainsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pSwapchainsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPresentInfoKHR.byteLength = 0x40;

VkPresentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  waitSemaphoreCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pWaitSemaphores: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  swapchainCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pSwapchains: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pImageIndices: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  pResults: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkDebugReportCallbackCreateInfoEXT **/
function VkDebugReportCallbackCreateInfoEXT(opts) {
  if (new.target !== VkDebugReportCallbackCreateInfoEXT) {
    _VkDebugReportCallbackCreateInfoEXT.reset();
    return _VkDebugReportCallbackCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pfnCallback = null;
  this._pUserData = null;
  this.sType = 0x3B9AF4F8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pfnCallback !== void 0) this.pfnCallback = opts.pfnCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkDebugReportCallbackCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugReportCallbackCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugReportCallbackCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "pfnCallback": {
    get() {
    return this._pfnCallback;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnCallback = value;
    } else if (value === null) {
      this._pfnCallback = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.pfnCallback': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugReportCallbackCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  this._pfnCallback = null;
  this._pUserData = null;
  this.sType = 0x3B9AF4F8;
};

VkDebugReportCallbackCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugReportCallbackCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugReportCallbackCreateInfoEXT.byteLength = 0x28;

VkDebugReportCallbackCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pfnCallback: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pUserData: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkValidationFlagsEXT **/
function VkValidationFlagsEXT(opts) {
  if (new.target !== VkValidationFlagsEXT) {
    _VkValidationFlagsEXT.reset();
    return _VkValidationFlagsEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDisabledValidationChecks = null;
  this.sType = 0x3B9BB848;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.disabledValidationCheckCount !== void 0) this.disabledValidationCheckCount = opts.disabledValidationCheckCount;
    if (opts.pDisabledValidationChecks !== void 0) this.pDisabledValidationChecks = opts.pDisabledValidationChecks;
    
  }
};

Object.defineProperties(VkValidationFlagsEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkValidationFlagsEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkValidationFlagsEXT.pNext' isn't allowed to be filled");
    }
    },
  "disabledValidationCheckCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.disabledValidationCheckCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDisabledValidationChecks": {
    get() {
    return this._pDisabledValidationChecks;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDisabledValidationChecks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDisabledValidationChecks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.pDisabledValidationChecks': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkValidationFlagsEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pDisabledValidationChecks = null;
  this.sType = 0x3B9BB848;
};

VkValidationFlagsEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationFlagsEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkValidationFlagsEXT.byteLength = 0x20;

VkValidationFlagsEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  disabledValidationCheckCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDisabledValidationChecks: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkValidationFeaturesEXT **/
function VkValidationFeaturesEXT(opts) {
  if (new.target !== VkValidationFeaturesEXT) {
    _VkValidationFeaturesEXT.reset();
    return _VkValidationFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pEnabledValidationFeatures = null;
  
  this._pDisabledValidationFeatures = null;
  this.sType = 0x3B9E8ED8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.enabledValidationFeatureCount !== void 0) this.enabledValidationFeatureCount = opts.enabledValidationFeatureCount;
    if (opts.pEnabledValidationFeatures !== void 0) this.pEnabledValidationFeatures = opts.pEnabledValidationFeatures;
    if (opts.disabledValidationFeatureCount !== void 0) this.disabledValidationFeatureCount = opts.disabledValidationFeatureCount;
    if (opts.pDisabledValidationFeatures !== void 0) this.pDisabledValidationFeatures = opts.pDisabledValidationFeatures;
    
  }
};

Object.defineProperties(VkValidationFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkValidationFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkValidationFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "enabledValidationFeatureCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.enabledValidationFeatureCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pEnabledValidationFeatures": {
    get() {
    return this._pEnabledValidationFeatures;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pEnabledValidationFeatures = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pEnabledValidationFeatures = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.pEnabledValidationFeatures': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "disabledValidationFeatureCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.disabledValidationFeatureCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pDisabledValidationFeatures": {
    get() {
    return this._pDisabledValidationFeatures;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDisabledValidationFeatures = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDisabledValidationFeatures = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.pDisabledValidationFeatures': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkValidationFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  this._pEnabledValidationFeatures = null;
  
  this._pDisabledValidationFeatures = null;
  this.sType = 0x3B9E8ED8;
};

VkValidationFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkValidationFeaturesEXT.byteLength = 0x30;

VkValidationFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  enabledValidationFeatureCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pEnabledValidationFeatures: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  disabledValidationFeatureCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pDisabledValidationFeatures: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkPipelineRasterizationStateRasterizationOrderAMD **/
function VkPipelineRasterizationStateRasterizationOrderAMD(opts) {
  if (new.target !== VkPipelineRasterizationStateRasterizationOrderAMD) {
    _VkPipelineRasterizationStateRasterizationOrderAMD.reset();
    return _VkPipelineRasterizationStateRasterizationOrderAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9B1050;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rasterizationOrder !== void 0) this.rasterizationOrder = opts.rasterizationOrder;
    
  }
};

Object.defineProperties(VkPipelineRasterizationStateRasterizationOrderAMD.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateRasterizationOrderAMD.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationStateRasterizationOrderAMD.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationStateRasterizationOrderAMD.pNext' isn't allowed to be filled");
    }
    },
  "rasterizationOrder": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkRasterizationOrderAMD(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder': '" + value + "' is not a value of 'VkRasterizationOrderAMD'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9B1050;
};

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationStateRasterizationOrderAMD.byteLength = 0x18;

VkPipelineRasterizationStateRasterizationOrderAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  rasterizationOrder: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDebugMarkerObjectNameInfoEXT **/
function VkDebugMarkerObjectNameInfoEXT(opts) {
  if (new.target !== VkDebugMarkerObjectNameInfoEXT) {
    _VkDebugMarkerObjectNameInfoEXT.reset();
    return _VkDebugMarkerObjectNameInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = 0x3B9B1FF0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.object !== void 0) this.object = opts.object;
    if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
    
  }
};

Object.defineProperties(VkDebugMarkerObjectNameInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugMarkerObjectNameInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugMarkerObjectNameInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.objectType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDebugReportObjectTypeEXT(value)) {
      throw new RangeError("Invalid value for 'VkDebugMarkerObjectNameInfoEXT.objectType': '" + value + "' is not a value of 'VkDebugReportObjectTypeEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "object": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.object': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "pObjectName": {
    get() {
    if (this._pObjectName !== null) {
      let str = textDecoder.decode(this._pObjectName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pObjectName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pObjectName);
    } else if (value === null) {
      this._pObjectName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.pObjectName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugMarkerObjectNameInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = 0x3B9B1FF0;
};

VkDebugMarkerObjectNameInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugMarkerObjectNameInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugMarkerObjectNameInfoEXT.byteLength = 0x28;

VkDebugMarkerObjectNameInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  object: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pObjectName: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkDebugMarkerObjectTagInfoEXT **/
function VkDebugMarkerObjectTagInfoEXT(opts) {
  if (new.target !== VkDebugMarkerObjectTagInfoEXT) {
    _VkDebugMarkerObjectTagInfoEXT.reset();
    return _VkDebugMarkerObjectTagInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = 0x3B9B1FF1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.object !== void 0) this.object = opts.object;
    if (opts.tagName !== void 0) this.tagName = opts.tagName;
    if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
    if (opts.pTag !== void 0) this.pTag = opts.pTag;
    
  }
};

Object.defineProperties(VkDebugMarkerObjectTagInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugMarkerObjectTagInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugMarkerObjectTagInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.objectType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDebugReportObjectTypeEXT(value)) {
      throw new RangeError("Invalid value for 'VkDebugMarkerObjectTagInfoEXT.objectType': '" + value + "' is not a value of 'VkDebugReportObjectTypeEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "object": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.object': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "tagName": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.tagName': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  "tagSize": {
    get() {
    return this.memoryViewBigInt64[0x5];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.tagSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x5] = BigInt(value);
    }
    },
  "pTag": {
    get() {
    return this._pTag;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pTag = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pTag = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.pTag': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugMarkerObjectTagInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = 0x3B9B1FF1;
};

VkDebugMarkerObjectTagInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugMarkerObjectTagInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugMarkerObjectTagInfoEXT.byteLength = 0x38;

VkDebugMarkerObjectTagInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  object: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  tagName: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  tagSize: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pTag: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
};
/** VkDebugMarkerMarkerInfoEXT **/
function VkDebugMarkerMarkerInfoEXT(opts) {
  if (new.target !== VkDebugMarkerMarkerInfoEXT) {
    _VkDebugMarkerMarkerInfoEXT.reset();
    return _VkDebugMarkerMarkerInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._pMarkerName = null;
  this._color = [...Array(4)].fill(0x0);
  this.sType = 0x3B9B1FF2;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pMarkerName !== void 0) this.pMarkerName = opts.pMarkerName;
    if (opts.color !== void 0) this.color = opts.color;
    
  }
};

Object.defineProperties(VkDebugMarkerMarkerInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugMarkerMarkerInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugMarkerMarkerInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "pMarkerName": {
    get() {
    if (this._pMarkerName !== null) {
      let str = textDecoder.decode(this._pMarkerName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pMarkerName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(this._pMarkerName);
    } else if (value === null) {
      this._pMarkerName = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.pMarkerName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "color": {
    get() {
    return this._color;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._color = value;
    } else if (value === null) {
      this._color = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.color': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugMarkerMarkerInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._pMarkerName = null;
  this._color = null;
  this.sType = 0x3B9B1FF2;
};

VkDebugMarkerMarkerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._color !== null) {
    let array = this._color;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkDebugMarkerMarkerInfoEXT.color'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.color[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0x6 + ii] = array[ii];
    };
  } else {
    this.memoryViewFloat32[0x6] = 0x0;
  }
  
  return true;
};

VkDebugMarkerMarkerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDebugMarkerMarkerInfoEXT.byteLength = 0x28;

VkDebugMarkerMarkerInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pMarkerName: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  color: {
    byteOffset: 0x18,
    byteLength: 0x10
  },
};
/** VkDedicatedAllocationImageCreateInfoNV **/
function VkDedicatedAllocationImageCreateInfoNV(opts) {
  if (new.target !== VkDedicatedAllocationImageCreateInfoNV) {
    _VkDedicatedAllocationImageCreateInfoNV.reset();
    return _VkDedicatedAllocationImageCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9B2F90;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
    
  }
};

Object.defineProperties(VkDedicatedAllocationImageCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationImageCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDedicatedAllocationImageCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDedicatedAllocationImageCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "dedicatedAllocation": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkDedicatedAllocationImageCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9B2F90;
};

VkDedicatedAllocationImageCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationImageCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDedicatedAllocationImageCreateInfoNV.byteLength = 0x18;

VkDedicatedAllocationImageCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  dedicatedAllocation: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDedicatedAllocationBufferCreateInfoNV **/
function VkDedicatedAllocationBufferCreateInfoNV(opts) {
  if (new.target !== VkDedicatedAllocationBufferCreateInfoNV) {
    _VkDedicatedAllocationBufferCreateInfoNV.reset();
    return _VkDedicatedAllocationBufferCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9B2F91;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
    
  }
};

Object.defineProperties(VkDedicatedAllocationBufferCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationBufferCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDedicatedAllocationBufferCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDedicatedAllocationBufferCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "dedicatedAllocation": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkDedicatedAllocationBufferCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9B2F91;
};

VkDedicatedAllocationBufferCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationBufferCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDedicatedAllocationBufferCreateInfoNV.byteLength = 0x18;

VkDedicatedAllocationBufferCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  dedicatedAllocation: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDedicatedAllocationMemoryAllocateInfoNV **/
function VkDedicatedAllocationMemoryAllocateInfoNV(opts) {
  if (new.target !== VkDedicatedAllocationMemoryAllocateInfoNV) {
    _VkDedicatedAllocationMemoryAllocateInfoNV.reset();
    return _VkDedicatedAllocationMemoryAllocateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = 0x3B9B2F92;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkDedicatedAllocationMemoryAllocateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDedicatedAllocationMemoryAllocateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDedicatedAllocationMemoryAllocateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = 0x3B9B2F92;
};

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDedicatedAllocationMemoryAllocateInfoNV.byteLength = 0x20;

VkDedicatedAllocationMemoryAllocateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkExternalImageFormatPropertiesNV **/
function VkExternalImageFormatPropertiesNV(opts) {
  if (new.target !== VkExternalImageFormatPropertiesNV) {
    _VkExternalImageFormatPropertiesNV.reset();
    return _VkExternalImageFormatPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExternalImageFormatPropertiesNV.prototype, {
  "imageFormatProperties": {
    get() {
    return this._imageFormatProperties;
    },
    },
  "externalMemoryFeatures": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    },
  
});

VkExternalImageFormatPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  this._imageFormatProperties = null;
  
  
  
  
};

VkExternalImageFormatPropertiesNV.prototype.flush = function flush() {
  
  return true;
};

VkExternalImageFormatPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
};

VkExternalImageFormatPropertiesNV.byteLength = 0x30;

VkExternalImageFormatPropertiesNV.memoryLayout = {
  imageFormatProperties: {
    byteOffset: 0x0,
    byteLength: 0x20
  },
  externalMemoryFeatures: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
};
/** VkExternalMemoryImageCreateInfoNV **/
function VkExternalMemoryImageCreateInfoNV(opts) {
  if (new.target !== VkExternalMemoryImageCreateInfoNV) {
    _VkExternalMemoryImageCreateInfoNV.reset();
    return _VkExternalMemoryImageCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BA4C0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryImageCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalMemoryImageCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryImageCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoNV.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExternalMemoryImageCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BA4C0;
};

VkExternalMemoryImageCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryImageCreateInfoNV.byteLength = 0x18;

VkExternalMemoryImageCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExportMemoryAllocateInfoNV **/
function VkExportMemoryAllocateInfoNV(opts) {
  if (new.target !== VkExportMemoryAllocateInfoNV) {
    _VkExportMemoryAllocateInfoNV.reset();
    return _VkExportMemoryAllocateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BA4C1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportMemoryAllocateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportMemoryAllocateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryAllocateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoNV.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportMemoryAllocateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BA4C1;
};

VkExportMemoryAllocateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryAllocateInfoNV.byteLength = 0x18;

VkExportMemoryAllocateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImportMemoryWin32HandleInfoNV **/
function VkImportMemoryWin32HandleInfoNV(opts) {
  if (new.target !== VkImportMemoryWin32HandleInfoNV) {
    _VkImportMemoryWin32HandleInfoNV.reset();
    return _VkImportMemoryWin32HandleInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BA8A8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    
  }
};

Object.defineProperties(VkImportMemoryWin32HandleInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportMemoryWin32HandleInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryWin32HandleInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoNV.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "handle": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoNV.handle': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  
});

VkImportMemoryWin32HandleInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BA8A8;
};

VkImportMemoryWin32HandleInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryWin32HandleInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportMemoryWin32HandleInfoNV.byteLength = 0x20;

VkImportMemoryWin32HandleInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  handle: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkExportMemoryWin32HandleInfoNV **/
function VkExportMemoryWin32HandleInfoNV(opts) {
  if (new.target !== VkExportMemoryWin32HandleInfoNV) {
    _VkExportMemoryWin32HandleInfoNV.reset();
    return _VkExportMemoryWin32HandleInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this.sType = 0x3B9BA8A9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExportMemoryWin32HandleInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryWin32HandleInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportMemoryWin32HandleInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryWin32HandleInfoNV.pNext' isn't allowed to be filled");
    }
    },
  
});

VkExportMemoryWin32HandleInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this.sType = 0x3B9BA8A9;
};

VkExportMemoryWin32HandleInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryWin32HandleInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryWin32HandleInfoNV.byteLength = 0x20;

VkExportMemoryWin32HandleInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkWin32KeyedMutexAcquireReleaseInfoNV **/
function VkWin32KeyedMutexAcquireReleaseInfoNV(opts) {
  if (new.target !== VkWin32KeyedMutexAcquireReleaseInfoNV) {
    _VkWin32KeyedMutexAcquireReleaseInfoNV.reset();
    return _VkWin32KeyedMutexAcquireReleaseInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
    this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeoutMilliseconds = null;
  
  this._pReleaseSyncs = null;
    this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = 0x3B9BAC90;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.acquireCount !== void 0) this.acquireCount = opts.acquireCount;
    if (opts.pAcquireSyncs !== void 0) this.pAcquireSyncs = opts.pAcquireSyncs;
    if (opts.pAcquireKeys !== void 0) this.pAcquireKeys = opts.pAcquireKeys;
    if (opts.pAcquireTimeoutMilliseconds !== void 0) this.pAcquireTimeoutMilliseconds = opts.pAcquireTimeoutMilliseconds;
    if (opts.releaseCount !== void 0) this.releaseCount = opts.releaseCount;
    if (opts.pReleaseSyncs !== void 0) this.pReleaseSyncs = opts.pReleaseSyncs;
    if (opts.pReleaseKeys !== void 0) this.pReleaseKeys = opts.pReleaseKeys;
    
  }
};

Object.defineProperties(VkWin32KeyedMutexAcquireReleaseInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkWin32KeyedMutexAcquireReleaseInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWin32KeyedMutexAcquireReleaseInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "acquireCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.acquireCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAcquireSyncs": {
    get() {
    return this._pAcquireSyncs;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAcquireSyncs = value;
    } else if (value === null) {
      this._pAcquireSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pAcquireKeys": {
    get() {
    return this._pAcquireKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pAcquireKeys = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pAcquireKeys = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pAcquireTimeoutMilliseconds": {
    get() {
    return this._pAcquireTimeoutMilliseconds;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pAcquireTimeoutMilliseconds = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pAcquireTimeoutMilliseconds = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "releaseCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.releaseCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pReleaseSyncs": {
    get() {
    return this._pReleaseSyncs;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pReleaseSyncs = value;
    } else if (value === null) {
      this._pReleaseSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pReleaseKeys": {
    get() {
    return this._pReleaseKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pReleaseKeys = value;
      this.memoryViewBigInt64[0x8] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pReleaseKeys = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkWin32KeyedMutexAcquireReleaseInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
    this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeoutMilliseconds = null;
  
  this._pReleaseSyncs = null;
    this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = 0x3B9BAC90;
};

VkWin32KeyedMutexAcquireReleaseInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAcquireSyncs !== null) {
    let array = this._pAcquireSyncs;
    
    if (array.length !== this.acquireCount) {
      throw new RangeError("Invalid array length, expected length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAcquireSyncsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAcquireSyncsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pReleaseSyncs !== null) {
    let array = this._pReleaseSyncs;
    
    if (array.length !== this.releaseCount) {
      throw new RangeError("Invalid array length, expected length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pReleaseSyncsNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pReleaseSyncsNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkWin32KeyedMutexAcquireReleaseInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkWin32KeyedMutexAcquireReleaseInfoNV.byteLength = 0x48;

VkWin32KeyedMutexAcquireReleaseInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  acquireCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAcquireSyncs: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pAcquireKeys: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pAcquireTimeoutMilliseconds: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  releaseCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pReleaseSyncs: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  pReleaseKeys: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
};
/** VkDeviceGeneratedCommandsFeaturesNVX **/
function VkDeviceGeneratedCommandsFeaturesNVX(opts) {
  if (new.target !== VkDeviceGeneratedCommandsFeaturesNVX) {
    _VkDeviceGeneratedCommandsFeaturesNVX.reset();
    return _VkDeviceGeneratedCommandsFeaturesNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C19F5;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.computeBindingPointSupport !== void 0) this.computeBindingPointSupport = opts.computeBindingPointSupport;
    
  }
};

Object.defineProperties(VkDeviceGeneratedCommandsFeaturesNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsFeaturesNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGeneratedCommandsFeaturesNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGeneratedCommandsFeaturesNVX.pNext' isn't allowed to be filled");
    }
    },
  "computeBindingPointSupport": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkDeviceGeneratedCommandsFeaturesNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C19F5;
};

VkDeviceGeneratedCommandsFeaturesNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGeneratedCommandsFeaturesNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGeneratedCommandsFeaturesNVX.byteLength = 0x18;

VkDeviceGeneratedCommandsFeaturesNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  computeBindingPointSupport: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDeviceGeneratedCommandsLimitsNVX **/
function VkDeviceGeneratedCommandsLimitsNVX(opts) {
  if (new.target !== VkDeviceGeneratedCommandsLimitsNVX) {
    _VkDeviceGeneratedCommandsLimitsNVX.reset();
    return _VkDeviceGeneratedCommandsLimitsNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9C19F4;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxIndirectCommandsLayoutTokenCount !== void 0) this.maxIndirectCommandsLayoutTokenCount = opts.maxIndirectCommandsLayoutTokenCount;
    if (opts.maxObjectEntryCounts !== void 0) this.maxObjectEntryCounts = opts.maxObjectEntryCounts;
    if (opts.minSequenceCountBufferOffsetAlignment !== void 0) this.minSequenceCountBufferOffsetAlignment = opts.minSequenceCountBufferOffsetAlignment;
    if (opts.minSequenceIndexBufferOffsetAlignment !== void 0) this.minSequenceIndexBufferOffsetAlignment = opts.minSequenceIndexBufferOffsetAlignment;
    if (opts.minCommandsTokenBufferOffsetAlignment !== void 0) this.minCommandsTokenBufferOffsetAlignment = opts.minCommandsTokenBufferOffsetAlignment;
    
  }
};

Object.defineProperties(VkDeviceGeneratedCommandsLimitsNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGeneratedCommandsLimitsNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGeneratedCommandsLimitsNVX.pNext' isn't allowed to be filled");
    }
    },
  "maxIndirectCommandsLayoutTokenCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.maxIndirectCommandsLayoutTokenCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "maxObjectEntryCounts": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.maxObjectEntryCounts': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "minSequenceCountBufferOffsetAlignment": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.minSequenceCountBufferOffsetAlignment': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "minSequenceIndexBufferOffsetAlignment": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.minSequenceIndexBufferOffsetAlignment': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "minCommandsTokenBufferOffsetAlignment": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.minCommandsTokenBufferOffsetAlignment': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  
});

VkDeviceGeneratedCommandsLimitsNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9C19F4;
};

VkDeviceGeneratedCommandsLimitsNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGeneratedCommandsLimitsNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGeneratedCommandsLimitsNVX.byteLength = 0x28;

VkDeviceGeneratedCommandsLimitsNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxIndirectCommandsLayoutTokenCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxObjectEntryCounts: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  minSequenceCountBufferOffsetAlignment: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  minSequenceIndexBufferOffsetAlignment: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  minCommandsTokenBufferOffsetAlignment: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkIndirectCommandsTokenNVX **/
function VkIndirectCommandsTokenNVX(opts) {
  if (new.target !== VkIndirectCommandsTokenNVX) {
    _VkIndirectCommandsTokenNVX.reset();
    return _VkIndirectCommandsTokenNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._buffer = null;
  
  
  if (typeof opts === "object") {
    if (opts.tokenType !== void 0) this.tokenType = opts.tokenType;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

Object.defineProperties(VkIndirectCommandsTokenNVX.prototype, {
  "tokenType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsTokenNVX.tokenType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkIndirectCommandsTokenTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkIndirectCommandsTokenNVX.tokenType': '" + value + "' is not a value of 'VkIndirectCommandsTokenTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsTokenNVX.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsTokenNVX.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  
});

VkIndirectCommandsTokenNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._buffer = null;
  
  
};

VkIndirectCommandsTokenNVX.prototype.flush = function flush() {
  
  return true;
};

VkIndirectCommandsTokenNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkIndirectCommandsTokenNVX.byteLength = 0x18;

VkIndirectCommandsTokenNVX.memoryLayout = {
  tokenType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  buffer: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  offset: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkIndirectCommandsLayoutTokenNVX **/
function VkIndirectCommandsLayoutTokenNVX(opts) {
  if (new.target !== VkIndirectCommandsLayoutTokenNVX) {
    _VkIndirectCommandsLayoutTokenNVX.reset();
    return _VkIndirectCommandsLayoutTokenNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.tokenType !== void 0) this.tokenType = opts.tokenType;
    if (opts.bindingUnit !== void 0) this.bindingUnit = opts.bindingUnit;
    if (opts.dynamicCount !== void 0) this.dynamicCount = opts.dynamicCount;
    if (opts.divisor !== void 0) this.divisor = opts.divisor;
    
  }
};

Object.defineProperties(VkIndirectCommandsLayoutTokenNVX.prototype, {
  "tokenType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.tokenType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkIndirectCommandsTokenTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkIndirectCommandsLayoutTokenNVX.tokenType': '" + value + "' is not a value of 'VkIndirectCommandsTokenTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "bindingUnit": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.bindingUnit': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "dynamicCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.dynamicCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "divisor": {
    get() {
    return this.memoryViewUint32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.divisor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x3] = value;
    }
    },
  
});

VkIndirectCommandsLayoutTokenNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
  
};

VkIndirectCommandsLayoutTokenNVX.prototype.flush = function flush() {
  
  return true;
};

VkIndirectCommandsLayoutTokenNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkIndirectCommandsLayoutTokenNVX.byteLength = 0x10;

VkIndirectCommandsLayoutTokenNVX.memoryLayout = {
  tokenType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  bindingUnit: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  dynamicCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  divisor: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkIndirectCommandsLayoutCreateInfoNVX **/
function VkIndirectCommandsLayoutCreateInfoNVX(opts) {
  if (new.target !== VkIndirectCommandsLayoutCreateInfoNVX) {
    _VkIndirectCommandsLayoutCreateInfoNVX.reset();
    return _VkIndirectCommandsLayoutCreateInfoNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._pTokens = null;
    this._pTokensNative = null;
  this.sType = 0x3B9C19F1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.tokenCount !== void 0) this.tokenCount = opts.tokenCount;
    if (opts.pTokens !== void 0) this.pTokens = opts.pTokens;
    
  }
};

Object.defineProperties(VkIndirectCommandsLayoutCreateInfoNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkIndirectCommandsLayoutCreateInfoNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkIndirectCommandsLayoutCreateInfoNVX.pNext' isn't allowed to be filled");
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPipelineBindPoint(value)) {
      throw new RangeError("Invalid value for 'VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint': '" + value + "' is not a value of 'VkPipelineBindPoint'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "tokenCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.tokenCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pTokens": {
    get() {
    return this._pTokens;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pTokens = value;
    } else if (value === null) {
      this._pTokens = null;
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens': Expected 'Array VkIndirectCommandsLayoutTokenNVX' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkIndirectCommandsLayoutCreateInfoNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  this._pTokens = null;
    this._pTokensNative = null;
  this.sType = 0x3B9C19F1;
};

VkIndirectCommandsLayoutCreateInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pTokens !== null) {
    let array = this._pTokens;
    
    if (array.length !== this.tokenCount) {
      throw new RangeError("Invalid array length, expected length of 'tokenCount' for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkIndirectCommandsLayoutTokenNVX)) {
        throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens[" + ii + "]': Expected 'VkIndirectCommandsLayoutTokenNVX' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pTokensNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pTokensNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkIndirectCommandsLayoutCreateInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkIndirectCommandsLayoutCreateInfoNVX.byteLength = 0x28;

VkIndirectCommandsLayoutCreateInfoNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pipelineBindPoint: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  tokenCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pTokens: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkCmdProcessCommandsInfoNVX **/
function VkCmdProcessCommandsInfoNVX(opts) {
  if (new.target !== VkCmdProcessCommandsInfoNVX) {
    _VkCmdProcessCommandsInfoNVX.reset();
    return _VkCmdProcessCommandsInfoNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x60) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x60);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._objectTable = null;
  this._indirectCommandsLayout = null;
  
  this._pIndirectCommandsTokens = null;
    this._pIndirectCommandsTokensNative = null;
  
  this._targetCommandBuffer = null;
  this._sequencesCountBuffer = null;
  
  this._sequencesIndexBuffer = null;
  
  this.sType = 0x3B9C19F2;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectTable !== void 0) this.objectTable = opts.objectTable;
    if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
    if (opts.indirectCommandsTokenCount !== void 0) this.indirectCommandsTokenCount = opts.indirectCommandsTokenCount;
    if (opts.pIndirectCommandsTokens !== void 0) this.pIndirectCommandsTokens = opts.pIndirectCommandsTokens;
    if (opts.maxSequencesCount !== void 0) this.maxSequencesCount = opts.maxSequencesCount;
    if (opts.targetCommandBuffer !== void 0) this.targetCommandBuffer = opts.targetCommandBuffer;
    if (opts.sequencesCountBuffer !== void 0) this.sequencesCountBuffer = opts.sequencesCountBuffer;
    if (opts.sequencesCountOffset !== void 0) this.sequencesCountOffset = opts.sequencesCountOffset;
    if (opts.sequencesIndexBuffer !== void 0) this.sequencesIndexBuffer = opts.sequencesIndexBuffer;
    if (opts.sequencesIndexOffset !== void 0) this.sequencesIndexOffset = opts.sequencesIndexOffset;
    
  }
};

Object.defineProperties(VkCmdProcessCommandsInfoNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCmdProcessCommandsInfoNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCmdProcessCommandsInfoNVX.pNext' isn't allowed to be filled");
    }
    },
  "objectTable": {
    get() {
    return this._objectTable;
    },
    set(value) {
    if (value !== null && value.constructor === VkObjectTableNVX) {
      
      this._objectTable = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._objectTable = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.objectTable': Expected 'VkObjectTableNVX' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indirectCommandsLayout": {
    get() {
    return this._indirectCommandsLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkIndirectCommandsLayoutNVX) {
      
      this._indirectCommandsLayout = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._indirectCommandsLayout = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.indirectCommandsLayout': Expected 'VkIndirectCommandsLayoutNVX' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indirectCommandsTokenCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.indirectCommandsTokenCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pIndirectCommandsTokens": {
    get() {
    return this._pIndirectCommandsTokens;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pIndirectCommandsTokens = value;
    } else if (value === null) {
      this._pIndirectCommandsTokens = null;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens': Expected 'Array VkIndirectCommandsTokenNVX' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "maxSequencesCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.maxSequencesCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "targetCommandBuffer": {
    get() {
    return this._targetCommandBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkCommandBuffer) {
      
      this._targetCommandBuffer = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._targetCommandBuffer = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.targetCommandBuffer': Expected 'VkCommandBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sequencesCountBuffer": {
    get() {
    return this._sequencesCountBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._sequencesCountBuffer = value;
      
      this.memoryViewBigInt64[0x8] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sequencesCountBuffer = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesCountBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sequencesCountOffset": {
    get() {
    return this.memoryViewBigUint64[0x9];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesCountOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x9] = BigInt(value);
    }
    },
  "sequencesIndexBuffer": {
    get() {
    return this._sequencesIndexBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._sequencesIndexBuffer = value;
      
      this.memoryViewBigInt64[0xA] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sequencesIndexBuffer = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sequencesIndexOffset": {
    get() {
    return this.memoryViewBigUint64[0xB];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesIndexOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0xB] = BigInt(value);
    }
    },
  
});

VkCmdProcessCommandsInfoNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x60], 0x0);
  
  this._pNext = null;
  this._objectTable = null;
  this._indirectCommandsLayout = null;
  
  this._pIndirectCommandsTokens = null;
    this._pIndirectCommandsTokensNative = null;
  
  this._targetCommandBuffer = null;
  this._sequencesCountBuffer = null;
  
  this._sequencesIndexBuffer = null;
  
  this.sType = 0x3B9C19F2;
};

VkCmdProcessCommandsInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pIndirectCommandsTokens !== null) {
    let array = this._pIndirectCommandsTokens;
    
    if (array.length !== this.indirectCommandsTokenCount) {
      throw new RangeError("Invalid array length, expected length of 'indirectCommandsTokenCount' for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkIndirectCommandsTokenNVX)) {
        throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens[" + ii + "]': Expected 'VkIndirectCommandsTokenNVX' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pIndirectCommandsTokensNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pIndirectCommandsTokensNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkCmdProcessCommandsInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkCmdProcessCommandsInfoNVX.byteLength = 0x60;

VkCmdProcessCommandsInfoNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectTable: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  indirectCommandsLayout: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  indirectCommandsTokenCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pIndirectCommandsTokens: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  maxSequencesCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  targetCommandBuffer: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  sequencesCountBuffer: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
  sequencesCountOffset: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  sequencesIndexBuffer: {
    byteOffset: 0x50,
    byteLength: 0x8
  },
  sequencesIndexOffset: {
    byteOffset: 0x58,
    byteLength: 0x8
  },
};
/** VkCmdReserveSpaceForCommandsInfoNVX **/
function VkCmdReserveSpaceForCommandsInfoNVX(opts) {
  if (new.target !== VkCmdReserveSpaceForCommandsInfoNVX) {
    _VkCmdReserveSpaceForCommandsInfoNVX.reset();
    return _VkCmdReserveSpaceForCommandsInfoNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._objectTable = null;
  this._indirectCommandsLayout = null;
  
  this.sType = 0x3B9C19F3;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectTable !== void 0) this.objectTable = opts.objectTable;
    if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
    if (opts.maxSequencesCount !== void 0) this.maxSequencesCount = opts.maxSequencesCount;
    
  }
};

Object.defineProperties(VkCmdReserveSpaceForCommandsInfoNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCmdReserveSpaceForCommandsInfoNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCmdReserveSpaceForCommandsInfoNVX.pNext' isn't allowed to be filled");
    }
    },
  "objectTable": {
    get() {
    return this._objectTable;
    },
    set(value) {
    if (value !== null && value.constructor === VkObjectTableNVX) {
      
      this._objectTable = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._objectTable = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.objectTable': Expected 'VkObjectTableNVX' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indirectCommandsLayout": {
    get() {
    return this._indirectCommandsLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkIndirectCommandsLayoutNVX) {
      
      this._indirectCommandsLayout = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._indirectCommandsLayout = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout': Expected 'VkIndirectCommandsLayoutNVX' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "maxSequencesCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.maxSequencesCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  
});

VkCmdReserveSpaceForCommandsInfoNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._objectTable = null;
  this._indirectCommandsLayout = null;
  
  this.sType = 0x3B9C19F3;
};

VkCmdReserveSpaceForCommandsInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCmdReserveSpaceForCommandsInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCmdReserveSpaceForCommandsInfoNVX.byteLength = 0x28;

VkCmdReserveSpaceForCommandsInfoNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectTable: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  indirectCommandsLayout: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  maxSequencesCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkObjectTableCreateInfoNVX **/
function VkObjectTableCreateInfoNVX(opts) {
  if (new.target !== VkObjectTableCreateInfoNVX) {
    _VkObjectTableCreateInfoNVX.reset();
    return _VkObjectTableCreateInfoNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pObjectEntryTypes = null;
  this._pObjectEntryCounts = null;
  this._pObjectEntryUsageFlags = null;
  
  
  
  
  
  this.sType = 0x3B9C19F0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectCount !== void 0) this.objectCount = opts.objectCount;
    if (opts.pObjectEntryTypes !== void 0) this.pObjectEntryTypes = opts.pObjectEntryTypes;
    if (opts.pObjectEntryCounts !== void 0) this.pObjectEntryCounts = opts.pObjectEntryCounts;
    if (opts.pObjectEntryUsageFlags !== void 0) this.pObjectEntryUsageFlags = opts.pObjectEntryUsageFlags;
    if (opts.maxUniformBuffersPerDescriptor !== void 0) this.maxUniformBuffersPerDescriptor = opts.maxUniformBuffersPerDescriptor;
    if (opts.maxStorageBuffersPerDescriptor !== void 0) this.maxStorageBuffersPerDescriptor = opts.maxStorageBuffersPerDescriptor;
    if (opts.maxStorageImagesPerDescriptor !== void 0) this.maxStorageImagesPerDescriptor = opts.maxStorageImagesPerDescriptor;
    if (opts.maxSampledImagesPerDescriptor !== void 0) this.maxSampledImagesPerDescriptor = opts.maxSampledImagesPerDescriptor;
    if (opts.maxPipelineLayouts !== void 0) this.maxPipelineLayouts = opts.maxPipelineLayouts;
    
  }
};

Object.defineProperties(VkObjectTableCreateInfoNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkObjectTableCreateInfoNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkObjectTableCreateInfoNVX.pNext' isn't allowed to be filled");
    }
    },
  "objectCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.objectCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pObjectEntryTypes": {
    get() {
    return this._pObjectEntryTypes;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pObjectEntryTypes = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pObjectEntryTypes = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.pObjectEntryTypes': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pObjectEntryCounts": {
    get() {
    return this._pObjectEntryCounts;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pObjectEntryCounts = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pObjectEntryCounts = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.pObjectEntryCounts': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pObjectEntryUsageFlags": {
    get() {
    return this._pObjectEntryUsageFlags;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pObjectEntryUsageFlags = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pObjectEntryUsageFlags = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "maxUniformBuffersPerDescriptor": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxUniformBuffersPerDescriptor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "maxStorageBuffersPerDescriptor": {
    get() {
    return this.memoryViewUint32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxStorageBuffersPerDescriptor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xD] = value;
    }
    },
  "maxStorageImagesPerDescriptor": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxStorageImagesPerDescriptor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xE] = value;
    }
    },
  "maxSampledImagesPerDescriptor": {
    get() {
    return this.memoryViewUint32[0xF];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxSampledImagesPerDescriptor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xF] = value;
    }
    },
  "maxPipelineLayouts": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxPipelineLayouts': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  
});

VkObjectTableCreateInfoNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  this._pObjectEntryTypes = null;
  this._pObjectEntryCounts = null;
  this._pObjectEntryUsageFlags = null;
  
  
  
  
  
  this.sType = 0x3B9C19F0;
};

VkObjectTableCreateInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkObjectTableCreateInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkObjectTableCreateInfoNVX.byteLength = 0x48;

VkObjectTableCreateInfoNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pObjectEntryTypes: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pObjectEntryCounts: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pObjectEntryUsageFlags: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  maxUniformBuffersPerDescriptor: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  maxStorageBuffersPerDescriptor: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  maxStorageImagesPerDescriptor: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  maxSampledImagesPerDescriptor: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  maxPipelineLayouts: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
};
/** VkObjectTableEntryNVX **/
function VkObjectTableEntryNVX(opts) {
  if (new.target !== VkObjectTableEntryNVX) {
    _VkObjectTableEntryNVX.reset();
    return _VkObjectTableEntryNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkObjectTableEntryNVX.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableEntryNVX.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectEntryTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkObjectTableEntryNVX.type': '" + value + "' is not a value of 'VkObjectEntryTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableEntryNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  
});

VkObjectTableEntryNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkObjectTableEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableEntryNVX.byteLength = 0x8;

VkObjectTableEntryNVX.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkObjectTablePipelineEntryNVX **/
function VkObjectTablePipelineEntryNVX(opts) {
  if (new.target !== VkObjectTablePipelineEntryNVX) {
    _VkObjectTablePipelineEntryNVX.reset();
    return _VkObjectTablePipelineEntryNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  this._pipeline = null;
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    
  }
};

Object.defineProperties(VkObjectTablePipelineEntryNVX.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePipelineEntryNVX.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectEntryTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkObjectTablePipelineEntryNVX.type': '" + value + "' is not a value of 'VkObjectEntryTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePipelineEntryNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "pipeline": {
    get() {
    return this._pipeline;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._pipeline = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipeline = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTablePipelineEntryNVX.pipeline': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkObjectTablePipelineEntryNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  this._pipeline = null;
  
};

VkObjectTablePipelineEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTablePipelineEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTablePipelineEntryNVX.byteLength = 0x10;

VkObjectTablePipelineEntryNVX.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  pipeline: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkObjectTableDescriptorSetEntryNVX **/
function VkObjectTableDescriptorSetEntryNVX(opts) {
  if (new.target !== VkObjectTableDescriptorSetEntryNVX) {
    _VkObjectTableDescriptorSetEntryNVX.reset();
    return _VkObjectTableDescriptorSetEntryNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  this._pipelineLayout = null;
  this._descriptorSet = null;
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.descriptorSet !== void 0) this.descriptorSet = opts.descriptorSet;
    
  }
};

Object.defineProperties(VkObjectTableDescriptorSetEntryNVX.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectEntryTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkObjectTableDescriptorSetEntryNVX.type': '" + value + "' is not a value of 'VkObjectEntryTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "pipelineLayout": {
    get() {
    return this._pipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.pipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "descriptorSet": {
    get() {
    return this._descriptorSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._descriptorSet = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorSet = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.descriptorSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkObjectTableDescriptorSetEntryNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  this._pipelineLayout = null;
  this._descriptorSet = null;
  
};

VkObjectTableDescriptorSetEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableDescriptorSetEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableDescriptorSetEntryNVX.byteLength = 0x18;

VkObjectTableDescriptorSetEntryNVX.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  pipelineLayout: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  descriptorSet: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkObjectTableVertexBufferEntryNVX **/
function VkObjectTableVertexBufferEntryNVX(opts) {
  if (new.target !== VkObjectTableVertexBufferEntryNVX) {
    _VkObjectTableVertexBufferEntryNVX.reset();
    return _VkObjectTableVertexBufferEntryNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  this._buffer = null;
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkObjectTableVertexBufferEntryNVX.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableVertexBufferEntryNVX.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectEntryTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkObjectTableVertexBufferEntryNVX.type': '" + value + "' is not a value of 'VkObjectEntryTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableVertexBufferEntryNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableVertexBufferEntryNVX.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkObjectTableVertexBufferEntryNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  this._buffer = null;
  
};

VkObjectTableVertexBufferEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableVertexBufferEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableVertexBufferEntryNVX.byteLength = 0x10;

VkObjectTableVertexBufferEntryNVX.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  buffer: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkObjectTableIndexBufferEntryNVX **/
function VkObjectTableIndexBufferEntryNVX(opts) {
  if (new.target !== VkObjectTableIndexBufferEntryNVX) {
    _VkObjectTableIndexBufferEntryNVX.reset();
    return _VkObjectTableIndexBufferEntryNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  this._buffer = null;
  
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    
  }
};

Object.defineProperties(VkObjectTableIndexBufferEntryNVX.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectEntryTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkObjectTableIndexBufferEntryNVX.type': '" + value + "' is not a value of 'VkObjectEntryTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indexType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.indexType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkIndexType(value)) {
      throw new RangeError("Invalid value for 'VkObjectTableIndexBufferEntryNVX.indexType': '" + value + "' is not a value of 'VkIndexType'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkObjectTableIndexBufferEntryNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  this._buffer = null;
  
  
};

VkObjectTableIndexBufferEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableIndexBufferEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableIndexBufferEntryNVX.byteLength = 0x18;

VkObjectTableIndexBufferEntryNVX.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  buffer: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  indexType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkObjectTablePushConstantEntryNVX **/
function VkObjectTablePushConstantEntryNVX(opts) {
  if (new.target !== VkObjectTablePushConstantEntryNVX) {
    _VkObjectTablePushConstantEntryNVX.reset();
    return _VkObjectTablePushConstantEntryNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  this._pipelineLayout = null;
  
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    
  }
};

Object.defineProperties(VkObjectTablePushConstantEntryNVX.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectEntryTypeNVX(value)) {
      throw new RangeError("Invalid value for 'VkObjectTablePushConstantEntryNVX.type': '" + value + "' is not a value of 'VkObjectEntryTypeNVX'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "pipelineLayout": {
    get() {
    return this._pipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.pipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "stageFlags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.stageFlags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkObjectTablePushConstantEntryNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  this._pipelineLayout = null;
  
  
};

VkObjectTablePushConstantEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTablePushConstantEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTablePushConstantEntryNVX.byteLength = 0x18;

VkObjectTablePushConstantEntryNVX.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  pipelineLayout: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  stageFlags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFeatures2 **/
function VkPhysicalDeviceFeatures2(opts) {
  if (new.target !== VkPhysicalDeviceFeatures2) {
    _VkPhysicalDeviceFeatures2.reset();
    return _VkPhysicalDeviceFeatures2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xF0) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xF0) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0xF0) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xF0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB078;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.features !== void 0) this.features = opts.features;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFeatures2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFeatures2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
      switch (sType) {
          
        case 0x3B9C9EC0:
        case 0x3B9B9909:
        case 0x3B9C0E38:
        case 0x3B9D2B64:
        case 0x3B9D0069:
        case 0x3B9D0C20:
        case 0x3B9CE510:
        case 0x3B9BC018:
        case 0x3B9C0A50:
        case 0x3B9EC588:
        case 0x3B9D3EE9:
        case 0x3B9D7D68:
        case 0x3B9C0669:
        case 0x3B9E0238:
        case 0x3B9D8920:
        case 0x3B9DB032:
        case 0x3B9BCFB9:
        case 0x3B9B3760:
        case 0x3B9D5270:
        case 0x3B9DEACA:
        case 0x3B9B8D50:
        case 0x3B9DDB28:
        case 0x3B9DE2F8:
        case 0x3B9DE6E0:
        case 0x3B9E7380:
        case 0x3B9D4AA1:
        case 0x3B9DDF10:
        case 0x3B9E1D90:
        case 0x3B9E2948:
        case 0x3B9EA648:
        case 0x3B9C5870:
        case 0x3B9E6BB0:
        case 0x3B9E8320:
        case 0x3B9C6FE0:
        case 0x3B9E96A8:
        case 0x3B9EA260:
        case 0x3B9E9A90:
        case 0x3B9DFA68:
        case 0x3B9D2390:
        case 0x3B9E9E78:
        case 0x3B9F0020:
        case 0x3B9F13A8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
    }
    
    }
    },
  "features": {
    get() {
    return this._features;
    },
    set(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._features = value;
      
      
    } else if (value === null) {
      this._features = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.features': Expected 'VkPhysicalDeviceFeatures' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceFeatures2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xF0], 0x0);
  
  this._pNext = null;
  this._features = null;
  this.sType = 0x3B9BB078;
};

VkPhysicalDeviceFeatures2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._features !== null) {
    let features = this._features;
    features.flush();
    if (this.memoryBuffer !== features.memoryBuffer) {
      let srcView = new Uint8Array(features.memoryBuffer).subarray(features.$memoryOffset, features.$memoryOffset + 0xDC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPhysicalDeviceFeatures2.features' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPhysicalDeviceFeatures2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPhysicalDeviceFeatures2.byteLength = 0xF0;

VkPhysicalDeviceFeatures2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  features: {
    byteOffset: 0x10,
    byteLength: 0xDC
  },
};
/** VkPhysicalDeviceFeatures2KHR **/
function VkPhysicalDeviceFeatures2KHR(opts) {
  if (new.target !== VkPhysicalDeviceFeatures2KHR) {
    _VkPhysicalDeviceFeatures2KHR.reset();
    return _VkPhysicalDeviceFeatures2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xF0) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xF0) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0xF0) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xF0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB078;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.features !== void 0) this.features = opts.features;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFeatures2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFeatures2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9C9EC0:
        case 0x3B9B9909:
        case 0x3B9C0E38:
        case 0x3B9D2B64:
        case 0x3B9D0069:
        case 0x3B9D0C20:
        case 0x3B9CE510:
        case 0x3B9BC018:
        case 0x3B9C0A50:
        case 0x3B9EC588:
        case 0x3B9D3EE9:
        case 0x3B9D7D68:
        case 0x3B9C0669:
        case 0x3B9E0238:
        case 0x3B9D8920:
        case 0x3B9DB032:
        case 0x3B9BCFB9:
        case 0x3B9B3760:
        case 0x3B9D5270:
        case 0x3B9DEACA:
        case 0x3B9B8D50:
        case 0x3B9DDB28:
        case 0x3B9DE2F8:
        case 0x3B9DE6E0:
        case 0x3B9E7380:
        case 0x3B9D4AA1:
        case 0x3B9DDF10:
        case 0x3B9E1D90:
        case 0x3B9E2948:
        case 0x3B9EA648:
        case 0x3B9C5870:
        case 0x3B9E6BB0:
        case 0x3B9E8320:
        case 0x3B9C6FE0:
        case 0x3B9E96A8:
        case 0x3B9EA260:
        case 0x3B9E9A90:
        case 0x3B9DFA68:
        case 0x3B9D2390:
        case 0x3B9E9E78:
        case 0x3B9F0020:
        case 0x3B9F13A8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
    }
    
    }
    },
  "features": {
    get() {
    return this._features;
    },
    set(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._features = value;
      
      
    } else if (value === null) {
      this._features = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.features': Expected 'VkPhysicalDeviceFeatures' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceFeatures2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xF0], 0x0);
  
  this._pNext = null;
  this._features = null;
  this.sType = 0x3B9BB078;
};

VkPhysicalDeviceFeatures2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._features !== null) {
    let features = this._features;
    features.flush();
    if (this.memoryBuffer !== features.memoryBuffer) {
      let srcView = new Uint8Array(features.memoryBuffer).subarray(features.$memoryOffset, features.$memoryOffset + 0xDC);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPhysicalDeviceFeatures2KHR.features' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPhysicalDeviceFeatures2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPhysicalDeviceFeatures2KHR.byteLength = 0xF0;

VkPhysicalDeviceFeatures2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  features: {
    byteOffset: 0x10,
    byteLength: 0xDC
  },
};
/** VkPhysicalDeviceProperties2 **/
function VkPhysicalDeviceProperties2(opts) {
  if (new.target !== VkPhysicalDeviceProperties2) {
    _VkPhysicalDeviceProperties2.reset();
    return _VkPhysicalDeviceProperties2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x348) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x348) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x348) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x348);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB079;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceProperties2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9C0280:
        case 0x3B9DC7A0:
        case 0x3B9BDF5C:
        case 0x3B9B990A:
        case 0x3B9C4CB8:
        case 0x3B9C44E8:
        case 0x3B9C3930:
        case 0x3B9C9308:
        case 0x3B9D006A:
        case 0x3B9CC5D0:
        case 0x3B9CF89B:
        case 0x3B9D0C21:
        case 0x3B9CE511:
        case 0x3B9D5A40:
        case 0x3B9DCB88:
        case 0x3B9D8152:
        case 0x3B9C5488:
        case 0x3B9D9CA8:
        case 0x3B9D3EEA:
        case 0x3B9DB030:
        case 0x3B9E0620:
        case 0x3B9DD358:
        case 0x3B9B3761:
        case 0x3B9D4AA2:
        case 0x3B9DDF11:
        case 0x3B9D4E91:
        case 0x3B9E1D91:
        case 0x3B9E96AA:
        case 0x3B9D2391:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
    }
    
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkPhysicalDeviceProperties2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x348], 0x0);
  
  this._pNext = null;
  this._properties = null;
  this.sType = 0x3B9BB079;
};

VkPhysicalDeviceProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x348));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x348), 0x0);
  
  
  
  
};

VkPhysicalDeviceProperties2.byteLength = 0x348;

VkPhysicalDeviceProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  properties: {
    byteOffset: 0x10,
    byteLength: 0x338
  },
};
/** VkPhysicalDeviceProperties2KHR **/
function VkPhysicalDeviceProperties2KHR(opts) {
  if (new.target !== VkPhysicalDeviceProperties2KHR) {
    _VkPhysicalDeviceProperties2KHR.reset();
    return _VkPhysicalDeviceProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x348) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x348) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x348) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x348);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB079;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9C0280:
        case 0x3B9DC7A0:
        case 0x3B9BDF5C:
        case 0x3B9B990A:
        case 0x3B9C4CB8:
        case 0x3B9C44E8:
        case 0x3B9C3930:
        case 0x3B9C9308:
        case 0x3B9D006A:
        case 0x3B9CC5D0:
        case 0x3B9CF89B:
        case 0x3B9D0C21:
        case 0x3B9CE511:
        case 0x3B9D5A40:
        case 0x3B9DCB88:
        case 0x3B9D8152:
        case 0x3B9C5488:
        case 0x3B9D9CA8:
        case 0x3B9D3EEA:
        case 0x3B9DB030:
        case 0x3B9E0620:
        case 0x3B9DD358:
        case 0x3B9B3761:
        case 0x3B9D4AA2:
        case 0x3B9DDF11:
        case 0x3B9D4E91:
        case 0x3B9E1D91:
        case 0x3B9E96AA:
        case 0x3B9D2391:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
    }
    
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkPhysicalDeviceProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x348], 0x0);
  
  this._pNext = null;
  this._properties = null;
  this.sType = 0x3B9BB079;
};

VkPhysicalDeviceProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x348));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x348), 0x0);
  
  
  
  
};

VkPhysicalDeviceProperties2KHR.byteLength = 0x348;

VkPhysicalDeviceProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  properties: {
    byteOffset: 0x10,
    byteLength: 0x338
  },
};
/** VkFormatProperties2 **/
function VkFormatProperties2(opts) {
  if (new.target !== VkFormatProperties2) {
    _VkFormatProperties2.reset();
    return _VkFormatProperties2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFormatProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFormatProperties2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFormatProperties2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9D3330:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
    }
    
    }
    },
  "formatProperties": {
    get() {
    return this._formatProperties;
    },
    },
  
});

VkFormatProperties2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._formatProperties = null;
  this.sType = 0x3B9BB07A;
};

VkFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkFormatProperties2.byteLength = 0x20;

VkFormatProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  formatProperties: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
};
/** VkFormatProperties2KHR **/
function VkFormatProperties2KHR(opts) {
  if (new.target !== VkFormatProperties2KHR) {
    _VkFormatProperties2KHR.reset();
    return _VkFormatProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFormatProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFormatProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFormatProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9D3330:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
    }
    
    }
    },
  "formatProperties": {
    get() {
    return this._formatProperties;
    },
    },
  
});

VkFormatProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._formatProperties = null;
  this.sType = 0x3B9BB07A;
};

VkFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkFormatProperties2KHR.byteLength = 0x20;

VkFormatProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  formatProperties: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
};
/** VkImageFormatProperties2 **/
function VkImageFormatProperties2(opts) {
  if (new.target !== VkImageFormatProperties2) {
    _VkImageFormatProperties2.reset();
    return _VkImageFormatProperties2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageFormatProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageFormatProperties2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9BDF59:
        case 0x3B9D2B65:
        case 0x3B9B6A28:
        case 0x3B9CC1E8:
        case 0x3B9D6211:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
    }
    
    }
    },
  "imageFormatProperties": {
    get() {
    return this._imageFormatProperties;
    },
    },
  
});

VkImageFormatProperties2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  this._imageFormatProperties = null;
  this.sType = 0x3B9BB07B;
};

VkImageFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
};

VkImageFormatProperties2.byteLength = 0x30;

VkImageFormatProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imageFormatProperties: {
    byteOffset: 0x10,
    byteLength: 0x20
  },
};
/** VkImageFormatProperties2KHR **/
function VkImageFormatProperties2KHR(opts) {
  if (new.target !== VkImageFormatProperties2KHR) {
    _VkImageFormatProperties2KHR.reset();
    return _VkImageFormatProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageFormatProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageFormatProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9BDF59:
        case 0x3B9D2B65:
        case 0x3B9B6A28:
        case 0x3B9CC1E8:
        case 0x3B9D6211:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
    }
    
    }
    },
  "imageFormatProperties": {
    get() {
    return this._imageFormatProperties;
    },
    },
  
});

VkImageFormatProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  this._imageFormatProperties = null;
  this.sType = 0x3B9BB07B;
};

VkImageFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
};

VkImageFormatProperties2KHR.byteLength = 0x30;

VkImageFormatProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imageFormatProperties: {
    byteOffset: 0x10,
    byteLength: 0x20
  },
};
/** VkPhysicalDeviceImageFormatInfo2 **/
function VkPhysicalDeviceImageFormatInfo2(opts) {
  if (new.target !== VkPhysicalDeviceImageFormatInfo2) {
    _VkPhysicalDeviceImageFormatInfo2.reset();
    return _VkPhysicalDeviceImageFormatInfo2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB07C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageFormatInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
      switch (sType) {
          
        case 0x3B9BDF58:
        case 0x3B9D0838:
        case 0x3B9D3332:
        case 0x3B9E8AF0:
        case 0x3B9D6210:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2.type': '" + value + "' is not a value of 'VkImageType'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "tiling": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.tiling': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageTiling(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2.tiling': '" + value + "' is not a value of 'VkImageTiling'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkPhysicalDeviceImageFormatInfo2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB07C;
};

VkPhysicalDeviceImageFormatInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageFormatInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageFormatInfo2.byteLength = 0x28;

VkPhysicalDeviceImageFormatInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  type: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  tiling: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceImageFormatInfo2KHR **/
function VkPhysicalDeviceImageFormatInfo2KHR(opts) {
  if (new.target !== VkPhysicalDeviceImageFormatInfo2KHR) {
    _VkPhysicalDeviceImageFormatInfo2KHR.reset();
    return _VkPhysicalDeviceImageFormatInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB07C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageFormatInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9BDF58:
        case 0x3B9D0838:
        case 0x3B9D3332:
        case 0x3B9E8AF0:
        case 0x3B9D6210:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2KHR.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2KHR.type': '" + value + "' is not a value of 'VkImageType'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "tiling": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.tiling': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageTiling(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageFormatInfo2KHR.tiling': '" + value + "' is not a value of 'VkImageTiling'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkPhysicalDeviceImageFormatInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB07C;
};

VkPhysicalDeviceImageFormatInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageFormatInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageFormatInfo2KHR.byteLength = 0x28;

VkPhysicalDeviceImageFormatInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  type: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  tiling: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkQueueFamilyProperties2 **/
function VkQueueFamilyProperties2(opts) {
  if (new.target !== VkQueueFamilyProperties2) {
    _VkQueueFamilyProperties2.reset();
    return _VkQueueFamilyProperties2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkQueueFamilyProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkQueueFamilyProperties2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9DEEB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
    }
    
    }
    },
  "queueFamilyProperties": {
    get() {
    return this._queueFamilyProperties;
    },
    },
  
});

VkQueueFamilyProperties2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._queueFamilyProperties = null;
  this.sType = 0x3B9BB07D;
};

VkQueueFamilyProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkQueueFamilyProperties2.byteLength = 0x28;

VkQueueFamilyProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  queueFamilyProperties: {
    byteOffset: 0x10,
    byteLength: 0x18
  },
};
/** VkQueueFamilyProperties2KHR **/
function VkQueueFamilyProperties2KHR(opts) {
  if (new.target !== VkQueueFamilyProperties2KHR) {
    _VkQueueFamilyProperties2KHR.reset();
    return _VkQueueFamilyProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkQueueFamilyProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkQueueFamilyProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9DEEB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
    }
    
    }
    },
  "queueFamilyProperties": {
    get() {
    return this._queueFamilyProperties;
    },
    },
  
});

VkQueueFamilyProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._queueFamilyProperties = null;
  this.sType = 0x3B9BB07D;
};

VkQueueFamilyProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkQueueFamilyProperties2KHR.byteLength = 0x28;

VkQueueFamilyProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  queueFamilyProperties: {
    byteOffset: 0x10,
    byteLength: 0x18
  },
};
/** VkPhysicalDeviceMemoryProperties2 **/
function VkPhysicalDeviceMemoryProperties2(opts) {
  if (new.target !== VkPhysicalDeviceMemoryProperties2) {
    _VkPhysicalDeviceMemoryProperties2.reset();
    return _VkPhysicalDeviceMemoryProperties2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x218) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x218) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x218) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x218);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMemoryProperties2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9E67C8:
        case 0x3B9F13A9:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
    }
    
    }
    },
  "memoryProperties": {
    get() {
    return this._memoryProperties;
    },
    },
  
});

VkPhysicalDeviceMemoryProperties2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x218], 0x0);
  
  this._pNext = null;
  this._memoryProperties = null;
  this.sType = 0x3B9BB07E;
};

VkPhysicalDeviceMemoryProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x218));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x218), 0x0);
  
  
  
  
};

VkPhysicalDeviceMemoryProperties2.byteLength = 0x218;

VkPhysicalDeviceMemoryProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryProperties: {
    byteOffset: 0x10,
    byteLength: 0x208
  },
};
/** VkPhysicalDeviceMemoryProperties2KHR **/
function VkPhysicalDeviceMemoryProperties2KHR(opts) {
  if (new.target !== VkPhysicalDeviceMemoryProperties2KHR) {
    _VkPhysicalDeviceMemoryProperties2KHR.reset();
    return _VkPhysicalDeviceMemoryProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x218) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x218) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x218) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x218);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMemoryProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9E67C8:
        case 0x3B9F13A9:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
    }
    
    }
    },
  "memoryProperties": {
    get() {
    return this._memoryProperties;
    },
    },
  
});

VkPhysicalDeviceMemoryProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x218], 0x0);
  
  this._pNext = null;
  this._memoryProperties = null;
  this.sType = 0x3B9BB07E;
};

VkPhysicalDeviceMemoryProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x218));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x218), 0x0);
  
  
  
  
};

VkPhysicalDeviceMemoryProperties2KHR.byteLength = 0x218;

VkPhysicalDeviceMemoryProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryProperties: {
    byteOffset: 0x10,
    byteLength: 0x208
  },
};
/** VkSparseImageFormatProperties2 **/
function VkSparseImageFormatProperties2(opts) {
  if (new.target !== VkSparseImageFormatProperties2) {
    _VkSparseImageFormatProperties2.reset();
    return _VkSparseImageFormatProperties2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07F;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageFormatProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageFormatProperties2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSparseImageFormatProperties2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageFormatProperties2.pNext' isn't allowed to be filled");
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkSparseImageFormatProperties2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._properties = null;
  this.sType = 0x3B9BB07F;
};

VkSparseImageFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkSparseImageFormatProperties2.byteLength = 0x28;

VkSparseImageFormatProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  properties: {
    byteOffset: 0x10,
    byteLength: 0x14
  },
};
/** VkSparseImageFormatProperties2KHR **/
function VkSparseImageFormatProperties2KHR(opts) {
  if (new.target !== VkSparseImageFormatProperties2KHR) {
    _VkSparseImageFormatProperties2KHR.reset();
    return _VkSparseImageFormatProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BB07F;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageFormatProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageFormatProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSparseImageFormatProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageFormatProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkSparseImageFormatProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._properties = null;
  this.sType = 0x3B9BB07F;
};

VkSparseImageFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkSparseImageFormatProperties2KHR.byteLength = 0x28;

VkSparseImageFormatProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  properties: {
    byteOffset: 0x10,
    byteLength: 0x14
  },
};
/** VkPhysicalDeviceSparseImageFormatInfo2 **/
function VkPhysicalDeviceSparseImageFormatInfo2(opts) {
  if (new.target !== VkPhysicalDeviceSparseImageFormatInfo2) {
    _VkPhysicalDeviceSparseImageFormatInfo2.reset();
    return _VkPhysicalDeviceSparseImageFormatInfo2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB080;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSparseImageFormatInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSparseImageFormatInfo2.pNext' isn't allowed to be filled");
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2.type': '" + value + "' is not a value of 'VkImageType'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "samples": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.samples': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "tiling": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.tiling': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageTiling(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2.tiling': '" + value + "' is not a value of 'VkImageTiling'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkPhysicalDeviceSparseImageFormatInfo2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB080;
};

VkPhysicalDeviceSparseImageFormatInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSparseImageFormatInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSparseImageFormatInfo2.byteLength = 0x28;

VkPhysicalDeviceSparseImageFormatInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  type: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  samples: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  tiling: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceSparseImageFormatInfo2KHR **/
function VkPhysicalDeviceSparseImageFormatInfo2KHR(opts) {
  if (new.target !== VkPhysicalDeviceSparseImageFormatInfo2KHR) {
    _VkPhysicalDeviceSparseImageFormatInfo2KHR.reset();
    return _VkPhysicalDeviceSparseImageFormatInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB080;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.type': '" + value + "' is not a value of 'VkImageType'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "samples": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.samples': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "tiling": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageTiling(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling': '" + value + "' is not a value of 'VkImageTiling'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9BB080;
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.byteLength = 0x28;

VkPhysicalDeviceSparseImageFormatInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  type: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  samples: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  tiling: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkPhysicalDevicePushDescriptorPropertiesKHR **/
function VkPhysicalDevicePushDescriptorPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDevicePushDescriptorPropertiesKHR) {
    _VkPhysicalDevicePushDescriptorPropertiesKHR.reset();
    return _VkPhysicalDevicePushDescriptorPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C0280;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePushDescriptorPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePushDescriptorPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevicePushDescriptorPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePushDescriptorPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxPushDescriptors": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C0280;
};

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDevicePushDescriptorPropertiesKHR.byteLength = 0x18;

VkPhysicalDevicePushDescriptorPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxPushDescriptors: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkConformanceVersionKHR **/
function VkConformanceVersionKHR(opts) {
  if (new.target !== VkConformanceVersionKHR) {
    _VkConformanceVersionKHR.reset();
    return _VkConformanceVersionKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x4) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x4);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.major !== void 0) this.major = opts.major;
    if (opts.minor !== void 0) this.minor = opts.minor;
    if (opts.subminor !== void 0) this.subminor = opts.subminor;
    if (opts.patch !== void 0) this.patch = opts.patch;
    
  }
};

Object.defineProperties(VkConformanceVersionKHR.prototype, {
  "major": {
    get() {
    return this.memoryViewUint8[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.major': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint8[0x0] = value;
    }
    },
  "minor": {
    get() {
    return this.memoryViewUint8[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.minor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint8[0x1] = value;
    }
    },
  "subminor": {
    get() {
    return this.memoryViewUint8[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.subminor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint8[0x2] = value;
    }
    },
  "patch": {
    get() {
    return this.memoryViewUint8[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.patch': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint8[0x3] = value;
    }
    },
  
});

VkConformanceVersionKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x4], 0x0);
  
  
  
  
  
};

VkConformanceVersionKHR.prototype.flush = function flush() {
  
  return true;
};

VkConformanceVersionKHR.prototype.reflect = function reflect(memoryAddress) {
  
};

VkConformanceVersionKHR.byteLength = 0x4;

VkConformanceVersionKHR.memoryLayout = {
  major: {
    byteOffset: 0x0,
    byteLength: 0x1
  },
  minor: {
    byteOffset: 0x1,
    byteLength: 0x1
  },
  subminor: {
    byteOffset: 0x2,
    byteLength: 0x1
  },
  patch: {
    byteOffset: 0x3,
    byteLength: 0x1
  },
};
/** VkPhysicalDeviceDriverPropertiesKHR **/
function VkPhysicalDeviceDriverPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceDriverPropertiesKHR) {
    _VkPhysicalDeviceDriverPropertiesKHR.reset();
    return _VkPhysicalDeviceDriverPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x218) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x218) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x218) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x218);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._conformanceVersion = new VkConformanceVersionKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x214 });
  this.sType = 0x3B9DC7A0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDriverPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDriverPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDriverPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDriverPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "driverID": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "driverName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x14, 0x128)
    ) || null;
    },
    },
  "driverInfo": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x114, 0x328)
    ) || null;
    },
    },
  "conformanceVersion": {
    get() {
    return this._conformanceVersion;
    },
    },
  
});

VkPhysicalDeviceDriverPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x218], 0x0);
  
  this._pNext = null;
  
  
  
  this._conformanceVersion = null;
  this.sType = 0x3B9DC7A0;
};

VkPhysicalDeviceDriverPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDriverPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x218));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x218), 0x0);
  
  
  
  
};

VkPhysicalDeviceDriverPropertiesKHR.byteLength = 0x218;

VkPhysicalDeviceDriverPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  driverID: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  driverName: {
    byteOffset: 0x14,
    byteLength: 0x100
  },
  driverInfo: {
    byteOffset: 0x114,
    byteLength: 0x100
  },
  conformanceVersion: {
    byteOffset: 0x214,
    byteLength: 0x4
  },
};
/** VkPresentRegionsKHR **/
function VkPresentRegionsKHR(opts) {
  if (new.target !== VkPresentRegionsKHR) {
    _VkPresentRegionsKHR.reset();
    return _VkPresentRegionsKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pRegions = null;
    this._pRegionsNative = null;
  this.sType = 0x3B9C1220;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkPresentRegionsKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPresentRegionsKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPresentRegionsKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.swapchainCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pRegions": {
    get() {
    return this._pRegions;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.pRegions': Expected 'Array VkPresentRegionKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPresentRegionsKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pRegions = null;
    this._pRegionsNative = null;
  this.sType = 0x3B9C1220;
};

VkPresentRegionsKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentRegionsKHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPresentRegionKHR)) {
        throw new TypeError("Invalid type for 'VkPresentRegionsKHR.pRegions[" + ii + "]': Expected 'VkPresentRegionKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pRegionsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPresentRegionsKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPresentRegionsKHR.byteLength = 0x20;

VkPresentRegionsKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  swapchainCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pRegions: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPresentRegionKHR **/
function VkPresentRegionKHR(opts) {
  if (new.target !== VkPresentRegionKHR) {
    _VkPresentRegionKHR.reset();
    return _VkPresentRegionKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pRectangles = null;
    this._pRectanglesNative = null;
  
  if (typeof opts === "object") {
    if (opts.rectangleCount !== void 0) this.rectangleCount = opts.rectangleCount;
    if (opts.pRectangles !== void 0) this.pRectangles = opts.pRectangles;
    
  }
};

Object.defineProperties(VkPresentRegionKHR.prototype, {
  "rectangleCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentRegionKHR.rectangleCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "pRectangles": {
    get() {
    return this._pRectangles;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRectangles = value;
    } else if (value === null) {
      this._pRectangles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentRegionKHR.pRectangles': Expected 'Array VkRectLayerKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPresentRegionKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  this._pRectangles = null;
    this._pRectanglesNative = null;
  
};

VkPresentRegionKHR.prototype.flush = function flush() {
  
  
  if (this._pRectangles !== null) {
    let array = this._pRectangles;
    
    if (array.length !== this.rectangleCount) {
      throw new RangeError("Invalid array length, expected length of 'rectangleCount' for 'VkPresentRegionKHR.pRectangles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRectLayerKHR)) {
        throw new TypeError("Invalid type for 'VkPresentRegionKHR.pRectangles[" + ii + "]': Expected 'VkRectLayerKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRectanglesNative = nativeArray;
      this.memoryViewBigInt64[0x1] = nativeArray.address;
    } else {
      this._pRectanglesNative = null;
      this.memoryViewBigInt64[0x1] = BI0;
    }
  }
  
  return true;
};

VkPresentRegionKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPresentRegionKHR.byteLength = 0x10;

VkPresentRegionKHR.memoryLayout = {
  rectangleCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pRectangles: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkRectLayerKHR **/
function VkRectLayerKHR(opts) {
  if (new.target !== VkRectLayerKHR) {
    _VkRectLayerKHR.reset();
    return _VkRectLayerKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x14) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x14);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  
  if (typeof opts === "object") {
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.layer !== void 0) this.layer = opts.layer;
    
  }
};

Object.defineProperties(VkRectLayerKHR.prototype, {
  "offset": {
    get() {
    return this._offset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset2D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.offset': Expected 'VkOffset2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.extent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layer": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.layer': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkRectLayerKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x14], 0x0);
  this._offset = null;
  this._extent = null;
  
  
};

VkRectLayerKHR.prototype.flush = function flush() {
  
  
  if (this._offset !== null) {
    let offset = this._offset;
    offset.flush();
    if (this.memoryBuffer !== offset.memoryBuffer) {
      let srcView = new Uint8Array(offset.memoryBuffer).subarray(offset.$memoryOffset, offset.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRectLayerKHR.offset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer).subarray(extent.$memoryOffset, extent.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRectLayerKHR.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkRectLayerKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRectLayerKHR.byteLength = 0x14;

VkRectLayerKHR.memoryLayout = {
  offset: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  extent: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  layer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceVariablePointersFeatures **/
function VkPhysicalDeviceVariablePointersFeatures(opts) {
  if (new.target !== VkPhysicalDeviceVariablePointersFeatures) {
    _VkPhysicalDeviceVariablePointersFeatures.reset();
    return _VkPhysicalDeviceVariablePointersFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointersFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVariablePointersFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVariablePointersFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointersFeatures.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "variablePointers": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceVariablePointersFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
};

VkPhysicalDeviceVariablePointersFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointersFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVariablePointersFeatures.byteLength = 0x18;

VkPhysicalDeviceVariablePointersFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  variablePointers: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceVariablePointersFeaturesKHR **/
function VkPhysicalDeviceVariablePointersFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceVariablePointersFeaturesKHR) {
    _VkPhysicalDeviceVariablePointersFeaturesKHR.reset();
    return _VkPhysicalDeviceVariablePointersFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointersFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVariablePointersFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVariablePointersFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointersFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "variablePointers": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceVariablePointersFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
};

VkPhysicalDeviceVariablePointersFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointersFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVariablePointersFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceVariablePointersFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  variablePointers: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceVariablePointerFeaturesKHR **/
function VkPhysicalDeviceVariablePointerFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceVariablePointerFeaturesKHR) {
    _VkPhysicalDeviceVariablePointerFeaturesKHR.reset();
    return _VkPhysicalDeviceVariablePointerFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointerFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVariablePointerFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVariablePointerFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointerFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "variablePointers": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
};

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVariablePointerFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceVariablePointerFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  variablePointers: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceVariablePointerFeatures **/
function VkPhysicalDeviceVariablePointerFeatures(opts) {
  if (new.target !== VkPhysicalDeviceVariablePointerFeatures) {
    _VkPhysicalDeviceVariablePointerFeatures.reset();
    return _VkPhysicalDeviceVariablePointerFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointerFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVariablePointerFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVariablePointerFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointerFeatures.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "variablePointers": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceVariablePointerFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C9EC0;
};

VkPhysicalDeviceVariablePointerFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointerFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVariablePointerFeatures.byteLength = 0x18;

VkPhysicalDeviceVariablePointerFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  variablePointers: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkExternalMemoryProperties **/
function VkExternalMemoryProperties(opts) {
  if (new.target !== VkExternalMemoryProperties) {
    _VkExternalMemoryProperties.reset();
    return _VkExternalMemoryProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExternalMemoryProperties.prototype, {
  "externalMemoryFeatures": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    },
  
});

VkExternalMemoryProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkExternalMemoryProperties.prototype.flush = function flush() {
  
  return true;
};

VkExternalMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0xC));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0xC), 0x0);
};

VkExternalMemoryProperties.byteLength = 0xC;

VkExternalMemoryProperties.memoryLayout = {
  externalMemoryFeatures: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkExternalMemoryPropertiesKHR **/
function VkExternalMemoryPropertiesKHR(opts) {
  if (new.target !== VkExternalMemoryPropertiesKHR) {
    _VkExternalMemoryPropertiesKHR.reset();
    return _VkExternalMemoryPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExternalMemoryPropertiesKHR.prototype, {
  "externalMemoryFeatures": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    },
  
});

VkExternalMemoryPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkExternalMemoryPropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkExternalMemoryPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0xC));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0xC), 0x0);
};

VkExternalMemoryPropertiesKHR.byteLength = 0xC;

VkExternalMemoryPropertiesKHR.memoryLayout = {
  externalMemoryFeatures: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalImageFormatInfo **/
function VkPhysicalDeviceExternalImageFormatInfo(opts) {
  if (new.target !== VkPhysicalDeviceExternalImageFormatInfo) {
    _VkPhysicalDeviceExternalImageFormatInfo.reset();
    return _VkPhysicalDeviceExternalImageFormatInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BDF58;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalImageFormatInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalImageFormatInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalImageFormatInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfo.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceExternalImageFormatInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BDF58;
};

VkPhysicalDeviceExternalImageFormatInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalImageFormatInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalImageFormatInfo.byteLength = 0x18;

VkPhysicalDeviceExternalImageFormatInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalImageFormatInfoKHR **/
function VkPhysicalDeviceExternalImageFormatInfoKHR(opts) {
  if (new.target !== VkPhysicalDeviceExternalImageFormatInfoKHR) {
    _VkPhysicalDeviceExternalImageFormatInfoKHR.reset();
    return _VkPhysicalDeviceExternalImageFormatInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BDF58;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalImageFormatInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalImageFormatInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalImageFormatInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BDF58;
};

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalImageFormatInfoKHR.byteLength = 0x18;

VkPhysicalDeviceExternalImageFormatInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExternalImageFormatProperties **/
function VkExternalImageFormatProperties(opts) {
  if (new.target !== VkExternalImageFormatProperties) {
    _VkExternalImageFormatProperties.reset();
    return _VkExternalImageFormatProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BDF59;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalImageFormatProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalImageFormatProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalImageFormatProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalImageFormatProperties.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalImageFormatProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._externalMemoryProperties = null;
  this.sType = 0x3B9BDF59;
};

VkExternalImageFormatProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalImageFormatProperties.byteLength = 0x20;

VkExternalImageFormatProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  externalMemoryProperties: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
};
/** VkExternalImageFormatPropertiesKHR **/
function VkExternalImageFormatPropertiesKHR(opts) {
  if (new.target !== VkExternalImageFormatPropertiesKHR) {
    _VkExternalImageFormatPropertiesKHR.reset();
    return _VkExternalImageFormatPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BDF59;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalImageFormatPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalImageFormatPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalImageFormatPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalImageFormatPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalImageFormatPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._externalMemoryProperties = null;
  this.sType = 0x3B9BDF59;
};

VkExternalImageFormatPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalImageFormatPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalImageFormatPropertiesKHR.byteLength = 0x20;

VkExternalImageFormatPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  externalMemoryProperties: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
};
/** VkPhysicalDeviceExternalBufferInfo **/
function VkPhysicalDeviceExternalBufferInfo(opts) {
  if (new.target !== VkPhysicalDeviceExternalBufferInfo) {
    _VkPhysicalDeviceExternalBufferInfo.reset();
    return _VkPhysicalDeviceExternalBufferInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BDF5A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalBufferInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalBufferInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalBufferInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkPhysicalDeviceExternalBufferInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BDF5A;
};

VkPhysicalDeviceExternalBufferInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalBufferInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalBufferInfo.byteLength = 0x20;

VkPhysicalDeviceExternalBufferInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalBufferInfoKHR **/
function VkPhysicalDeviceExternalBufferInfoKHR(opts) {
  if (new.target !== VkPhysicalDeviceExternalBufferInfoKHR) {
    _VkPhysicalDeviceExternalBufferInfoKHR.reset();
    return _VkPhysicalDeviceExternalBufferInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BDF5A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalBufferInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalBufferInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalBufferInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkPhysicalDeviceExternalBufferInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BDF5A;
};

VkPhysicalDeviceExternalBufferInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalBufferInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalBufferInfoKHR.byteLength = 0x20;

VkPhysicalDeviceExternalBufferInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkExternalBufferProperties **/
function VkExternalBufferProperties(opts) {
  if (new.target !== VkExternalBufferProperties) {
    _VkExternalBufferProperties.reset();
    return _VkExternalBufferProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BDF5B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalBufferProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalBufferProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalBufferProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalBufferProperties.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalBufferProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._externalMemoryProperties = null;
  this.sType = 0x3B9BDF5B;
};

VkExternalBufferProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalBufferProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalBufferProperties.byteLength = 0x20;

VkExternalBufferProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  externalMemoryProperties: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
};
/** VkExternalBufferPropertiesKHR **/
function VkExternalBufferPropertiesKHR(opts) {
  if (new.target !== VkExternalBufferPropertiesKHR) {
    _VkExternalBufferPropertiesKHR.reset();
    return _VkExternalBufferPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9BDF5B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalBufferPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalBufferPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalBufferPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalBufferPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalBufferPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._externalMemoryProperties = null;
  this.sType = 0x3B9BDF5B;
};

VkExternalBufferPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalBufferPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalBufferPropertiesKHR.byteLength = 0x20;

VkExternalBufferPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  externalMemoryProperties: {
    byteOffset: 0x10,
    byteLength: 0xC
  },
};
/** VkPhysicalDeviceIDProperties **/
function VkPhysicalDeviceIDProperties(opts) {
  if (new.target !== VkPhysicalDeviceIDProperties) {
    _VkPhysicalDeviceIDProperties.reset();
    return _VkPhysicalDeviceIDProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._deviceUUID = [...Array(16)].fill(0x0);
  this._driverUUID = [...Array(16)].fill(0x0);
  this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  this.sType = 0x3B9BDF5C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceIDProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceIDProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceIDProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceIDProperties.pNext' isn't allowed to be filled");
    }
    },
  "deviceUUID": {
    get() {
    return [
      this.memoryViewUint8[0x10],
      this.memoryViewUint8[0x11],
      this.memoryViewUint8[0x12],
      this.memoryViewUint8[0x13],
      this.memoryViewUint8[0x14],
      this.memoryViewUint8[0x15],
      this.memoryViewUint8[0x16],
      this.memoryViewUint8[0x17],
      this.memoryViewUint8[0x18],
      this.memoryViewUint8[0x19],
      this.memoryViewUint8[0x1A],
      this.memoryViewUint8[0x1B],
      this.memoryViewUint8[0x1C],
      this.memoryViewUint8[0x1D],
      this.memoryViewUint8[0x1E],
      this.memoryViewUint8[0x1F]
    ];
    },
    },
  "driverUUID": {
    get() {
    return [
      this.memoryViewUint8[0x20],
      this.memoryViewUint8[0x21],
      this.memoryViewUint8[0x22],
      this.memoryViewUint8[0x23],
      this.memoryViewUint8[0x24],
      this.memoryViewUint8[0x25],
      this.memoryViewUint8[0x26],
      this.memoryViewUint8[0x27],
      this.memoryViewUint8[0x28],
      this.memoryViewUint8[0x29],
      this.memoryViewUint8[0x2A],
      this.memoryViewUint8[0x2B],
      this.memoryViewUint8[0x2C],
      this.memoryViewUint8[0x2D],
      this.memoryViewUint8[0x2E],
      this.memoryViewUint8[0x2F]
    ];
    },
    },
  "deviceLUID": {
    get() {
    return [
      this.memoryViewUint8[0x30],
      this.memoryViewUint8[0x31],
      this.memoryViewUint8[0x32],
      this.memoryViewUint8[0x33],
      this.memoryViewUint8[0x34],
      this.memoryViewUint8[0x35],
      this.memoryViewUint8[0x36],
      this.memoryViewUint8[0x37]
    ];
    },
    },
  "deviceNodeMask": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    },
  "deviceLUIDValid": {
    get() {
    return this.memoryViewUint32[0xF] !== 0;
    },
    },
  
});

VkPhysicalDeviceIDProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._deviceUUID = null;
  this._driverUUID = null;
  this._deviceLUID = null;
  
  
  this.sType = 0x3B9BDF5C;
};

VkPhysicalDeviceIDProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIDProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceIDProperties.byteLength = 0x40;

VkPhysicalDeviceIDProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceUUID: {
    byteOffset: 0x10,
    byteLength: 0x10
  },
  driverUUID: {
    byteOffset: 0x20,
    byteLength: 0x10
  },
  deviceLUID: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  deviceNodeMask: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  deviceLUIDValid: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceIDPropertiesKHR **/
function VkPhysicalDeviceIDPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceIDPropertiesKHR) {
    _VkPhysicalDeviceIDPropertiesKHR.reset();
    return _VkPhysicalDeviceIDPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._deviceUUID = [...Array(16)].fill(0x0);
  this._driverUUID = [...Array(16)].fill(0x0);
  this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  this.sType = 0x3B9BDF5C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceIDPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceIDPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceIDPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceIDPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceUUID": {
    get() {
    return [
      this.memoryViewUint8[0x10],
      this.memoryViewUint8[0x11],
      this.memoryViewUint8[0x12],
      this.memoryViewUint8[0x13],
      this.memoryViewUint8[0x14],
      this.memoryViewUint8[0x15],
      this.memoryViewUint8[0x16],
      this.memoryViewUint8[0x17],
      this.memoryViewUint8[0x18],
      this.memoryViewUint8[0x19],
      this.memoryViewUint8[0x1A],
      this.memoryViewUint8[0x1B],
      this.memoryViewUint8[0x1C],
      this.memoryViewUint8[0x1D],
      this.memoryViewUint8[0x1E],
      this.memoryViewUint8[0x1F]
    ];
    },
    },
  "driverUUID": {
    get() {
    return [
      this.memoryViewUint8[0x20],
      this.memoryViewUint8[0x21],
      this.memoryViewUint8[0x22],
      this.memoryViewUint8[0x23],
      this.memoryViewUint8[0x24],
      this.memoryViewUint8[0x25],
      this.memoryViewUint8[0x26],
      this.memoryViewUint8[0x27],
      this.memoryViewUint8[0x28],
      this.memoryViewUint8[0x29],
      this.memoryViewUint8[0x2A],
      this.memoryViewUint8[0x2B],
      this.memoryViewUint8[0x2C],
      this.memoryViewUint8[0x2D],
      this.memoryViewUint8[0x2E],
      this.memoryViewUint8[0x2F]
    ];
    },
    },
  "deviceLUID": {
    get() {
    return [
      this.memoryViewUint8[0x30],
      this.memoryViewUint8[0x31],
      this.memoryViewUint8[0x32],
      this.memoryViewUint8[0x33],
      this.memoryViewUint8[0x34],
      this.memoryViewUint8[0x35],
      this.memoryViewUint8[0x36],
      this.memoryViewUint8[0x37]
    ];
    },
    },
  "deviceNodeMask": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    },
  "deviceLUIDValid": {
    get() {
    return this.memoryViewUint32[0xF] !== 0;
    },
    },
  
});

VkPhysicalDeviceIDPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._deviceUUID = null;
  this._driverUUID = null;
  this._deviceLUID = null;
  
  
  this.sType = 0x3B9BDF5C;
};

VkPhysicalDeviceIDPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIDPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceIDPropertiesKHR.byteLength = 0x40;

VkPhysicalDeviceIDPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceUUID: {
    byteOffset: 0x10,
    byteLength: 0x10
  },
  driverUUID: {
    byteOffset: 0x20,
    byteLength: 0x10
  },
  deviceLUID: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  deviceNodeMask: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  deviceLUIDValid: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
};
/** VkExternalMemoryImageCreateInfo **/
function VkExternalMemoryImageCreateInfo(opts) {
  if (new.target !== VkExternalMemoryImageCreateInfo) {
    _VkExternalMemoryImageCreateInfo.reset();
    return _VkExternalMemoryImageCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE341;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryImageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalMemoryImageCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryImageCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfo.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExternalMemoryImageCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE341;
};

VkExternalMemoryImageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryImageCreateInfo.byteLength = 0x18;

VkExternalMemoryImageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExternalMemoryImageCreateInfoKHR **/
function VkExternalMemoryImageCreateInfoKHR(opts) {
  if (new.target !== VkExternalMemoryImageCreateInfoKHR) {
    _VkExternalMemoryImageCreateInfoKHR.reset();
    return _VkExternalMemoryImageCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE341;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryImageCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalMemoryImageCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryImageCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoKHR.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExternalMemoryImageCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE341;
};

VkExternalMemoryImageCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryImageCreateInfoKHR.byteLength = 0x18;

VkExternalMemoryImageCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExternalMemoryBufferCreateInfo **/
function VkExternalMemoryBufferCreateInfo(opts) {
  if (new.target !== VkExternalMemoryBufferCreateInfo) {
    _VkExternalMemoryBufferCreateInfo.reset();
    return _VkExternalMemoryBufferCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE340;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryBufferCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalMemoryBufferCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryBufferCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfo.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExternalMemoryBufferCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE340;
};

VkExternalMemoryBufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryBufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryBufferCreateInfo.byteLength = 0x18;

VkExternalMemoryBufferCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExternalMemoryBufferCreateInfoKHR **/
function VkExternalMemoryBufferCreateInfoKHR(opts) {
  if (new.target !== VkExternalMemoryBufferCreateInfoKHR) {
    _VkExternalMemoryBufferCreateInfoKHR.reset();
    return _VkExternalMemoryBufferCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE340;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryBufferCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalMemoryBufferCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryBufferCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfoKHR.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExternalMemoryBufferCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE340;
};

VkExternalMemoryBufferCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryBufferCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryBufferCreateInfoKHR.byteLength = 0x18;

VkExternalMemoryBufferCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExportMemoryAllocateInfo **/
function VkExportMemoryAllocateInfo(opts) {
  if (new.target !== VkExportMemoryAllocateInfo) {
    _VkExportMemoryAllocateInfo.reset();
    return _VkExportMemoryAllocateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE342;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportMemoryAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportMemoryAllocateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfo.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportMemoryAllocateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE342;
};

VkExportMemoryAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryAllocateInfo.byteLength = 0x18;

VkExportMemoryAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExportMemoryAllocateInfoKHR **/
function VkExportMemoryAllocateInfoKHR(opts) {
  if (new.target !== VkExportMemoryAllocateInfoKHR) {
    _VkExportMemoryAllocateInfoKHR.reset();
    return _VkExportMemoryAllocateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE342;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportMemoryAllocateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportMemoryAllocateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryAllocateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoKHR.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportMemoryAllocateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE342;
};

VkExportMemoryAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryAllocateInfoKHR.byteLength = 0x18;

VkExportMemoryAllocateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImportMemoryWin32HandleInfoKHR **/
function VkImportMemoryWin32HandleInfoKHR(opts) {
  if (new.target !== VkImportMemoryWin32HandleInfoKHR) {
    _VkImportMemoryWin32HandleInfoKHR.reset();
    return _VkImportMemoryWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = 0x3B9BE728;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkImportMemoryWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportMemoryWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "handle": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoKHR.handle': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._name);
    } else if (value === null) {
      this._name = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportMemoryWin32HandleInfoKHR.name': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImportMemoryWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = 0x3B9BE728;
};

VkImportMemoryWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportMemoryWin32HandleInfoKHR.byteLength = 0x28;

VkImportMemoryWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  handle: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  name: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkExportMemoryWin32HandleInfoKHR **/
function VkExportMemoryWin32HandleInfoKHR(opts) {
  if (new.target !== VkExportMemoryWin32HandleInfoKHR) {
    _VkExportMemoryWin32HandleInfoKHR.reset();
    return _VkExportMemoryWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._name = null;
  this.sType = 0x3B9BE729;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkExportMemoryWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportMemoryWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._name);
    } else if (value === null) {
      this._name = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkExportMemoryWin32HandleInfoKHR.name': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkExportMemoryWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._name = null;
  this.sType = 0x3B9BE729;
};

VkExportMemoryWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryWin32HandleInfoKHR.byteLength = 0x28;

VkExportMemoryWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  name: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkMemoryWin32HandlePropertiesKHR **/
function VkMemoryWin32HandlePropertiesKHR(opts) {
  if (new.target !== VkMemoryWin32HandlePropertiesKHR) {
    _VkMemoryWin32HandlePropertiesKHR.reset();
    return _VkMemoryWin32HandlePropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BE72A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryWin32HandlePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryWin32HandlePropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryWin32HandlePropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryWin32HandlePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "memoryTypeBits": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkMemoryWin32HandlePropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BE72A;
};

VkMemoryWin32HandlePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryWin32HandlePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryWin32HandlePropertiesKHR.byteLength = 0x18;

VkMemoryWin32HandlePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryTypeBits: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkMemoryGetWin32HandleInfoKHR **/
function VkMemoryGetWin32HandleInfoKHR(opts) {
  if (new.target !== VkMemoryGetWin32HandleInfoKHR) {
    _VkMemoryGetWin32HandleInfoKHR.reset();
    return _VkMemoryGetWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = 0x3B9BE72B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkMemoryGetWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryGetWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryGetWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryGetWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryGetWin32HandleInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryGetWin32HandleInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkMemoryGetWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = 0x3B9BE72B;
};

VkMemoryGetWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryGetWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryGetWin32HandleInfoKHR.byteLength = 0x20;

VkMemoryGetWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkImportMemoryFdInfoKHR **/
function VkImportMemoryFdInfoKHR(opts) {
  if (new.target !== VkImportMemoryFdInfoKHR) {
    _VkImportMemoryFdInfoKHR.reset();
    return _VkImportMemoryFdInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BEB10;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

Object.defineProperties(VkImportMemoryFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryFdInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportMemoryFdInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryFdInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "fd": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryFdInfoKHR.fd': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  
});

VkImportMemoryFdInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BEB10;
};

VkImportMemoryFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportMemoryFdInfoKHR.byteLength = 0x18;

VkImportMemoryFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  fd: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkMemoryFdPropertiesKHR **/
function VkMemoryFdPropertiesKHR(opts) {
  if (new.target !== VkMemoryFdPropertiesKHR) {
    _VkMemoryFdPropertiesKHR.reset();
    return _VkMemoryFdPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BEB11;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryFdPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryFdPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryFdPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryFdPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "memoryTypeBits": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkMemoryFdPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BEB11;
};

VkMemoryFdPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryFdPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryFdPropertiesKHR.byteLength = 0x18;

VkMemoryFdPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryTypeBits: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkMemoryGetFdInfoKHR **/
function VkMemoryGetFdInfoKHR(opts) {
  if (new.target !== VkMemoryGetFdInfoKHR) {
    _VkMemoryGetFdInfoKHR.reset();
    return _VkMemoryGetFdInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = 0x3B9BEB12;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkMemoryGetFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryGetFdInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryGetFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkMemoryGetFdInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = 0x3B9BEB12;
};

VkMemoryGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryGetFdInfoKHR.byteLength = 0x20;

VkMemoryGetFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkWin32KeyedMutexAcquireReleaseInfoKHR **/
function VkWin32KeyedMutexAcquireReleaseInfoKHR(opts) {
  if (new.target !== VkWin32KeyedMutexAcquireReleaseInfoKHR) {
    _VkWin32KeyedMutexAcquireReleaseInfoKHR.reset();
    return _VkWin32KeyedMutexAcquireReleaseInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
    this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeouts = null;
  
  this._pReleaseSyncs = null;
    this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = 0x3B9BEEF8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.acquireCount !== void 0) this.acquireCount = opts.acquireCount;
    if (opts.pAcquireSyncs !== void 0) this.pAcquireSyncs = opts.pAcquireSyncs;
    if (opts.pAcquireKeys !== void 0) this.pAcquireKeys = opts.pAcquireKeys;
    if (opts.pAcquireTimeouts !== void 0) this.pAcquireTimeouts = opts.pAcquireTimeouts;
    if (opts.releaseCount !== void 0) this.releaseCount = opts.releaseCount;
    if (opts.pReleaseSyncs !== void 0) this.pReleaseSyncs = opts.pReleaseSyncs;
    if (opts.pReleaseKeys !== void 0) this.pReleaseKeys = opts.pReleaseKeys;
    
  }
};

Object.defineProperties(VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "acquireCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.acquireCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAcquireSyncs": {
    get() {
    return this._pAcquireSyncs;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAcquireSyncs = value;
    } else if (value === null) {
      this._pAcquireSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pAcquireKeys": {
    get() {
    return this._pAcquireKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pAcquireKeys = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pAcquireKeys = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pAcquireTimeouts": {
    get() {
    return this._pAcquireTimeouts;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pAcquireTimeouts = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pAcquireTimeouts = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "releaseCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.releaseCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pReleaseSyncs": {
    get() {
    return this._pReleaseSyncs;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pReleaseSyncs = value;
    } else if (value === null) {
      this._pReleaseSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pReleaseKeys": {
    get() {
    return this._pReleaseKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pReleaseKeys = value;
      this.memoryViewBigInt64[0x8] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pReleaseKeys = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
    this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeouts = null;
  
  this._pReleaseSyncs = null;
    this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = 0x3B9BEEF8;
};

VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAcquireSyncs !== null) {
    let array = this._pAcquireSyncs;
    
    if (array.length !== this.acquireCount) {
      throw new RangeError("Invalid array length, expected length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAcquireSyncsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAcquireSyncsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pReleaseSyncs !== null) {
    let array = this._pReleaseSyncs;
    
    if (array.length !== this.releaseCount) {
      throw new RangeError("Invalid array length, expected length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pReleaseSyncsNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pReleaseSyncsNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkWin32KeyedMutexAcquireReleaseInfoKHR.byteLength = 0x48;

VkWin32KeyedMutexAcquireReleaseInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  acquireCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAcquireSyncs: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pAcquireKeys: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pAcquireTimeouts: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  releaseCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pReleaseSyncs: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  pReleaseKeys: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceExternalSemaphoreInfo **/
function VkPhysicalDeviceExternalSemaphoreInfo(opts) {
  if (new.target !== VkPhysicalDeviceExternalSemaphoreInfo) {
    _VkPhysicalDeviceExternalSemaphoreInfo.reset();
    return _VkPhysicalDeviceExternalSemaphoreInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BF2E0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalSemaphoreInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalSemaphoreInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalSemaphoreInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceExternalSemaphoreInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BF2E0;
};

VkPhysicalDeviceExternalSemaphoreInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalSemaphoreInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalSemaphoreInfo.byteLength = 0x18;

VkPhysicalDeviceExternalSemaphoreInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalSemaphoreInfoKHR **/
function VkPhysicalDeviceExternalSemaphoreInfoKHR(opts) {
  if (new.target !== VkPhysicalDeviceExternalSemaphoreInfoKHR) {
    _VkPhysicalDeviceExternalSemaphoreInfoKHR.reset();
    return _VkPhysicalDeviceExternalSemaphoreInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BF2E0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BF2E0;
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.byteLength = 0x18;

VkPhysicalDeviceExternalSemaphoreInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExternalSemaphoreProperties **/
function VkExternalSemaphoreProperties(opts) {
  if (new.target !== VkExternalSemaphoreProperties) {
    _VkExternalSemaphoreProperties.reset();
    return _VkExternalSemaphoreProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BF2E1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalSemaphoreProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalSemaphoreProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalSemaphoreProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalSemaphoreProperties.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "externalSemaphoreFeatures": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    },
  
});

VkExternalSemaphoreProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BF2E1;
};

VkExternalSemaphoreProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalSemaphoreProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalSemaphoreProperties.byteLength = 0x20;

VkExternalSemaphoreProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  externalSemaphoreFeatures: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkExternalSemaphorePropertiesKHR **/
function VkExternalSemaphorePropertiesKHR(opts) {
  if (new.target !== VkExternalSemaphorePropertiesKHR) {
    _VkExternalSemaphorePropertiesKHR.reset();
    return _VkExternalSemaphorePropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BF2E1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalSemaphorePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalSemaphorePropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalSemaphorePropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalSemaphorePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "externalSemaphoreFeatures": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    },
  
});

VkExternalSemaphorePropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9BF2E1;
};

VkExternalSemaphorePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalSemaphorePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalSemaphorePropertiesKHR.byteLength = 0x20;

VkExternalSemaphorePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  externalSemaphoreFeatures: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkExportSemaphoreCreateInfo **/
function VkExportSemaphoreCreateInfo(opts) {
  if (new.target !== VkExportSemaphoreCreateInfo) {
    _VkExportSemaphoreCreateInfo.reset();
    return _VkExportSemaphoreCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BF6C8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportSemaphoreCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportSemaphoreCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportSemaphoreCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfo.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportSemaphoreCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BF6C8;
};

VkExportSemaphoreCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportSemaphoreCreateInfo.byteLength = 0x18;

VkExportSemaphoreCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExportSemaphoreCreateInfoKHR **/
function VkExportSemaphoreCreateInfoKHR(opts) {
  if (new.target !== VkExportSemaphoreCreateInfoKHR) {
    _VkExportSemaphoreCreateInfoKHR.reset();
    return _VkExportSemaphoreCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BF6C8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportSemaphoreCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportSemaphoreCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportSemaphoreCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfoKHR.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportSemaphoreCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BF6C8;
};

VkExportSemaphoreCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportSemaphoreCreateInfoKHR.byteLength = 0x18;

VkExportSemaphoreCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImportSemaphoreWin32HandleInfoKHR **/
function VkImportSemaphoreWin32HandleInfoKHR(opts) {
  if (new.target !== VkImportSemaphoreWin32HandleInfoKHR) {
    _VkImportSemaphoreWin32HandleInfoKHR.reset();
    return _VkImportSemaphoreWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this._name = null;
  this.sType = 0x3B9BFAB0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkImportSemaphoreWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportSemaphoreWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportSemaphoreWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "handle": {
    get() {
    return this.memoryViewBigInt64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.handle': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x4] = BigInt(value);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(this._name);
    } else if (value === null) {
      this._name = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.name': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImportSemaphoreWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this._name = null;
  this.sType = 0x3B9BFAB0;
};

VkImportSemaphoreWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportSemaphoreWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportSemaphoreWin32HandleInfoKHR.byteLength = 0x30;

VkImportSemaphoreWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  semaphore: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  handleType: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  handle: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  name: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkExportSemaphoreWin32HandleInfoKHR **/
function VkExportSemaphoreWin32HandleInfoKHR(opts) {
  if (new.target !== VkExportSemaphoreWin32HandleInfoKHR) {
    _VkExportSemaphoreWin32HandleInfoKHR.reset();
    return _VkExportSemaphoreWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._name = null;
  this.sType = 0x3B9BFAB1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkExportSemaphoreWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportSemaphoreWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportSemaphoreWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._name);
    } else if (value === null) {
      this._name = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkExportSemaphoreWin32HandleInfoKHR.name': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkExportSemaphoreWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._name = null;
  this.sType = 0x3B9BFAB1;
};

VkExportSemaphoreWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportSemaphoreWin32HandleInfoKHR.byteLength = 0x28;

VkExportSemaphoreWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  name: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkD3D12FenceSubmitInfoKHR **/
function VkD3D12FenceSubmitInfoKHR(opts) {
  if (new.target !== VkD3D12FenceSubmitInfoKHR) {
    _VkD3D12FenceSubmitInfoKHR.reset();
    return _VkD3D12FenceSubmitInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = 0x3B9BFAB2;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValuesCount !== void 0) this.waitSemaphoreValuesCount = opts.waitSemaphoreValuesCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValuesCount !== void 0) this.signalSemaphoreValuesCount = opts.signalSemaphoreValuesCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

Object.defineProperties(VkD3D12FenceSubmitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkD3D12FenceSubmitInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkD3D12FenceSubmitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreValuesCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.waitSemaphoreValuesCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pWaitSemaphoreValues": {
    get() {
    return this._pWaitSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pWaitSemaphoreValues = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitSemaphoreValues = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreValuesCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.signalSemaphoreValuesCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pSignalSemaphoreValues": {
    get() {
    return this._pSignalSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pSignalSemaphoreValues = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSignalSemaphoreValues = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkD3D12FenceSubmitInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = 0x3B9BFAB2;
};

VkD3D12FenceSubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkD3D12FenceSubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkD3D12FenceSubmitInfoKHR.byteLength = 0x30;

VkD3D12FenceSubmitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  waitSemaphoreValuesCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pWaitSemaphoreValues: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  signalSemaphoreValuesCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pSignalSemaphoreValues: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkSemaphoreGetWin32HandleInfoKHR **/
function VkSemaphoreGetWin32HandleInfoKHR(opts) {
  if (new.target !== VkSemaphoreGetWin32HandleInfoKHR) {
    _VkSemaphoreGetWin32HandleInfoKHR.reset();
    return _VkSemaphoreGetWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = 0x3B9BFAB3;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkSemaphoreGetWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreGetWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSemaphoreGetWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreGetWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreGetWin32HandleInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreGetWin32HandleInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkSemaphoreGetWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = 0x3B9BFAB3;
};

VkSemaphoreGetWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreGetWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSemaphoreGetWin32HandleInfoKHR.byteLength = 0x20;

VkSemaphoreGetWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  semaphore: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkImportSemaphoreFdInfoKHR **/
function VkImportSemaphoreFdInfoKHR(opts) {
  if (new.target !== VkImportSemaphoreFdInfoKHR) {
    _VkImportSemaphoreFdInfoKHR.reset();
    return _VkImportSemaphoreFdInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this.sType = 0x3B9BFE98;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

Object.defineProperties(VkImportSemaphoreFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportSemaphoreFdInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportSemaphoreFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "fd": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.fd': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkImportSemaphoreFdInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this.sType = 0x3B9BFE98;
};

VkImportSemaphoreFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportSemaphoreFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportSemaphoreFdInfoKHR.byteLength = 0x28;

VkImportSemaphoreFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  semaphore: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  handleType: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  fd: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkSemaphoreGetFdInfoKHR **/
function VkSemaphoreGetFdInfoKHR(opts) {
  if (new.target !== VkSemaphoreGetFdInfoKHR) {
    _VkSemaphoreGetFdInfoKHR.reset();
    return _VkSemaphoreGetFdInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = 0x3B9BFE99;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkSemaphoreGetFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSemaphoreGetFdInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreGetFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkSemaphoreGetFdInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = 0x3B9BFE99;
};

VkSemaphoreGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSemaphoreGetFdInfoKHR.byteLength = 0x20;

VkSemaphoreGetFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  semaphore: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalFenceInfo **/
function VkPhysicalDeviceExternalFenceInfo(opts) {
  if (new.target !== VkPhysicalDeviceExternalFenceInfo) {
    _VkPhysicalDeviceExternalFenceInfo.reset();
    return _VkPhysicalDeviceExternalFenceInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C7F80;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalFenceInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalFenceInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalFenceInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfo.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceExternalFenceInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C7F80;
};

VkPhysicalDeviceExternalFenceInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalFenceInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalFenceInfo.byteLength = 0x18;

VkPhysicalDeviceExternalFenceInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalFenceInfoKHR **/
function VkPhysicalDeviceExternalFenceInfoKHR(opts) {
  if (new.target !== VkPhysicalDeviceExternalFenceInfoKHR) {
    _VkPhysicalDeviceExternalFenceInfoKHR.reset();
    return _VkPhysicalDeviceExternalFenceInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C7F80;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalFenceInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalFenceInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalFenceInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceExternalFenceInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C7F80;
};

VkPhysicalDeviceExternalFenceInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalFenceInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalFenceInfoKHR.byteLength = 0x18;

VkPhysicalDeviceExternalFenceInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExternalFenceProperties **/
function VkExternalFenceProperties(opts) {
  if (new.target !== VkExternalFenceProperties) {
    _VkExternalFenceProperties.reset();
    return _VkExternalFenceProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C7F81;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalFenceProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalFenceProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalFenceProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalFenceProperties.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "externalFenceFeatures": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    },
  
});

VkExternalFenceProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C7F81;
};

VkExternalFenceProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalFenceProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalFenceProperties.byteLength = 0x20;

VkExternalFenceProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  externalFenceFeatures: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkExternalFencePropertiesKHR **/
function VkExternalFencePropertiesKHR(opts) {
  if (new.target !== VkExternalFencePropertiesKHR) {
    _VkExternalFencePropertiesKHR.reset();
    return _VkExternalFencePropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C7F81;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalFencePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalFencePropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExternalFencePropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalFencePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "externalFenceFeatures": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    },
  
});

VkExternalFencePropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C7F81;
};

VkExternalFencePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalFencePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalFencePropertiesKHR.byteLength = 0x20;

VkExternalFencePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  compatibleHandleTypes: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  externalFenceFeatures: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkExportFenceCreateInfo **/
function VkExportFenceCreateInfo(opts) {
  if (new.target !== VkExportFenceCreateInfo) {
    _VkExportFenceCreateInfo.reset();
    return _VkExportFenceCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C8368;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportFenceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportFenceCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportFenceCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfo.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportFenceCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C8368;
};

VkExportFenceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportFenceCreateInfo.byteLength = 0x18;

VkExportFenceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkExportFenceCreateInfoKHR **/
function VkExportFenceCreateInfoKHR(opts) {
  if (new.target !== VkExportFenceCreateInfoKHR) {
    _VkExportFenceCreateInfoKHR.reset();
    return _VkExportFenceCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C8368;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportFenceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportFenceCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportFenceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfoKHR.handleTypes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkExportFenceCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C8368;
};

VkExportFenceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportFenceCreateInfoKHR.byteLength = 0x18;

VkExportFenceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleTypes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImportFenceWin32HandleInfoKHR **/
function VkImportFenceWin32HandleInfoKHR(opts) {
  if (new.target !== VkImportFenceWin32HandleInfoKHR) {
    _VkImportFenceWin32HandleInfoKHR.reset();
    return _VkImportFenceWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this._name = null;
  this.sType = 0x3B9C8750;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkImportFenceWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportFenceWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportFenceWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "handle": {
    get() {
    return this.memoryViewBigInt64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.handle': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x4] = BigInt(value);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(this._name);
    } else if (value === null) {
      this._name = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.name': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImportFenceWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this._name = null;
  this.sType = 0x3B9C8750;
};

VkImportFenceWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportFenceWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportFenceWin32HandleInfoKHR.byteLength = 0x30;

VkImportFenceWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fence: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  handleType: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  handle: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  name: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkExportFenceWin32HandleInfoKHR **/
function VkExportFenceWin32HandleInfoKHR(opts) {
  if (new.target !== VkExportFenceWin32HandleInfoKHR) {
    _VkExportFenceWin32HandleInfoKHR.reset();
    return _VkExportFenceWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._name = null;
  this.sType = 0x3B9C8751;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkExportFenceWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkExportFenceWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportFenceWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._name);
    } else if (value === null) {
      this._name = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkExportFenceWin32HandleInfoKHR.name': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkExportFenceWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._name = null;
  this.sType = 0x3B9C8751;
};

VkExportFenceWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportFenceWin32HandleInfoKHR.byteLength = 0x28;

VkExportFenceWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  name: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkFenceGetWin32HandleInfoKHR **/
function VkFenceGetWin32HandleInfoKHR(opts) {
  if (new.target !== VkFenceGetWin32HandleInfoKHR) {
    _VkFenceGetWin32HandleInfoKHR.reset();
    return _VkFenceGetWin32HandleInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = 0x3B9C8752;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkFenceGetWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceGetWin32HandleInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFenceGetWin32HandleInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFenceGetWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFenceGetWin32HandleInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceGetWin32HandleInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkFenceGetWin32HandleInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = 0x3B9C8752;
};

VkFenceGetWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceGetWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkFenceGetWin32HandleInfoKHR.byteLength = 0x20;

VkFenceGetWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fence: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkImportFenceFdInfoKHR **/
function VkImportFenceFdInfoKHR(opts) {
  if (new.target !== VkImportFenceFdInfoKHR) {
    _VkImportFenceFdInfoKHR.reset();
    return _VkImportFenceFdInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this.sType = 0x3B9C8B38;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

Object.defineProperties(VkImportFenceFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportFenceFdInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportFenceFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "fd": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.fd': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkImportFenceFdInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this.sType = 0x3B9C8B38;
};

VkImportFenceFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportFenceFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportFenceFdInfoKHR.byteLength = 0x28;

VkImportFenceFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fence: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  handleType: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  fd: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkFenceGetFdInfoKHR **/
function VkFenceGetFdInfoKHR(opts) {
  if (new.target !== VkFenceGetFdInfoKHR) {
    _VkFenceGetFdInfoKHR.reset();
    return _VkFenceGetFdInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = 0x3B9C8B39;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkFenceGetFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFenceGetFdInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFenceGetFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkFenceGetFdInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = 0x3B9C8B39;
};

VkFenceGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkFenceGetFdInfoKHR.byteLength = 0x20;

VkFenceGetFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fence: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceMultiviewFeatures **/
function VkPhysicalDeviceMultiviewFeatures(opts) {
  if (new.target !== VkPhysicalDeviceMultiviewFeatures) {
    _VkPhysicalDeviceMultiviewFeatures.reset();
    return _VkPhysicalDeviceMultiviewFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9B9909;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMultiviewFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewFeatures.pNext' isn't allowed to be filled");
    }
    },
  "multiview": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "multiviewGeometryShader": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "multiviewTessellationShader": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDeviceMultiviewFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9B9909;
};

VkPhysicalDeviceMultiviewFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMultiviewFeatures.byteLength = 0x20;

VkPhysicalDeviceMultiviewFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  multiview: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  multiviewGeometryShader: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  multiviewTessellationShader: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceMultiviewFeaturesKHR **/
function VkPhysicalDeviceMultiviewFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceMultiviewFeaturesKHR) {
    _VkPhysicalDeviceMultiviewFeaturesKHR.reset();
    return _VkPhysicalDeviceMultiviewFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9B9909;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMultiviewFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "multiview": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "multiviewGeometryShader": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "multiviewTessellationShader": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9B9909;
};

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMultiviewFeaturesKHR.byteLength = 0x20;

VkPhysicalDeviceMultiviewFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  multiview: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  multiviewGeometryShader: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  multiviewTessellationShader: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceMultiviewProperties **/
function VkPhysicalDeviceMultiviewProperties(opts) {
  if (new.target !== VkPhysicalDeviceMultiviewProperties) {
    _VkPhysicalDeviceMultiviewProperties.reset();
    return _VkPhysicalDeviceMultiviewProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B990A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMultiviewProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewProperties.pNext' isn't allowed to be filled");
    }
    },
  "maxMultiviewViewCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxMultiviewInstanceIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  
});

VkPhysicalDeviceMultiviewProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B990A;
};

VkPhysicalDeviceMultiviewProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceMultiviewProperties.byteLength = 0x18;

VkPhysicalDeviceMultiviewProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxMultiviewViewCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxMultiviewInstanceIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceMultiviewPropertiesKHR **/
function VkPhysicalDeviceMultiviewPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceMultiviewPropertiesKHR) {
    _VkPhysicalDeviceMultiviewPropertiesKHR.reset();
    return _VkPhysicalDeviceMultiviewPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B990A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMultiviewPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxMultiviewViewCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxMultiviewInstanceIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  
});

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B990A;
};

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceMultiviewPropertiesKHR.byteLength = 0x18;

VkPhysicalDeviceMultiviewPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxMultiviewViewCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxMultiviewInstanceIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkRenderPassMultiviewCreateInfo **/
function VkRenderPassMultiviewCreateInfo(opts) {
  if (new.target !== VkRenderPassMultiviewCreateInfo) {
    _VkRenderPassMultiviewCreateInfo.reset();
    return _VkRenderPassMultiviewCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = 0x3B9B9908;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
    if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
    if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
    
  }
};

Object.defineProperties(VkRenderPassMultiviewCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassMultiviewCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassMultiviewCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "subpassCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.subpassCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pViewMasks": {
    get() {
    return this._pViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pViewMasks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewMasks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.dependencyCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pViewOffsets": {
    get() {
    return this._pViewOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewOffsets = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewOffsets = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pViewOffsets': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "correlationMaskCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.correlationMaskCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pCorrelationMasks": {
    get() {
    return this._pCorrelationMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelationMasks = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCorrelationMasks = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pCorrelationMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassMultiviewCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = 0x3B9B9908;
};

VkRenderPassMultiviewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassMultiviewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkRenderPassMultiviewCreateInfo.byteLength = 0x40;

VkRenderPassMultiviewCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  subpassCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pViewMasks: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  dependencyCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pViewOffsets: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  correlationMaskCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pCorrelationMasks: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkRenderPassMultiviewCreateInfoKHR **/
function VkRenderPassMultiviewCreateInfoKHR(opts) {
  if (new.target !== VkRenderPassMultiviewCreateInfoKHR) {
    _VkRenderPassMultiviewCreateInfoKHR.reset();
    return _VkRenderPassMultiviewCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = 0x3B9B9908;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
    if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
    if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
    
  }
};

Object.defineProperties(VkRenderPassMultiviewCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassMultiviewCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassMultiviewCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "subpassCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.subpassCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pViewMasks": {
    get() {
    return this._pViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pViewMasks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewMasks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.dependencyCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pViewOffsets": {
    get() {
    return this._pViewOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewOffsets = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewOffsets = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pViewOffsets': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "correlationMaskCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.correlationMaskCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pCorrelationMasks": {
    get() {
    return this._pCorrelationMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelationMasks = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCorrelationMasks = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pCorrelationMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassMultiviewCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = 0x3B9B9908;
};

VkRenderPassMultiviewCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassMultiviewCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkRenderPassMultiviewCreateInfoKHR.byteLength = 0x40;

VkRenderPassMultiviewCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  subpassCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pViewMasks: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  dependencyCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pViewOffsets: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  correlationMaskCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pCorrelationMasks: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkSurfaceCapabilities2EXT **/
function VkSurfaceCapabilities2EXT(opts) {
  if (new.target !== VkSurfaceCapabilities2EXT) {
    _VkSurfaceCapabilities2EXT.reset();
    return _VkSurfaceCapabilities2EXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x20 });
  this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x28 });
  
  
  
  
  
  
  this.sType = 0x3B9C2990;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceCapabilities2EXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2EXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceCapabilities2EXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceCapabilities2EXT.pNext' isn't allowed to be filled");
    }
    },
  "minImageCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxImageCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "currentExtent": {
    get() {
    return this._currentExtent;
    },
    },
  "minImageExtent": {
    get() {
    return this._minImageExtent;
    },
    },
  "maxImageExtent": {
    get() {
    return this._maxImageExtent;
    },
    },
  "maxImageArrayLayers": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    },
  "supportedTransforms": {
    get() {
    return this.memoryViewInt32[0xD];
    },
    },
  "currentTransform": {
    get() {
    return this.memoryViewInt32[0xE];
    },
    },
  "supportedCompositeAlpha": {
    get() {
    return this.memoryViewInt32[0xF];
    },
    },
  "supportedUsageFlags": {
    get() {
    return this.memoryViewInt32[0x10];
    },
    },
  "supportedSurfaceCounters": {
    get() {
    return this.memoryViewInt32[0x11];
    },
    },
  
});

VkSurfaceCapabilities2EXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  
  this._currentExtent = null;
  this._minImageExtent = null;
  this._maxImageExtent = null;
  
  
  
  
  
  
  this.sType = 0x3B9C2990;
};

VkSurfaceCapabilities2EXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilities2EXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
  
  
  
  
  
  
};

VkSurfaceCapabilities2EXT.byteLength = 0x48;

VkSurfaceCapabilities2EXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  minImageCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxImageCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  currentExtent: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  minImageExtent: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  maxImageExtent: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  maxImageArrayLayers: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  supportedTransforms: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  currentTransform: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  supportedCompositeAlpha: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  supportedUsageFlags: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  supportedSurfaceCounters: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
};
/** VkDisplayPowerInfoEXT **/
function VkDisplayPowerInfoEXT(opts) {
  if (new.target !== VkDisplayPowerInfoEXT) {
    _VkDisplayPowerInfoEXT.reset();
    return _VkDisplayPowerInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D78;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.powerState !== void 0) this.powerState = opts.powerState;
    
  }
};

Object.defineProperties(VkDisplayPowerInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPowerInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayPowerInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPowerInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "powerState": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPowerInfoEXT.powerState': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDisplayPowerStateEXT(value)) {
      throw new RangeError("Invalid value for 'VkDisplayPowerInfoEXT.powerState': '" + value + "' is not a value of 'VkDisplayPowerStateEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDisplayPowerInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D78;
};

VkDisplayPowerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPowerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayPowerInfoEXT.byteLength = 0x18;

VkDisplayPowerInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  powerState: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDeviceEventInfoEXT **/
function VkDeviceEventInfoEXT(opts) {
  if (new.target !== VkDeviceEventInfoEXT) {
    _VkDeviceEventInfoEXT.reset();
    return _VkDeviceEventInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D79;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceEvent !== void 0) this.deviceEvent = opts.deviceEvent;
    
  }
};

Object.defineProperties(VkDeviceEventInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceEventInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceEventInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceEventInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "deviceEvent": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceEventInfoEXT.deviceEvent': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDeviceEventTypeEXT(value)) {
      throw new RangeError("Invalid value for 'VkDeviceEventInfoEXT.deviceEvent': '" + value + "' is not a value of 'VkDeviceEventTypeEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDeviceEventInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D79;
};

VkDeviceEventInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceEventInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceEventInfoEXT.byteLength = 0x18;

VkDeviceEventInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceEvent: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDisplayEventInfoEXT **/
function VkDisplayEventInfoEXT(opts) {
  if (new.target !== VkDisplayEventInfoEXT) {
    _VkDisplayEventInfoEXT.reset();
    return _VkDisplayEventInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D7A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.displayEvent !== void 0) this.displayEvent = opts.displayEvent;
    
  }
};

Object.defineProperties(VkDisplayEventInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayEventInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayEventInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayEventInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "displayEvent": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayEventInfoEXT.displayEvent': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDisplayEventTypeEXT(value)) {
      throw new RangeError("Invalid value for 'VkDisplayEventInfoEXT.displayEvent': '" + value + "' is not a value of 'VkDisplayEventTypeEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDisplayEventInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D7A;
};

VkDisplayEventInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayEventInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayEventInfoEXT.byteLength = 0x18;

VkDisplayEventInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  displayEvent: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSwapchainCounterCreateInfoEXT **/
function VkSwapchainCounterCreateInfoEXT(opts) {
  if (new.target !== VkSwapchainCounterCreateInfoEXT) {
    _VkSwapchainCounterCreateInfoEXT.reset();
    return _VkSwapchainCounterCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D7B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.surfaceCounters !== void 0) this.surfaceCounters = opts.surfaceCounters;
    
  }
};

Object.defineProperties(VkSwapchainCounterCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCounterCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainCounterCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSwapchainCounterCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "surfaceCounters": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCounterCreateInfoEXT.surfaceCounters': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkSwapchainCounterCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C2D7B;
};

VkSwapchainCounterCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSwapchainCounterCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSwapchainCounterCreateInfoEXT.byteLength = 0x18;

VkSwapchainCounterCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  surfaceCounters: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceGroupProperties **/
function VkPhysicalDeviceGroupProperties(opts) {
  if (new.target !== VkPhysicalDeviceGroupProperties) {
    _VkPhysicalDeviceGroupProperties.reset();
    return _VkPhysicalDeviceGroupProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x120) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x120) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x120);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._physicalDevices = null;
  
  this.sType = 0x3B9BDB70;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceGroupProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceGroupProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceGroupProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceGroupProperties.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "physicalDevices": {
    get() {
    return this._physicalDevices;
    },
    },
  "subsetAllocation": {
    get() {
    return this.memoryViewUint32[0x46] !== 0;
    },
    },
  
});

VkPhysicalDeviceGroupProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x120], 0x0);
  
  this._pNext = null;
  
  this._physicalDevices = null;
  
  this.sType = 0x3B9BDB70;
};

VkPhysicalDeviceGroupProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceGroupProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x120));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x120), 0x0);
  
  
  
  
};

VkPhysicalDeviceGroupProperties.byteLength = 0x120;

VkPhysicalDeviceGroupProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  physicalDeviceCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  physicalDevices: {
    byteOffset: 0x18,
    byteLength: 0x100
  },
  subsetAllocation: {
    byteOffset: 0x118,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceGroupPropertiesKHR **/
function VkPhysicalDeviceGroupPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceGroupPropertiesKHR) {
    _VkPhysicalDeviceGroupPropertiesKHR.reset();
    return _VkPhysicalDeviceGroupPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x120) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x120) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x120);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._physicalDevices = null;
  
  this.sType = 0x3B9BDB70;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceGroupPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceGroupPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceGroupPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceGroupPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "physicalDevices": {
    get() {
    return this._physicalDevices;
    },
    },
  "subsetAllocation": {
    get() {
    return this.memoryViewUint32[0x46] !== 0;
    },
    },
  
});

VkPhysicalDeviceGroupPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x120], 0x0);
  
  this._pNext = null;
  
  this._physicalDevices = null;
  
  this.sType = 0x3B9BDB70;
};

VkPhysicalDeviceGroupPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceGroupPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x120));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x120), 0x0);
  
  
  
  
};

VkPhysicalDeviceGroupPropertiesKHR.byteLength = 0x120;

VkPhysicalDeviceGroupPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  physicalDeviceCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  physicalDevices: {
    byteOffset: 0x18,
    byteLength: 0x100
  },
  subsetAllocation: {
    byteOffset: 0x118,
    byteLength: 0x4
  },
};
/** VkMemoryAllocateFlagsInfo **/
function VkMemoryAllocateFlagsInfo(opts) {
  if (new.target !== VkMemoryAllocateFlagsInfo) {
    _VkMemoryAllocateFlagsInfo.reset();
    return _VkMemoryAllocateFlagsInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB460;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkMemoryAllocateFlagsInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryAllocateFlagsInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryAllocateFlagsInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfo.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkMemoryAllocateFlagsInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB460;
};

VkMemoryAllocateFlagsInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateFlagsInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryAllocateFlagsInfo.byteLength = 0x18;

VkMemoryAllocateFlagsInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  deviceMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkMemoryAllocateFlagsInfoKHR **/
function VkMemoryAllocateFlagsInfoKHR(opts) {
  if (new.target !== VkMemoryAllocateFlagsInfoKHR) {
    _VkMemoryAllocateFlagsInfoKHR.reset();
    return _VkMemoryAllocateFlagsInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB460;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkMemoryAllocateFlagsInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryAllocateFlagsInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryAllocateFlagsInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfoKHR.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkMemoryAllocateFlagsInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB460;
};

VkMemoryAllocateFlagsInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateFlagsInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryAllocateFlagsInfoKHR.byteLength = 0x18;

VkMemoryAllocateFlagsInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  deviceMask: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkBindBufferMemoryInfo **/
function VkBindBufferMemoryInfo(opts) {
  if (new.target !== VkBindBufferMemoryInfo) {
    _VkBindBufferMemoryInfo.reset();
    return _VkBindBufferMemoryInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F48;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindBufferMemoryInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindBufferMemoryInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB46D:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  
});

VkBindBufferMemoryInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F48;
};

VkBindBufferMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryInfo.byteLength = 0x28;

VkBindBufferMemoryInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkBindBufferMemoryInfoKHR **/
function VkBindBufferMemoryInfoKHR(opts) {
  if (new.target !== VkBindBufferMemoryInfoKHR) {
    _VkBindBufferMemoryInfoKHR.reset();
    return _VkBindBufferMemoryInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F48;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindBufferMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindBufferMemoryInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9BB46D:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  
});

VkBindBufferMemoryInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F48;
};

VkBindBufferMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryInfoKHR.byteLength = 0x28;

VkBindBufferMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkBindBufferMemoryDeviceGroupInfo **/
function VkBindBufferMemoryDeviceGroupInfo(opts) {
  if (new.target !== VkBindBufferMemoryDeviceGroupInfo) {
    _VkBindBufferMemoryDeviceGroupInfo.reset();
    return _VkBindBufferMemoryDeviceGroupInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = 0x3B9BB46D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

Object.defineProperties(VkBindBufferMemoryDeviceGroupInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindBufferMemoryDeviceGroupInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindBufferMemoryDeviceGroupInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.deviceIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBindBufferMemoryDeviceGroupInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = 0x3B9BB46D;
};

VkBindBufferMemoryDeviceGroupInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryDeviceGroupInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryDeviceGroupInfo.byteLength = 0x20;

VkBindBufferMemoryDeviceGroupInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceIndexCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDeviceIndices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkBindBufferMemoryDeviceGroupInfoKHR **/
function VkBindBufferMemoryDeviceGroupInfoKHR(opts) {
  if (new.target !== VkBindBufferMemoryDeviceGroupInfoKHR) {
    _VkBindBufferMemoryDeviceGroupInfoKHR.reset();
    return _VkBindBufferMemoryDeviceGroupInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = 0x3B9BB46D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

Object.defineProperties(VkBindBufferMemoryDeviceGroupInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindBufferMemoryDeviceGroupInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindBufferMemoryDeviceGroupInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.deviceIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = 0x3B9BB46D;
};

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryDeviceGroupInfoKHR.byteLength = 0x20;

VkBindBufferMemoryDeviceGroupInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceIndexCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDeviceIndices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkBindImageMemoryInfo **/
function VkBindImageMemoryInfo(opts) {
  if (new.target !== VkBindImageMemoryInfo) {
    _VkBindImageMemoryInfo.reset();
    return _VkBindImageMemoryInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F49;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindImageMemoryInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImageMemoryInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB46E:
        case 0x3B9BB469:
        case 0x3B9D2B62:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  
});

VkBindImageMemoryInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F49;
};

VkBindImageMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImageMemoryInfo.byteLength = 0x28;

VkBindImageMemoryInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkBindImageMemoryInfoKHR **/
function VkBindImageMemoryInfoKHR(opts) {
  if (new.target !== VkBindImageMemoryInfoKHR) {
    _VkBindImageMemoryInfoKHR.reset();
    return _VkBindImageMemoryInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F49;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindImageMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImageMemoryInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9BB46E:
        case 0x3B9BB469:
        case 0x3B9D2B62:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  
});

VkBindImageMemoryInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = 0x3B9D2F49;
};

VkBindImageMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImageMemoryInfoKHR.byteLength = 0x28;

VkBindImageMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkBindImageMemoryDeviceGroupInfo **/
function VkBindImageMemoryDeviceGroupInfo(opts) {
  if (new.target !== VkBindImageMemoryDeviceGroupInfo) {
    _VkBindImageMemoryDeviceGroupInfo.reset();
    return _VkBindImageMemoryDeviceGroupInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
    this._pSplitInstanceBindRegionsNative = null;
  this.sType = 0x3B9BB46E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
    if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
    
  }
};

Object.defineProperties(VkBindImageMemoryDeviceGroupInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImageMemoryDeviceGroupInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImageMemoryDeviceGroupInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.deviceIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "splitInstanceBindRegionCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.splitInstanceBindRegionCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pSplitInstanceBindRegions": {
    get() {
    return this._pSplitInstanceBindRegions;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSplitInstanceBindRegions = value;
    } else if (value === null) {
      this._pSplitInstanceBindRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkBindImageMemoryDeviceGroupInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
    this._pSplitInstanceBindRegionsNative = null;
  this.sType = 0x3B9BB46E;
};

VkBindImageMemoryDeviceGroupInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSplitInstanceBindRegions !== null) {
    let array = this._pSplitInstanceBindRegions;
    
    if (array.length !== this.splitInstanceBindRegionCount) {
      throw new RangeError("Invalid array length, expected length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSplitInstanceBindRegionsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pSplitInstanceBindRegionsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkBindImageMemoryDeviceGroupInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkBindImageMemoryDeviceGroupInfo.byteLength = 0x30;

VkBindImageMemoryDeviceGroupInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceIndexCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDeviceIndices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  splitInstanceBindRegionCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pSplitInstanceBindRegions: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkBindImageMemoryDeviceGroupInfoKHR **/
function VkBindImageMemoryDeviceGroupInfoKHR(opts) {
  if (new.target !== VkBindImageMemoryDeviceGroupInfoKHR) {
    _VkBindImageMemoryDeviceGroupInfoKHR.reset();
    return _VkBindImageMemoryDeviceGroupInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
    this._pSplitInstanceBindRegionsNative = null;
  this.sType = 0x3B9BB46E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
    if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
    
  }
};

Object.defineProperties(VkBindImageMemoryDeviceGroupInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImageMemoryDeviceGroupInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImageMemoryDeviceGroupInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.deviceIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "splitInstanceBindRegionCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.splitInstanceBindRegionCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pSplitInstanceBindRegions": {
    get() {
    return this._pSplitInstanceBindRegions;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSplitInstanceBindRegions = value;
    } else if (value === null) {
      this._pSplitInstanceBindRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkBindImageMemoryDeviceGroupInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
    this._pSplitInstanceBindRegionsNative = null;
  this.sType = 0x3B9BB46E;
};

VkBindImageMemoryDeviceGroupInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSplitInstanceBindRegions !== null) {
    let array = this._pSplitInstanceBindRegions;
    
    if (array.length !== this.splitInstanceBindRegionCount) {
      throw new RangeError("Invalid array length, expected length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSplitInstanceBindRegionsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pSplitInstanceBindRegionsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkBindImageMemoryDeviceGroupInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkBindImageMemoryDeviceGroupInfoKHR.byteLength = 0x30;

VkBindImageMemoryDeviceGroupInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceIndexCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDeviceIndices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  splitInstanceBindRegionCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pSplitInstanceBindRegions: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkDeviceGroupRenderPassBeginInfo **/
function VkDeviceGroupRenderPassBeginInfo(opts) {
  if (new.target !== VkDeviceGroupRenderPassBeginInfo) {
    _VkDeviceGroupRenderPassBeginInfo.reset();
    return _VkDeviceGroupRenderPassBeginInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
    this._pDeviceRenderAreasNative = null;
  this.sType = 0x3B9BB463;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
    if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
    
  }
};

Object.defineProperties(VkDeviceGroupRenderPassBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupRenderPassBeginInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupRenderPassBeginInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "deviceRenderAreaCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.deviceRenderAreaCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pDeviceRenderAreas": {
    get() {
    return this._pDeviceRenderAreas;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDeviceRenderAreas = value;
    } else if (value === null) {
      this._pDeviceRenderAreas = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupRenderPassBeginInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
    this._pDeviceRenderAreasNative = null;
  this.sType = 0x3B9BB463;
};

VkDeviceGroupRenderPassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDeviceRenderAreas !== null) {
    let array = this._pDeviceRenderAreas;
    
    if (array.length !== this.deviceRenderAreaCount) {
      throw new RangeError("Invalid array length, expected length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDeviceRenderAreasNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pDeviceRenderAreasNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDeviceGroupRenderPassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupRenderPassBeginInfo.byteLength = 0x20;

VkDeviceGroupRenderPassBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  deviceRenderAreaCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pDeviceRenderAreas: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDeviceGroupRenderPassBeginInfoKHR **/
function VkDeviceGroupRenderPassBeginInfoKHR(opts) {
  if (new.target !== VkDeviceGroupRenderPassBeginInfoKHR) {
    _VkDeviceGroupRenderPassBeginInfoKHR.reset();
    return _VkDeviceGroupRenderPassBeginInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
    this._pDeviceRenderAreasNative = null;
  this.sType = 0x3B9BB463;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
    if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
    
  }
};

Object.defineProperties(VkDeviceGroupRenderPassBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupRenderPassBeginInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupRenderPassBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "deviceRenderAreaCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.deviceRenderAreaCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pDeviceRenderAreas": {
    get() {
    return this._pDeviceRenderAreas;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDeviceRenderAreas = value;
    } else if (value === null) {
      this._pDeviceRenderAreas = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupRenderPassBeginInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
    this._pDeviceRenderAreasNative = null;
  this.sType = 0x3B9BB463;
};

VkDeviceGroupRenderPassBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDeviceRenderAreas !== null) {
    let array = this._pDeviceRenderAreas;
    
    if (array.length !== this.deviceRenderAreaCount) {
      throw new RangeError("Invalid array length, expected length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDeviceRenderAreasNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pDeviceRenderAreasNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDeviceGroupRenderPassBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupRenderPassBeginInfoKHR.byteLength = 0x20;

VkDeviceGroupRenderPassBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  deviceRenderAreaCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pDeviceRenderAreas: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDeviceGroupCommandBufferBeginInfo **/
function VkDeviceGroupCommandBufferBeginInfo(opts) {
  if (new.target !== VkDeviceGroupCommandBufferBeginInfo) {
    _VkDeviceGroupCommandBufferBeginInfo.reset();
    return _VkDeviceGroupCommandBufferBeginInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BB464;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkDeviceGroupCommandBufferBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupCommandBufferBeginInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupCommandBufferBeginInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfo.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkDeviceGroupCommandBufferBeginInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BB464;
};

VkDeviceGroupCommandBufferBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupCommandBufferBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupCommandBufferBeginInfo.byteLength = 0x18;

VkDeviceGroupCommandBufferBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDeviceGroupCommandBufferBeginInfoKHR **/
function VkDeviceGroupCommandBufferBeginInfoKHR(opts) {
  if (new.target !== VkDeviceGroupCommandBufferBeginInfoKHR) {
    _VkDeviceGroupCommandBufferBeginInfoKHR.reset();
    return _VkDeviceGroupCommandBufferBeginInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BB464;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkDeviceGroupCommandBufferBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupCommandBufferBeginInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupCommandBufferBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfoKHR.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BB464;
};

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupCommandBufferBeginInfoKHR.byteLength = 0x18;

VkDeviceGroupCommandBufferBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDeviceGroupSubmitInfo **/
function VkDeviceGroupSubmitInfo(opts) {
  if (new.target !== VkDeviceGroupSubmitInfo) {
    _VkDeviceGroupSubmitInfo.reset();
    return _VkDeviceGroupSubmitInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = 0x3B9BB465;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
    
  }
};

Object.defineProperties(VkDeviceGroupSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupSubmitInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupSubmitInfo.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.waitSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pWaitSemaphoreDeviceIndices": {
    get() {
    return this._pWaitSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pWaitSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.commandBufferCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pCommandBufferDeviceMasks": {
    get() {
    return this._pCommandBufferDeviceMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCommandBufferDeviceMasks = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCommandBufferDeviceMasks = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.signalSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pSignalSemaphoreDeviceIndices": {
    get() {
    return this._pSignalSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSignalSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSignalSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceGroupSubmitInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = 0x3B9BB465;
};

VkDeviceGroupSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupSubmitInfo.byteLength = 0x40;

VkDeviceGroupSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  waitSemaphoreCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pWaitSemaphoreDeviceIndices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  commandBufferCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pCommandBufferDeviceMasks: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  signalSemaphoreCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pSignalSemaphoreDeviceIndices: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkDeviceGroupSubmitInfoKHR **/
function VkDeviceGroupSubmitInfoKHR(opts) {
  if (new.target !== VkDeviceGroupSubmitInfoKHR) {
    _VkDeviceGroupSubmitInfoKHR.reset();
    return _VkDeviceGroupSubmitInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = 0x3B9BB465;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
    
  }
};

Object.defineProperties(VkDeviceGroupSubmitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupSubmitInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupSubmitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.waitSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pWaitSemaphoreDeviceIndices": {
    get() {
    return this._pWaitSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pWaitSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pWaitSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.commandBufferCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pCommandBufferDeviceMasks": {
    get() {
    return this._pCommandBufferDeviceMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCommandBufferDeviceMasks = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCommandBufferDeviceMasks = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pCommandBufferDeviceMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.signalSemaphoreCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pSignalSemaphoreDeviceIndices": {
    get() {
    return this._pSignalSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSignalSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSignalSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pSignalSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceGroupSubmitInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = 0x3B9BB465;
};

VkDeviceGroupSubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupSubmitInfoKHR.byteLength = 0x40;

VkDeviceGroupSubmitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  waitSemaphoreCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pWaitSemaphoreDeviceIndices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  commandBufferCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pCommandBufferDeviceMasks: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  signalSemaphoreCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pSignalSemaphoreDeviceIndices: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
};
/** VkDeviceGroupBindSparseInfo **/
function VkDeviceGroupBindSparseInfo(opts) {
  if (new.target !== VkDeviceGroupBindSparseInfo) {
    _VkDeviceGroupBindSparseInfo.reset();
    return _VkDeviceGroupBindSparseInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB466;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
    if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
    
  }
};

Object.defineProperties(VkDeviceGroupBindSparseInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupBindSparseInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupBindSparseInfo.pNext' isn't allowed to be filled");
    }
    },
  "resourceDeviceIndex": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfo.resourceDeviceIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "memoryDeviceIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfo.memoryDeviceIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkDeviceGroupBindSparseInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB466;
};

VkDeviceGroupBindSparseInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupBindSparseInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupBindSparseInfo.byteLength = 0x18;

VkDeviceGroupBindSparseInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  resourceDeviceIndex: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  memoryDeviceIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkDeviceGroupBindSparseInfoKHR **/
function VkDeviceGroupBindSparseInfoKHR(opts) {
  if (new.target !== VkDeviceGroupBindSparseInfoKHR) {
    _VkDeviceGroupBindSparseInfoKHR.reset();
    return _VkDeviceGroupBindSparseInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB466;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
    if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
    
  }
};

Object.defineProperties(VkDeviceGroupBindSparseInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupBindSparseInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupBindSparseInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "resourceDeviceIndex": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfoKHR.resourceDeviceIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "memoryDeviceIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfoKHR.memoryDeviceIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkDeviceGroupBindSparseInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9BB466;
};

VkDeviceGroupBindSparseInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupBindSparseInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupBindSparseInfoKHR.byteLength = 0x18;

VkDeviceGroupBindSparseInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  resourceDeviceIndex: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  memoryDeviceIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkDeviceGroupPresentCapabilitiesKHR **/
function VkDeviceGroupPresentCapabilitiesKHR(opts) {
  if (new.target !== VkDeviceGroupPresentCapabilitiesKHR) {
    _VkDeviceGroupPresentCapabilitiesKHR.reset();
    return _VkDeviceGroupPresentCapabilitiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x98) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x98) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x98) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x98) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x98);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._presentMask = [...Array(32)].fill(0x0);
  
  this.sType = 0x3B9BB467;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDeviceGroupPresentCapabilitiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentCapabilitiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupPresentCapabilitiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupPresentCapabilitiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "presentMask": {
    get() {
    return [
      this.memoryViewUint32[0x4],
      this.memoryViewUint32[0x5],
      this.memoryViewUint32[0x6],
      this.memoryViewUint32[0x7],
      this.memoryViewUint32[0x8],
      this.memoryViewUint32[0x9],
      this.memoryViewUint32[0xA],
      this.memoryViewUint32[0xB],
      this.memoryViewUint32[0xC],
      this.memoryViewUint32[0xD],
      this.memoryViewUint32[0xE],
      this.memoryViewUint32[0xF],
      this.memoryViewUint32[0x10],
      this.memoryViewUint32[0x11],
      this.memoryViewUint32[0x12],
      this.memoryViewUint32[0x13],
      this.memoryViewUint32[0x14],
      this.memoryViewUint32[0x15],
      this.memoryViewUint32[0x16],
      this.memoryViewUint32[0x17],
      this.memoryViewUint32[0x18],
      this.memoryViewUint32[0x19],
      this.memoryViewUint32[0x1A],
      this.memoryViewUint32[0x1B],
      this.memoryViewUint32[0x1C],
      this.memoryViewUint32[0x1D],
      this.memoryViewUint32[0x1E],
      this.memoryViewUint32[0x1F],
      this.memoryViewUint32[0x20],
      this.memoryViewUint32[0x21],
      this.memoryViewUint32[0x22],
      this.memoryViewUint32[0x23]
    ];
    },
    },
  "modes": {
    get() {
    return this.memoryViewInt32[0x24];
    },
    },
  
});

VkDeviceGroupPresentCapabilitiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x98], 0x0);
  
  this._pNext = null;
  this._presentMask = null;
  
  this.sType = 0x3B9BB467;
};

VkDeviceGroupPresentCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupPresentCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x98));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x98), 0x0);
  
  
  
  
};

VkDeviceGroupPresentCapabilitiesKHR.byteLength = 0x98;

VkDeviceGroupPresentCapabilitiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  presentMask: {
    byteOffset: 0x10,
    byteLength: 0x80
  },
  modes: {
    byteOffset: 0x90,
    byteLength: 0x4
  },
};
/** VkImageSwapchainCreateInfoKHR **/
function VkImageSwapchainCreateInfoKHR(opts) {
  if (new.target !== VkImageSwapchainCreateInfoKHR) {
    _VkImageSwapchainCreateInfoKHR.reset();
    return _VkImageSwapchainCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._swapchain = null;
  this.sType = 0x3B9BB468;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    
  }
};

Object.defineProperties(VkImageSwapchainCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSwapchainCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageSwapchainCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageSwapchainCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchain": {
    get() {
    return this._swapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._swapchain = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageSwapchainCreateInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageSwapchainCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._swapchain = null;
  this.sType = 0x3B9BB468;
};

VkImageSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageSwapchainCreateInfoKHR.byteLength = 0x18;

VkImageSwapchainCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  swapchain: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkBindImageMemorySwapchainInfoKHR **/
function VkBindImageMemorySwapchainInfoKHR(opts) {
  if (new.target !== VkBindImageMemorySwapchainInfoKHR) {
    _VkBindImageMemorySwapchainInfoKHR.reset();
    return _VkBindImageMemorySwapchainInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._swapchain = null;
  
  this.sType = 0x3B9BB469;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    if (opts.imageIndex !== void 0) this.imageIndex = opts.imageIndex;
    
  }
};

Object.defineProperties(VkBindImageMemorySwapchainInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImageMemorySwapchainInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImageMemorySwapchainInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchain": {
    get() {
    return this._swapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._swapchain = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageIndex": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.imageIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  
});

VkBindImageMemorySwapchainInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._swapchain = null;
  
  this.sType = 0x3B9BB469;
};

VkBindImageMemorySwapchainInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemorySwapchainInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImageMemorySwapchainInfoKHR.byteLength = 0x20;

VkBindImageMemorySwapchainInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  swapchain: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  imageIndex: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkAcquireNextImageInfoKHR **/
function VkAcquireNextImageInfoKHR(opts) {
  if (new.target !== VkAcquireNextImageInfoKHR) {
    _VkAcquireNextImageInfoKHR.reset();
    return _VkAcquireNextImageInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._swapchain = null;
  
  this._semaphore = null;
  this._fence = null;
  
  this.sType = 0x3B9BB46A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    if (opts.timeout !== void 0) this.timeout = opts.timeout;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkAcquireNextImageInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkAcquireNextImageInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAcquireNextImageInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchain": {
    get() {
    return this._swapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._swapchain = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "timeout": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.timeout': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "deviceMask": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.deviceMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  
});

VkAcquireNextImageInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  this._swapchain = null;
  
  this._semaphore = null;
  this._fence = null;
  
  this.sType = 0x3B9BB46A;
};

VkAcquireNextImageInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAcquireNextImageInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAcquireNextImageInfoKHR.byteLength = 0x38;

VkAcquireNextImageInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  swapchain: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  timeout: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  semaphore: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  fence: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  deviceMask: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkDeviceGroupPresentInfoKHR **/
function VkDeviceGroupPresentInfoKHR(opts) {
  if (new.target !== VkDeviceGroupPresentInfoKHR) {
    _VkDeviceGroupPresentInfoKHR.reset();
    return _VkDeviceGroupPresentInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDeviceMasks = null;
  
  this.sType = 0x3B9BB46B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pDeviceMasks !== void 0) this.pDeviceMasks = opts.pDeviceMasks;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

Object.defineProperties(VkDeviceGroupPresentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupPresentInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupPresentInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.swapchainCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDeviceMasks": {
    get() {
    return this._pDeviceMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceMasks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceMasks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.pDeviceMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mode": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.mode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkDeviceGroupPresentInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  this._pDeviceMasks = null;
  
  this.sType = 0x3B9BB46B;
};

VkDeviceGroupPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupPresentInfoKHR.byteLength = 0x28;

VkDeviceGroupPresentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  swapchainCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDeviceMasks: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  mode: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkDeviceGroupDeviceCreateInfo **/
function VkDeviceGroupDeviceCreateInfo(opts) {
  if (new.target !== VkDeviceGroupDeviceCreateInfo) {
    _VkDeviceGroupDeviceCreateInfo.reset();
    return _VkDeviceGroupDeviceCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
    this._pPhysicalDevicesNative = null;
  this.sType = 0x3B9BDB71;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
    if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
    
  }
};

Object.defineProperties(VkDeviceGroupDeviceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupDeviceCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupDeviceCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.physicalDeviceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pPhysicalDevices": {
    get() {
    return this._pPhysicalDevices;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPhysicalDevices = value;
    } else if (value === null) {
      this._pPhysicalDevices = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices': Expected 'Array VkPhysicalDevice' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupDeviceCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
    this._pPhysicalDevicesNative = null;
  this.sType = 0x3B9BDB71;
};

VkDeviceGroupDeviceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPhysicalDevices !== null) {
    let array = this._pPhysicalDevices;
    
    if (array.length !== this.physicalDeviceCount) {
      throw new RangeError("Invalid array length, expected length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPhysicalDevice)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices[" + ii + "]': Expected 'VkPhysicalDevice' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPhysicalDevicesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pPhysicalDevicesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDeviceGroupDeviceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupDeviceCreateInfo.byteLength = 0x20;

VkDeviceGroupDeviceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  physicalDeviceCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pPhysicalDevices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDeviceGroupDeviceCreateInfoKHR **/
function VkDeviceGroupDeviceCreateInfoKHR(opts) {
  if (new.target !== VkDeviceGroupDeviceCreateInfoKHR) {
    _VkDeviceGroupDeviceCreateInfoKHR.reset();
    return _VkDeviceGroupDeviceCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
    this._pPhysicalDevicesNative = null;
  this.sType = 0x3B9BDB71;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
    if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
    
  }
};

Object.defineProperties(VkDeviceGroupDeviceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupDeviceCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupDeviceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.physicalDeviceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pPhysicalDevices": {
    get() {
    return this._pPhysicalDevices;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPhysicalDevices = value;
    } else if (value === null) {
      this._pPhysicalDevices = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices': Expected 'Array VkPhysicalDevice' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupDeviceCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
    this._pPhysicalDevicesNative = null;
  this.sType = 0x3B9BDB71;
};

VkDeviceGroupDeviceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPhysicalDevices !== null) {
    let array = this._pPhysicalDevices;
    
    if (array.length !== this.physicalDeviceCount) {
      throw new RangeError("Invalid array length, expected length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPhysicalDevice)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices[" + ii + "]': Expected 'VkPhysicalDevice' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPhysicalDevicesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pPhysicalDevicesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDeviceGroupDeviceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupDeviceCreateInfoKHR.byteLength = 0x20;

VkDeviceGroupDeviceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  physicalDeviceCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pPhysicalDevices: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDeviceGroupSwapchainCreateInfoKHR **/
function VkDeviceGroupSwapchainCreateInfoKHR(opts) {
  if (new.target !== VkDeviceGroupSwapchainCreateInfoKHR) {
    _VkDeviceGroupSwapchainCreateInfoKHR.reset();
    return _VkDeviceGroupSwapchainCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BB46C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.modes !== void 0) this.modes = opts.modes;
    
  }
};

Object.defineProperties(VkDeviceGroupSwapchainCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSwapchainCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceGroupSwapchainCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupSwapchainCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "modes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSwapchainCreateInfoKHR.modes': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDeviceGroupSwapchainCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BB46C;
};

VkDeviceGroupSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupSwapchainCreateInfoKHR.byteLength = 0x18;

VkDeviceGroupSwapchainCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  modes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDescriptorUpdateTemplateEntry **/
function VkDescriptorUpdateTemplateEntry(opts) {
  if (new.target !== VkDescriptorUpdateTemplateEntry) {
    _VkDescriptorUpdateTemplateEntry.reset();
    return _VkDescriptorUpdateTemplateEntry;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateEntry.prototype, {
  "dstBinding": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.dstBinding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.dstArrayElement': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.descriptorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "descriptorType": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.descriptorType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateEntry.descriptorType': '" + value + "' is not a value of 'VkDescriptorType'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigInt64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x2] = BigInt(value);
    }
    },
  "stride": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.stride': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  
});

VkDescriptorUpdateTemplateEntry.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  
  
  
  
  
  
};

VkDescriptorUpdateTemplateEntry.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorUpdateTemplateEntry.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorUpdateTemplateEntry.byteLength = 0x20;

VkDescriptorUpdateTemplateEntry.memoryLayout = {
  dstBinding: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  dstArrayElement: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  descriptorCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  descriptorType: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  stride: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorUpdateTemplateEntryKHR **/
function VkDescriptorUpdateTemplateEntryKHR(opts) {
  if (new.target !== VkDescriptorUpdateTemplateEntryKHR) {
    _VkDescriptorUpdateTemplateEntryKHR.reset();
    return _VkDescriptorUpdateTemplateEntryKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateEntryKHR.prototype, {
  "dstBinding": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.dstBinding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.dstArrayElement': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.descriptorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "descriptorType": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.descriptorType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateEntryKHR.descriptorType': '" + value + "' is not a value of 'VkDescriptorType'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigInt64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x2] = BigInt(value);
    }
    },
  "stride": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.stride': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  
});

VkDescriptorUpdateTemplateEntryKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  
  
  
  
  
  
};

VkDescriptorUpdateTemplateEntryKHR.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorUpdateTemplateEntryKHR.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorUpdateTemplateEntryKHR.byteLength = 0x20;

VkDescriptorUpdateTemplateEntryKHR.memoryLayout = {
  dstBinding: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  dstArrayElement: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  descriptorCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  descriptorType: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  stride: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorUpdateTemplateCreateInfo **/
function VkDescriptorUpdateTemplateCreateInfo(opts) {
  if (new.target !== VkDescriptorUpdateTemplateCreateInfo) {
    _VkDescriptorUpdateTemplateCreateInfo.reset();
    return _VkDescriptorUpdateTemplateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
    this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = 0x3B9C1608;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
    if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
    if (opts.templateType !== void 0) this.templateType = opts.templateType;
    if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.set !== void 0) this.set = opts.set;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorUpdateTemplateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "descriptorUpdateEntryCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.descriptorUpdateEntryCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pDescriptorUpdateEntries": {
    get() {
    return this._pDescriptorUpdateEntries;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDescriptorUpdateEntries = value;
    } else if (value === null) {
      this._pDescriptorUpdateEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries': Expected 'Array VkDescriptorUpdateTemplateEntry' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "templateType": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.templateType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorUpdateTemplateType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateCreateInfo.templateType': '" + value + "' is not a value of 'VkDescriptorUpdateTemplateType'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "descriptorSetLayout": {
    get() {
    return this._descriptorSetLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSetLayout) {
      
      this._descriptorSetLayout = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorSetLayout = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout': Expected 'VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pipelineBindPoint': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPipelineBindPoint(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateCreateInfo.pipelineBindPoint': '" + value + "' is not a value of 'VkPipelineBindPoint'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "pipelineLayout": {
    get() {
    return this._pipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "set": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.set': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  
});

VkDescriptorUpdateTemplateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
    this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = 0x3B9C1608;
};

VkDescriptorUpdateTemplateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDescriptorUpdateEntries !== null) {
    let array = this._pDescriptorUpdateEntries;
    
    if (array.length !== this.descriptorUpdateEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorUpdateTemplateEntry)) {
        throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries[" + ii + "]': Expected 'VkDescriptorUpdateTemplateEntry' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDescriptorUpdateEntriesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pDescriptorUpdateEntriesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDescriptorUpdateTemplateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorUpdateTemplateCreateInfo.byteLength = 0x48;

VkDescriptorUpdateTemplateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  descriptorUpdateEntryCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pDescriptorUpdateEntries: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  templateType: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  descriptorSetLayout: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pipelineBindPoint: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pipelineLayout: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  set: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
};
/** VkDescriptorUpdateTemplateCreateInfoKHR **/
function VkDescriptorUpdateTemplateCreateInfoKHR(opts) {
  if (new.target !== VkDescriptorUpdateTemplateCreateInfoKHR) {
    _VkDescriptorUpdateTemplateCreateInfoKHR.reset();
    return _VkDescriptorUpdateTemplateCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
    this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = 0x3B9C1608;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
    if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
    if (opts.templateType !== void 0) this.templateType = opts.templateType;
    if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.set !== void 0) this.set = opts.set;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorUpdateTemplateCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "descriptorUpdateEntryCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.descriptorUpdateEntryCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pDescriptorUpdateEntries": {
    get() {
    return this._pDescriptorUpdateEntries;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDescriptorUpdateEntries = value;
    } else if (value === null) {
      this._pDescriptorUpdateEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries': Expected 'Array VkDescriptorUpdateTemplateEntry' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "templateType": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.templateType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorUpdateTemplateType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateCreateInfoKHR.templateType': '" + value + "' is not a value of 'VkDescriptorUpdateTemplateType'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "descriptorSetLayout": {
    get() {
    return this._descriptorSetLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSetLayout) {
      
      this._descriptorSetLayout = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorSetLayout = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout': Expected 'VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPipelineBindPoint(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint': '" + value + "' is not a value of 'VkPipelineBindPoint'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "pipelineLayout": {
    get() {
    return this._pipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "set": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.set': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  
});

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
    this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = 0x3B9C1608;
};

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDescriptorUpdateEntries !== null) {
    let array = this._pDescriptorUpdateEntries;
    
    if (array.length !== this.descriptorUpdateEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorUpdateTemplateEntry)) {
        throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries[" + ii + "]': Expected 'VkDescriptorUpdateTemplateEntry' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDescriptorUpdateEntriesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pDescriptorUpdateEntriesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorUpdateTemplateCreateInfoKHR.byteLength = 0x48;

VkDescriptorUpdateTemplateCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  descriptorUpdateEntryCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pDescriptorUpdateEntries: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  templateType: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  descriptorSetLayout: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pipelineBindPoint: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pipelineLayout: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  set: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
};
/** VkXYColorEXT **/
function VkXYColorEXT(opts) {
  if (new.target !== VkXYColorEXT) {
    _VkXYColorEXT.reset();
    return _VkXYColorEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

Object.defineProperties(VkXYColorEXT.prototype, {
  "x": {
    get() {
    return this.memoryViewFloat32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkXYColorEXT.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewFloat32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkXYColorEXT.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x1] = value;
    }
    },
  
});

VkXYColorEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkXYColorEXT.prototype.flush = function flush() {
  
  return true;
};

VkXYColorEXT.prototype.reflect = function reflect(memoryAddress) {
  
};

VkXYColorEXT.byteLength = 0x8;

VkXYColorEXT.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkHdrMetadataEXT **/
function VkHdrMetadataEXT(opts) {
  if (new.target !== VkHdrMetadataEXT) {
    _VkHdrMetadataEXT.reset();
    return _VkHdrMetadataEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._displayPrimaryRed = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._displayPrimaryGreen = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  this._displayPrimaryBlue = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x20 });
  this._whitePoint = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x28 });
  
  
  
  
  this.sType = 0x3B9C6428;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.displayPrimaryRed !== void 0) this.displayPrimaryRed = opts.displayPrimaryRed;
    if (opts.displayPrimaryGreen !== void 0) this.displayPrimaryGreen = opts.displayPrimaryGreen;
    if (opts.displayPrimaryBlue !== void 0) this.displayPrimaryBlue = opts.displayPrimaryBlue;
    if (opts.whitePoint !== void 0) this.whitePoint = opts.whitePoint;
    if (opts.maxLuminance !== void 0) this.maxLuminance = opts.maxLuminance;
    if (opts.minLuminance !== void 0) this.minLuminance = opts.minLuminance;
    if (opts.maxContentLightLevel !== void 0) this.maxContentLightLevel = opts.maxContentLightLevel;
    if (opts.maxFrameAverageLightLevel !== void 0) this.maxFrameAverageLightLevel = opts.maxFrameAverageLightLevel;
    
  }
};

Object.defineProperties(VkHdrMetadataEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkHdrMetadataEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkHdrMetadataEXT.pNext' isn't allowed to be filled");
    }
    },
  "displayPrimaryRed": {
    get() {
    return this._displayPrimaryRed;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryRed = value;
      
      
    } else if (value === null) {
      this._displayPrimaryRed = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryRed': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "displayPrimaryGreen": {
    get() {
    return this._displayPrimaryGreen;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryGreen = value;
      
      
    } else if (value === null) {
      this._displayPrimaryGreen = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryGreen': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "displayPrimaryBlue": {
    get() {
    return this._displayPrimaryBlue;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryBlue = value;
      
      
    } else if (value === null) {
      this._displayPrimaryBlue = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryBlue': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "whitePoint": {
    get() {
    return this._whitePoint;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._whitePoint = value;
      
      
    } else if (value === null) {
      this._whitePoint = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.whitePoint': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "maxLuminance": {
    get() {
    return this.memoryViewFloat32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.maxLuminance': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xC] = value;
    }
    },
  "minLuminance": {
    get() {
    return this.memoryViewFloat32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.minLuminance': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xD] = value;
    }
    },
  "maxContentLightLevel": {
    get() {
    return this.memoryViewFloat32[0xE];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.maxContentLightLevel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xE] = value;
    }
    },
  "maxFrameAverageLightLevel": {
    get() {
    return this.memoryViewFloat32[0xF];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.maxFrameAverageLightLevel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0xF] = value;
    }
    },
  
});

VkHdrMetadataEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._displayPrimaryRed = null;
  this._displayPrimaryGreen = null;
  this._displayPrimaryBlue = null;
  this._whitePoint = null;
  
  
  
  
  this.sType = 0x3B9C6428;
};

VkHdrMetadataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._displayPrimaryRed !== null) {
    let displayPrimaryRed = this._displayPrimaryRed;
    displayPrimaryRed.flush();
    if (this.memoryBuffer !== displayPrimaryRed.memoryBuffer) {
      let srcView = new Uint8Array(displayPrimaryRed.memoryBuffer).subarray(displayPrimaryRed.$memoryOffset, displayPrimaryRed.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.displayPrimaryRed' isn't used as shared-memory");
    }
  }
  
  
  if (this._displayPrimaryGreen !== null) {
    let displayPrimaryGreen = this._displayPrimaryGreen;
    displayPrimaryGreen.flush();
    if (this.memoryBuffer !== displayPrimaryGreen.memoryBuffer) {
      let srcView = new Uint8Array(displayPrimaryGreen.memoryBuffer).subarray(displayPrimaryGreen.$memoryOffset, displayPrimaryGreen.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.displayPrimaryGreen' isn't used as shared-memory");
    }
  }
  
  
  if (this._displayPrimaryBlue !== null) {
    let displayPrimaryBlue = this._displayPrimaryBlue;
    displayPrimaryBlue.flush();
    if (this.memoryBuffer !== displayPrimaryBlue.memoryBuffer) {
      let srcView = new Uint8Array(displayPrimaryBlue.memoryBuffer).subarray(displayPrimaryBlue.$memoryOffset, displayPrimaryBlue.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.displayPrimaryBlue' isn't used as shared-memory");
    }
  }
  
  
  if (this._whitePoint !== null) {
    let whitePoint = this._whitePoint;
    whitePoint.flush();
    if (this.memoryBuffer !== whitePoint.memoryBuffer) {
      let srcView = new Uint8Array(whitePoint.memoryBuffer).subarray(whitePoint.$memoryOffset, whitePoint.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.whitePoint' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkHdrMetadataEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
};

VkHdrMetadataEXT.byteLength = 0x40;

VkHdrMetadataEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  displayPrimaryRed: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  displayPrimaryGreen: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  displayPrimaryBlue: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  whitePoint: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  maxLuminance: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  minLuminance: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  maxContentLightLevel: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  maxFrameAverageLightLevel: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
};
/** VkDisplayNativeHdrSurfaceCapabilitiesAMD **/
function VkDisplayNativeHdrSurfaceCapabilitiesAMD(opts) {
  if (new.target !== VkDisplayNativeHdrSurfaceCapabilitiesAMD) {
    _VkDisplayNativeHdrSurfaceCapabilitiesAMD.reset();
    return _VkDisplayNativeHdrSurfaceCapabilitiesAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E0A08;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayNativeHdrSurfaceCapabilitiesAMD.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayNativeHdrSurfaceCapabilitiesAMD.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayNativeHdrSurfaceCapabilitiesAMD.pNext' isn't allowed to be filled");
    }
    },
  "localDimmingSupport": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E0A08;
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.byteLength = 0x18;

VkDisplayNativeHdrSurfaceCapabilitiesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  localDimmingSupport: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSwapchainDisplayNativeHdrCreateInfoAMD **/
function VkSwapchainDisplayNativeHdrCreateInfoAMD(opts) {
  if (new.target !== VkSwapchainDisplayNativeHdrCreateInfoAMD) {
    _VkSwapchainDisplayNativeHdrCreateInfoAMD.reset();
    return _VkSwapchainDisplayNativeHdrCreateInfoAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E0A09;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.localDimmingEnable !== void 0) this.localDimmingEnable = opts.localDimmingEnable;
    
  }
};

Object.defineProperties(VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainDisplayNativeHdrCreateInfoAMD.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSwapchainDisplayNativeHdrCreateInfoAMD.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSwapchainDisplayNativeHdrCreateInfoAMD.pNext' isn't allowed to be filled");
    }
    },
  "localDimmingEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E0A09;
};

VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSwapchainDisplayNativeHdrCreateInfoAMD.byteLength = 0x18;

VkSwapchainDisplayNativeHdrCreateInfoAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  localDimmingEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkRefreshCycleDurationGOOGLE **/
function VkRefreshCycleDurationGOOGLE(opts) {
  if (new.target !== VkRefreshCycleDurationGOOGLE) {
    _VkRefreshCycleDurationGOOGLE.reset();
    return _VkRefreshCycleDurationGOOGLE;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x8) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkRefreshCycleDurationGOOGLE.prototype, {
  "refreshDuration": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    },
  
});

VkRefreshCycleDurationGOOGLE.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
};

VkRefreshCycleDurationGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkRefreshCycleDurationGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x8), 0x0);
};

VkRefreshCycleDurationGOOGLE.byteLength = 0x8;

VkRefreshCycleDurationGOOGLE.memoryLayout = {
  refreshDuration: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
};
/** VkPastPresentationTimingGOOGLE **/
function VkPastPresentationTimingGOOGLE(opts) {
  if (new.target !== VkPastPresentationTimingGOOGLE) {
    _VkPastPresentationTimingGOOGLE.reset();
    return _VkPastPresentationTimingGOOGLE;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPastPresentationTimingGOOGLE.prototype, {
  "presentID": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    },
  "desiredPresentTime": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    },
  "actualPresentTime": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    },
  "earliestPresentTime": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  "presentMargin": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    },
  
});

VkPastPresentationTimingGOOGLE.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  
  
  
  
  
};

VkPastPresentationTimingGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkPastPresentationTimingGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
};

VkPastPresentationTimingGOOGLE.byteLength = 0x28;

VkPastPresentationTimingGOOGLE.memoryLayout = {
  presentID: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  desiredPresentTime: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  actualPresentTime: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  earliestPresentTime: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  presentMargin: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkPresentTimesInfoGOOGLE **/
function VkPresentTimesInfoGOOGLE(opts) {
  if (new.target !== VkPresentTimesInfoGOOGLE) {
    _VkPresentTimesInfoGOOGLE.reset();
    return _VkPresentTimesInfoGOOGLE;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pTimes = null;
    this._pTimesNative = null;
  this.sType = 0x3B9C3160;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pTimes !== void 0) this.pTimes = opts.pTimes;
    
  }
};

Object.defineProperties(VkPresentTimesInfoGOOGLE.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPresentTimesInfoGOOGLE.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPresentTimesInfoGOOGLE.pNext' isn't allowed to be filled");
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.swapchainCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pTimes": {
    get() {
    return this._pTimes;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pTimes = value;
    } else if (value === null) {
      this._pTimes = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.pTimes': Expected 'Array VkPresentTimeGOOGLE' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPresentTimesInfoGOOGLE.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pTimes = null;
    this._pTimesNative = null;
  this.sType = 0x3B9C3160;
};

VkPresentTimesInfoGOOGLE.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pTimes !== null) {
    let array = this._pTimes;
    
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentTimesInfoGOOGLE.pTimes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPresentTimeGOOGLE)) {
        throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.pTimes[" + ii + "]': Expected 'VkPresentTimeGOOGLE' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pTimesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pTimesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPresentTimesInfoGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPresentTimesInfoGOOGLE.byteLength = 0x20;

VkPresentTimesInfoGOOGLE.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  swapchainCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pTimes: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPresentTimeGOOGLE **/
function VkPresentTimeGOOGLE(opts) {
  if (new.target !== VkPresentTimeGOOGLE) {
    _VkPresentTimeGOOGLE.reset();
    return _VkPresentTimeGOOGLE;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.presentID !== void 0) this.presentID = opts.presentID;
    if (opts.desiredPresentTime !== void 0) this.desiredPresentTime = opts.desiredPresentTime;
    
  }
};

Object.defineProperties(VkPresentTimeGOOGLE.prototype, {
  "presentID": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimeGOOGLE.presentID': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "desiredPresentTime": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimeGOOGLE.desiredPresentTime': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x1] = BigInt(value);
    }
    },
  
});

VkPresentTimeGOOGLE.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
};

VkPresentTimeGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkPresentTimeGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPresentTimeGOOGLE.byteLength = 0x10;

VkPresentTimeGOOGLE.memoryLayout = {
  presentID: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  desiredPresentTime: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkViewportWScalingNV **/
function VkViewportWScalingNV(opts) {
  if (new.target !== VkViewportWScalingNV) {
    _VkViewportWScalingNV.reset();
    return _VkViewportWScalingNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.xcoeff !== void 0) this.xcoeff = opts.xcoeff;
    if (opts.ycoeff !== void 0) this.ycoeff = opts.ycoeff;
    
  }
};

Object.defineProperties(VkViewportWScalingNV.prototype, {
  "xcoeff": {
    get() {
    return this.memoryViewFloat32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportWScalingNV.xcoeff': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x0] = value;
    }
    },
  "ycoeff": {
    get() {
    return this.memoryViewFloat32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportWScalingNV.ycoeff': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x1] = value;
    }
    },
  
});

VkViewportWScalingNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkViewportWScalingNV.prototype.flush = function flush() {
  
  return true;
};

VkViewportWScalingNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkViewportWScalingNV.byteLength = 0x8;

VkViewportWScalingNV.memoryLayout = {
  xcoeff: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  ycoeff: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkPipelineViewportWScalingStateCreateInfoNV **/
function VkPipelineViewportWScalingStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineViewportWScalingStateCreateInfoNV) {
    _VkPipelineViewportWScalingStateCreateInfoNV.reset();
    return _VkPipelineViewportWScalingStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pViewportWScalings = null;
    this._pViewportWScalingsNative = null;
  this.sType = 0x3B9C1DD8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewportWScalingEnable !== void 0) this.viewportWScalingEnable = opts.viewportWScalingEnable;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewportWScalings !== void 0) this.pViewportWScalings = opts.pViewportWScalings;
    
  }
};

Object.defineProperties(VkPipelineViewportWScalingStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportWScalingStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportWScalingStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "viewportWScalingEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "viewportCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.viewportCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pViewportWScalings": {
    get() {
    return this._pViewportWScalings;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewportWScalings = value;
    } else if (value === null) {
      this._pViewportWScalings = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings': Expected 'Array VkViewportWScalingNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportWScalingStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pViewportWScalings = null;
    this._pViewportWScalingsNative = null;
  this.sType = 0x3B9C1DD8;
};

VkPipelineViewportWScalingStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewportWScalings !== null) {
    let array = this._pViewportWScalings;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkViewportWScalingNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings[" + ii + "]': Expected 'VkViewportWScalingNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pViewportWScalingsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pViewportWScalingsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPipelineViewportWScalingStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportWScalingStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportWScalingStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  viewportWScalingEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  viewportCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pViewportWScalings: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkViewportSwizzleNV **/
function VkViewportSwizzleNV(opts) {
  if (new.target !== VkViewportSwizzleNV) {
    _VkViewportSwizzleNV.reset();
    return _VkViewportSwizzleNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    if (opts.w !== void 0) this.w = opts.w;
    
  }
};

Object.defineProperties(VkViewportSwizzleNV.prototype, {
  "x": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkViewportCoordinateSwizzleNV(value)) {
      throw new RangeError("Invalid value for 'VkViewportSwizzleNV.x': '" + value + "' is not a value of 'VkViewportCoordinateSwizzleNV'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewInt32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkViewportCoordinateSwizzleNV(value)) {
      throw new RangeError("Invalid value for 'VkViewportSwizzleNV.y': '" + value + "' is not a value of 'VkViewportCoordinateSwizzleNV'");
    }
    this.memoryViewInt32[0x1] = value;
    }
    },
  "z": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.z': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkViewportCoordinateSwizzleNV(value)) {
      throw new RangeError("Invalid value for 'VkViewportSwizzleNV.z': '" + value + "' is not a value of 'VkViewportCoordinateSwizzleNV'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  "w": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.w': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkViewportCoordinateSwizzleNV(value)) {
      throw new RangeError("Invalid value for 'VkViewportSwizzleNV.w': '" + value + "' is not a value of 'VkViewportCoordinateSwizzleNV'");
    }
    this.memoryViewInt32[0x3] = value;
    }
    },
  
});

VkViewportSwizzleNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
  
};

VkViewportSwizzleNV.prototype.flush = function flush() {
  
  return true;
};

VkViewportSwizzleNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkViewportSwizzleNV.byteLength = 0x10;

VkViewportSwizzleNV.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  z: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  w: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkPipelineViewportSwizzleStateCreateInfoNV **/
function VkPipelineViewportSwizzleStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineViewportSwizzleStateCreateInfoNV) {
    _VkPipelineViewportSwizzleStateCreateInfoNV.reset();
    return _VkPipelineViewportSwizzleStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pViewportSwizzles = null;
    this._pViewportSwizzlesNative = null;
  this.sType = 0x3B9C48D0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewportSwizzles !== void 0) this.pViewportSwizzles = opts.pViewportSwizzles;
    
  }
};

Object.defineProperties(VkPipelineViewportSwizzleStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportSwizzleStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportSwizzleStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "viewportCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pViewportSwizzles": {
    get() {
    return this._pViewportSwizzles;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewportSwizzles = value;
    } else if (value === null) {
      this._pViewportSwizzles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles': Expected 'Array VkViewportSwizzleNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pViewportSwizzles = null;
    this._pViewportSwizzlesNative = null;
  this.sType = 0x3B9C48D0;
};

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewportSwizzles !== null) {
    let array = this._pViewportSwizzles;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkViewportSwizzleNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles[" + ii + "]': Expected 'VkViewportSwizzleNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pViewportSwizzlesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pViewportSwizzlesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportSwizzleStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportSwizzleStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  viewportCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pViewportSwizzles: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceDiscardRectanglePropertiesEXT **/
function VkPhysicalDeviceDiscardRectanglePropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceDiscardRectanglePropertiesEXT) {
    _VkPhysicalDeviceDiscardRectanglePropertiesEXT.reset();
    return _VkPhysicalDeviceDiscardRectanglePropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C4CB8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxDiscardRectangles": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C4CB8;
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceDiscardRectanglePropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxDiscardRectangles: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineDiscardRectangleStateCreateInfoEXT **/
function VkPipelineDiscardRectangleStateCreateInfoEXT(opts) {
  if (new.target !== VkPipelineDiscardRectangleStateCreateInfoEXT) {
    _VkPipelineDiscardRectangleStateCreateInfoEXT.reset();
    return _VkPipelineDiscardRectangleStateCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._pDiscardRectangles = null;
    this._pDiscardRectanglesNative = null;
  this.sType = 0x3B9C4CB9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.discardRectangleMode !== void 0) this.discardRectangleMode = opts.discardRectangleMode;
    if (opts.discardRectangleCount !== void 0) this.discardRectangleCount = opts.discardRectangleCount;
    if (opts.pDiscardRectangles !== void 0) this.pDiscardRectangles = opts.pDiscardRectangles;
    
  }
};

Object.defineProperties(VkPipelineDiscardRectangleStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineDiscardRectangleStateCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineDiscardRectangleStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "discardRectangleMode": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDiscardRectangleModeEXT(value)) {
      throw new RangeError("Invalid value for 'VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode': '" + value + "' is not a value of 'VkDiscardRectangleModeEXT'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "discardRectangleCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pDiscardRectangles": {
    get() {
    return this._pDiscardRectangles;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDiscardRectangles = value;
    } else if (value === null) {
      this._pDiscardRectangles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  this._pDiscardRectangles = null;
    this._pDiscardRectanglesNative = null;
  this.sType = 0x3B9C4CB9;
};

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDiscardRectangles !== null) {
    let array = this._pDiscardRectangles;
    
    if (array.length !== this.discardRectangleCount) {
      throw new RangeError("Invalid array length, expected length of 'discardRectangleCount' for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDiscardRectanglesNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pDiscardRectanglesNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineDiscardRectangleStateCreateInfoEXT.byteLength = 0x28;

VkPipelineDiscardRectangleStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  discardRectangleMode: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  discardRectangleCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pDiscardRectangles: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX **/
function VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(opts) {
  if (new.target !== VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) {
    _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.reset();
    return _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C44E8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext' isn't allowed to be filled");
    }
    },
  "perViewPositionAllComponents": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C44E8;
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.byteLength = 0x18;

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  perViewPositionAllComponents: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkInputAttachmentAspectReference **/
function VkInputAttachmentAspectReference(opts) {
  if (new.target !== VkInputAttachmentAspectReference) {
    _VkInputAttachmentAspectReference.reset();
    return _VkInputAttachmentAspectReference;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkInputAttachmentAspectReference.prototype, {
  "subpass": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReference.subpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "inputAttachmentIndex": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReference.inputAttachmentIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReference.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  
});

VkInputAttachmentAspectReference.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkInputAttachmentAspectReference.prototype.flush = function flush() {
  
  return true;
};

VkInputAttachmentAspectReference.prototype.reflect = function reflect(memoryAddress) {
  
};

VkInputAttachmentAspectReference.byteLength = 0xC;

VkInputAttachmentAspectReference.memoryLayout = {
  subpass: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  inputAttachmentIndex: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  aspectMask: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkInputAttachmentAspectReferenceKHR **/
function VkInputAttachmentAspectReferenceKHR(opts) {
  if (new.target !== VkInputAttachmentAspectReferenceKHR) {
    _VkInputAttachmentAspectReferenceKHR.reset();
    return _VkInputAttachmentAspectReferenceKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkInputAttachmentAspectReferenceKHR.prototype, {
  "subpass": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReferenceKHR.subpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "inputAttachmentIndex": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReferenceKHR.inputAttachmentIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReferenceKHR.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x2] = value;
    }
    },
  
});

VkInputAttachmentAspectReferenceKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkInputAttachmentAspectReferenceKHR.prototype.flush = function flush() {
  
  return true;
};

VkInputAttachmentAspectReferenceKHR.prototype.reflect = function reflect(memoryAddress) {
  
};

VkInputAttachmentAspectReferenceKHR.byteLength = 0xC;

VkInputAttachmentAspectReferenceKHR.memoryLayout = {
  subpass: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  inputAttachmentIndex: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  aspectMask: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkRenderPassInputAttachmentAspectCreateInfo **/
function VkRenderPassInputAttachmentAspectCreateInfo(opts) {
  if (new.target !== VkRenderPassInputAttachmentAspectCreateInfo) {
    _VkRenderPassInputAttachmentAspectCreateInfo.reset();
    return _VkRenderPassInputAttachmentAspectCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAspectReferences = null;
    this._pAspectReferencesNative = null;
  this.sType = 0x3B9C9309;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
    if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
    
  }
};

Object.defineProperties(VkRenderPassInputAttachmentAspectCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassInputAttachmentAspectCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassInputAttachmentAspectCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "aspectReferenceCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.aspectReferenceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAspectReferences": {
    get() {
    return this._pAspectReferences;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAspectReferences = value;
    } else if (value === null) {
      this._pAspectReferences = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences': Expected 'Array VkInputAttachmentAspectReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassInputAttachmentAspectCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pAspectReferences = null;
    this._pAspectReferencesNative = null;
  this.sType = 0x3B9C9309;
};

VkRenderPassInputAttachmentAspectCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAspectReferences !== null) {
    let array = this._pAspectReferences;
    
    if (array.length !== this.aspectReferenceCount) {
      throw new RangeError("Invalid array length, expected length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkInputAttachmentAspectReference)) {
        throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences[" + ii + "]': Expected 'VkInputAttachmentAspectReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAspectReferencesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAspectReferencesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkRenderPassInputAttachmentAspectCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassInputAttachmentAspectCreateInfo.byteLength = 0x20;

VkRenderPassInputAttachmentAspectCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  aspectReferenceCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAspectReferences: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkRenderPassInputAttachmentAspectCreateInfoKHR **/
function VkRenderPassInputAttachmentAspectCreateInfoKHR(opts) {
  if (new.target !== VkRenderPassInputAttachmentAspectCreateInfoKHR) {
    _VkRenderPassInputAttachmentAspectCreateInfoKHR.reset();
    return _VkRenderPassInputAttachmentAspectCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAspectReferences = null;
    this._pAspectReferencesNative = null;
  this.sType = 0x3B9C9309;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
    if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
    
  }
};

Object.defineProperties(VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "aspectReferenceCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.aspectReferenceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAspectReferences": {
    get() {
    return this._pAspectReferences;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAspectReferences = value;
    } else if (value === null) {
      this._pAspectReferences = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences': Expected 'Array VkInputAttachmentAspectReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pAspectReferences = null;
    this._pAspectReferencesNative = null;
  this.sType = 0x3B9C9309;
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAspectReferences !== null) {
    let array = this._pAspectReferences;
    
    if (array.length !== this.aspectReferenceCount) {
      throw new RangeError("Invalid array length, expected length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkInputAttachmentAspectReference)) {
        throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences[" + ii + "]': Expected 'VkInputAttachmentAspectReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAspectReferencesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAspectReferencesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.byteLength = 0x20;

VkRenderPassInputAttachmentAspectCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  aspectReferenceCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAspectReferences: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceSurfaceInfo2KHR **/
function VkPhysicalDeviceSurfaceInfo2KHR(opts) {
  if (new.target !== VkPhysicalDeviceSurfaceInfo2KHR) {
    _VkPhysicalDeviceSurfaceInfo2KHR.reset();
    return _VkPhysicalDeviceSurfaceInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._surface = null;
  this.sType = 0x3B9C9AD8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.surface !== void 0) this.surface = opts.surface;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSurfaceInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSurfaceInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9EAE18:
        case 0x3B9EAE19:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.pNext'");
    }
    
    }
    },
  "surface": {
    get() {
    return this._surface;
    },
    set(value) {
    if (value !== null && value.constructor === VkSurfaceKHR) {
      
      this._surface = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._surface = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.surface': Expected 'VkSurfaceKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceSurfaceInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._surface = null;
  this.sType = 0x3B9C9AD8;
};

VkPhysicalDeviceSurfaceInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSurfaceInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSurfaceInfo2KHR.byteLength = 0x18;

VkPhysicalDeviceSurfaceInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  surface: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSurfaceCapabilities2KHR **/
function VkSurfaceCapabilities2KHR(opts) {
  if (new.target !== VkSurfaceCapabilities2KHR) {
    _VkSurfaceCapabilities2KHR.reset();
    return _VkSurfaceCapabilities2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._surfaceCapabilities = new VkSurfaceCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9C9AD9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceCapabilities2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceCapabilities2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9E0A08:
        case 0x3B9C7B98:
        case 0x3B9E6F98:
        case 0x3B9EAE1A:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
    }
    
    }
    },
  "surfaceCapabilities": {
    get() {
    return this._surfaceCapabilities;
    },
    },
  
});

VkSurfaceCapabilities2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  this._surfaceCapabilities = null;
  this.sType = 0x3B9C9AD9;
};

VkSurfaceCapabilities2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilities2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
  
  
};

VkSurfaceCapabilities2KHR.byteLength = 0x48;

VkSurfaceCapabilities2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  surfaceCapabilities: {
    byteOffset: 0x10,
    byteLength: 0x34
  },
};
/** VkSurfaceFormat2KHR **/
function VkSurfaceFormat2KHR(opts) {
  if (new.target !== VkSurfaceFormat2KHR) {
    _VkSurfaceFormat2KHR.reset();
    return _VkSurfaceFormat2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._surfaceFormat = new VkSurfaceFormatKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9C9ADA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceFormat2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceFormat2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceFormat2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceFormat2KHR.pNext' isn't allowed to be filled");
    }
    },
  "surfaceFormat": {
    get() {
    return this._surfaceFormat;
    },
    },
  
});

VkSurfaceFormat2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._surfaceFormat = null;
  this.sType = 0x3B9C9ADA;
};

VkSurfaceFormat2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFormat2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
  
  
};

VkSurfaceFormat2KHR.byteLength = 0x18;

VkSurfaceFormat2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  surfaceFormat: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkDisplayProperties2KHR **/
function VkDisplayProperties2KHR(opts) {
  if (new.target !== VkDisplayProperties2KHR) {
    _VkDisplayProperties2KHR.reset();
    return _VkDisplayProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._displayProperties = new VkDisplayPropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9CA2A8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "displayProperties": {
    get() {
    return this._displayProperties;
    },
    },
  
});

VkDisplayProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._displayProperties = null;
  this.sType = 0x3B9CA2A8;
};

VkDisplayProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
};

VkDisplayProperties2KHR.byteLength = 0x40;

VkDisplayProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  displayProperties: {
    byteOffset: 0x10,
    byteLength: 0x30
  },
};
/** VkDisplayPlaneProperties2KHR **/
function VkDisplayPlaneProperties2KHR(opts) {
  if (new.target !== VkDisplayPlaneProperties2KHR) {
    _VkDisplayPlaneProperties2KHR.reset();
    return _VkDisplayPlaneProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._displayPlaneProperties = new VkDisplayPlanePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9CA2A9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayPlaneProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayPlaneProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPlaneProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "displayPlaneProperties": {
    get() {
    return this._displayPlaneProperties;
    },
    },
  
});

VkDisplayPlaneProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._displayPlaneProperties = null;
  this.sType = 0x3B9CA2A9;
};

VkDisplayPlaneProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkDisplayPlaneProperties2KHR.byteLength = 0x20;

VkDisplayPlaneProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  displayPlaneProperties: {
    byteOffset: 0x10,
    byteLength: 0x10
  },
};
/** VkDisplayModeProperties2KHR **/
function VkDisplayModeProperties2KHR(opts) {
  if (new.target !== VkDisplayModeProperties2KHR) {
    _VkDisplayModeProperties2KHR.reset();
    return _VkDisplayModeProperties2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._displayModeProperties = new VkDisplayModePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9CA2AA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayModeProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeProperties2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayModeProperties2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayModeProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "displayModeProperties": {
    get() {
    return this._displayModeProperties;
    },
    },
  
});

VkDisplayModeProperties2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._displayModeProperties = null;
  this.sType = 0x3B9CA2AA;
};

VkDisplayModeProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayModeProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkDisplayModeProperties2KHR.byteLength = 0x28;

VkDisplayModeProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  displayModeProperties: {
    byteOffset: 0x10,
    byteLength: 0x18
  },
};
/** VkDisplayPlaneInfo2KHR **/
function VkDisplayPlaneInfo2KHR(opts) {
  if (new.target !== VkDisplayPlaneInfo2KHR) {
    _VkDisplayPlaneInfo2KHR.reset();
    return _VkDisplayPlaneInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._mode = null;
  
  this.sType = 0x3B9CA2AB;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.mode !== void 0) this.mode = opts.mode;
    if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
    
  }
};

Object.defineProperties(VkDisplayPlaneInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayPlaneInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPlaneInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "mode": {
    get() {
    return this._mode;
    },
    set(value) {
    if (value !== null && value.constructor === VkDisplayModeKHR) {
      
      this._mode = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._mode = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.mode': Expected 'VkDisplayModeKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "planeIndex": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.planeIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  
});

VkDisplayPlaneInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._mode = null;
  
  this.sType = 0x3B9CA2AB;
};

VkDisplayPlaneInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayPlaneInfo2KHR.byteLength = 0x20;

VkDisplayPlaneInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  mode: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  planeIndex: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkDisplayPlaneCapabilities2KHR **/
function VkDisplayPlaneCapabilities2KHR(opts) {
  if (new.target !== VkDisplayPlaneCapabilities2KHR) {
    _VkDisplayPlaneCapabilities2KHR.reset();
    return _VkDisplayPlaneCapabilities2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x58) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x58);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._capabilities = new VkDisplayPlaneCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9CA2AC;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayPlaneCapabilities2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneCapabilities2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDisplayPlaneCapabilities2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPlaneCapabilities2KHR.pNext' isn't allowed to be filled");
    }
    },
  "capabilities": {
    get() {
    return this._capabilities;
    },
    },
  
});

VkDisplayPlaneCapabilities2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x58], 0x0);
  
  this._pNext = null;
  this._capabilities = null;
  this.sType = 0x3B9CA2AC;
};

VkDisplayPlaneCapabilities2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneCapabilities2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x58));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x58), 0x0);
  
  
  
  
};

VkDisplayPlaneCapabilities2KHR.byteLength = 0x58;

VkDisplayPlaneCapabilities2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  capabilities: {
    byteOffset: 0x10,
    byteLength: 0x44
  },
};
/** VkSharedPresentSurfaceCapabilitiesKHR **/
function VkSharedPresentSurfaceCapabilitiesKHR(opts) {
  if (new.target !== VkSharedPresentSurfaceCapabilitiesKHR) {
    _VkSharedPresentSurfaceCapabilitiesKHR.reset();
    return _VkSharedPresentSurfaceCapabilitiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C7B98;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSharedPresentSurfaceCapabilitiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSharedPresentSurfaceCapabilitiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSharedPresentSurfaceCapabilitiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSharedPresentSurfaceCapabilitiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "sharedPresentSupportedUsageFlags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  
});

VkSharedPresentSurfaceCapabilitiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C7B98;
};

VkSharedPresentSurfaceCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSharedPresentSurfaceCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkSharedPresentSurfaceCapabilitiesKHR.byteLength = 0x18;

VkSharedPresentSurfaceCapabilitiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  sharedPresentSupportedUsageFlags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDevice16BitStorageFeatures **/
function VkPhysicalDevice16BitStorageFeatures(opts) {
  if (new.target !== VkPhysicalDevice16BitStorageFeatures) {
    _VkPhysicalDevice16BitStorageFeatures.reset();
    return _VkPhysicalDevice16BitStorageFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9C0E38;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    
  }
};

Object.defineProperties(VkPhysicalDevice16BitStorageFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevice16BitStorageFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevice16BitStorageFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice16BitStorageFeatures.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer16BitAccess": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "uniformAndStorageBuffer16BitAccess": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "storagePushConstant16": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "storageInputOutput16": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x7] = value | 0;
    }
    },
  
});

VkPhysicalDevice16BitStorageFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9C0E38;
};

VkPhysicalDevice16BitStorageFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice16BitStorageFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDevice16BitStorageFeatures.byteLength = 0x20;

VkPhysicalDevice16BitStorageFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  storageBuffer16BitAccess: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  uniformAndStorageBuffer16BitAccess: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  storagePushConstant16: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  storageInputOutput16: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkPhysicalDevice16BitStorageFeaturesKHR **/
function VkPhysicalDevice16BitStorageFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDevice16BitStorageFeaturesKHR) {
    _VkPhysicalDevice16BitStorageFeaturesKHR.reset();
    return _VkPhysicalDevice16BitStorageFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9C0E38;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    
  }
};

Object.defineProperties(VkPhysicalDevice16BitStorageFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevice16BitStorageFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevice16BitStorageFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice16BitStorageFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer16BitAccess": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "uniformAndStorageBuffer16BitAccess": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "storagePushConstant16": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "storageInputOutput16": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x7] = value | 0;
    }
    },
  
});

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9C0E38;
};

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDevice16BitStorageFeaturesKHR.byteLength = 0x20;

VkPhysicalDevice16BitStorageFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  storageBuffer16BitAccess: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  uniformAndStorageBuffer16BitAccess: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  storagePushConstant16: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  storageInputOutput16: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceSubgroupProperties **/
function VkPhysicalDeviceSubgroupProperties(opts) {
  if (new.target !== VkPhysicalDeviceSubgroupProperties) {
    _VkPhysicalDeviceSubgroupProperties.reset();
    return _VkPhysicalDeviceSubgroupProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9C3930;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSubgroupProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSubgroupProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSubgroupProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSubgroupProperties.pNext' isn't allowed to be filled");
    }
    },
  "subgroupSize": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "supportedStages": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "supportedOperations": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    },
  "quadOperationsInAllStages": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    },
  
});

VkPhysicalDeviceSubgroupProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9C3930;
};

VkPhysicalDeviceSubgroupProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSubgroupProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceSubgroupProperties.byteLength = 0x20;

VkPhysicalDeviceSubgroupProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  subgroupSize: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  supportedStages: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  supportedOperations: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  quadOperationsInAllStages: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkBufferMemoryRequirementsInfo2 **/
function VkBufferMemoryRequirementsInfo2(opts) {
  if (new.target !== VkBufferMemoryRequirementsInfo2) {
    _VkBufferMemoryRequirementsInfo2.reset();
    return _VkBufferMemoryRequirementsInfo2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = 0x3B9D0450;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferMemoryRequirementsInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferMemoryRequirementsInfo2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferMemoryRequirementsInfo2.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferMemoryRequirementsInfo2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = 0x3B9D0450;
};

VkBufferMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferMemoryRequirementsInfo2.byteLength = 0x18;

VkBufferMemoryRequirementsInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkBufferMemoryRequirementsInfo2KHR **/
function VkBufferMemoryRequirementsInfo2KHR(opts) {
  if (new.target !== VkBufferMemoryRequirementsInfo2KHR) {
    _VkBufferMemoryRequirementsInfo2KHR.reset();
    return _VkBufferMemoryRequirementsInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = 0x3B9D0450;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferMemoryRequirementsInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferMemoryRequirementsInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferMemoryRequirementsInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2KHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferMemoryRequirementsInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = 0x3B9D0450;
};

VkBufferMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferMemoryRequirementsInfo2KHR.byteLength = 0x18;

VkBufferMemoryRequirementsInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkImageMemoryRequirementsInfo2 **/
function VkImageMemoryRequirementsInfo2(opts) {
  if (new.target !== VkImageMemoryRequirementsInfo2) {
    _VkImageMemoryRequirementsInfo2.reset();
    return _VkImageMemoryRequirementsInfo2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0451;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageMemoryRequirementsInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageMemoryRequirementsInfo2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
      switch (sType) {
          
        case 0x3B9D2B63:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageMemoryRequirementsInfo2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0451;
};

VkImageMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageMemoryRequirementsInfo2.byteLength = 0x18;

VkImageMemoryRequirementsInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkImageMemoryRequirementsInfo2KHR **/
function VkImageMemoryRequirementsInfo2KHR(opts) {
  if (new.target !== VkImageMemoryRequirementsInfo2KHR) {
    _VkImageMemoryRequirementsInfo2KHR.reset();
    return _VkImageMemoryRequirementsInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0451;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageMemoryRequirementsInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageMemoryRequirementsInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9D2B63:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageMemoryRequirementsInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0451;
};

VkImageMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageMemoryRequirementsInfo2KHR.byteLength = 0x18;

VkImageMemoryRequirementsInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkImageSparseMemoryRequirementsInfo2 **/
function VkImageSparseMemoryRequirementsInfo2(opts) {
  if (new.target !== VkImageSparseMemoryRequirementsInfo2) {
    _VkImageSparseMemoryRequirementsInfo2.reset();
    return _VkImageSparseMemoryRequirementsInfo2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0452;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageSparseMemoryRequirementsInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageSparseMemoryRequirementsInfo2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageSparseMemoryRequirementsInfo2.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageSparseMemoryRequirementsInfo2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0452;
};

VkImageSparseMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSparseMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageSparseMemoryRequirementsInfo2.byteLength = 0x18;

VkImageSparseMemoryRequirementsInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkImageSparseMemoryRequirementsInfo2KHR **/
function VkImageSparseMemoryRequirementsInfo2KHR(opts) {
  if (new.target !== VkImageSparseMemoryRequirementsInfo2KHR) {
    _VkImageSparseMemoryRequirementsInfo2KHR.reset();
    return _VkImageSparseMemoryRequirementsInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0452;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageSparseMemoryRequirementsInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageSparseMemoryRequirementsInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageSparseMemoryRequirementsInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2KHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageSparseMemoryRequirementsInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = 0x3B9D0452;
};

VkImageSparseMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSparseMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageSparseMemoryRequirementsInfo2KHR.byteLength = 0x18;

VkImageSparseMemoryRequirementsInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkMemoryRequirements2 **/
function VkMemoryRequirements2(opts) {
  if (new.target !== VkMemoryRequirements2) {
    _VkMemoryRequirements2.reset();
    return _VkMemoryRequirements2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9D0453;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryRequirements2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryRequirements2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
      switch (sType) {
          
        case 0x3B9CBA18:
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
    }
    
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkMemoryRequirements2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._memoryRequirements = null;
  this.sType = 0x3B9D0453;
};

VkMemoryRequirements2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryRequirements2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkMemoryRequirements2.byteLength = 0x28;

VkMemoryRequirements2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryRequirements: {
    byteOffset: 0x10,
    byteLength: 0x18
  },
};
/** VkMemoryRequirements2KHR **/
function VkMemoryRequirements2KHR(opts) {
  if (new.target !== VkMemoryRequirements2KHR) {
    _VkMemoryRequirements2KHR.reset();
    return _VkMemoryRequirements2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9D0453;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryRequirements2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryRequirements2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9CBA18:
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
    }
    
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkMemoryRequirements2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._memoryRequirements = null;
  this.sType = 0x3B9D0453;
};

VkMemoryRequirements2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryRequirements2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkMemoryRequirements2KHR.byteLength = 0x28;

VkMemoryRequirements2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryRequirements: {
    byteOffset: 0x10,
    byteLength: 0x18
  },
};
/** VkSparseImageMemoryRequirements2 **/
function VkSparseImageMemoryRequirements2(opts) {
  if (new.target !== VkSparseImageMemoryRequirements2) {
    _VkSparseImageMemoryRequirements2.reset();
    return _VkSparseImageMemoryRequirements2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9D0454;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageMemoryRequirements2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryRequirements2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSparseImageMemoryRequirements2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageMemoryRequirements2.pNext' isn't allowed to be filled");
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkSparseImageMemoryRequirements2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._memoryRequirements = null;
  this.sType = 0x3B9D0454;
};

VkSparseImageMemoryRequirements2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageMemoryRequirements2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
};

VkSparseImageMemoryRequirements2.byteLength = 0x40;

VkSparseImageMemoryRequirements2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryRequirements: {
    byteOffset: 0x10,
    byteLength: 0x30
  },
};
/** VkSparseImageMemoryRequirements2KHR **/
function VkSparseImageMemoryRequirements2KHR(opts) {
  if (new.target !== VkSparseImageMemoryRequirements2KHR) {
    _VkSparseImageMemoryRequirements2KHR.reset();
    return _VkSparseImageMemoryRequirements2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9D0454;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageMemoryRequirements2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryRequirements2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSparseImageMemoryRequirements2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageMemoryRequirements2KHR.pNext' isn't allowed to be filled");
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkSparseImageMemoryRequirements2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  this._memoryRequirements = null;
  this.sType = 0x3B9D0454;
};

VkSparseImageMemoryRequirements2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageMemoryRequirements2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
};

VkSparseImageMemoryRequirements2KHR.byteLength = 0x40;

VkSparseImageMemoryRequirements2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryRequirements: {
    byteOffset: 0x10,
    byteLength: 0x30
  },
};
/** VkPhysicalDevicePointClippingProperties **/
function VkPhysicalDevicePointClippingProperties(opts) {
  if (new.target !== VkPhysicalDevicePointClippingProperties) {
    _VkPhysicalDevicePointClippingProperties.reset();
    return _VkPhysicalDevicePointClippingProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C9308;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePointClippingProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePointClippingProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevicePointClippingProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePointClippingProperties.pNext' isn't allowed to be filled");
    }
    },
  "pointClippingBehavior": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  
});

VkPhysicalDevicePointClippingProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C9308;
};

VkPhysicalDevicePointClippingProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePointClippingProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDevicePointClippingProperties.byteLength = 0x18;

VkPhysicalDevicePointClippingProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pointClippingBehavior: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDevicePointClippingPropertiesKHR **/
function VkPhysicalDevicePointClippingPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDevicePointClippingPropertiesKHR) {
    _VkPhysicalDevicePointClippingPropertiesKHR.reset();
    return _VkPhysicalDevicePointClippingPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C9308;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePointClippingPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePointClippingPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevicePointClippingPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePointClippingPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "pointClippingBehavior": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  
});

VkPhysicalDevicePointClippingPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C9308;
};

VkPhysicalDevicePointClippingPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePointClippingPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDevicePointClippingPropertiesKHR.byteLength = 0x18;

VkPhysicalDevicePointClippingPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pointClippingBehavior: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkMemoryDedicatedRequirements **/
function VkMemoryDedicatedRequirements(opts) {
  if (new.target !== VkMemoryDedicatedRequirements) {
    _VkMemoryDedicatedRequirements.reset();
    return _VkMemoryDedicatedRequirements;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CBA18;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryDedicatedRequirements.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedRequirements.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryDedicatedRequirements.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedRequirements.pNext' isn't allowed to be filled");
    }
    },
  "prefersDedicatedAllocation": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  "requiresDedicatedAllocation": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  
});

VkMemoryDedicatedRequirements.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CBA18;
};

VkMemoryDedicatedRequirements.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryDedicatedRequirements.byteLength = 0x18;

VkMemoryDedicatedRequirements.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  prefersDedicatedAllocation: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  requiresDedicatedAllocation: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkMemoryDedicatedRequirementsKHR **/
function VkMemoryDedicatedRequirementsKHR(opts) {
  if (new.target !== VkMemoryDedicatedRequirementsKHR) {
    _VkMemoryDedicatedRequirementsKHR.reset();
    return _VkMemoryDedicatedRequirementsKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CBA18;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryDedicatedRequirementsKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedRequirementsKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryDedicatedRequirementsKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedRequirementsKHR.pNext' isn't allowed to be filled");
    }
    },
  "prefersDedicatedAllocation": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  "requiresDedicatedAllocation": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  
});

VkMemoryDedicatedRequirementsKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CBA18;
};

VkMemoryDedicatedRequirementsKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedRequirementsKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryDedicatedRequirementsKHR.byteLength = 0x18;

VkMemoryDedicatedRequirementsKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  prefersDedicatedAllocation: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  requiresDedicatedAllocation: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkMemoryDedicatedAllocateInfo **/
function VkMemoryDedicatedAllocateInfo(opts) {
  if (new.target !== VkMemoryDedicatedAllocateInfo) {
    _VkMemoryDedicatedAllocateInfo.reset();
    return _VkMemoryDedicatedAllocateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = 0x3B9CBA19;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkMemoryDedicatedAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryDedicatedAllocateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkMemoryDedicatedAllocateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = 0x3B9CBA19;
};

VkMemoryDedicatedAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryDedicatedAllocateInfo.byteLength = 0x20;

VkMemoryDedicatedAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkMemoryDedicatedAllocateInfoKHR **/
function VkMemoryDedicatedAllocateInfoKHR(opts) {
  if (new.target !== VkMemoryDedicatedAllocateInfoKHR) {
    _VkMemoryDedicatedAllocateInfoKHR.reset();
    return _VkMemoryDedicatedAllocateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = 0x3B9CBA19;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkMemoryDedicatedAllocateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryDedicatedAllocateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedAllocateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkMemoryDedicatedAllocateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = 0x3B9CBA19;
};

VkMemoryDedicatedAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryDedicatedAllocateInfoKHR.byteLength = 0x20;

VkMemoryDedicatedAllocateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  image: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkImageViewUsageCreateInfo **/
function VkImageViewUsageCreateInfo(opts) {
  if (new.target !== VkImageViewUsageCreateInfo) {
    _VkImageViewUsageCreateInfo.reset();
    return _VkImageViewUsageCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C930A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.usage !== void 0) this.usage = opts.usage;
    
  }
};

Object.defineProperties(VkImageViewUsageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewUsageCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewUsageCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfo.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkImageViewUsageCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C930A;
};

VkImageViewUsageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewUsageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewUsageCreateInfo.byteLength = 0x18;

VkImageViewUsageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  usage: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImageViewUsageCreateInfoKHR **/
function VkImageViewUsageCreateInfoKHR(opts) {
  if (new.target !== VkImageViewUsageCreateInfoKHR) {
    _VkImageViewUsageCreateInfoKHR.reset();
    return _VkImageViewUsageCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C930A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.usage !== void 0) this.usage = opts.usage;
    
  }
};

Object.defineProperties(VkImageViewUsageCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewUsageCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewUsageCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfoKHR.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkImageViewUsageCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C930A;
};

VkImageViewUsageCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewUsageCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewUsageCreateInfoKHR.byteLength = 0x18;

VkImageViewUsageCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  usage: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineTessellationDomainOriginStateCreateInfo **/
function VkPipelineTessellationDomainOriginStateCreateInfo(opts) {
  if (new.target !== VkPipelineTessellationDomainOriginStateCreateInfo) {
    _VkPipelineTessellationDomainOriginStateCreateInfo.reset();
    return _VkPipelineTessellationDomainOriginStateCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C930B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
    
  }
};

Object.defineProperties(VkPipelineTessellationDomainOriginStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineTessellationDomainOriginStateCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineTessellationDomainOriginStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "domainOrigin": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfo.domainOrigin': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkTessellationDomainOrigin(value)) {
      throw new RangeError("Invalid value for 'VkPipelineTessellationDomainOriginStateCreateInfo.domainOrigin': '" + value + "' is not a value of 'VkTessellationDomainOrigin'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C930B;
};

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineTessellationDomainOriginStateCreateInfo.byteLength = 0x18;

VkPipelineTessellationDomainOriginStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  domainOrigin: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineTessellationDomainOriginStateCreateInfoKHR **/
function VkPipelineTessellationDomainOriginStateCreateInfoKHR(opts) {
  if (new.target !== VkPipelineTessellationDomainOriginStateCreateInfoKHR) {
    _VkPipelineTessellationDomainOriginStateCreateInfoKHR.reset();
    return _VkPipelineTessellationDomainOriginStateCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C930B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
    
  }
};

Object.defineProperties(VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "domainOrigin": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR.domainOrigin': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkTessellationDomainOrigin(value)) {
      throw new RangeError("Invalid value for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR.domainOrigin': '" + value + "' is not a value of 'VkTessellationDomainOrigin'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C930B;
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.byteLength = 0x18;

VkPipelineTessellationDomainOriginStateCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  domainOrigin: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSamplerYcbcrConversionInfo **/
function VkSamplerYcbcrConversionInfo(opts) {
  if (new.target !== VkSamplerYcbcrConversionInfo) {
    _VkSamplerYcbcrConversionInfo.reset();
    return _VkSamplerYcbcrConversionInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._conversion = null;
  this.sType = 0x3B9D2B61;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conversion !== void 0) this.conversion = opts.conversion;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionInfo.pNext' isn't allowed to be filled");
    }
    },
  "conversion": {
    get() {
    return this._conversion;
    },
    set(value) {
    if (value !== null && value.constructor === VkSamplerYcbcrConversion) {
      
      this._conversion = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._conversion = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfo.conversion': Expected 'VkSamplerYcbcrConversion' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSamplerYcbcrConversionInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._conversion = null;
  this.sType = 0x3B9D2B61;
};

VkSamplerYcbcrConversionInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerYcbcrConversionInfo.byteLength = 0x18;

VkSamplerYcbcrConversionInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  conversion: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSamplerYcbcrConversionInfoKHR **/
function VkSamplerYcbcrConversionInfoKHR(opts) {
  if (new.target !== VkSamplerYcbcrConversionInfoKHR) {
    _VkSamplerYcbcrConversionInfoKHR.reset();
    return _VkSamplerYcbcrConversionInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._conversion = null;
  this.sType = 0x3B9D2B61;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conversion !== void 0) this.conversion = opts.conversion;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "conversion": {
    get() {
    return this._conversion;
    },
    set(value) {
    if (value !== null && value.constructor === VkSamplerYcbcrConversion) {
      
      this._conversion = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._conversion = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfoKHR.conversion': Expected 'VkSamplerYcbcrConversion' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSamplerYcbcrConversionInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._conversion = null;
  this.sType = 0x3B9D2B61;
};

VkSamplerYcbcrConversionInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerYcbcrConversionInfoKHR.byteLength = 0x18;

VkSamplerYcbcrConversionInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  conversion: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSamplerYcbcrConversionCreateInfo **/
function VkSamplerYcbcrConversionCreateInfo(opts) {
  if (new.target !== VkSamplerYcbcrConversionCreateInfo) {
    _VkSamplerYcbcrConversionCreateInfo.reset();
    return _VkSamplerYcbcrConversionCreateInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x1C });
  
  
  
  
  this.sType = 0x3B9D2B60;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
    if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
    if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
    if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
    if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9CC1ED:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "ycbcrModel": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.ycbcrModel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerYcbcrModelConversion(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.ycbcrModel': '" + value + "' is not a value of 'VkSamplerYcbcrModelConversion'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "ycbcrRange": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.ycbcrRange': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerYcbcrRange(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.ycbcrRange': '" + value + "' is not a value of 'VkSamplerYcbcrRange'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "components": {
    get() {
    return this._components;
    },
    set(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.components': Expected 'VkComponentMapping' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "xChromaOffset": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.xChromaOffset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkChromaLocation(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.xChromaOffset': '" + value + "' is not a value of 'VkChromaLocation'");
    }
    this.memoryViewInt32[0xB] = value;
    }
    },
  "yChromaOffset": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.yChromaOffset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkChromaLocation(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.yChromaOffset': '" + value + "' is not a value of 'VkChromaLocation'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "chromaFilter": {
    get() {
    return this.memoryViewInt32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.chromaFilter': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFilter(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfo.chromaFilter': '" + value + "' is not a value of 'VkFilter'");
    }
    this.memoryViewInt32[0xD] = value;
    }
    },
  "forceExplicitReconstruction": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xE] = value | 0;
    }
    },
  
});

VkSamplerYcbcrConversionCreateInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  
  
  this._components = null;
  
  
  
  
  this.sType = 0x3B9D2B60;
};

VkSamplerYcbcrConversionCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    let components = this._components;
    components.flush();
    if (this.memoryBuffer !== components.memoryBuffer) {
      let srcView = new Uint8Array(components.memoryBuffer).subarray(components.$memoryOffset, components.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSamplerYcbcrConversionCreateInfo.components' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSamplerYcbcrConversionCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkSamplerYcbcrConversionCreateInfo.byteLength = 0x40;

VkSamplerYcbcrConversionCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  ycbcrModel: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  ycbcrRange: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  components: {
    byteOffset: 0x1C,
    byteLength: 0x10
  },
  xChromaOffset: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  yChromaOffset: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  chromaFilter: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  forceExplicitReconstruction: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkSamplerYcbcrConversionCreateInfoKHR **/
function VkSamplerYcbcrConversionCreateInfoKHR(opts) {
  if (new.target !== VkSamplerYcbcrConversionCreateInfoKHR) {
    _VkSamplerYcbcrConversionCreateInfoKHR.reset();
    return _VkSamplerYcbcrConversionCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x1C });
  
  
  
  
  this.sType = 0x3B9D2B60;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
    if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
    if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
    if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
    if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9CC1ED:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "ycbcrModel": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.ycbcrModel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerYcbcrModelConversion(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.ycbcrModel': '" + value + "' is not a value of 'VkSamplerYcbcrModelConversion'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "ycbcrRange": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.ycbcrRange': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerYcbcrRange(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.ycbcrRange': '" + value + "' is not a value of 'VkSamplerYcbcrRange'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "components": {
    get() {
    return this._components;
    },
    set(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.components': Expected 'VkComponentMapping' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "xChromaOffset": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.xChromaOffset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkChromaLocation(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.xChromaOffset': '" + value + "' is not a value of 'VkChromaLocation'");
    }
    this.memoryViewInt32[0xB] = value;
    }
    },
  "yChromaOffset": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.yChromaOffset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkChromaLocation(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.yChromaOffset': '" + value + "' is not a value of 'VkChromaLocation'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "chromaFilter": {
    get() {
    return this.memoryViewInt32[0xD];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.chromaFilter': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFilter(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionCreateInfoKHR.chromaFilter': '" + value + "' is not a value of 'VkFilter'");
    }
    this.memoryViewInt32[0xD] = value;
    }
    },
  "forceExplicitReconstruction": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xE] = value | 0;
    }
    },
  
});

VkSamplerYcbcrConversionCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  
  
  this._components = null;
  
  
  
  
  this.sType = 0x3B9D2B60;
};

VkSamplerYcbcrConversionCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    let components = this._components;
    components.flush();
    if (this.memoryBuffer !== components.memoryBuffer) {
      let srcView = new Uint8Array(components.memoryBuffer).subarray(components.$memoryOffset, components.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSamplerYcbcrConversionCreateInfoKHR.components' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSamplerYcbcrConversionCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkSamplerYcbcrConversionCreateInfoKHR.byteLength = 0x40;

VkSamplerYcbcrConversionCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  format: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  ycbcrModel: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  ycbcrRange: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  components: {
    byteOffset: 0x1C,
    byteLength: 0x10
  },
  xChromaOffset: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  yChromaOffset: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  chromaFilter: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  forceExplicitReconstruction: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkBindImagePlaneMemoryInfo **/
function VkBindImagePlaneMemoryInfo(opts) {
  if (new.target !== VkBindImagePlaneMemoryInfo) {
    _VkBindImagePlaneMemoryInfo.reset();
    return _VkBindImagePlaneMemoryInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B62;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkBindImagePlaneMemoryInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImagePlaneMemoryInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImagePlaneMemoryInfo.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfo.planeAspect': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkBindImagePlaneMemoryInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B62;
};

VkBindImagePlaneMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImagePlaneMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImagePlaneMemoryInfo.byteLength = 0x18;

VkBindImagePlaneMemoryInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  planeAspect: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkBindImagePlaneMemoryInfoKHR **/
function VkBindImagePlaneMemoryInfoKHR(opts) {
  if (new.target !== VkBindImagePlaneMemoryInfoKHR) {
    _VkBindImagePlaneMemoryInfoKHR.reset();
    return _VkBindImagePlaneMemoryInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B62;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkBindImagePlaneMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindImagePlaneMemoryInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImagePlaneMemoryInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfoKHR.planeAspect': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkBindImagePlaneMemoryInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B62;
};

VkBindImagePlaneMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImagePlaneMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImagePlaneMemoryInfoKHR.byteLength = 0x18;

VkBindImagePlaneMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  planeAspect: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImagePlaneMemoryRequirementsInfo **/
function VkImagePlaneMemoryRequirementsInfo(opts) {
  if (new.target !== VkImagePlaneMemoryRequirementsInfo) {
    _VkImagePlaneMemoryRequirementsInfo.reset();
    return _VkImagePlaneMemoryRequirementsInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B63;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkImagePlaneMemoryRequirementsInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImagePlaneMemoryRequirementsInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImagePlaneMemoryRequirementsInfo.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfo.planeAspect': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkImagePlaneMemoryRequirementsInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B63;
};

VkImagePlaneMemoryRequirementsInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImagePlaneMemoryRequirementsInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImagePlaneMemoryRequirementsInfo.byteLength = 0x18;

VkImagePlaneMemoryRequirementsInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  planeAspect: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImagePlaneMemoryRequirementsInfoKHR **/
function VkImagePlaneMemoryRequirementsInfoKHR(opts) {
  if (new.target !== VkImagePlaneMemoryRequirementsInfoKHR) {
    _VkImagePlaneMemoryRequirementsInfoKHR.reset();
    return _VkImagePlaneMemoryRequirementsInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B63;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkImagePlaneMemoryRequirementsInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImagePlaneMemoryRequirementsInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImagePlaneMemoryRequirementsInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfoKHR.planeAspect': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkImagePlaneMemoryRequirementsInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B63;
};

VkImagePlaneMemoryRequirementsInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImagePlaneMemoryRequirementsInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImagePlaneMemoryRequirementsInfoKHR.byteLength = 0x18;

VkImagePlaneMemoryRequirementsInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  planeAspect: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceSamplerYcbcrConversionFeatures **/
function VkPhysicalDeviceSamplerYcbcrConversionFeatures(opts) {
  if (new.target !== VkPhysicalDeviceSamplerYcbcrConversionFeatures) {
    _VkPhysicalDeviceSamplerYcbcrConversionFeatures.reset();
    return _VkPhysicalDeviceSamplerYcbcrConversionFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B64;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSamplerYcbcrConversionFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSamplerYcbcrConversionFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerYcbcrConversionFeatures.pNext' isn't allowed to be filled");
    }
    },
  "samplerYcbcrConversion": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B64;
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.byteLength = 0x18;

VkPhysicalDeviceSamplerYcbcrConversionFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  samplerYcbcrConversion: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR **/
function VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR) {
    _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.reset();
    return _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B64;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "samplerYcbcrConversion": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B64;
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  samplerYcbcrConversion: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSamplerYcbcrConversionImageFormatProperties **/
function VkSamplerYcbcrConversionImageFormatProperties(opts) {
  if (new.target !== VkSamplerYcbcrConversionImageFormatProperties) {
    _VkSamplerYcbcrConversionImageFormatProperties.reset();
    return _VkSamplerYcbcrConversionImageFormatProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B65;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionImageFormatProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionImageFormatProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionImageFormatProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionImageFormatProperties.pNext' isn't allowed to be filled");
    }
    },
  "combinedImageSamplerDescriptorCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkSamplerYcbcrConversionImageFormatProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B65;
};

VkSamplerYcbcrConversionImageFormatProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkSamplerYcbcrConversionImageFormatProperties.byteLength = 0x18;

VkSamplerYcbcrConversionImageFormatProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  combinedImageSamplerDescriptorCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSamplerYcbcrConversionImageFormatPropertiesKHR **/
function VkSamplerYcbcrConversionImageFormatPropertiesKHR(opts) {
  if (new.target !== VkSamplerYcbcrConversionImageFormatPropertiesKHR) {
    _VkSamplerYcbcrConversionImageFormatPropertiesKHR.reset();
    return _VkSamplerYcbcrConversionImageFormatPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B65;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionImageFormatPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerYcbcrConversionImageFormatPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "combinedImageSamplerDescriptorCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2B65;
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.byteLength = 0x18;

VkSamplerYcbcrConversionImageFormatPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  combinedImageSamplerDescriptorCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkTextureLODGatherFormatPropertiesAMD **/
function VkTextureLODGatherFormatPropertiesAMD(opts) {
  if (new.target !== VkTextureLODGatherFormatPropertiesAMD) {
    _VkTextureLODGatherFormatPropertiesAMD.reset();
    return _VkTextureLODGatherFormatPropertiesAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9B6A28;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkTextureLODGatherFormatPropertiesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkTextureLODGatherFormatPropertiesAMD.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkTextureLODGatherFormatPropertiesAMD.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkTextureLODGatherFormatPropertiesAMD.pNext' isn't allowed to be filled");
    }
    },
  "supportsTextureGatherLODBiasAMD": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkTextureLODGatherFormatPropertiesAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9B6A28;
};

VkTextureLODGatherFormatPropertiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkTextureLODGatherFormatPropertiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkTextureLODGatherFormatPropertiesAMD.byteLength = 0x18;

VkTextureLODGatherFormatPropertiesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  supportsTextureGatherLODBiasAMD: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkConditionalRenderingBeginInfoEXT **/
function VkConditionalRenderingBeginInfoEXT(opts) {
  if (new.target !== VkConditionalRenderingBeginInfoEXT) {
    _VkConditionalRenderingBeginInfoEXT.reset();
    return _VkConditionalRenderingBeginInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._buffer = null;
  
  
  this.sType = 0x3B9C066A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkConditionalRenderingBeginInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkConditionalRenderingBeginInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkConditionalRenderingBeginInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  
});

VkConditionalRenderingBeginInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  
  
  this.sType = 0x3B9C066A;
};

VkConditionalRenderingBeginInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkConditionalRenderingBeginInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkConditionalRenderingBeginInfoEXT.byteLength = 0x28;

VkConditionalRenderingBeginInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  offset: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkProtectedSubmitInfo **/
function VkProtectedSubmitInfo(opts) {
  if (new.target !== VkProtectedSubmitInfo) {
    _VkProtectedSubmitInfo.reset();
    return _VkProtectedSubmitInfo;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D0068;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.protectedSubmit !== void 0) this.protectedSubmit = opts.protectedSubmit;
    
  }
};

Object.defineProperties(VkProtectedSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkProtectedSubmitInfo.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkProtectedSubmitInfo.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkProtectedSubmitInfo.pNext' isn't allowed to be filled");
    }
    },
  "protectedSubmit": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkProtectedSubmitInfo.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D0068;
};

VkProtectedSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkProtectedSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkProtectedSubmitInfo.byteLength = 0x18;

VkProtectedSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  protectedSubmit: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceProtectedMemoryFeatures **/
function VkPhysicalDeviceProtectedMemoryFeatures(opts) {
  if (new.target !== VkPhysicalDeviceProtectedMemoryFeatures) {
    _VkPhysicalDeviceProtectedMemoryFeatures.reset();
    return _VkPhysicalDeviceProtectedMemoryFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D0069;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.protectedMemory !== void 0) this.protectedMemory = opts.protectedMemory;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProtectedMemoryFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProtectedMemoryFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceProtectedMemoryFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceProtectedMemoryFeatures.pNext' isn't allowed to be filled");
    }
    },
  "protectedMemory": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceProtectedMemoryFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D0069;
};

VkPhysicalDeviceProtectedMemoryFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProtectedMemoryFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceProtectedMemoryFeatures.byteLength = 0x18;

VkPhysicalDeviceProtectedMemoryFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  protectedMemory: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceProtectedMemoryProperties **/
function VkPhysicalDeviceProtectedMemoryProperties(opts) {
  if (new.target !== VkPhysicalDeviceProtectedMemoryProperties) {
    _VkPhysicalDeviceProtectedMemoryProperties.reset();
    return _VkPhysicalDeviceProtectedMemoryProperties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D006A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProtectedMemoryProperties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProtectedMemoryProperties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceProtectedMemoryProperties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceProtectedMemoryProperties.pNext' isn't allowed to be filled");
    }
    },
  "protectedNoFault": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkPhysicalDeviceProtectedMemoryProperties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D006A;
};

VkPhysicalDeviceProtectedMemoryProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProtectedMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceProtectedMemoryProperties.byteLength = 0x18;

VkPhysicalDeviceProtectedMemoryProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  protectedNoFault: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDeviceQueueInfo2 **/
function VkDeviceQueueInfo2(opts) {
  if (new.target !== VkDeviceQueueInfo2) {
    _VkDeviceQueueInfo2.reset();
    return _VkDeviceQueueInfo2;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D006B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.queueIndex !== void 0) this.queueIndex = opts.queueIndex;
    
  }
};

Object.defineProperties(VkDeviceQueueInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceQueueInfo2.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceQueueInfo2.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.queueFamilyIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "queueIndex": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.queueIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  
});

VkDeviceQueueInfo2.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D006B;
};

VkDeviceQueueInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceQueueInfo2.byteLength = 0x20;

VkDeviceQueueInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  queueFamilyIndex: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  queueIndex: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPipelineCoverageToColorStateCreateInfoNV **/
function VkPipelineCoverageToColorStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineCoverageToColorStateCreateInfoNV) {
    _VkPipelineCoverageToColorStateCreateInfoNV.reset();
    return _VkPipelineCoverageToColorStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D1008;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageToColorEnable !== void 0) this.coverageToColorEnable = opts.coverageToColorEnable;
    if (opts.coverageToColorLocation !== void 0) this.coverageToColorLocation = opts.coverageToColorLocation;
    
  }
};

Object.defineProperties(VkPipelineCoverageToColorStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageToColorStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCoverageToColorStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCoverageToColorStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageToColorStateCreateInfoNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "coverageToColorEnable": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "coverageToColorLocation": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  
});

VkPipelineCoverageToColorStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D1008;
};

VkPipelineCoverageToColorStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageToColorStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCoverageToColorStateCreateInfoNV.byteLength = 0x20;

VkPipelineCoverageToColorStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  coverageToColorEnable: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  coverageToColorLocation: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT **/
function VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT) {
    _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.reset();
    return _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CC5D0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "filterMinmaxSingleComponentFormats": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  "filterMinmaxImageComponentMapping": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  
});

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CC5D0;
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  filterMinmaxSingleComponentFormats: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  filterMinmaxImageComponentMapping: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkSampleLocationEXT **/
function VkSampleLocationEXT(opts) {
  if (new.target !== VkSampleLocationEXT) {
    _VkSampleLocationEXT.reset();
    return _VkSampleLocationEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

Object.defineProperties(VkSampleLocationEXT.prototype, {
  "x": {
    get() {
    return this.memoryViewFloat32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationEXT.x': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x0] = value;
    }
    },
  "y": {
    get() {
    return this.memoryViewFloat32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationEXT.y': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x1] = value;
    }
    },
  
});

VkSampleLocationEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkSampleLocationEXT.prototype.flush = function flush() {
  
  return true;
};

VkSampleLocationEXT.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSampleLocationEXT.byteLength = 0x8;

VkSampleLocationEXT.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  y: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkSampleLocationsInfoEXT **/
function VkSampleLocationsInfoEXT(opts) {
  if (new.target !== VkSampleLocationsInfoEXT) {
    _VkSampleLocationsInfoEXT.reset();
    return _VkSampleLocationsInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._sampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x14 });
  
  this._pSampleLocations = null;
    this._pSampleLocationsNative = null;
  this.sType = 0x3B9CF898;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleLocationsPerPixel !== void 0) this.sampleLocationsPerPixel = opts.sampleLocationsPerPixel;
    if (opts.sampleLocationGridSize !== void 0) this.sampleLocationGridSize = opts.sampleLocationGridSize;
    if (opts.sampleLocationsCount !== void 0) this.sampleLocationsCount = opts.sampleLocationsCount;
    if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
    
  }
};

Object.defineProperties(VkSampleLocationsInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSampleLocationsInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSampleLocationsInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "sampleLocationsPerPixel": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationsPerPixel': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "sampleLocationGridSize": {
    get() {
    return this._sampleLocationGridSize;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._sampleLocationGridSize = value;
      
      
    } else if (value === null) {
      this._sampleLocationGridSize = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationGridSize': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sampleLocationsCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationsCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "pSampleLocations": {
    get() {
    return this._pSampleLocations;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSampleLocations = value;
    } else if (value === null) {
      this._pSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.pSampleLocations': Expected 'Array VkSampleLocationEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSampleLocationsInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  this._sampleLocationGridSize = null;
  
  this._pSampleLocations = null;
    this._pSampleLocationsNative = null;
  this.sType = 0x3B9CF898;
};

VkSampleLocationsInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._sampleLocationGridSize !== null) {
    let sampleLocationGridSize = this._sampleLocationGridSize;
    sampleLocationGridSize.flush();
    if (this.memoryBuffer !== sampleLocationGridSize.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationGridSize.memoryBuffer).subarray(sampleLocationGridSize.$memoryOffset, sampleLocationGridSize.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x14);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSampleLocationsInfoEXT.sampleLocationGridSize' isn't used as shared-memory");
    }
  }
  
  
  if (this._pSampleLocations !== null) {
    let array = this._pSampleLocations;
    
    if (array.length !== this.sampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'sampleLocationsCount' for 'VkSampleLocationsInfoEXT.pSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSampleLocationEXT)) {
        throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.pSampleLocations[" + ii + "]': Expected 'VkSampleLocationEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSampleLocationsNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pSampleLocationsNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkSampleLocationsInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkSampleLocationsInfoEXT.byteLength = 0x28;

VkSampleLocationsInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  sampleLocationsPerPixel: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  sampleLocationGridSize: {
    byteOffset: 0x14,
    byteLength: 0x8
  },
  sampleLocationsCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pSampleLocations: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkAttachmentSampleLocationsEXT **/
function VkAttachmentSampleLocationsEXT(opts) {
  if (new.target !== VkAttachmentSampleLocationsEXT) {
    _VkAttachmentSampleLocationsEXT.reset();
    return _VkAttachmentSampleLocationsEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  if (typeof opts === "object") {
    if (opts.attachmentIndex !== void 0) this.attachmentIndex = opts.attachmentIndex;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

Object.defineProperties(VkAttachmentSampleLocationsEXT.prototype, {
  "attachmentIndex": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentSampleLocationsEXT.attachmentIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "sampleLocationsInfo": {
    get() {
    return this._sampleLocationsInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentSampleLocationsEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAttachmentSampleLocationsEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._sampleLocationsInfo = null;
  
};

VkAttachmentSampleLocationsEXT.prototype.flush = function flush() {
  
  
  if (this._sampleLocationsInfo !== null) {
    let sampleLocationsInfo = this._sampleLocationsInfo;
    sampleLocationsInfo.flush();
    if (this.memoryBuffer !== sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationsInfo.memoryBuffer).subarray(sampleLocationsInfo.$memoryOffset, sampleLocationsInfo.$memoryOffset + 0x28);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAttachmentSampleLocationsEXT.sampleLocationsInfo' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAttachmentSampleLocationsEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAttachmentSampleLocationsEXT.byteLength = 0x30;

VkAttachmentSampleLocationsEXT.memoryLayout = {
  attachmentIndex: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  sampleLocationsInfo: {
    byteOffset: 0x8,
    byteLength: 0x28
  },
};
/** VkSubpassSampleLocationsEXT **/
function VkSubpassSampleLocationsEXT(opts) {
  if (new.target !== VkSubpassSampleLocationsEXT) {
    _VkSubpassSampleLocationsEXT.reset();
    return _VkSubpassSampleLocationsEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  if (typeof opts === "object") {
    if (opts.subpassIndex !== void 0) this.subpassIndex = opts.subpassIndex;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

Object.defineProperties(VkSubpassSampleLocationsEXT.prototype, {
  "subpassIndex": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassSampleLocationsEXT.subpassIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "sampleLocationsInfo": {
    get() {
    return this._sampleLocationsInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSubpassSampleLocationsEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassSampleLocationsEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._sampleLocationsInfo = null;
  
};

VkSubpassSampleLocationsEXT.prototype.flush = function flush() {
  
  
  if (this._sampleLocationsInfo !== null) {
    let sampleLocationsInfo = this._sampleLocationsInfo;
    sampleLocationsInfo.flush();
    if (this.memoryBuffer !== sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationsInfo.memoryBuffer).subarray(sampleLocationsInfo.$memoryOffset, sampleLocationsInfo.$memoryOffset + 0x28);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSubpassSampleLocationsEXT.sampleLocationsInfo' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSubpassSampleLocationsEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassSampleLocationsEXT.byteLength = 0x30;

VkSubpassSampleLocationsEXT.memoryLayout = {
  subpassIndex: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  sampleLocationsInfo: {
    byteOffset: 0x8,
    byteLength: 0x28
  },
};
/** VkRenderPassSampleLocationsBeginInfoEXT **/
function VkRenderPassSampleLocationsBeginInfoEXT(opts) {
  if (new.target !== VkRenderPassSampleLocationsBeginInfoEXT) {
    _VkRenderPassSampleLocationsBeginInfoEXT.reset();
    return _VkRenderPassSampleLocationsBeginInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAttachmentInitialSampleLocations = null;
    this._pAttachmentInitialSampleLocationsNative = null;
  
  this._pPostSubpassSampleLocations = null;
    this._pPostSubpassSampleLocationsNative = null;
  this.sType = 0x3B9CF899;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentInitialSampleLocationsCount !== void 0) this.attachmentInitialSampleLocationsCount = opts.attachmentInitialSampleLocationsCount;
    if (opts.pAttachmentInitialSampleLocations !== void 0) this.pAttachmentInitialSampleLocations = opts.pAttachmentInitialSampleLocations;
    if (opts.postSubpassSampleLocationsCount !== void 0) this.postSubpassSampleLocationsCount = opts.postSubpassSampleLocationsCount;
    if (opts.pPostSubpassSampleLocations !== void 0) this.pPostSubpassSampleLocations = opts.pPostSubpassSampleLocations;
    
  }
};

Object.defineProperties(VkRenderPassSampleLocationsBeginInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassSampleLocationsBeginInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassSampleLocationsBeginInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "attachmentInitialSampleLocationsCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.attachmentInitialSampleLocationsCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAttachmentInitialSampleLocations": {
    get() {
    return this._pAttachmentInitialSampleLocations;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachmentInitialSampleLocations = value;
    } else if (value === null) {
      this._pAttachmentInitialSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations': Expected 'Array VkAttachmentSampleLocationsEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "postSubpassSampleLocationsCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.postSubpassSampleLocationsCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pPostSubpassSampleLocations": {
    get() {
    return this._pPostSubpassSampleLocations;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPostSubpassSampleLocations = value;
    } else if (value === null) {
      this._pPostSubpassSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations': Expected 'Array VkSubpassSampleLocationsEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassSampleLocationsBeginInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  this._pAttachmentInitialSampleLocations = null;
    this._pAttachmentInitialSampleLocationsNative = null;
  
  this._pPostSubpassSampleLocations = null;
    this._pPostSubpassSampleLocationsNative = null;
  this.sType = 0x3B9CF899;
};

VkRenderPassSampleLocationsBeginInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachmentInitialSampleLocations !== null) {
    let array = this._pAttachmentInitialSampleLocations;
    
    if (array.length !== this.attachmentInitialSampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentInitialSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentSampleLocationsEXT)) {
        throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations[" + ii + "]': Expected 'VkAttachmentSampleLocationsEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentInitialSampleLocationsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAttachmentInitialSampleLocationsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pPostSubpassSampleLocations !== null) {
    let array = this._pPostSubpassSampleLocations;
    
    if (array.length !== this.postSubpassSampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'postSubpassSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassSampleLocationsEXT)) {
        throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations[" + ii + "]': Expected 'VkSubpassSampleLocationsEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPostSubpassSampleLocationsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pPostSubpassSampleLocationsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkRenderPassSampleLocationsBeginInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkRenderPassSampleLocationsBeginInfoEXT.byteLength = 0x30;

VkRenderPassSampleLocationsBeginInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  attachmentInitialSampleLocationsCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAttachmentInitialSampleLocations: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  postSubpassSampleLocationsCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pPostSubpassSampleLocations: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkPipelineSampleLocationsStateCreateInfoEXT **/
function VkPipelineSampleLocationsStateCreateInfoEXT(opts) {
  if (new.target !== VkPipelineSampleLocationsStateCreateInfoEXT) {
    _VkPipelineSampleLocationsStateCreateInfoEXT.reset();
    return _VkPipelineSampleLocationsStateCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  this.sType = 0x3B9CF89A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleLocationsEnable !== void 0) this.sampleLocationsEnable = opts.sampleLocationsEnable;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

Object.defineProperties(VkPipelineSampleLocationsStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineSampleLocationsStateCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineSampleLocationsStateCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineSampleLocationsStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "sampleLocationsEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "sampleLocationsInfo": {
    get() {
    return this._sampleLocationsInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._sampleLocationsInfo = null;
  this.sType = 0x3B9CF89A;
};

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._sampleLocationsInfo !== null) {
    let sampleLocationsInfo = this._sampleLocationsInfo;
    sampleLocationsInfo.flush();
    if (this.memoryBuffer !== sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationsInfo.memoryBuffer).subarray(sampleLocationsInfo.$memoryOffset, sampleLocationsInfo.$memoryOffset + 0x28);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineSampleLocationsStateCreateInfoEXT.byteLength = 0x40;

VkPipelineSampleLocationsStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  sampleLocationsEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  sampleLocationsInfo: {
    byteOffset: 0x18,
    byteLength: 0x28
  },
};
/** VkPhysicalDeviceSampleLocationsPropertiesEXT **/
function VkPhysicalDeviceSampleLocationsPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceSampleLocationsPropertiesEXT) {
    _VkPhysicalDeviceSampleLocationsPropertiesEXT.reset();
    return _VkPhysicalDeviceSampleLocationsPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x14 });
  this._sampleLocationCoordinateRange = [...Array(2)].fill(0x0);
  
  
  this.sType = 0x3B9CF89B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSampleLocationsPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceSampleLocationsPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "sampleLocationSampleCounts": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "maxSampleLocationGridSize": {
    get() {
    return this._maxSampleLocationGridSize;
    },
    },
  "sampleLocationCoordinateRange": {
    get() {
    return [
      this.memoryViewFloat32[0x7],
      this.memoryViewFloat32[0x8]
    ];
    },
    },
  "sampleLocationSubPixelBits": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    },
  "variableSampleLocations": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    },
  
});

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  this._maxSampleLocationGridSize = null;
  this._sampleLocationCoordinateRange = null;
  
  
  this.sType = 0x3B9CF89B;
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.byteLength = 0x30;

VkPhysicalDeviceSampleLocationsPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  sampleLocationSampleCounts: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxSampleLocationGridSize: {
    byteOffset: 0x14,
    byteLength: 0x8
  },
  sampleLocationCoordinateRange: {
    byteOffset: 0x1C,
    byteLength: 0x8
  },
  sampleLocationSubPixelBits: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  variableSampleLocations: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
};
/** VkMultisamplePropertiesEXT **/
function VkMultisamplePropertiesEXT(opts) {
  if (new.target !== VkMultisamplePropertiesEXT) {
    _VkMultisamplePropertiesEXT.reset();
    return _VkMultisamplePropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9CF89C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMultisamplePropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMultisamplePropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMultisamplePropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMultisamplePropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxSampleLocationGridSize": {
    get() {
    return this._maxSampleLocationGridSize;
    },
    },
  
});

VkMultisamplePropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._maxSampleLocationGridSize = null;
  this.sType = 0x3B9CF89C;
};

VkMultisamplePropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMultisamplePropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
  
  
};

VkMultisamplePropertiesEXT.byteLength = 0x18;

VkMultisamplePropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxSampleLocationGridSize: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkSamplerReductionModeCreateInfoEXT **/
function VkSamplerReductionModeCreateInfoEXT(opts) {
  if (new.target !== VkSamplerReductionModeCreateInfoEXT) {
    _VkSamplerReductionModeCreateInfoEXT.reset();
    return _VkSamplerReductionModeCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9CC5D1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.reductionMode !== void 0) this.reductionMode = opts.reductionMode;
    
  }
};

Object.defineProperties(VkSamplerReductionModeCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerReductionModeCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSamplerReductionModeCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerReductionModeCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "reductionMode": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerReductionModeCreateInfoEXT.reductionMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSamplerReductionModeEXT(value)) {
      throw new RangeError("Invalid value for 'VkSamplerReductionModeCreateInfoEXT.reductionMode': '" + value + "' is not a value of 'VkSamplerReductionModeEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkSamplerReductionModeCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9CC5D1;
};

VkSamplerReductionModeCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerReductionModeCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerReductionModeCreateInfoEXT.byteLength = 0x18;

VkSamplerReductionModeCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  reductionMode: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT **/
function VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) {
    _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.reset();
    return _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D0C20;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.advancedBlendCoherentOperations !== void 0) this.advancedBlendCoherentOperations = opts.advancedBlendCoherentOperations;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "advancedBlendCoherentOperations": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D0C20;
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  advancedBlendCoherentOperations: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT **/
function VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) {
    _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.reset();
    return _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this.sType = 0x3B9D0C21;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "advancedBlendMaxColorAttachments": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "advancedBlendIndependentBlend": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  "advancedBlendNonPremultipliedSrcColor": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    },
  "advancedBlendNonPremultipliedDstColor": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    },
  "advancedBlendCorrelatedOverlap": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    },
  "advancedBlendAllOperations": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    },
  
});

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this.sType = 0x3B9D0C21;
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.byteLength = 0x28;

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  advancedBlendMaxColorAttachments: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  advancedBlendIndependentBlend: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  advancedBlendNonPremultipliedSrcColor: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  advancedBlendNonPremultipliedDstColor: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  advancedBlendCorrelatedOverlap: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  advancedBlendAllOperations: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
};
/** VkPipelineColorBlendAdvancedStateCreateInfoEXT **/
function VkPipelineColorBlendAdvancedStateCreateInfoEXT(opts) {
  if (new.target !== VkPipelineColorBlendAdvancedStateCreateInfoEXT) {
    _VkPipelineColorBlendAdvancedStateCreateInfoEXT.reset();
    return _VkPipelineColorBlendAdvancedStateCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D0C22;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcPremultiplied !== void 0) this.srcPremultiplied = opts.srcPremultiplied;
    if (opts.dstPremultiplied !== void 0) this.dstPremultiplied = opts.dstPremultiplied;
    if (opts.blendOverlap !== void 0) this.blendOverlap = opts.blendOverlap;
    
  }
};

Object.defineProperties(VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "srcPremultiplied": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "dstPremultiplied": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "blendOverlap": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkBlendOverlapEXT(value)) {
      throw new RangeError("Invalid value for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap': '" + value + "' is not a value of 'VkBlendOverlapEXT'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D0C22;
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.byteLength = 0x20;

VkPipelineColorBlendAdvancedStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcPremultiplied: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstPremultiplied: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  blendOverlap: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceInlineUniformBlockFeaturesEXT **/
function VkPhysicalDeviceInlineUniformBlockFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceInlineUniformBlockFeaturesEXT) {
    _VkPhysicalDeviceInlineUniformBlockFeaturesEXT.reset();
    return _VkPhysicalDeviceInlineUniformBlockFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CE510;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.inlineUniformBlock !== void 0) this.inlineUniformBlock = opts.inlineUniformBlock;
    if (opts.descriptorBindingInlineUniformBlockUpdateAfterBind !== void 0) this.descriptorBindingInlineUniformBlockUpdateAfterBind = opts.descriptorBindingInlineUniformBlockUpdateAfterBind;
    
  }
};

Object.defineProperties(VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceInlineUniformBlockFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceInlineUniformBlockFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceInlineUniformBlockFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "inlineUniformBlock": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "descriptorBindingInlineUniformBlockUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9CE510;
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  inlineUniformBlock: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  descriptorBindingInlineUniformBlockUpdateAfterBind: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceInlineUniformBlockPropertiesEXT **/
function VkPhysicalDeviceInlineUniformBlockPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceInlineUniformBlockPropertiesEXT) {
    _VkPhysicalDeviceInlineUniformBlockPropertiesEXT.reset();
    return _VkPhysicalDeviceInlineUniformBlockPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9CE511;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceInlineUniformBlockPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceInlineUniformBlockPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceInlineUniformBlockPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxInlineUniformBlockSize": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxPerStageDescriptorInlineUniformBlocks": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    },
  "maxDescriptorSetInlineUniformBlocks": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    },
  "maxDescriptorSetUpdateAfterBindInlineUniformBlocks": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    },
  
});

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9CE511;
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.byteLength = 0x28;

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxInlineUniformBlockSize: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxPerStageDescriptorInlineUniformBlocks: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  maxDescriptorSetInlineUniformBlocks: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindInlineUniformBlocks: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkWriteDescriptorSetInlineUniformBlockEXT **/
function VkWriteDescriptorSetInlineUniformBlockEXT(opts) {
  if (new.target !== VkWriteDescriptorSetInlineUniformBlockEXT) {
    _VkWriteDescriptorSetInlineUniformBlockEXT.reset();
    return _VkWriteDescriptorSetInlineUniformBlockEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pData = null;
  this.sType = 0x3B9CE512;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

Object.defineProperties(VkWriteDescriptorSetInlineUniformBlockEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkWriteDescriptorSetInlineUniformBlockEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWriteDescriptorSetInlineUniformBlockEXT.pNext' isn't allowed to be filled");
    }
    },
  "dataSize": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.dataSize': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pData": {
    get() {
    return this._pData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pData = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.pData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pData = null;
  this.sType = 0x3B9CE512;
};

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkWriteDescriptorSetInlineUniformBlockEXT.byteLength = 0x20;

VkWriteDescriptorSetInlineUniformBlockEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  dataSize: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pData: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorPoolInlineUniformBlockCreateInfoEXT **/
function VkDescriptorPoolInlineUniformBlockCreateInfoEXT(opts) {
  if (new.target !== VkDescriptorPoolInlineUniformBlockCreateInfoEXT) {
    _VkDescriptorPoolInlineUniformBlockCreateInfoEXT.reset();
    return _VkDescriptorPoolInlineUniformBlockCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9CE513;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxInlineUniformBlockBindings !== void 0) this.maxInlineUniformBlockBindings = opts.maxInlineUniformBlockBindings;
    
  }
};

Object.defineProperties(VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxInlineUniformBlockBindings": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.maxInlineUniformBlockBindings': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9CE513;
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.byteLength = 0x18;

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxInlineUniformBlockBindings: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineCoverageModulationStateCreateInfoNV **/
function VkPipelineCoverageModulationStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineCoverageModulationStateCreateInfoNV) {
    _VkPipelineCoverageModulationStateCreateInfoNV.reset();
    return _VkPipelineCoverageModulationStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pCoverageModulationTable = null;
  this.sType = 0x3B9D1BC0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageModulationMode !== void 0) this.coverageModulationMode = opts.coverageModulationMode;
    if (opts.coverageModulationTableEnable !== void 0) this.coverageModulationTableEnable = opts.coverageModulationTableEnable;
    if (opts.coverageModulationTableCount !== void 0) this.coverageModulationTableCount = opts.coverageModulationTableCount;
    if (opts.pCoverageModulationTable !== void 0) this.pCoverageModulationTable = opts.pCoverageModulationTable;
    
  }
};

Object.defineProperties(VkPipelineCoverageModulationStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCoverageModulationStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCoverageModulationStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "coverageModulationMode": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCoverageModulationModeNV(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode': '" + value + "' is not a value of 'VkCoverageModulationModeNV'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "coverageModulationTableEnable": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "coverageModulationTableCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "pCoverageModulationTable": {
    get() {
    return this._pCoverageModulationTable;
    },
    set(value) {
    if (value !== null && value.constructor === Float32Array) {
      this._pCoverageModulationTable = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCoverageModulationTable = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable': Expected 'Float32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineCoverageModulationStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pCoverageModulationTable = null;
  this.sType = 0x3B9D1BC0;
};

VkPipelineCoverageModulationStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageModulationStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCoverageModulationStateCreateInfoNV.byteLength = 0x28;

VkPipelineCoverageModulationStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  coverageModulationMode: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  coverageModulationTableEnable: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  coverageModulationTableCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pCoverageModulationTable: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkImageFormatListCreateInfoKHR **/
function VkImageFormatListCreateInfoKHR(opts) {
  if (new.target !== VkImageFormatListCreateInfoKHR) {
    _VkImageFormatListCreateInfoKHR.reset();
    return _VkImageFormatListCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pViewFormats = null;
  this.sType = 0x3B9D0838;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

Object.defineProperties(VkImageFormatListCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageFormatListCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageFormatListCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "viewFormatCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.viewFormatCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pViewFormats": {
    get() {
    return this._pViewFormats;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.pViewFormats': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageFormatListCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pViewFormats = null;
  this.sType = 0x3B9D0838;
};

VkImageFormatListCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatListCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageFormatListCreateInfoKHR.byteLength = 0x20;

VkImageFormatListCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  viewFormatCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pViewFormats: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkValidationCacheCreateInfoEXT **/
function VkValidationCacheCreateInfoEXT(opts) {
  if (new.target !== VkValidationCacheCreateInfoEXT) {
    _VkValidationCacheCreateInfoEXT.reset();
    return _VkValidationCacheCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = 0x3B9D3B00;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
    if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
    
  }
};

Object.defineProperties(VkValidationCacheCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkValidationCacheCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkValidationCacheCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "initialDataSize": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.initialDataSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x3] = BigInt(value);
    }
    },
  "pInitialData": {
    get() {
    return this._pInitialData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pInitialData = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pInitialData = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.pInitialData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkValidationCacheCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = 0x3B9D3B00;
};

VkValidationCacheCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationCacheCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkValidationCacheCreateInfoEXT.byteLength = 0x28;

VkValidationCacheCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  initialDataSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pInitialData: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkShaderModuleValidationCacheCreateInfoEXT **/
function VkShaderModuleValidationCacheCreateInfoEXT(opts) {
  if (new.target !== VkShaderModuleValidationCacheCreateInfoEXT) {
    _VkShaderModuleValidationCacheCreateInfoEXT.reset();
    return _VkShaderModuleValidationCacheCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._validationCache = null;
  this.sType = 0x3B9D3B01;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.validationCache !== void 0) this.validationCache = opts.validationCache;
    
  }
};

Object.defineProperties(VkShaderModuleValidationCacheCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleValidationCacheCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkShaderModuleValidationCacheCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkShaderModuleValidationCacheCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "validationCache": {
    get() {
    return this._validationCache;
    },
    set(value) {
    if (value !== null && value.constructor === VkValidationCacheEXT) {
      
      this._validationCache = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._validationCache = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleValidationCacheCreateInfoEXT.validationCache': Expected 'VkValidationCacheEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkShaderModuleValidationCacheCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._validationCache = null;
  this.sType = 0x3B9D3B01;
};

VkShaderModuleValidationCacheCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkShaderModuleValidationCacheCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkShaderModuleValidationCacheCreateInfoEXT.byteLength = 0x18;

VkShaderModuleValidationCacheCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  validationCache: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceMaintenance3Properties **/
function VkPhysicalDeviceMaintenance3Properties(opts) {
  if (new.target !== VkPhysicalDeviceMaintenance3Properties) {
    _VkPhysicalDeviceMaintenance3Properties.reset();
    return _VkPhysicalDeviceMaintenance3Properties;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D5A40;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMaintenance3Properties.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMaintenance3Properties.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMaintenance3Properties.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMaintenance3Properties.pNext' isn't allowed to be filled");
    }
    },
  "maxPerSetDescriptors": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxMemoryAllocationSize": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  
});

VkPhysicalDeviceMaintenance3Properties.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D5A40;
};

VkPhysicalDeviceMaintenance3Properties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMaintenance3Properties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceMaintenance3Properties.byteLength = 0x20;

VkPhysicalDeviceMaintenance3Properties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxPerSetDescriptors: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxMemoryAllocationSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceMaintenance3PropertiesKHR **/
function VkPhysicalDeviceMaintenance3PropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceMaintenance3PropertiesKHR) {
    _VkPhysicalDeviceMaintenance3PropertiesKHR.reset();
    return _VkPhysicalDeviceMaintenance3PropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D5A40;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMaintenance3PropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMaintenance3PropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMaintenance3PropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMaintenance3PropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxPerSetDescriptors": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxMemoryAllocationSize": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  
});

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D5A40;
};

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceMaintenance3PropertiesKHR.byteLength = 0x20;

VkPhysicalDeviceMaintenance3PropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxPerSetDescriptors: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxMemoryAllocationSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorSetLayoutSupport **/
function VkDescriptorSetLayoutSupport(opts) {
  if (new.target !== VkDescriptorSetLayoutSupport) {
    _VkDescriptorSetLayoutSupport.reset();
    return _VkDescriptorSetLayoutSupport;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D5A41;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutSupport.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetLayoutSupport.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
      switch (sType) {
          
        case 0x3B9D3EEC:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
    }
    
    }
    },
  "supported": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkDescriptorSetLayoutSupport.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D5A41;
};

VkDescriptorSetLayoutSupport.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutSupport.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDescriptorSetLayoutSupport.byteLength = 0x18;

VkDescriptorSetLayoutSupport.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  supported: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDescriptorSetLayoutSupportKHR **/
function VkDescriptorSetLayoutSupportKHR(opts) {
  if (new.target !== VkDescriptorSetLayoutSupportKHR) {
    _VkDescriptorSetLayoutSupportKHR.reset();
    return _VkDescriptorSetLayoutSupportKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D5A41;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutSupportKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetLayoutSupportKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
      switch (sType) {
          
        case 0x3B9D3EEC:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
    }
    
    }
    },
  "supported": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  
});

VkDescriptorSetLayoutSupportKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D5A41;
};

VkDescriptorSetLayoutSupportKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutSupportKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDescriptorSetLayoutSupportKHR.byteLength = 0x18;

VkDescriptorSetLayoutSupportKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  supported: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderDrawParametersFeatures **/
function VkPhysicalDeviceShaderDrawParametersFeatures(opts) {
  if (new.target !== VkPhysicalDeviceShaderDrawParametersFeatures) {
    _VkPhysicalDeviceShaderDrawParametersFeatures.reset();
    return _VkPhysicalDeviceShaderDrawParametersFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BC018;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderDrawParametersFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderDrawParametersFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderDrawParametersFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderDrawParametersFeatures.pNext' isn't allowed to be filled");
    }
    },
  "shaderDrawParameters": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderDrawParametersFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BC018;
};

VkPhysicalDeviceShaderDrawParametersFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDrawParametersFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderDrawParametersFeatures.byteLength = 0x18;

VkPhysicalDeviceShaderDrawParametersFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderDrawParameters: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderDrawParameterFeatures **/
function VkPhysicalDeviceShaderDrawParameterFeatures(opts) {
  if (new.target !== VkPhysicalDeviceShaderDrawParameterFeatures) {
    _VkPhysicalDeviceShaderDrawParameterFeatures.reset();
    return _VkPhysicalDeviceShaderDrawParameterFeatures;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BC018;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderDrawParameterFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderDrawParameterFeatures.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderDrawParameterFeatures.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderDrawParameterFeatures.pNext' isn't allowed to be filled");
    }
    },
  "shaderDrawParameters": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BC018;
};

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderDrawParameterFeatures.byteLength = 0x18;

VkPhysicalDeviceShaderDrawParameterFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderDrawParameters: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFloat16Int8FeaturesKHR **/
function VkPhysicalDeviceFloat16Int8FeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceFloat16Int8FeaturesKHR) {
    _VkPhysicalDeviceFloat16Int8FeaturesKHR.reset();
    return _VkPhysicalDeviceFloat16Int8FeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C0A50;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFloat16Int8FeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFloat16Int8FeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFloat16Int8FeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderFloat16": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "shaderInt8": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C0A50;
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceFloat16Int8FeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderFloat16: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shaderInt8: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFloatControlsPropertiesKHR **/
function VkPhysicalDeviceFloatControlsPropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceFloatControlsPropertiesKHR) {
    _VkPhysicalDeviceFloatControlsPropertiesKHR.reset();
    return _VkPhysicalDeviceFloatControlsPropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x58) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x58);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9DCB88;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFloatControlsPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFloatControlsPropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFloatControlsPropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFloatControlsPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "separateDenormSettings": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  "separateRoundingModeSettings": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat16": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat32": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat64": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    },
  "shaderDenormPreserveFloat16": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    },
  "shaderDenormPreserveFloat32": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    },
  "shaderDenormPreserveFloat64": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat16": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat32": {
    get() {
    return this.memoryViewUint32[0xD] !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat64": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    },
  "shaderRoundingModeRTEFloat16": {
    get() {
    return this.memoryViewUint32[0xF] !== 0;
    },
    },
  "shaderRoundingModeRTEFloat32": {
    get() {
    return this.memoryViewUint32[0x10] !== 0;
    },
    },
  "shaderRoundingModeRTEFloat64": {
    get() {
    return this.memoryViewUint32[0x11] !== 0;
    },
    },
  "shaderRoundingModeRTZFloat16": {
    get() {
    return this.memoryViewUint32[0x12] !== 0;
    },
    },
  "shaderRoundingModeRTZFloat32": {
    get() {
    return this.memoryViewUint32[0x13] !== 0;
    },
    },
  "shaderRoundingModeRTZFloat64": {
    get() {
    return this.memoryViewUint32[0x14] !== 0;
    },
    },
  
});

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x58], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9DCB88;
};

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x58));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x58), 0x0);
  
  
};

VkPhysicalDeviceFloatControlsPropertiesKHR.byteLength = 0x58;

VkPhysicalDeviceFloatControlsPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  separateDenormSettings: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  separateRoundingModeSettings: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  shaderSignedZeroInfNanPreserveFloat16: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  shaderSignedZeroInfNanPreserveFloat32: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  shaderSignedZeroInfNanPreserveFloat64: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  shaderDenormPreserveFloat16: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  shaderDenormPreserveFloat32: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  shaderDenormPreserveFloat64: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  shaderDenormFlushToZeroFloat16: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  shaderDenormFlushToZeroFloat32: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  shaderDenormFlushToZeroFloat64: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  shaderRoundingModeRTEFloat16: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  shaderRoundingModeRTEFloat32: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  shaderRoundingModeRTEFloat64: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  shaderRoundingModeRTZFloat16: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  shaderRoundingModeRTZFloat32: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  shaderRoundingModeRTZFloat64: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceHostQueryResetFeaturesEXT **/
function VkPhysicalDeviceHostQueryResetFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceHostQueryResetFeaturesEXT) {
    _VkPhysicalDeviceHostQueryResetFeaturesEXT.reset();
    return _VkPhysicalDeviceHostQueryResetFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9EC588;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    
  }
};

Object.defineProperties(VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceHostQueryResetFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceHostQueryResetFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceHostQueryResetFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "hostQueryReset": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9EC588;
};

VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceHostQueryResetFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceHostQueryResetFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  hostQueryReset: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkShaderResourceUsageAMD **/
function VkShaderResourceUsageAMD(opts) {
  if (new.target !== VkShaderResourceUsageAMD) {
    _VkShaderResourceUsageAMD.reset();
    return _VkShaderResourceUsageAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkShaderResourceUsageAMD.prototype, {
  "numUsedVgprs": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    },
  "numUsedSgprs": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    },
  "ldsSizePerLocalWorkGroup": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    },
  "ldsUsageSizeInBytes": {
    get() {
    return this.memoryViewBigInt64[0x2];
    },
    },
  "scratchMemUsageInBytes": {
    get() {
    return this.memoryViewBigInt64[0x3];
    },
    },
  
});

VkShaderResourceUsageAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  
  
  
  
  
};

VkShaderResourceUsageAMD.prototype.flush = function flush() {
  
  return true;
};

VkShaderResourceUsageAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
};

VkShaderResourceUsageAMD.byteLength = 0x20;

VkShaderResourceUsageAMD.memoryLayout = {
  numUsedVgprs: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  numUsedSgprs: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  ldsSizePerLocalWorkGroup: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  ldsUsageSizeInBytes: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  scratchMemUsageInBytes: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkShaderStatisticsInfoAMD **/
function VkShaderStatisticsInfoAMD(opts) {
  if (new.target !== VkShaderStatisticsInfoAMD) {
    _VkShaderStatisticsInfoAMD.reset();
    return _VkShaderStatisticsInfoAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._resourceUsage = new VkShaderResourceUsageAMD({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  
  
  
  this._computeWorkGroupSize = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkShaderStatisticsInfoAMD.prototype, {
  "shaderStageMask": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "resourceUsage": {
    get() {
    return this._resourceUsage;
    },
    },
  "numPhysicalVgprs": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    },
  "numPhysicalSgprs": {
    get() {
    return this.memoryViewUint32[0xB];
    },
    },
  "numAvailableVgprs": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    },
  "numAvailableSgprs": {
    get() {
    return this.memoryViewUint32[0xD];
    },
    },
  "computeWorkGroupSize": {
    get() {
    return [
      this.memoryViewUint32[0xE],
      this.memoryViewUint32[0xF],
      this.memoryViewUint32[0x10]
    ];
    },
    },
  
});

VkShaderStatisticsInfoAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._resourceUsage = null;
  
  
  
  
  this._computeWorkGroupSize = null;
  
};

VkShaderStatisticsInfoAMD.prototype.flush = function flush() {
  
  return true;
};

VkShaderStatisticsInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
  
  
};

VkShaderStatisticsInfoAMD.byteLength = 0x48;

VkShaderStatisticsInfoAMD.memoryLayout = {
  shaderStageMask: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  resourceUsage: {
    byteOffset: 0x8,
    byteLength: 0x20
  },
  numPhysicalVgprs: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  numPhysicalSgprs: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  numAvailableVgprs: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  numAvailableSgprs: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  computeWorkGroupSize: {
    byteOffset: 0x38,
    byteLength: 0xC
  },
};
/** VkDeviceQueueGlobalPriorityCreateInfoEXT **/
function VkDeviceQueueGlobalPriorityCreateInfoEXT(opts) {
  if (new.target !== VkDeviceQueueGlobalPriorityCreateInfoEXT) {
    _VkDeviceQueueGlobalPriorityCreateInfoEXT.reset();
    return _VkDeviceQueueGlobalPriorityCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D71B0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.globalPriority !== void 0) this.globalPriority = opts.globalPriority;
    
  }
};

Object.defineProperties(VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueGlobalPriorityCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceQueueGlobalPriorityCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "globalPriority": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkQueueGlobalPriorityEXT(value)) {
      throw new RangeError("Invalid value for 'VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority': '" + value + "' is not a value of 'VkQueueGlobalPriorityEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D71B0;
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.byteLength = 0x18;

VkDeviceQueueGlobalPriorityCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  globalPriority: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDebugUtilsObjectNameInfoEXT **/
function VkDebugUtilsObjectNameInfoEXT(opts) {
  if (new.target !== VkDebugUtilsObjectNameInfoEXT) {
    _VkDebugUtilsObjectNameInfoEXT.reset();
    return _VkDebugUtilsObjectNameInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = 0x3B9CBE00;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
    if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
    
  }
};

Object.defineProperties(VkDebugUtilsObjectNameInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsObjectNameInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsObjectNameInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.objectType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsObjectNameInfoEXT.objectType': '" + value + "' is not a value of 'VkObjectType'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "objectHandle": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.objectHandle': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "pObjectName": {
    get() {
    if (this._pObjectName !== null) {
      let str = textDecoder.decode(this._pObjectName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pObjectName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pObjectName);
    } else if (value === null) {
      this._pObjectName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.pObjectName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsObjectNameInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = 0x3B9CBE00;
};

VkDebugUtilsObjectNameInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsObjectNameInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugUtilsObjectNameInfoEXT.byteLength = 0x28;

VkDebugUtilsObjectNameInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  objectHandle: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  pObjectName: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkDebugUtilsObjectTagInfoEXT **/
function VkDebugUtilsObjectTagInfoEXT(opts) {
  if (new.target !== VkDebugUtilsObjectTagInfoEXT) {
    _VkDebugUtilsObjectTagInfoEXT.reset();
    return _VkDebugUtilsObjectTagInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = 0x3B9CBE01;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
    if (opts.tagName !== void 0) this.tagName = opts.tagName;
    if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
    if (opts.pTag !== void 0) this.pTag = opts.pTag;
    
  }
};

Object.defineProperties(VkDebugUtilsObjectTagInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsObjectTagInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsObjectTagInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.objectType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkObjectType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsObjectTagInfoEXT.objectType': '" + value + "' is not a value of 'VkObjectType'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "objectHandle": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.objectHandle': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "tagName": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.tagName': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  "tagSize": {
    get() {
    return this.memoryViewBigInt64[0x5];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.tagSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigInt64[0x5] = BigInt(value);
    }
    },
  "pTag": {
    get() {
    return this._pTag;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pTag = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pTag = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.pTag': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsObjectTagInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = 0x3B9CBE01;
};

VkDebugUtilsObjectTagInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsObjectTagInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugUtilsObjectTagInfoEXT.byteLength = 0x38;

VkDebugUtilsObjectTagInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  objectType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  objectHandle: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  tagName: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  tagSize: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  pTag: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
};
/** VkDebugUtilsLabelEXT **/
function VkDebugUtilsLabelEXT(opts) {
  if (new.target !== VkDebugUtilsLabelEXT) {
    _VkDebugUtilsLabelEXT.reset();
    return _VkDebugUtilsLabelEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._pLabelName = null;
  this._color = [...Array(4)].fill(0x0);
  this.sType = 0x3B9CBE02;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pLabelName !== void 0) this.pLabelName = opts.pLabelName;
    if (opts.color !== void 0) this.color = opts.color;
    
  }
};

Object.defineProperties(VkDebugUtilsLabelEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsLabelEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsLabelEXT.pNext' isn't allowed to be filled");
    }
    },
  "pLabelName": {
    get() {
    if (this._pLabelName !== null) {
      let str = textDecoder.decode(this._pLabelName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pLabelName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(this._pLabelName);
    } else if (value === null) {
      this._pLabelName = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.pLabelName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "color": {
    get() {
    return this._color;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._color = value;
    } else if (value === null) {
      this._color = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.color': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsLabelEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._pLabelName = null;
  this._color = null;
  this.sType = 0x3B9CBE02;
};

VkDebugUtilsLabelEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._color !== null) {
    let array = this._color;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkDebugUtilsLabelEXT.color'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.color[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0x6 + ii] = array[ii];
    };
  } else {
    this.memoryViewFloat32[0x6] = 0x0;
  }
  
  return true;
};

VkDebugUtilsLabelEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDebugUtilsLabelEXT.byteLength = 0x28;

VkDebugUtilsLabelEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pLabelName: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  color: {
    byteOffset: 0x18,
    byteLength: 0x10
  },
};
/** VkDebugUtilsMessengerCreateInfoEXT **/
function VkDebugUtilsMessengerCreateInfoEXT(opts) {
  if (new.target !== VkDebugUtilsMessengerCreateInfoEXT) {
    _VkDebugUtilsMessengerCreateInfoEXT.reset();
    return _VkDebugUtilsMessengerCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._pfnUserCallback = null;
  this._pUserData = null;
  this.sType = 0x3B9CBE04;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.messageSeverity !== void 0) this.messageSeverity = opts.messageSeverity;
    if (opts.messageType !== void 0) this.messageType = opts.messageType;
    if (opts.pfnUserCallback !== void 0) this.pfnUserCallback = opts.pfnUserCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkDebugUtilsMessengerCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsMessengerCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsMessengerCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "messageSeverity": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.messageSeverity': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "messageType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.messageType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "pfnUserCallback": {
    get() {
    return this._pfnUserCallback;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      this._pfnUserCallback = value;
    } else if (value === null) {
      this._pfnUserCallback = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.pfnUserCallback': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsMessengerCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  
  this._pfnUserCallback = null;
  this._pUserData = null;
  this.sType = 0x3B9CBE04;
};

VkDebugUtilsMessengerCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsMessengerCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugUtilsMessengerCreateInfoEXT.byteLength = 0x30;

VkDebugUtilsMessengerCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  messageSeverity: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  messageType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pfnUserCallback: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  pUserData: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkDebugUtilsMessengerCallbackDataEXT **/
function VkDebugUtilsMessengerCallbackDataEXT(opts) {
  if (new.target !== VkDebugUtilsMessengerCallbackDataEXT) {
    _VkDebugUtilsMessengerCallbackDataEXT.reset();
    return _VkDebugUtilsMessengerCallbackDataEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x60) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x60);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pMessageIdName = null;
  
  this._pMessage = null;
  
  this._pQueueLabels = null;
    this._pQueueLabelsNative = null;
  
  this._pCmdBufLabels = null;
    this._pCmdBufLabelsNative = null;
  
  this._pObjects = null;
    this._pObjectsNative = null;
  this.sType = 0x3B9CBE03;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pMessageIdName !== void 0) this.pMessageIdName = opts.pMessageIdName;
    if (opts.messageIdNumber !== void 0) this.messageIdNumber = opts.messageIdNumber;
    if (opts.pMessage !== void 0) this.pMessage = opts.pMessage;
    if (opts.queueLabelCount !== void 0) this.queueLabelCount = opts.queueLabelCount;
    if (opts.pQueueLabels !== void 0) this.pQueueLabels = opts.pQueueLabels;
    if (opts.cmdBufLabelCount !== void 0) this.cmdBufLabelCount = opts.cmdBufLabelCount;
    if (opts.pCmdBufLabels !== void 0) this.pCmdBufLabels = opts.pCmdBufLabels;
    if (opts.objectCount !== void 0) this.objectCount = opts.objectCount;
    if (opts.pObjects !== void 0) this.pObjects = opts.pObjects;
    
  }
};

Object.defineProperties(VkDebugUtilsMessengerCallbackDataEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDebugUtilsMessengerCallbackDataEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsMessengerCallbackDataEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "pMessageIdName": {
    get() {
    if (this._pMessageIdName !== null) {
      let str = textDecoder.decode(this._pMessageIdName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pMessageIdName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(this._pMessageIdName);
    } else if (value === null) {
      this._pMessageIdName = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pMessageIdName': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "messageIdNumber": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.messageIdNumber': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "pMessage": {
    get() {
    if (this._pMessage !== null) {
      let str = textDecoder.decode(this._pMessage);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pMessage = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(this._pMessage);
    } else if (value === null) {
      this._pMessage = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pMessage': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "queueLabelCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.queueLabelCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pQueueLabels": {
    get() {
    return this._pQueueLabels;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pQueueLabels = value;
    } else if (value === null) {
      this._pQueueLabels = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels': Expected 'Array VkDebugUtilsLabelEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "cmdBufLabelCount": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.cmdBufLabelCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  "pCmdBufLabels": {
    get() {
    return this._pCmdBufLabels;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pCmdBufLabels = value;
    } else if (value === null) {
      this._pCmdBufLabels = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels': Expected 'Array VkDebugUtilsLabelEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "objectCount": {
    get() {
    return this.memoryViewUint32[0x14];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.objectCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x14] = value;
    }
    },
  "pObjects": {
    get() {
    return this._pObjects;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pObjects = value;
    } else if (value === null) {
      this._pObjects = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects': Expected 'Array VkDebugUtilsObjectNameInfoEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDebugUtilsMessengerCallbackDataEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x60], 0x0);
  
  this._pNext = null;
  
  this._pMessageIdName = null;
  
  this._pMessage = null;
  
  this._pQueueLabels = null;
    this._pQueueLabelsNative = null;
  
  this._pCmdBufLabels = null;
    this._pCmdBufLabelsNative = null;
  
  this._pObjects = null;
    this._pObjectsNative = null;
  this.sType = 0x3B9CBE03;
};

VkDebugUtilsMessengerCallbackDataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pQueueLabels !== null) {
    let array = this._pQueueLabels;
    
    if (array.length !== this.queueLabelCount) {
      throw new RangeError("Invalid array length, expected length of 'queueLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDebugUtilsLabelEXT)) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels[" + ii + "]': Expected 'VkDebugUtilsLabelEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pQueueLabelsNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pQueueLabelsNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  
  if (this._pCmdBufLabels !== null) {
    let array = this._pCmdBufLabels;
    
    if (array.length !== this.cmdBufLabelCount) {
      throw new RangeError("Invalid array length, expected length of 'cmdBufLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDebugUtilsLabelEXT)) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels[" + ii + "]': Expected 'VkDebugUtilsLabelEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pCmdBufLabelsNative = nativeArray;
      this.memoryViewBigInt64[0x9] = nativeArray.address;
    } else {
      this._pCmdBufLabelsNative = null;
      this.memoryViewBigInt64[0x9] = BI0;
    }
  }
  
  
  if (this._pObjects !== null) {
    let array = this._pObjects;
    
    if (array.length !== this.objectCount) {
      throw new RangeError("Invalid array length, expected length of 'objectCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDebugUtilsObjectNameInfoEXT)) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects[" + ii + "]': Expected 'VkDebugUtilsObjectNameInfoEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pObjectsNative = nativeArray;
      this.memoryViewBigInt64[0xB] = nativeArray.address;
    } else {
      this._pObjectsNative = null;
      this.memoryViewBigInt64[0xB] = BI0;
    }
  }
  
  return true;
};

VkDebugUtilsMessengerCallbackDataEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkDebugUtilsMessengerCallbackDataEXT.byteLength = 0x60;

VkDebugUtilsMessengerCallbackDataEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pMessageIdName: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  messageIdNumber: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pMessage: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  queueLabelCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pQueueLabels: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  cmdBufLabelCount: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  pCmdBufLabels: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
  objectCount: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  pObjects: {
    byteOffset: 0x58,
    byteLength: 0x8
  },
};
/** VkImportMemoryHostPointerInfoEXT **/
function VkImportMemoryHostPointerInfoEXT(opts) {
  if (new.target !== VkImportMemoryHostPointerInfoEXT) {
    _VkImportMemoryHostPointerInfoEXT.reset();
    return _VkImportMemoryHostPointerInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pHostPointer = null;
  this.sType = 0x3B9D8150;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.pHostPointer !== void 0) this.pHostPointer = opts.pHostPointer;
    
  }
};

Object.defineProperties(VkImportMemoryHostPointerInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImportMemoryHostPointerInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryHostPointerInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.handleType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "pHostPointer": {
    get() {
    return this._pHostPointer;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pHostPointer = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pHostPointer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.pHostPointer': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImportMemoryHostPointerInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pHostPointer = null;
  this.sType = 0x3B9D8150;
};

VkImportMemoryHostPointerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryHostPointerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportMemoryHostPointerInfoEXT.byteLength = 0x20;

VkImportMemoryHostPointerInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  handleType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pHostPointer: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkMemoryHostPointerPropertiesEXT **/
function VkMemoryHostPointerPropertiesEXT(opts) {
  if (new.target !== VkMemoryHostPointerPropertiesEXT) {
    _VkMemoryHostPointerPropertiesEXT.reset();
    return _VkMemoryHostPointerPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D8151;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryHostPointerPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryHostPointerPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryHostPointerPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryHostPointerPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "memoryTypeBits": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkMemoryHostPointerPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D8151;
};

VkMemoryHostPointerPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryHostPointerPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryHostPointerPropertiesEXT.byteLength = 0x18;

VkMemoryHostPointerPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryTypeBits: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExternalMemoryHostPropertiesEXT **/
function VkPhysicalDeviceExternalMemoryHostPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceExternalMemoryHostPropertiesEXT) {
    _VkPhysicalDeviceExternalMemoryHostPropertiesEXT.reset();
    return _VkPhysicalDeviceExternalMemoryHostPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D8152;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "minImportedHostPointerAlignment": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    },
  
});

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D8152;
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  minImportedHostPointerAlignment: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceConservativeRasterizationPropertiesEXT **/
function VkPhysicalDeviceConservativeRasterizationPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceConservativeRasterizationPropertiesEXT) {
    _VkPhysicalDeviceConservativeRasterizationPropertiesEXT.reset();
    return _VkPhysicalDeviceConservativeRasterizationPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9C5488;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "primitiveOverestimationSize": {
    get() {
    return this.memoryViewFloat32[0x4];
    },
    },
  "maxExtraPrimitiveOverestimationSize": {
    get() {
    return this.memoryViewFloat32[0x5];
    },
    },
  "extraPrimitiveOverestimationSizeGranularity": {
    get() {
    return this.memoryViewFloat32[0x6];
    },
    },
  "primitiveUnderestimation": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    },
  "conservativePointAndLineRasterization": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    },
  "degenerateTrianglesRasterized": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    },
  "degenerateLinesRasterized": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    },
  "fullyCoveredFragmentShaderInputVariable": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    },
  "conservativeRasterizationPostDepthCoverage": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    },
  
});

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9C5488;
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x38));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x38), 0x0);
  
  
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.byteLength = 0x38;

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  primitiveOverestimationSize: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxExtraPrimitiveOverestimationSize: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  extraPrimitiveOverestimationSizeGranularity: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  primitiveUnderestimation: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  conservativePointAndLineRasterization: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  degenerateTrianglesRasterized: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  degenerateLinesRasterized: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  fullyCoveredFragmentShaderInputVariable: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  conservativeRasterizationPostDepthCoverage: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkCalibratedTimestampInfoEXT **/
function VkCalibratedTimestampInfoEXT(opts) {
  if (new.target !== VkCalibratedTimestampInfoEXT) {
    _VkCalibratedTimestampInfoEXT.reset();
    return _VkCalibratedTimestampInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D98C0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timeDomain !== void 0) this.timeDomain = opts.timeDomain;
    
  }
};

Object.defineProperties(VkCalibratedTimestampInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCalibratedTimestampInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCalibratedTimestampInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCalibratedTimestampInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "timeDomain": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCalibratedTimestampInfoEXT.timeDomain': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkTimeDomainEXT(value)) {
      throw new RangeError("Invalid value for 'VkCalibratedTimestampInfoEXT.timeDomain': '" + value + "' is not a value of 'VkTimeDomainEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkCalibratedTimestampInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D98C0;
};

VkCalibratedTimestampInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCalibratedTimestampInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCalibratedTimestampInfoEXT.byteLength = 0x18;

VkCalibratedTimestampInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  timeDomain: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderCorePropertiesAMD **/
function VkPhysicalDeviceShaderCorePropertiesAMD(opts) {
  if (new.target !== VkPhysicalDeviceShaderCorePropertiesAMD) {
    _VkPhysicalDeviceShaderCorePropertiesAMD.reset();
    return _VkPhysicalDeviceShaderCorePropertiesAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x48) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x48);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D9CA8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderCorePropertiesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderCorePropertiesAMD.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderCorePropertiesAMD.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderCorePropertiesAMD.pNext' isn't allowed to be filled");
    }
    },
  "shaderEngineCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "shaderArraysPerEngineCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "computeUnitsPerShaderArray": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    },
  "simdPerComputeUnit": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    },
  "wavefrontsPerSimd": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    },
  "wavefrontSize": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    },
  "sgprsPerSimd": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    },
  "minSgprAllocation": {
    get() {
    return this.memoryViewUint32[0xB];
    },
    },
  "maxSgprAllocation": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    },
  "sgprAllocationGranularity": {
    get() {
    return this.memoryViewUint32[0xD];
    },
    },
  "vgprsPerSimd": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    },
  "minVgprAllocation": {
    get() {
    return this.memoryViewUint32[0xF];
    },
    },
  "maxVgprAllocation": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    },
  "vgprAllocationGranularity": {
    get() {
    return this.memoryViewUint32[0x11];
    },
    },
  
});

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x48], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D9CA8;
};

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
};

VkPhysicalDeviceShaderCorePropertiesAMD.byteLength = 0x48;

VkPhysicalDeviceShaderCorePropertiesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderEngineCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shaderArraysPerEngineCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  computeUnitsPerShaderArray: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  simdPerComputeUnit: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  wavefrontsPerSimd: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  wavefrontSize: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  sgprsPerSimd: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  minSgprAllocation: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  maxSgprAllocation: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  sgprAllocationGranularity: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  vgprsPerSimd: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  minVgprAllocation: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  maxVgprAllocation: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  vgprAllocationGranularity: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
};
/** VkPipelineRasterizationConservativeStateCreateInfoEXT **/
function VkPipelineRasterizationConservativeStateCreateInfoEXT(opts) {
  if (new.target !== VkPipelineRasterizationConservativeStateCreateInfoEXT) {
    _VkPipelineRasterizationConservativeStateCreateInfoEXT.reset();
    return _VkPipelineRasterizationConservativeStateCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C5489;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.conservativeRasterizationMode !== void 0) this.conservativeRasterizationMode = opts.conservativeRasterizationMode;
    if (opts.extraPrimitiveOverestimationSize !== void 0) this.extraPrimitiveOverestimationSize = opts.extraPrimitiveOverestimationSize;
    
  }
};

Object.defineProperties(VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "conservativeRasterizationMode": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkConservativeRasterizationModeEXT(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode': '" + value + "' is not a value of 'VkConservativeRasterizationModeEXT'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "extraPrimitiveOverestimationSize": {
    get() {
    return this.memoryViewFloat32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.extraPrimitiveOverestimationSize': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x6] = value;
    }
    },
  
});

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C5489;
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.byteLength = 0x20;

VkPipelineRasterizationConservativeStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  conservativeRasterizationMode: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  extraPrimitiveOverestimationSize: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceDescriptorIndexingFeaturesEXT **/
function VkPhysicalDeviceDescriptorIndexingFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceDescriptorIndexingFeaturesEXT) {
    _VkPhysicalDeviceDescriptorIndexingFeaturesEXT.reset();
    return _VkPhysicalDeviceDescriptorIndexingFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x60) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x60);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D3EE9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "shaderInputAttachmentArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "shaderUniformTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "shaderStorageTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  "shaderUniformBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x7] = value | 0;
    }
    },
  "shaderSampledImageArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x8] = value | 0;
    }
    },
  "shaderStorageBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x9] = value | 0;
    }
    },
  "shaderStorageImageArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xA] = value | 0;
    }
    },
  "shaderInputAttachmentArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xB] = value | 0;
    }
    },
  "shaderUniformTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xC] = value | 0;
    }
    },
  "shaderStorageTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryViewUint32[0xD] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xD] = value | 0;
    }
    },
  "descriptorBindingUniformBufferUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xE] = value | 0;
    }
    },
  "descriptorBindingSampledImageUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0xF] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0xF] = value | 0;
    }
    },
  "descriptorBindingStorageImageUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0x10] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x10] = value | 0;
    }
    },
  "descriptorBindingStorageBufferUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0x11] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x11] = value | 0;
    }
    },
  "descriptorBindingUniformTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0x12] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x12] = value | 0;
    }
    },
  "descriptorBindingStorageTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0x13] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x13] = value | 0;
    }
    },
  "descriptorBindingUpdateUnusedWhilePending": {
    get() {
    return this.memoryViewUint32[0x14] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x14] = value | 0;
    }
    },
  "descriptorBindingPartiallyBound": {
    get() {
    return this.memoryViewUint32[0x15] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x15] = value | 0;
    }
    },
  "descriptorBindingVariableDescriptorCount": {
    get() {
    return this.memoryViewUint32[0x16] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x16] = value | 0;
    }
    },
  "runtimeDescriptorArray": {
    get() {
    return this.memoryViewUint32[0x17] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x17] = value | 0;
    }
    },
  
});

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x60], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D3EE9;
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.byteLength = 0x60;

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderInputAttachmentArrayDynamicIndexing: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shaderUniformTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  shaderStorageTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  shaderUniformBufferArrayNonUniformIndexing: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  shaderSampledImageArrayNonUniformIndexing: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  shaderStorageBufferArrayNonUniformIndexing: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  shaderStorageImageArrayNonUniformIndexing: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  shaderInputAttachmentArrayNonUniformIndexing: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  shaderUniformTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  shaderStorageTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  descriptorBindingUniformBufferUpdateAfterBind: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  descriptorBindingSampledImageUpdateAfterBind: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  descriptorBindingStorageImageUpdateAfterBind: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  descriptorBindingStorageBufferUpdateAfterBind: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  descriptorBindingUniformTexelBufferUpdateAfterBind: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  descriptorBindingStorageTexelBufferUpdateAfterBind: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  descriptorBindingUpdateUnusedWhilePending: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  descriptorBindingPartiallyBound: {
    byteOffset: 0x54,
    byteLength: 0x4
  },
  descriptorBindingVariableDescriptorCount: {
    byteOffset: 0x58,
    byteLength: 0x4
  },
  runtimeDescriptorArray: {
    byteOffset: 0x5C,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceDescriptorIndexingPropertiesEXT **/
function VkPhysicalDeviceDescriptorIndexingPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceDescriptorIndexingPropertiesEXT) {
    _VkPhysicalDeviceDescriptorIndexingPropertiesEXT.reset();
    return _VkPhysicalDeviceDescriptorIndexingPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x70) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x70) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x70) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x70) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x70);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D3EEA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxUpdateAfterBindDescriptorsInAllPools": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "shaderUniformBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  "shaderSampledImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    },
  "shaderStorageBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    },
  "shaderStorageImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    },
  "shaderInputAttachmentArrayNonUniformIndexingNative": {
    get() {
    return this.memoryViewUint32[0x9] !== 0;
    },
    },
  "robustBufferAccessUpdateAfterBind": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    },
  "quadDivergentImplicitLod": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSamplers": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    },
  "maxPerStageDescriptorUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryViewUint32[0xD];
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSampledImages": {
    get() {
    return this.memoryViewUint32[0xF];
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageImages": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    },
  "maxPerStageDescriptorUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryViewUint32[0x11];
    },
    },
  "maxPerStageUpdateAfterBindResources": {
    get() {
    return this.memoryViewUint32[0x12];
    },
    },
  "maxDescriptorSetUpdateAfterBindSamplers": {
    get() {
    return this.memoryViewUint32[0x13];
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryViewUint32[0x14];
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic": {
    get() {
    return this.memoryViewUint32[0x15];
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryViewUint32[0x16];
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic": {
    get() {
    return this.memoryViewUint32[0x17];
    },
    },
  "maxDescriptorSetUpdateAfterBindSampledImages": {
    get() {
    return this.memoryViewUint32[0x18];
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageImages": {
    get() {
    return this.memoryViewUint32[0x19];
    },
    },
  "maxDescriptorSetUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryViewUint32[0x1A];
    },
    },
  
});

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x70], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D3EEA;
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x70));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x70), 0x0);
  
  
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.byteLength = 0x70;

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxUpdateAfterBindDescriptorsInAllPools: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shaderUniformBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  shaderSampledImageArrayNonUniformIndexingNative: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  shaderStorageBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  shaderStorageImageArrayNonUniformIndexingNative: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  shaderInputAttachmentArrayNonUniformIndexingNative: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  robustBufferAccessUpdateAfterBind: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  quadDivergentImplicitLod: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindSamplers: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindUniformBuffers: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindStorageBuffers: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindSampledImages: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindStorageImages: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  maxPerStageDescriptorUpdateAfterBindInputAttachments: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  maxPerStageUpdateAfterBindResources: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindSamplers: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindUniformBuffers: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: {
    byteOffset: 0x54,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindStorageBuffers: {
    byteOffset: 0x58,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: {
    byteOffset: 0x5C,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindSampledImages: {
    byteOffset: 0x60,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindStorageImages: {
    byteOffset: 0x64,
    byteLength: 0x4
  },
  maxDescriptorSetUpdateAfterBindInputAttachments: {
    byteOffset: 0x68,
    byteLength: 0x4
  },
};
/** VkDescriptorSetLayoutBindingFlagsCreateInfoEXT **/
function VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(opts) {
  if (new.target !== VkDescriptorSetLayoutBindingFlagsCreateInfoEXT) {
    _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.reset();
    return _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pBindingFlags = null;
  this.sType = 0x3B9D3EE8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindingFlags !== void 0) this.pBindingFlags = opts.pBindingFlags;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "bindingCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.bindingCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pBindingFlags": {
    get() {
    return this._pBindingFlags;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pBindingFlags = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pBindingFlags = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pBindingFlags = null;
  this.sType = 0x3B9D3EE8;
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.byteLength = 0x20;

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  bindingCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pBindingFlags: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorSetVariableDescriptorCountAllocateInfoEXT **/
function VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(opts) {
  if (new.target !== VkDescriptorSetVariableDescriptorCountAllocateInfoEXT) {
    _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.reset();
    return _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDescriptorCounts = null;
  this.sType = 0x3B9D3EEB;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pDescriptorCounts !== void 0) this.pDescriptorCounts = opts.pDescriptorCounts;
    
  }
};

Object.defineProperties(VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "descriptorSetCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.descriptorSetCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDescriptorCounts": {
    get() {
    return this._pDescriptorCounts;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDescriptorCounts = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDescriptorCounts = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pDescriptorCounts = null;
  this.sType = 0x3B9D3EEB;
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.byteLength = 0x20;

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  descriptorSetCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDescriptorCounts: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDescriptorSetVariableDescriptorCountLayoutSupportEXT **/
function VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(opts) {
  if (new.target !== VkDescriptorSetVariableDescriptorCountLayoutSupportEXT) {
    _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.reset();
    return _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D3EEC;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxVariableDescriptorCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D3EEC;
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.byteLength = 0x18;

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxVariableDescriptorCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkAttachmentDescription2KHR **/
function VkAttachmentDescription2KHR(opts) {
  if (new.target !== VkAttachmentDescription2KHR) {
    _VkAttachmentDescription2KHR.reset();
    return _VkAttachmentDescription2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9C73C8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescription2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAttachmentDescription2KHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "format": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.format': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.format': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "samples": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.samples': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "loadOp": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.loadOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentLoadOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.loadOp': '" + value + "' is not a value of 'VkAttachmentLoadOp'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "storeOp": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.storeOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentStoreOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.storeOp': '" + value + "' is not a value of 'VkAttachmentStoreOp'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "stencilLoadOp": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.stencilLoadOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentLoadOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.stencilLoadOp': '" + value + "' is not a value of 'VkAttachmentLoadOp'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "stencilStoreOp": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.stencilStoreOp': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAttachmentStoreOp(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.stencilStoreOp': '" + value + "' is not a value of 'VkAttachmentStoreOp'");
    }
    this.memoryViewInt32[0xA] = value;
    }
    },
  "initialLayout": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.initialLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.initialLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0xB] = value;
    }
    },
  "finalLayout": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.finalLayout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentDescription2KHR.finalLayout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  
});

VkAttachmentDescription2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9C73C8;
};

VkAttachmentDescription2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentDescription2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAttachmentDescription2KHR.byteLength = 0x38;

VkAttachmentDescription2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  format: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  samples: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  loadOp: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  storeOp: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  stencilLoadOp: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  stencilStoreOp: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  initialLayout: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  finalLayout: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
};
/** VkAttachmentReference2KHR **/
function VkAttachmentReference2KHR(opts) {
  if (new.target !== VkAttachmentReference2KHR) {
    _VkAttachmentReference2KHR.reset();
    return _VkAttachmentReference2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C73C9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkAttachmentReference2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentReference2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAttachmentReference2KHR.pNext' isn't allowed to be filled");
    }
    },
  "attachment": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.attachment': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "layout": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.layout': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageLayout(value)) {
      throw new RangeError("Invalid value for 'VkAttachmentReference2KHR.layout': '" + value + "' is not a value of 'VkImageLayout'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "aspectMask": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.aspectMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  
});

VkAttachmentReference2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9C73C9;
};

VkAttachmentReference2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentReference2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAttachmentReference2KHR.byteLength = 0x20;

VkAttachmentReference2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  attachment: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  layout: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  aspectMask: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkSubpassDescription2KHR **/
function VkSubpassDescription2KHR(opts) {
  if (new.target !== VkSubpassDescription2KHR) {
    _VkSubpassDescription2KHR.reset();
    return _VkSubpassDescription2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x58) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x58);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pInputAttachments = null;
    this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
    this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
    this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  this.sType = 0x3B9C73CA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.viewMask !== void 0) this.viewMask = opts.viewMask;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

Object.defineProperties(VkSubpassDescription2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSubpassDescription2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9DD359:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pipelineBindPoint': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPipelineBindPoint(value)) {
      throw new RangeError("Invalid value for 'VkSubpassDescription2KHR.pipelineBindPoint': '" + value + "' is not a value of 'VkPipelineBindPoint'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "viewMask": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.viewMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "inputAttachmentCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.inputAttachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "pInputAttachments": {
    get() {
    return this._pInputAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pInputAttachments': Expected 'Array VkAttachmentReference2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "colorAttachmentCount": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.colorAttachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "pColorAttachments": {
    get() {
    return this._pColorAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pColorAttachments': Expected 'Array VkAttachmentReference2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pResolveAttachments": {
    get() {
    return this._pResolveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pResolveAttachments': Expected 'Array VkAttachmentReference2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pDepthStencilAttachment": {
    get() {
    return this._pDepthStencilAttachment;
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2KHR) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryViewBigInt64[0x8] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pDepthStencilAttachment': Expected 'VkAttachmentReference2KHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preserveAttachmentCount": {
    get() {
    return this.memoryViewUint32[0x12];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.preserveAttachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x12] = value;
    }
    },
  "pPreserveAttachments": {
    get() {
    return this._pPreserveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryViewBigInt64[0xA] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pPreserveAttachments': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescription2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x58], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pInputAttachments = null;
    this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
    this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
    this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  this.sType = 0x3B9C73CA;
};

VkSubpassDescription2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription2KHR.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2KHR)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pInputAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pInputAttachmentsNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2KHR)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pColorAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x6] = nativeArray.address;
    } else {
      this._pColorAttachmentsNative = null;
      this.memoryViewBigInt64[0x6] = BI0;
    }
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2KHR)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pResolveAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pResolveAttachmentsNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkSubpassDescription2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkSubpassDescription2KHR.byteLength = 0x58;

VkSubpassDescription2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pipelineBindPoint: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  viewMask: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  inputAttachmentCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pInputAttachments: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  colorAttachmentCount: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  pColorAttachments: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  pResolveAttachments: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  pDepthStencilAttachment: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
  preserveAttachmentCount: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  pPreserveAttachments: {
    byteOffset: 0x50,
    byteLength: 0x8
  },
};
/** VkSubpassDependency2KHR **/
function VkSubpassDependency2KHR(opts) {
  if (new.target !== VkSubpassDependency2KHR) {
    _VkSubpassDependency2KHR.reset();
    return _VkSubpassDependency2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = 0x3B9C73CB;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    if (opts.viewOffset !== void 0) this.viewOffset = opts.viewOffset;
    
  }
};

Object.defineProperties(VkSubpassDependency2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSubpassDependency2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassDependency2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcSubpass": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.srcSubpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "dstSubpass": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dstSubpass': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "srcStageMask": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.srcStageMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "dstStageMask": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dstStageMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.srcAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dstAccessMask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "dependencyFlags": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dependencyFlags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xA] = value;
    }
    },
  "viewOffset": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.viewOffset': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0xB] = value;
    }
    },
  
});

VkSubpassDependency2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = 0x3B9C73CB;
};

VkSubpassDependency2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDependency2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassDependency2KHR.byteLength = 0x30;

VkSubpassDependency2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  srcSubpass: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  dstSubpass: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  srcStageMask: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  dstStageMask: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  srcAccessMask: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  dstAccessMask: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  dependencyFlags: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  viewOffset: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
};
/** VkRenderPassCreateInfo2KHR **/
function VkRenderPassCreateInfo2KHR(opts) {
  if (new.target !== VkRenderPassCreateInfo2KHR) {
    _VkRenderPassCreateInfo2KHR.reset();
    return _VkRenderPassCreateInfo2KHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x50) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x50);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
    this._pSubpassesNative = null;
  
  this._pDependencies = null;
    this._pDependenciesNative = null;
  
  this._pCorrelatedViewMasks = null;
  this.sType = 0x3B9C73CC;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    if (opts.correlatedViewMaskCount !== void 0) this.correlatedViewMaskCount = opts.correlatedViewMaskCount;
    if (opts.pCorrelatedViewMasks !== void 0) this.pCorrelatedViewMasks = opts.pCorrelatedViewMasks;
    
  }
};

Object.defineProperties(VkRenderPassCreateInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassCreateInfo2KHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassCreateInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.attachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pAttachments": {
    get() {
    return this._pAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pAttachments': Expected 'Array VkAttachmentDescription2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "subpassCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.subpassCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pSubpasses": {
    get() {
    return this._pSubpasses;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pSubpasses': Expected 'Array VkSubpassDescription2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.dependencyCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "pDependencies": {
    get() {
    return this._pDependencies;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pDependencies': Expected 'Array VkSubpassDependency2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "correlatedViewMaskCount": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.correlatedViewMaskCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x10] = value;
    }
    },
  "pCorrelatedViewMasks": {
    get() {
    return this._pCorrelatedViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelatedViewMasks = value;
      this.memoryViewBigInt64[0x9] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCorrelatedViewMasks = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassCreateInfo2KHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x50], 0x0);
  
  this._pNext = null;
  
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
    this._pSubpassesNative = null;
  
  this._pDependencies = null;
    this._pDependenciesNative = null;
  
  this._pCorrelatedViewMasks = null;
  this.sType = 0x3B9C73CC;
};

VkRenderPassCreateInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo2KHR.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentDescription2KHR)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAttachmentsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo2KHR.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDescription2KHR)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSubpassesNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pSubpassesNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo2KHR.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDependency2KHR)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pDependencies[" + ii + "]': Expected 'VkSubpassDependency2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDependenciesNative = nativeArray;
      this.memoryViewBigInt64[0x7] = nativeArray.address;
    } else {
      this._pDependenciesNative = null;
      this.memoryViewBigInt64[0x7] = BI0;
    }
  }
  
  return true;
};

VkRenderPassCreateInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkRenderPassCreateInfo2KHR.byteLength = 0x50;

VkRenderPassCreateInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  attachmentCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pAttachments: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  subpassCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pSubpasses: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  dependencyCount: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  pDependencies: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  correlatedViewMaskCount: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  pCorrelatedViewMasks: {
    byteOffset: 0x48,
    byteLength: 0x8
  },
};
/** VkSubpassBeginInfoKHR **/
function VkSubpassBeginInfoKHR(opts) {
  if (new.target !== VkSubpassBeginInfoKHR) {
    _VkSubpassBeginInfoKHR.reset();
    return _VkSubpassBeginInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C73CD;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.contents !== void 0) this.contents = opts.contents;
    
  }
};

Object.defineProperties(VkSubpassBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassBeginInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSubpassBeginInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "contents": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassBeginInfoKHR.contents': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSubpassContents(value)) {
      throw new RangeError("Invalid value for 'VkSubpassBeginInfoKHR.contents': '" + value + "' is not a value of 'VkSubpassContents'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkSubpassBeginInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C73CD;
};

VkSubpassBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassBeginInfoKHR.byteLength = 0x18;

VkSubpassBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  contents: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSubpassEndInfoKHR **/
function VkSubpassEndInfoKHR(opts) {
  if (new.target !== VkSubpassEndInfoKHR) {
    _VkSubpassEndInfoKHR.reset();
    return _VkSubpassEndInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this.sType = 0x3B9C73CE;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSubpassEndInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassEndInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSubpassEndInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassEndInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  
});

VkSubpassEndInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  this._pNext = null;
  this.sType = 0x3B9C73CE;
};

VkSubpassEndInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassEndInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassEndInfoKHR.byteLength = 0x10;

VkSubpassEndInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkVertexInputBindingDivisorDescriptionEXT **/
function VkVertexInputBindingDivisorDescriptionEXT(opts) {
  if (new.target !== VkVertexInputBindingDivisorDescriptionEXT) {
    _VkVertexInputBindingDivisorDescriptionEXT.reset();
    return _VkVertexInputBindingDivisorDescriptionEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.divisor !== void 0) this.divisor = opts.divisor;
    
  }
};

Object.defineProperties(VkVertexInputBindingDivisorDescriptionEXT.prototype, {
  "binding": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDivisorDescriptionEXT.binding': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "divisor": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDivisorDescriptionEXT.divisor': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  
});

VkVertexInputBindingDivisorDescriptionEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkVertexInputBindingDivisorDescriptionEXT.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputBindingDivisorDescriptionEXT.prototype.reflect = function reflect(memoryAddress) {
  
};

VkVertexInputBindingDivisorDescriptionEXT.byteLength = 0x8;

VkVertexInputBindingDivisorDescriptionEXT.memoryLayout = {
  binding: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  divisor: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkPipelineVertexInputDivisorStateCreateInfoEXT **/
function VkPipelineVertexInputDivisorStateCreateInfoEXT(opts) {
  if (new.target !== VkPipelineVertexInputDivisorStateCreateInfoEXT) {
    _VkPipelineVertexInputDivisorStateCreateInfoEXT.reset();
    return _VkPipelineVertexInputDivisorStateCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pVertexBindingDivisors = null;
    this._pVertexBindingDivisorsNative = null;
  this.sType = 0x3B9DB031;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexBindingDivisorCount !== void 0) this.vertexBindingDivisorCount = opts.vertexBindingDivisorCount;
    if (opts.pVertexBindingDivisors !== void 0) this.pVertexBindingDivisors = opts.pVertexBindingDivisors;
    
  }
};

Object.defineProperties(VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineVertexInputDivisorStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "vertexBindingDivisorCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.vertexBindingDivisorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pVertexBindingDivisors": {
    get() {
    return this._pVertexBindingDivisors;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexBindingDivisors = value;
    } else if (value === null) {
      this._pVertexBindingDivisors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors': Expected 'Array VkVertexInputBindingDivisorDescriptionEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pVertexBindingDivisors = null;
    this._pVertexBindingDivisorsNative = null;
  this.sType = 0x3B9DB031;
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pVertexBindingDivisors !== null) {
    let array = this._pVertexBindingDivisors;
    
    if (array.length !== this.vertexBindingDivisorCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexBindingDivisorCount' for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkVertexInputBindingDivisorDescriptionEXT)) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors[" + ii + "]': Expected 'VkVertexInputBindingDivisorDescriptionEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pVertexBindingDivisorsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pVertexBindingDivisorsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.byteLength = 0x20;

VkPipelineVertexInputDivisorStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  vertexBindingDivisorCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pVertexBindingDivisors: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT **/
function VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) {
    _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.reset();
    return _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DB030;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxVertexAttribDivisor": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  
});

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DB030;
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxVertexAttribDivisor: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDevicePCIBusInfoPropertiesEXT **/
function VkPhysicalDevicePCIBusInfoPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDevicePCIBusInfoPropertiesEXT) {
    _VkPhysicalDevicePCIBusInfoPropertiesEXT.reset();
    return _VkPhysicalDevicePCIBusInfoPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9E0620;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePCIBusInfoPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevicePCIBusInfoPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePCIBusInfoPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "pciDomain": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "pciBus": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "pciDevice": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    },
  "pciFunction": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    },
  
});

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9E0620;
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.byteLength = 0x20;

VkPhysicalDevicePCIBusInfoPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pciDomain: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pciBus: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pciDevice: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pciFunction: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkCommandBufferInheritanceConditionalRenderingInfoEXT **/
function VkCommandBufferInheritanceConditionalRenderingInfoEXT(opts) {
  if (new.target !== VkCommandBufferInheritanceConditionalRenderingInfoEXT) {
    _VkCommandBufferInheritanceConditionalRenderingInfoEXT.reset();
    return _VkCommandBufferInheritanceConditionalRenderingInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C0668;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conditionalRenderingEnable !== void 0) this.conditionalRenderingEnable = opts.conditionalRenderingEnable;
    
  }
};

Object.defineProperties(VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceConditionalRenderingInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCommandBufferInheritanceConditionalRenderingInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandBufferInheritanceConditionalRenderingInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "conditionalRenderingEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C0668;
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.byteLength = 0x18;

VkCommandBufferInheritanceConditionalRenderingInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  conditionalRenderingEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDevice8BitStorageFeaturesKHR **/
function VkPhysicalDevice8BitStorageFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDevice8BitStorageFeaturesKHR) {
    _VkPhysicalDevice8BitStorageFeaturesKHR.reset();
    return _VkPhysicalDevice8BitStorageFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D7D68;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    
  }
};

Object.defineProperties(VkPhysicalDevice8BitStorageFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevice8BitStorageFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDevice8BitStorageFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice8BitStorageFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer8BitAccess": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "uniformAndStorageBuffer8BitAccess": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "storagePushConstant8": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9D7D68;
};

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDevice8BitStorageFeaturesKHR.byteLength = 0x20;

VkPhysicalDevice8BitStorageFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  storageBuffer8BitAccess: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  uniformAndStorageBuffer8BitAccess: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  storagePushConstant8: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceConditionalRenderingFeaturesEXT **/
function VkPhysicalDeviceConditionalRenderingFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceConditionalRenderingFeaturesEXT) {
    _VkPhysicalDeviceConditionalRenderingFeaturesEXT.reset();
    return _VkPhysicalDeviceConditionalRenderingFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C0669;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conditionalRendering !== void 0) this.conditionalRendering = opts.conditionalRendering;
    if (opts.inheritedConditionalRendering !== void 0) this.inheritedConditionalRendering = opts.inheritedConditionalRendering;
    
  }
};

Object.defineProperties(VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceConditionalRenderingFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceConditionalRenderingFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceConditionalRenderingFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "conditionalRendering": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "inheritedConditionalRendering": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C0669;
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceConditionalRenderingFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  conditionalRendering: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  inheritedConditionalRendering: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceVulkanMemoryModelFeaturesKHR **/
function VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceVulkanMemoryModelFeaturesKHR) {
    _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.reset();
    return _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E0238;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "vulkanMemoryModel": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "vulkanMemoryModelDeviceScope": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "vulkanMemoryModelAvailabilityVisibilityChains": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E0238;
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.byteLength = 0x20;

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  vulkanMemoryModel: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  vulkanMemoryModelDeviceScope: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  vulkanMemoryModelAvailabilityVisibilityChains: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderAtomicInt64FeaturesKHR **/
function VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceShaderAtomicInt64FeaturesKHR) {
    _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.reset();
    return _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D8920;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderBufferInt64Atomics": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "shaderSharedInt64Atomics": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D8920;
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderBufferInt64Atomics: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shaderSharedInt64Atomics: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT **/
function VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT) {
    _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.reset();
    return _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9DB032;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexAttributeInstanceRateDivisor !== void 0) this.vertexAttributeInstanceRateDivisor = opts.vertexAttributeInstanceRateDivisor;
    if (opts.vertexAttributeInstanceRateZeroDivisor !== void 0) this.vertexAttributeInstanceRateZeroDivisor = opts.vertexAttributeInstanceRateZeroDivisor;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "vertexAttributeInstanceRateDivisor": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "vertexAttributeInstanceRateZeroDivisor": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9DB032;
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  vertexAttributeInstanceRateDivisor: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  vertexAttributeInstanceRateZeroDivisor: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkQueueFamilyCheckpointPropertiesNV **/
function VkQueueFamilyCheckpointPropertiesNV(opts) {
  if (new.target !== VkQueueFamilyCheckpointPropertiesNV) {
    _VkQueueFamilyCheckpointPropertiesNV.reset();
    return _VkQueueFamilyCheckpointPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DEEB1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkQueueFamilyCheckpointPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueueFamilyCheckpointPropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkQueueFamilyCheckpointPropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueueFamilyCheckpointPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "checkpointExecutionStageMask": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  
});

VkQueueFamilyCheckpointPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DEEB1;
};

VkQueueFamilyCheckpointPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyCheckpointPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkQueueFamilyCheckpointPropertiesNV.byteLength = 0x18;

VkQueueFamilyCheckpointPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  checkpointExecutionStageMask: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkCheckpointDataNV **/
function VkCheckpointDataNV(opts) {
  if (new.target !== VkCheckpointDataNV) {
    _VkCheckpointDataNV.reset();
    return _VkCheckpointDataNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pCheckpointMarker = null;
  this.sType = 0x3B9DEEB0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pCheckpointMarker !== void 0) this.pCheckpointMarker = opts.pCheckpointMarker;
    
  }
};

Object.defineProperties(VkCheckpointDataNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCheckpointDataNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCheckpointDataNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCheckpointDataNV.pNext' isn't allowed to be filled");
    }
    },
  "stage": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "pCheckpointMarker": {
    get() {
    return this._pCheckpointMarker;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pCheckpointMarker = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pCheckpointMarker = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCheckpointDataNV.pCheckpointMarker': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkCheckpointDataNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pCheckpointMarker = null;
  this.sType = 0x3B9DEEB0;
};

VkCheckpointDataNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCheckpointDataNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkCheckpointDataNV.byteLength = 0x20;

VkCheckpointDataNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  stage: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pCheckpointMarker: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceDepthStencilResolvePropertiesKHR **/
function VkPhysicalDeviceDepthStencilResolvePropertiesKHR(opts) {
  if (new.target !== VkPhysicalDeviceDepthStencilResolvePropertiesKHR) {
    _VkPhysicalDeviceDepthStencilResolvePropertiesKHR.reset();
    return _VkPhysicalDeviceDepthStencilResolvePropertiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9DD358;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDepthStencilResolvePropertiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDepthStencilResolvePropertiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDepthStencilResolvePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "supportedDepthResolveModes": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "supportedStencilResolveModes": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "independentResolveNone": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    },
  "independentResolve": {
    get() {
    return this.memoryViewUint32[0x7] !== 0;
    },
    },
  
});

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9DD358;
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.byteLength = 0x20;

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  supportedDepthResolveModes: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  supportedStencilResolveModes: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  independentResolveNone: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  independentResolve: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkSubpassDescriptionDepthStencilResolveKHR **/
function VkSubpassDescriptionDepthStencilResolveKHR(opts) {
  if (new.target !== VkSubpassDescriptionDepthStencilResolveKHR) {
    _VkSubpassDescriptionDepthStencilResolveKHR.reset();
    return _VkSubpassDescriptionDepthStencilResolveKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pDepthStencilResolveAttachment = null;
  this.sType = 0x3B9DD359;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthResolveMode !== void 0) this.depthResolveMode = opts.depthResolveMode;
    if (opts.stencilResolveMode !== void 0) this.stencilResolveMode = opts.stencilResolveMode;
    if (opts.pDepthStencilResolveAttachment !== void 0) this.pDepthStencilResolveAttachment = opts.pDepthStencilResolveAttachment;
    
  }
};

Object.defineProperties(VkSubpassDescriptionDepthStencilResolveKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSubpassDescriptionDepthStencilResolveKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassDescriptionDepthStencilResolveKHR.pNext' isn't allowed to be filled");
    }
    },
  "depthResolveMode": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.depthResolveMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "stencilResolveMode": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.stencilResolveMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "pDepthStencilResolveAttachment": {
    get() {
    return this._pDepthStencilResolveAttachment;
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2KHR) {
      value.flush();
      this._pDepthStencilResolveAttachment = value;
      this.memoryViewBigInt64[0x3] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilResolveAttachment = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.pDepthStencilResolveAttachment': Expected 'VkAttachmentReference2KHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescriptionDepthStencilResolveKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pDepthStencilResolveAttachment = null;
  this.sType = 0x3B9DD359;
};

VkSubpassDescriptionDepthStencilResolveKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDescriptionDepthStencilResolveKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassDescriptionDepthStencilResolveKHR.byteLength = 0x20;

VkSubpassDescriptionDepthStencilResolveKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  depthResolveMode: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  stencilResolveMode: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pDepthStencilResolveAttachment: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkImageViewASTCDecodeModeEXT **/
function VkImageViewASTCDecodeModeEXT(opts) {
  if (new.target !== VkImageViewASTCDecodeModeEXT) {
    _VkImageViewASTCDecodeModeEXT.reset();
    return _VkImageViewASTCDecodeModeEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BCFB8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.decodeMode !== void 0) this.decodeMode = opts.decodeMode;
    
  }
};

Object.defineProperties(VkImageViewASTCDecodeModeEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewASTCDecodeModeEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewASTCDecodeModeEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewASTCDecodeModeEXT.pNext' isn't allowed to be filled");
    }
    },
  "decodeMode": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewASTCDecodeModeEXT.decodeMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkImageViewASTCDecodeModeEXT.decodeMode': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkImageViewASTCDecodeModeEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BCFB8;
};

VkImageViewASTCDecodeModeEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewASTCDecodeModeEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewASTCDecodeModeEXT.byteLength = 0x18;

VkImageViewASTCDecodeModeEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  decodeMode: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceASTCDecodeFeaturesEXT **/
function VkPhysicalDeviceASTCDecodeFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceASTCDecodeFeaturesEXT) {
    _VkPhysicalDeviceASTCDecodeFeaturesEXT.reset();
    return _VkPhysicalDeviceASTCDecodeFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9BCFB9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.decodeModeSharedExponent !== void 0) this.decodeModeSharedExponent = opts.decodeModeSharedExponent;
    
  }
};

Object.defineProperties(VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceASTCDecodeFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceASTCDecodeFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceASTCDecodeFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "decodeModeSharedExponent": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9BCFB9;
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceASTCDecodeFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  decodeModeSharedExponent: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceTransformFeedbackFeaturesEXT **/
function VkPhysicalDeviceTransformFeedbackFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceTransformFeedbackFeaturesEXT) {
    _VkPhysicalDeviceTransformFeedbackFeaturesEXT.reset();
    return _VkPhysicalDeviceTransformFeedbackFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B3760;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transformFeedback !== void 0) this.transformFeedback = opts.transformFeedback;
    if (opts.geometryStreams !== void 0) this.geometryStreams = opts.geometryStreams;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceTransformFeedbackFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceTransformFeedbackFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTransformFeedbackFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "transformFeedback": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "geometryStreams": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B3760;
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceTransformFeedbackFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  transformFeedback: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  geometryStreams: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceTransformFeedbackPropertiesEXT **/
function VkPhysicalDeviceTransformFeedbackPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceTransformFeedbackPropertiesEXT) {
    _VkPhysicalDeviceTransformFeedbackPropertiesEXT.reset();
    return _VkPhysicalDeviceTransformFeedbackPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9B3761;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceTransformFeedbackPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceTransformFeedbackPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTransformFeedbackPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxTransformFeedbackStreams": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxTransformFeedbackBuffers": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "maxTransformFeedbackBufferSize": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    },
  "maxTransformFeedbackStreamDataSize": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    },
  "maxTransformFeedbackBufferDataSize": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    },
  "maxTransformFeedbackBufferDataStride": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    },
  "transformFeedbackQueries": {
    get() {
    return this.memoryViewUint32[0xB] !== 0;
    },
    },
  "transformFeedbackStreamsLinesTriangles": {
    get() {
    return this.memoryViewUint32[0xC] !== 0;
    },
    },
  "transformFeedbackRasterizationStreamSelect": {
    get() {
    return this.memoryViewUint32[0xD] !== 0;
    },
    },
  "transformFeedbackDraw": {
    get() {
    return this.memoryViewUint32[0xE] !== 0;
    },
    },
  
});

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  this.sType = 0x3B9B3761;
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.byteLength = 0x40;

VkPhysicalDeviceTransformFeedbackPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxTransformFeedbackStreams: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxTransformFeedbackBuffers: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  maxTransformFeedbackBufferSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  maxTransformFeedbackStreamDataSize: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  maxTransformFeedbackBufferDataSize: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  maxTransformFeedbackBufferDataStride: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  transformFeedbackQueries: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  transformFeedbackStreamsLinesTriangles: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  transformFeedbackRasterizationStreamSelect: {
    byteOffset: 0x34,
    byteLength: 0x4
  },
  transformFeedbackDraw: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkPipelineRasterizationStateStreamCreateInfoEXT **/
function VkPipelineRasterizationStateStreamCreateInfoEXT(opts) {
  if (new.target !== VkPipelineRasterizationStateStreamCreateInfoEXT) {
    _VkPipelineRasterizationStateStreamCreateInfoEXT.reset();
    return _VkPipelineRasterizationStateStreamCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B3762;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.rasterizationStream !== void 0) this.rasterizationStream = opts.rasterizationStream;
    
  }
};

Object.defineProperties(VkPipelineRasterizationStateStreamCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateStreamCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationStateStreamCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationStateStreamCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateStreamCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "rasterizationStream": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateStreamCreateInfoEXT.rasterizationStream': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  
});

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9B3762;
};

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationStateStreamCreateInfoEXT.byteLength = 0x18;

VkPipelineRasterizationStateStreamCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  rasterizationStream: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV **/
function VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) {
    _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.reset();
    return _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D5270;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.representativeFragmentTest !== void 0) this.representativeFragmentTest = opts.representativeFragmentTest;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "representativeFragmentTest": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D5270;
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  representativeFragmentTest: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineRepresentativeFragmentTestStateCreateInfoNV **/
function VkPipelineRepresentativeFragmentTestStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineRepresentativeFragmentTestStateCreateInfoNV) {
    _VkPipelineRepresentativeFragmentTestStateCreateInfoNV.reset();
    return _VkPipelineRepresentativeFragmentTestStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D5271;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.representativeFragmentTestEnable !== void 0) this.representativeFragmentTestEnable = opts.representativeFragmentTestEnable;
    
  }
};

Object.defineProperties(VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRepresentativeFragmentTestStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRepresentativeFragmentTestStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRepresentativeFragmentTestStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "representativeFragmentTestEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D5271;
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.byteLength = 0x18;

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  representativeFragmentTestEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceExclusiveScissorFeaturesNV **/
function VkPhysicalDeviceExclusiveScissorFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceExclusiveScissorFeaturesNV) {
    _VkPhysicalDeviceExclusiveScissorFeaturesNV.reset();
    return _VkPhysicalDeviceExclusiveScissorFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DEACA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.exclusiveScissor !== void 0) this.exclusiveScissor = opts.exclusiveScissor;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExclusiveScissorFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceExclusiveScissorFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExclusiveScissorFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "exclusiveScissor": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DEACA;
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceExclusiveScissorFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  exclusiveScissor: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineViewportExclusiveScissorStateCreateInfoNV **/
function VkPipelineViewportExclusiveScissorStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineViewportExclusiveScissorStateCreateInfoNV) {
    _VkPipelineViewportExclusiveScissorStateCreateInfoNV.reset();
    return _VkPipelineViewportExclusiveScissorStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pExclusiveScissors = null;
    this._pExclusiveScissorsNative = null;
  this.sType = 0x3B9DEAC8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.exclusiveScissorCount !== void 0) this.exclusiveScissorCount = opts.exclusiveScissorCount;
    if (opts.pExclusiveScissors !== void 0) this.pExclusiveScissors = opts.pExclusiveScissors;
    
  }
};

Object.defineProperties(VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "exclusiveScissorCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.exclusiveScissorCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pExclusiveScissors": {
    get() {
    return this._pExclusiveScissors;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pExclusiveScissors = value;
    } else if (value === null) {
      this._pExclusiveScissors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pExclusiveScissors = null;
    this._pExclusiveScissorsNative = null;
  this.sType = 0x3B9DEAC8;
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pExclusiveScissors !== null) {
    let array = this._pExclusiveScissors;
    
    if (array.length !== this.exclusiveScissorCount) {
      throw new RangeError("Invalid array length, expected length of 'exclusiveScissorCount' for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pExclusiveScissorsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pExclusiveScissorsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportExclusiveScissorStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  exclusiveScissorCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pExclusiveScissors: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceCornerSampledImageFeaturesNV **/
function VkPhysicalDeviceCornerSampledImageFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceCornerSampledImageFeaturesNV) {
    _VkPhysicalDeviceCornerSampledImageFeaturesNV.reset();
    return _VkPhysicalDeviceCornerSampledImageFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9B8D50;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.cornerSampledImage !== void 0) this.cornerSampledImage = opts.cornerSampledImage;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCornerSampledImageFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceCornerSampledImageFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCornerSampledImageFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "cornerSampledImage": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9B8D50;
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceCornerSampledImageFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  cornerSampledImage: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceComputeShaderDerivativesFeaturesNV **/
function VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceComputeShaderDerivativesFeaturesNV) {
    _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.reset();
    return _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9DDB28;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.computeDerivativeGroupQuads !== void 0) this.computeDerivativeGroupQuads = opts.computeDerivativeGroupQuads;
    if (opts.computeDerivativeGroupLinear !== void 0) this.computeDerivativeGroupLinear = opts.computeDerivativeGroupLinear;
    
  }
};

Object.defineProperties(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "computeDerivativeGroupQuads": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "computeDerivativeGroupLinear": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9DDB28;
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  computeDerivativeGroupQuads: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  computeDerivativeGroupLinear: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV **/
function VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV) {
    _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.reset();
    return _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DE2F8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShaderBarycentric !== void 0) this.fragmentShaderBarycentric = opts.fragmentShaderBarycentric;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "fragmentShaderBarycentric": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DE2F8;
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fragmentShaderBarycentric: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderImageFootprintFeaturesNV **/
function VkPhysicalDeviceShaderImageFootprintFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceShaderImageFootprintFeaturesNV) {
    _VkPhysicalDeviceShaderImageFootprintFeaturesNV.reset();
    return _VkPhysicalDeviceShaderImageFootprintFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DE6E0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageFootprint !== void 0) this.imageFootprint = opts.imageFootprint;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderImageFootprintFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderImageFootprintFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderImageFootprintFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "imageFootprint": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DE6E0;
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceShaderImageFootprintFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imageFootprint: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV **/
function VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) {
    _VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.reset();
    return _VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E7380;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocationImageAliasing !== void 0) this.dedicatedAllocationImageAliasing = opts.dedicatedAllocationImageAliasing;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "dedicatedAllocationImageAliasing": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E7380;
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  dedicatedAllocationImageAliasing: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkShadingRatePaletteNV **/
function VkShadingRatePaletteNV(opts) {
  if (new.target !== VkShadingRatePaletteNV) {
    _VkShadingRatePaletteNV.reset();
    return _VkShadingRatePaletteNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pShadingRatePaletteEntries = null;
  
  if (typeof opts === "object") {
    if (opts.shadingRatePaletteEntryCount !== void 0) this.shadingRatePaletteEntryCount = opts.shadingRatePaletteEntryCount;
    if (opts.pShadingRatePaletteEntries !== void 0) this.pShadingRatePaletteEntries = opts.pShadingRatePaletteEntries;
    
  }
};

Object.defineProperties(VkShadingRatePaletteNV.prototype, {
  "shadingRatePaletteEntryCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShadingRatePaletteNV.shadingRatePaletteEntryCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "pShadingRatePaletteEntries": {
    get() {
    return this._pShadingRatePaletteEntries;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pShadingRatePaletteEntries = value;
      this.memoryViewBigInt64[0x1] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pShadingRatePaletteEntries = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShadingRatePaletteNV.pShadingRatePaletteEntries': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkShadingRatePaletteNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  this._pShadingRatePaletteEntries = null;
  
};

VkShadingRatePaletteNV.prototype.flush = function flush() {
  
  return true;
};

VkShadingRatePaletteNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkShadingRatePaletteNV.byteLength = 0x10;

VkShadingRatePaletteNV.memoryLayout = {
  shadingRatePaletteEntryCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pShadingRatePaletteEntries: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkPipelineViewportShadingRateImageStateCreateInfoNV **/
function VkPipelineViewportShadingRateImageStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineViewportShadingRateImageStateCreateInfoNV) {
    _VkPipelineViewportShadingRateImageStateCreateInfoNV.reset();
    return _VkPipelineViewportShadingRateImageStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pShadingRatePalettes = null;
    this._pShadingRatePalettesNative = null;
  this.sType = 0x3B9D4AA0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateImageEnable !== void 0) this.shadingRateImageEnable = opts.shadingRateImageEnable;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pShadingRatePalettes !== void 0) this.pShadingRatePalettes = opts.pShadingRatePalettes;
    
  }
};

Object.defineProperties(VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportShadingRateImageStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateImageEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "viewportCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.viewportCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pShadingRatePalettes": {
    get() {
    return this._pShadingRatePalettes;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pShadingRatePalettes = value;
    } else if (value === null) {
      this._pShadingRatePalettes = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes': Expected 'Array VkShadingRatePaletteNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pShadingRatePalettes = null;
    this._pShadingRatePalettesNative = null;
  this.sType = 0x3B9D4AA0;
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pShadingRatePalettes !== null) {
    let array = this._pShadingRatePalettes;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkShadingRatePaletteNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes[" + ii + "]': Expected 'VkShadingRatePaletteNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pShadingRatePalettesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pShadingRatePalettesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportShadingRateImageStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shadingRateImageEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  viewportCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pShadingRatePalettes: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceShadingRateImageFeaturesNV **/
function VkPhysicalDeviceShadingRateImageFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceShadingRateImageFeaturesNV) {
    _VkPhysicalDeviceShadingRateImageFeaturesNV.reset();
    return _VkPhysicalDeviceShadingRateImageFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D4AA1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateImage !== void 0) this.shadingRateImage = opts.shadingRateImage;
    if (opts.shadingRateCoarseSampleOrder !== void 0) this.shadingRateCoarseSampleOrder = opts.shadingRateCoarseSampleOrder;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShadingRateImageFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShadingRateImageFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShadingRateImageFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShadingRateImageFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateImage": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "shadingRateCoarseSampleOrder": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D4AA1;
};

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShadingRateImageFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceShadingRateImageFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shadingRateImage: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shadingRateCoarseSampleOrder: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShadingRateImagePropertiesNV **/
function VkPhysicalDeviceShadingRateImagePropertiesNV(opts) {
  if (new.target !== VkPhysicalDeviceShadingRateImagePropertiesNV) {
    _VkPhysicalDeviceShadingRateImagePropertiesNV.reset();
    return _VkPhysicalDeviceShadingRateImagePropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._shadingRateTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  
  
  this.sType = 0x3B9D4AA2;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShadingRateImagePropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShadingRateImagePropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShadingRateImagePropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShadingRateImagePropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateTexelSize": {
    get() {
    return this._shadingRateTexelSize;
    },
    },
  "shadingRatePaletteSize": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    },
  "shadingRateMaxCoarseSamples": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    },
  
});

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  this._shadingRateTexelSize = null;
  
  
  this.sType = 0x3B9D4AA2;
};

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkPhysicalDeviceShadingRateImagePropertiesNV.byteLength = 0x20;

VkPhysicalDeviceShadingRateImagePropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shadingRateTexelSize: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  shadingRatePaletteSize: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  shadingRateMaxCoarseSamples: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkCoarseSampleLocationNV **/
function VkCoarseSampleLocationNV(opts) {
  if (new.target !== VkCoarseSampleLocationNV) {
    _VkCoarseSampleLocationNV.reset();
    return _VkCoarseSampleLocationNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xC) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xC);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.pixelX !== void 0) this.pixelX = opts.pixelX;
    if (opts.pixelY !== void 0) this.pixelY = opts.pixelY;
    if (opts.sample !== void 0) this.sample = opts.sample;
    
  }
};

Object.defineProperties(VkCoarseSampleLocationNV.prototype, {
  "pixelX": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleLocationNV.pixelX': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "pixelY": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleLocationNV.pixelY': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "sample": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleLocationNV.sample': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  
});

VkCoarseSampleLocationNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xC], 0x0);
  
  
  
  
};

VkCoarseSampleLocationNV.prototype.flush = function flush() {
  
  return true;
};

VkCoarseSampleLocationNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkCoarseSampleLocationNV.byteLength = 0xC;

VkCoarseSampleLocationNV.memoryLayout = {
  pixelX: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pixelY: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  sample: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
};
/** VkCoarseSampleOrderCustomNV **/
function VkCoarseSampleOrderCustomNV(opts) {
  if (new.target !== VkCoarseSampleOrderCustomNV) {
    _VkCoarseSampleOrderCustomNV.reset();
    return _VkCoarseSampleOrderCustomNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  this._pSampleLocations = null;
    this._pSampleLocationsNative = null;
  
  if (typeof opts === "object") {
    if (opts.shadingRate !== void 0) this.shadingRate = opts.shadingRate;
    if (opts.sampleCount !== void 0) this.sampleCount = opts.sampleCount;
    if (opts.sampleLocationCount !== void 0) this.sampleLocationCount = opts.sampleLocationCount;
    if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
    
  }
};

Object.defineProperties(VkCoarseSampleOrderCustomNV.prototype, {
  "shadingRate": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.shadingRate': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkShadingRatePaletteEntryNV(value)) {
      throw new RangeError("Invalid value for 'VkCoarseSampleOrderCustomNV.shadingRate': '" + value + "' is not a value of 'VkShadingRatePaletteEntryNV'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "sampleCount": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.sampleCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  "sampleLocationCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.sampleLocationCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x2] = value;
    }
    },
  "pSampleLocations": {
    get() {
    return this._pSampleLocations;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSampleLocations = value;
    } else if (value === null) {
      this._pSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.pSampleLocations': Expected 'Array VkCoarseSampleLocationNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkCoarseSampleOrderCustomNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  
  
  this._pSampleLocations = null;
    this._pSampleLocationsNative = null;
  
};

VkCoarseSampleOrderCustomNV.prototype.flush = function flush() {
  
  
  if (this._pSampleLocations !== null) {
    let array = this._pSampleLocations;
    
    if (array.length !== this.sampleLocationCount) {
      throw new RangeError("Invalid array length, expected length of 'sampleLocationCount' for 'VkCoarseSampleOrderCustomNV.pSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkCoarseSampleLocationNV)) {
        throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.pSampleLocations[" + ii + "]': Expected 'VkCoarseSampleLocationNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSampleLocationsNative = nativeArray;
      this.memoryViewBigInt64[0x2] = nativeArray.address;
    } else {
      this._pSampleLocationsNative = null;
      this.memoryViewBigInt64[0x2] = BI0;
    }
  }
  
  return true;
};

VkCoarseSampleOrderCustomNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCoarseSampleOrderCustomNV.byteLength = 0x18;

VkCoarseSampleOrderCustomNV.memoryLayout = {
  shadingRate: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  sampleCount: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
  sampleLocationCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  pSampleLocations: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkPipelineViewportCoarseSampleOrderStateCreateInfoNV **/
function VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) {
    _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.reset();
    return _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pCustomSampleOrders = null;
    this._pCustomSampleOrdersNative = null;
  this.sType = 0x3B9D4AA5;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleOrderType !== void 0) this.sampleOrderType = opts.sampleOrderType;
    if (opts.customSampleOrderCount !== void 0) this.customSampleOrderCount = opts.customSampleOrderCount;
    if (opts.pCustomSampleOrders !== void 0) this.pCustomSampleOrders = opts.pCustomSampleOrders;
    
  }
};

Object.defineProperties(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "sampleOrderType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sampleOrderType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCoarseSampleOrderTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sampleOrderType': '" + value + "' is not a value of 'VkCoarseSampleOrderTypeNV'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "customSampleOrderCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.customSampleOrderCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pCustomSampleOrders": {
    get() {
    return this._pCustomSampleOrders;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pCustomSampleOrders = value;
    } else if (value === null) {
      this._pCustomSampleOrders = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders': Expected 'Array VkCoarseSampleOrderCustomNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  this._pCustomSampleOrders = null;
    this._pCustomSampleOrdersNative = null;
  this.sType = 0x3B9D4AA5;
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pCustomSampleOrders !== null) {
    let array = this._pCustomSampleOrders;
    
    if (array.length !== this.customSampleOrderCount) {
      throw new RangeError("Invalid array length, expected length of 'customSampleOrderCount' for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkCoarseSampleOrderCustomNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders[" + ii + "]': Expected 'VkCoarseSampleOrderCustomNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pCustomSampleOrdersNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pCustomSampleOrdersNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  sampleOrderType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  customSampleOrderCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pCustomSampleOrders: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceMeshShaderFeaturesNV **/
function VkPhysicalDeviceMeshShaderFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceMeshShaderFeaturesNV) {
    _VkPhysicalDeviceMeshShaderFeaturesNV.reset();
    return _VkPhysicalDeviceMeshShaderFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9DDF10;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.taskShader !== void 0) this.taskShader = opts.taskShader;
    if (opts.meshShader !== void 0) this.meshShader = opts.meshShader;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMeshShaderFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMeshShaderFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMeshShaderFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMeshShaderFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "taskShader": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "meshShader": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9DDF10;
};

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMeshShaderFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceMeshShaderFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  taskShader: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  meshShader: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceMeshShaderPropertiesNV **/
function VkPhysicalDeviceMeshShaderPropertiesNV(opts) {
  if (new.target !== VkPhysicalDeviceMeshShaderPropertiesNV) {
    _VkPhysicalDeviceMeshShaderPropertiesNV.reset();
    return _VkPhysicalDeviceMeshShaderPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x58) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x58);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._maxTaskWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  this._maxMeshWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  
  
  
  this.sType = 0x3B9DDF11;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMeshShaderPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMeshShaderPropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMeshShaderPropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMeshShaderPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "maxDrawMeshTasksCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxTaskWorkGroupInvocations": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "maxTaskWorkGroupSize": {
    get() {
    return [
      this.memoryViewUint32[0x6],
      this.memoryViewUint32[0x7],
      this.memoryViewUint32[0x8]
    ];
    },
    },
  "maxTaskTotalMemorySize": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    },
  "maxTaskOutputCount": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    },
  "maxMeshWorkGroupInvocations": {
    get() {
    return this.memoryViewUint32[0xB];
    },
    },
  "maxMeshWorkGroupSize": {
    get() {
    return [
      this.memoryViewUint32[0xC],
      this.memoryViewUint32[0xD],
      this.memoryViewUint32[0xE]
    ];
    },
    },
  "maxMeshTotalMemorySize": {
    get() {
    return this.memoryViewUint32[0xF];
    },
    },
  "maxMeshOutputVertices": {
    get() {
    return this.memoryViewUint32[0x10];
    },
    },
  "maxMeshOutputPrimitives": {
    get() {
    return this.memoryViewUint32[0x11];
    },
    },
  "maxMeshMultiviewViewCount": {
    get() {
    return this.memoryViewUint32[0x12];
    },
    },
  "meshOutputPerVertexGranularity": {
    get() {
    return this.memoryViewUint32[0x13];
    },
    },
  "meshOutputPerPrimitiveGranularity": {
    get() {
    return this.memoryViewUint32[0x14];
    },
    },
  
});

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x58], 0x0);
  
  this._pNext = null;
  
  
  this._maxTaskWorkGroupSize = null;
  
  
  
  this._maxMeshWorkGroupSize = null;
  
  
  
  
  
  
  this.sType = 0x3B9DDF11;
};

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x58));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x58), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceMeshShaderPropertiesNV.byteLength = 0x58;

VkPhysicalDeviceMeshShaderPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  maxDrawMeshTasksCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxTaskWorkGroupInvocations: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  maxTaskWorkGroupSize: {
    byteOffset: 0x18,
    byteLength: 0xC
  },
  maxTaskTotalMemorySize: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  maxTaskOutputCount: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  maxMeshWorkGroupInvocations: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
  maxMeshWorkGroupSize: {
    byteOffset: 0x30,
    byteLength: 0xC
  },
  maxMeshTotalMemorySize: {
    byteOffset: 0x3C,
    byteLength: 0x4
  },
  maxMeshOutputVertices: {
    byteOffset: 0x40,
    byteLength: 0x4
  },
  maxMeshOutputPrimitives: {
    byteOffset: 0x44,
    byteLength: 0x4
  },
  maxMeshMultiviewViewCount: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  meshOutputPerVertexGranularity: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  meshOutputPerPrimitiveGranularity: {
    byteOffset: 0x50,
    byteLength: 0x4
  },
};
/** VkDrawMeshTasksIndirectCommandNV **/
function VkDrawMeshTasksIndirectCommandNV(opts) {
  if (new.target !== VkDrawMeshTasksIndirectCommandNV) {
    _VkDrawMeshTasksIndirectCommandNV.reset();
    return _VkDrawMeshTasksIndirectCommandNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.taskCount !== void 0) this.taskCount = opts.taskCount;
    if (opts.firstTask !== void 0) this.firstTask = opts.firstTask;
    
  }
};

Object.defineProperties(VkDrawMeshTasksIndirectCommandNV.prototype, {
  "taskCount": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawMeshTasksIndirectCommandNV.taskCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "firstTask": {
    get() {
    return this.memoryViewUint32[0x1];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawMeshTasksIndirectCommandNV.firstTask': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x1] = value;
    }
    },
  
});

VkDrawMeshTasksIndirectCommandNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
};

VkDrawMeshTasksIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkDrawMeshTasksIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDrawMeshTasksIndirectCommandNV.byteLength = 0x8;

VkDrawMeshTasksIndirectCommandNV.memoryLayout = {
  taskCount: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  firstTask: {
    byteOffset: 0x4,
    byteLength: 0x4
  },
};
/** VkRayTracingShaderGroupCreateInfoNV **/
function VkRayTracingShaderGroupCreateInfoNV(opts) {
  if (new.target !== VkRayTracingShaderGroupCreateInfoNV) {
    _VkRayTracingShaderGroupCreateInfoNV.reset();
    return _VkRayTracingShaderGroupCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9D4E93;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.generalShader !== void 0) this.generalShader = opts.generalShader;
    if (opts.closestHitShader !== void 0) this.closestHitShader = opts.closestHitShader;
    if (opts.anyHitShader !== void 0) this.anyHitShader = opts.anyHitShader;
    if (opts.intersectionShader !== void 0) this.intersectionShader = opts.intersectionShader;
    
  }
};

Object.defineProperties(VkRayTracingShaderGroupCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRayTracingShaderGroupCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRayTracingShaderGroupCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkRayTracingShaderGroupTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkRayTracingShaderGroupCreateInfoNV.type': '" + value + "' is not a value of 'VkRayTracingShaderGroupTypeNV'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "generalShader": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.generalShader': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "closestHitShader": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.closestHitShader': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "anyHitShader": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.anyHitShader': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "intersectionShader": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.intersectionShader': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  
});

VkRayTracingShaderGroupCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = 0x3B9D4E93;
};

VkRayTracingShaderGroupCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRayTracingShaderGroupCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkRayTracingShaderGroupCreateInfoNV.byteLength = 0x28;

VkRayTracingShaderGroupCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  type: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  generalShader: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  closestHitShader: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  anyHitShader: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  intersectionShader: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkRayTracingPipelineCreateInfoNV **/
function VkRayTracingPipelineCreateInfoNV(opts) {
  if (new.target !== VkRayTracingPipelineCreateInfoNV) {
    _VkRayTracingPipelineCreateInfoNV.reset();
    return _VkRayTracingPipelineCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x50) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x50);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pStages = null;
    this._pStagesNative = null;
  
  this._pGroups = null;
    this._pGroupsNative = null;
  
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = 0x3B9D4E88;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.maxRecursionDepth !== void 0) this.maxRecursionDepth = opts.maxRecursionDepth;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkRayTracingPipelineCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRayTracingPipelineCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pNext'");
      switch (sType) {
          
        case 0x3B9DB800:
          break;
        default:
          throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "stageCount": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.stageCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "pStages": {
    get() {
    return this._pStages;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "groupCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.groupCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "pGroups": {
    get() {
    return this._pGroups;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGroups = value;
    } else if (value === null) {
      this._pGroups = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pGroups': Expected 'Array VkRayTracingShaderGroupCreateInfoNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "maxRecursionDepth": {
    get() {
    return this.memoryViewUint32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.maxRecursionDepth': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xC] = value;
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._layout = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryViewBigInt64[0x8] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryViewInt32[0x12];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.basePipelineIndex': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x12] = value;
    }
    },
  
});

VkRayTracingPipelineCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x50], 0x0);
  
  this._pNext = null;
  
  
  this._pStages = null;
    this._pStagesNative = null;
  
  this._pGroups = null;
    this._pGroupsNative = null;
  
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = 0x3B9D4E88;
};

VkRayTracingPipelineCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkRayTracingPipelineCreateInfoNV.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineShaderStageCreateInfo)) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStagesNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pStagesNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  
  if (this._pGroups !== null) {
    let array = this._pGroups;
    
    if (array.length !== this.groupCount) {
      throw new RangeError("Invalid array length, expected length of 'groupCount' for 'VkRayTracingPipelineCreateInfoNV.pGroups'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRayTracingShaderGroupCreateInfoNV)) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pGroups[" + ii + "]': Expected 'VkRayTracingShaderGroupCreateInfoNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGroupsNative = nativeArray;
      this.memoryViewBigInt64[0x5] = nativeArray.address;
    } else {
      this._pGroupsNative = null;
      this.memoryViewBigInt64[0x5] = BI0;
    }
  }
  
  return true;
};

VkRayTracingPipelineCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkRayTracingPipelineCreateInfoNV.byteLength = 0x50;

VkRayTracingPipelineCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  stageCount: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  pStages: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  groupCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  pGroups: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  maxRecursionDepth: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  layout: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  basePipelineHandle: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
  basePipelineIndex: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
};
/** VkGeometryTrianglesNV **/
function VkGeometryTrianglesNV(opts) {
  if (new.target !== VkGeometryTrianglesNV) {
    _VkGeometryTrianglesNV.reset();
    return _VkGeometryTrianglesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x60) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x60);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._vertexData = null;
  
  
  
  
  this._indexData = null;
  
  
  
  this._transformData = null;
  
  this.sType = 0x3B9D4E8C;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexData !== void 0) this.vertexData = opts.vertexData;
    if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
    if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
    if (opts.vertexStride !== void 0) this.vertexStride = opts.vertexStride;
    if (opts.vertexFormat !== void 0) this.vertexFormat = opts.vertexFormat;
    if (opts.indexData !== void 0) this.indexData = opts.indexData;
    if (opts.indexOffset !== void 0) this.indexOffset = opts.indexOffset;
    if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    if (opts.transformData !== void 0) this.transformData = opts.transformData;
    if (opts.transformOffset !== void 0) this.transformOffset = opts.transformOffset;
    
  }
};

Object.defineProperties(VkGeometryTrianglesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkGeometryTrianglesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeometryTrianglesNV.pNext' isn't allowed to be filled");
    }
    },
  "vertexData": {
    get() {
    return this._vertexData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._vertexData = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._vertexData = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "vertexOffset": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  "vertexCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "vertexStride": {
    get() {
    return this.memoryViewBigUint64[0x5];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexStride': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x5] = BigInt(value);
    }
    },
  "vertexFormat": {
    get() {
    return this.memoryViewInt32[0xC];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexFormat': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFormat(value)) {
      throw new RangeError("Invalid value for 'VkGeometryTrianglesNV.vertexFormat': '" + value + "' is not a value of 'VkFormat'");
    }
    this.memoryViewInt32[0xC] = value;
    }
    },
  "indexData": {
    get() {
    return this._indexData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._indexData = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._indexData = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indexOffset": {
    get() {
    return this.memoryViewBigUint64[0x8];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x8] = BigInt(value);
    }
    },
  "indexCount": {
    get() {
    return this.memoryViewUint32[0x12];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x12] = value;
    }
    },
  "indexType": {
    get() {
    return this.memoryViewInt32[0x13];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkIndexType(value)) {
      throw new RangeError("Invalid value for 'VkGeometryTrianglesNV.indexType': '" + value + "' is not a value of 'VkIndexType'");
    }
    this.memoryViewInt32[0x13] = value;
    }
    },
  "transformData": {
    get() {
    return this._transformData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._transformData = value;
      
      this.memoryViewBigInt64[0xA] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._transformData = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.transformData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "transformOffset": {
    get() {
    return this.memoryViewBigUint64[0xB];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.transformOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0xB] = BigInt(value);
    }
    },
  
});

VkGeometryTrianglesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x60], 0x0);
  
  this._pNext = null;
  this._vertexData = null;
  
  
  
  
  this._indexData = null;
  
  
  
  this._transformData = null;
  
  this.sType = 0x3B9D4E8C;
};

VkGeometryTrianglesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeometryTrianglesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkGeometryTrianglesNV.byteLength = 0x60;

VkGeometryTrianglesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  vertexData: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  vertexOffset: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  vertexCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  vertexStride: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  vertexFormat: {
    byteOffset: 0x30,
    byteLength: 0x4
  },
  indexData: {
    byteOffset: 0x38,
    byteLength: 0x8
  },
  indexOffset: {
    byteOffset: 0x40,
    byteLength: 0x8
  },
  indexCount: {
    byteOffset: 0x48,
    byteLength: 0x4
  },
  indexType: {
    byteOffset: 0x4C,
    byteLength: 0x4
  },
  transformData: {
    byteOffset: 0x50,
    byteLength: 0x8
  },
  transformOffset: {
    byteOffset: 0x58,
    byteLength: 0x8
  },
};
/** VkGeometryAABBNV **/
function VkGeometryAABBNV(opts) {
  if (new.target !== VkGeometryAABBNV) {
    _VkGeometryAABBNV.reset();
    return _VkGeometryAABBNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._aabbData = null;
  
  
  
  this.sType = 0x3B9D4E8D;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aabbData !== void 0) this.aabbData = opts.aabbData;
    if (opts.numAABBs !== void 0) this.numAABBs = opts.numAABBs;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

Object.defineProperties(VkGeometryAABBNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkGeometryAABBNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeometryAABBNV.pNext' isn't allowed to be filled");
    }
    },
  "aabbData": {
    get() {
    return this._aabbData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._aabbData = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._aabbData = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.aabbData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "numAABBs": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.numAABBs': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "stride": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.stride': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "offset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.offset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  
});

VkGeometryAABBNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._aabbData = null;
  
  
  
  this.sType = 0x3B9D4E8D;
};

VkGeometryAABBNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeometryAABBNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkGeometryAABBNV.byteLength = 0x28;

VkGeometryAABBNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  aabbData: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  numAABBs: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  stride: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  offset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkGeometryDataNV **/
function VkGeometryDataNV(opts) {
  if (new.target !== VkGeometryDataNV) {
    _VkGeometryDataNV.reset();
    return _VkGeometryDataNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x88) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x88);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._triangles = new VkGeometryTrianglesNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._aabbs = new VkGeometryAABBNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x60 });
  
  if (typeof opts === "object") {
    if (opts.triangles !== void 0) this.triangles = opts.triangles;
    if (opts.aabbs !== void 0) this.aabbs = opts.aabbs;
    
  }
};

Object.defineProperties(VkGeometryDataNV.prototype, {
  "triangles": {
    get() {
    return this._triangles;
    },
    set(value) {
    if (value !== null && value.constructor === VkGeometryTrianglesNV) {
      value.flush();
      this._triangles = value;
      
      
    } else if (value === null) {
      this._triangles = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryDataNV.triangles': Expected 'VkGeometryTrianglesNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "aabbs": {
    get() {
    return this._aabbs;
    },
    set(value) {
    if (value !== null && value.constructor === VkGeometryAABBNV) {
      value.flush();
      this._aabbs = value;
      
      
    } else if (value === null) {
      this._aabbs = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryDataNV.aabbs': Expected 'VkGeometryAABBNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkGeometryDataNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x88], 0x0);
  this._triangles = null;
  this._aabbs = null;
  
};

VkGeometryDataNV.prototype.flush = function flush() {
  
  
  if (this._triangles !== null) {
    let triangles = this._triangles;
    triangles.flush();
    if (this.memoryBuffer !== triangles.memoryBuffer) {
      let srcView = new Uint8Array(triangles.memoryBuffer).subarray(triangles.$memoryOffset, triangles.$memoryOffset + 0x60);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkGeometryDataNV.triangles' isn't used as shared-memory");
    }
  }
  
  
  if (this._aabbs !== null) {
    let aabbs = this._aabbs;
    aabbs.flush();
    if (this.memoryBuffer !== aabbs.memoryBuffer) {
      let srcView = new Uint8Array(aabbs.memoryBuffer).subarray(aabbs.$memoryOffset, aabbs.$memoryOffset + 0x28);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x60);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkGeometryDataNV.aabbs' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkGeometryDataNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkGeometryDataNV.byteLength = 0x88;

VkGeometryDataNV.memoryLayout = {
  triangles: {
    byteOffset: 0x0,
    byteLength: 0x60
  },
  aabbs: {
    byteOffset: 0x60,
    byteLength: 0x28
  },
};
/** VkGeometryNV **/
function VkGeometryNV(opts) {
  if (new.target !== VkGeometryNV) {
    _VkGeometryNV.reset();
    return _VkGeometryNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0xA8) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xA8) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0xA8) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0xA8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._geometry = new VkGeometryDataNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  
  this.sType = 0x3B9D4E8B;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.geometryType !== void 0) this.geometryType = opts.geometryType;
    if (opts.geometry !== void 0) this.geometry = opts.geometry;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkGeometryNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkGeometryNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeometryNV.pNext' isn't allowed to be filled");
    }
    },
  "geometryType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryNV.geometryType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkGeometryTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkGeometryNV.geometryType': '" + value + "' is not a value of 'VkGeometryTypeNV'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "geometry": {
    get() {
    return this._geometry;
    },
    set(value) {
    if (value !== null && value.constructor === VkGeometryDataNV) {
      value.flush();
      this._geometry = value;
      
      
    } else if (value === null) {
      this._geometry = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryNV.geometry': Expected 'VkGeometryDataNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x28];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x28] = value;
    }
    },
  
});

VkGeometryNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0xA8], 0x0);
  
  this._pNext = null;
  
  this._geometry = null;
  
  this.sType = 0x3B9D4E8B;
};

VkGeometryNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._geometry !== null) {
    let geometry = this._geometry;
    geometry.flush();
    if (this.memoryBuffer !== geometry.memoryBuffer) {
      let srcView = new Uint8Array(geometry.memoryBuffer).subarray(geometry.$memoryOffset, geometry.$memoryOffset + 0x88);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkGeometryNV.geometry' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkGeometryNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkGeometryNV.byteLength = 0xA8;

VkGeometryNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  geometryType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  geometry: {
    byteOffset: 0x18,
    byteLength: 0x88
  },
  flags: {
    byteOffset: 0xA0,
    byteLength: 0x4
  },
};
/** VkAccelerationStructureInfoNV **/
function VkAccelerationStructureInfoNV(opts) {
  if (new.target !== VkAccelerationStructureInfoNV) {
    _VkAccelerationStructureInfoNV.reset();
    return _VkAccelerationStructureInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this._pGeometries = null;
    this._pGeometriesNative = null;
  this.sType = 0x3B9D4E94;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.geometryCount !== void 0) this.geometryCount = opts.geometryCount;
    if (opts.pGeometries !== void 0) this.pGeometries = opts.pGeometries;
    
  }
};

Object.defineProperties(VkAccelerationStructureInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkAccelerationStructureInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAccelerationStructureTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkAccelerationStructureInfoNV.type': '" + value + "' is not a value of 'VkAccelerationStructureTypeNV'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "instanceCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.instanceCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "geometryCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.geometryCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "pGeometries": {
    get() {
    return this._pGeometries;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGeometries = value;
    } else if (value === null) {
      this._pGeometries = null;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.pGeometries': Expected 'Array VkGeometryNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkAccelerationStructureInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pGeometries = null;
    this._pGeometriesNative = null;
  this.sType = 0x3B9D4E94;
};

VkAccelerationStructureInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pGeometries !== null) {
    let array = this._pGeometries;
    
    if (array.length !== this.geometryCount) {
      throw new RangeError("Invalid array length, expected length of 'geometryCount' for 'VkAccelerationStructureInfoNV.pGeometries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkGeometryNV)) {
        throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.pGeometries[" + ii + "]': Expected 'VkGeometryNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGeometriesNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pGeometriesNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkAccelerationStructureInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkAccelerationStructureInfoNV.byteLength = 0x28;

VkAccelerationStructureInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  type: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  flags: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  instanceCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  geometryCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pGeometries: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkAccelerationStructureCreateInfoNV **/
function VkAccelerationStructureCreateInfoNV(opts) {
  if (new.target !== VkAccelerationStructureCreateInfoNV) {
    _VkAccelerationStructureCreateInfoNV.reset();
    return _VkAccelerationStructureCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._info = new VkAccelerationStructureInfoNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  this.sType = 0x3B9D4E89;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.compactedSize !== void 0) this.compactedSize = opts.compactedSize;
    if (opts.info !== void 0) this.info = opts.info;
    
  }
};

Object.defineProperties(VkAccelerationStructureCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkAccelerationStructureCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "compactedSize": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.compactedSize': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  "info": {
    get() {
    return this._info;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureInfoNV) {
      value.flush();
      this._info = value;
      
      
    } else if (value === null) {
      this._info = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.info': Expected 'VkAccelerationStructureInfoNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  this._info = null;
  this.sType = 0x3B9D4E89;
};

VkAccelerationStructureCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._info !== null) {
    let info = this._info;
    info.flush();
    if (this.memoryBuffer !== info.memoryBuffer) {
      let srcView = new Uint8Array(info.memoryBuffer).subarray(info.$memoryOffset, info.$memoryOffset + 0x28);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureCreateInfoNV.info' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkAccelerationStructureCreateInfoNV.byteLength = 0x40;

VkAccelerationStructureCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  compactedSize: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  info: {
    byteOffset: 0x18,
    byteLength: 0x28
  },
};
/** VkBindAccelerationStructureMemoryInfoNV **/
function VkBindAccelerationStructureMemoryInfoNV(opts) {
  if (new.target !== VkBindAccelerationStructureMemoryInfoNV) {
    _VkBindAccelerationStructureMemoryInfoNV.reset();
    return _VkBindAccelerationStructureMemoryInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x38) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x38);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._accelerationStructure = null;
  this._memory = null;
  
  
  this._pDeviceIndices = null;
  this.sType = 0x3B9D4E8E;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

Object.defineProperties(VkBindAccelerationStructureMemoryInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBindAccelerationStructureMemoryInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindAccelerationStructureMemoryInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructure": {
    get() {
    return this._accelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureNV) {
      
      this._accelerationStructure = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.accelerationStructure': Expected 'VkAccelerationStructureNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.memoryOffset': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x4] = BigInt(value);
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryViewUint32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.deviceIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0xA] = value;
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBindAccelerationStructureMemoryInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x38], 0x0);
  
  this._pNext = null;
  this._accelerationStructure = null;
  this._memory = null;
  
  
  this._pDeviceIndices = null;
  this.sType = 0x3B9D4E8E;
};

VkBindAccelerationStructureMemoryInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindAccelerationStructureMemoryInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindAccelerationStructureMemoryInfoNV.byteLength = 0x38;

VkBindAccelerationStructureMemoryInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  accelerationStructure: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  memory: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  memoryOffset: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  deviceIndexCount: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  pDeviceIndices: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
};
/** VkWriteDescriptorSetAccelerationStructureNV **/
function VkWriteDescriptorSetAccelerationStructureNV(opts) {
  if (new.target !== VkWriteDescriptorSetAccelerationStructureNV) {
    _VkWriteDescriptorSetAccelerationStructureNV.reset();
    return _VkWriteDescriptorSetAccelerationStructureNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAccelerationStructures = null;
    this._pAccelerationStructuresNative = null;
  this.sType = 0x3B9D4E8F;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureCount !== void 0) this.accelerationStructureCount = opts.accelerationStructureCount;
    if (opts.pAccelerationStructures !== void 0) this.pAccelerationStructures = opts.pAccelerationStructures;
    
  }
};

Object.defineProperties(VkWriteDescriptorSetAccelerationStructureNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkWriteDescriptorSetAccelerationStructureNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWriteDescriptorSetAccelerationStructureNV.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructureCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.accelerationStructureCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAccelerationStructures": {
    get() {
    return this._pAccelerationStructures;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAccelerationStructures = value;
    } else if (value === null) {
      this._pAccelerationStructures = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures': Expected 'Array VkAccelerationStructureNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkWriteDescriptorSetAccelerationStructureNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pAccelerationStructures = null;
    this._pAccelerationStructuresNative = null;
  this.sType = 0x3B9D4E8F;
};

VkWriteDescriptorSetAccelerationStructureNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAccelerationStructures !== null) {
    let array = this._pAccelerationStructures;
    
    if (array.length !== this.accelerationStructureCount) {
      throw new RangeError("Invalid array length, expected length of 'accelerationStructureCount' for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAccelerationStructureNV)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures[" + ii + "]': Expected 'VkAccelerationStructureNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAccelerationStructuresNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAccelerationStructuresNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkWriteDescriptorSetAccelerationStructureNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkWriteDescriptorSetAccelerationStructureNV.byteLength = 0x20;

VkWriteDescriptorSetAccelerationStructureNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  accelerationStructureCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAccelerationStructures: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkAccelerationStructureMemoryRequirementsInfoNV **/
function VkAccelerationStructureMemoryRequirementsInfoNV(opts) {
  if (new.target !== VkAccelerationStructureMemoryRequirementsInfoNV) {
    _VkAccelerationStructureMemoryRequirementsInfoNV.reset();
    return _VkAccelerationStructureMemoryRequirementsInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._accelerationStructure = null;
  this.sType = 0x3B9D4E90;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    
  }
};

Object.defineProperties(VkAccelerationStructureMemoryRequirementsInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkAccelerationStructureMemoryRequirementsInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureMemoryRequirementsInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkAccelerationStructureMemoryRequirementsTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkAccelerationStructureMemoryRequirementsInfoNV.type': '" + value + "' is not a value of 'VkAccelerationStructureMemoryRequirementsTypeNV'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "accelerationStructure": {
    get() {
    return this._accelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureNV) {
      
      this._accelerationStructure = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.accelerationStructure': Expected 'VkAccelerationStructureNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._accelerationStructure = null;
  this.sType = 0x3B9D4E90;
};

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAccelerationStructureMemoryRequirementsInfoNV.byteLength = 0x20;

VkAccelerationStructureMemoryRequirementsInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  type: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  accelerationStructure: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceRayTracingPropertiesNV **/
function VkPhysicalDeviceRayTracingPropertiesNV(opts) {
  if (new.target !== VkPhysicalDeviceRayTracingPropertiesNV) {
    _VkPhysicalDeviceRayTracingPropertiesNV.reset();
    return _VkPhysicalDeviceRayTracingPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x40);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D4E91;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRayTracingPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceRayTracingPropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceRayTracingPropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRayTracingPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "shaderGroupHandleSize": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "maxRecursionDepth": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  "maxShaderGroupStride": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    },
  "shaderGroupBaseAlignment": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    },
  "maxGeometryCount": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    },
  "maxInstanceCount": {
    get() {
    return this.memoryViewBigUint64[0x5];
    },
    },
  "maxTriangleCount": {
    get() {
    return this.memoryViewBigUint64[0x6];
    },
    },
  "maxDescriptorSetAccelerationStructures": {
    get() {
    return this.memoryViewUint32[0xE];
    },
    },
  
});

VkPhysicalDeviceRayTracingPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x40], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = 0x3B9D4E91;
};

VkPhysicalDeviceRayTracingPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRayTracingPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
};

VkPhysicalDeviceRayTracingPropertiesNV.byteLength = 0x40;

VkPhysicalDeviceRayTracingPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderGroupHandleSize: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  maxRecursionDepth: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  maxShaderGroupStride: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  shaderGroupBaseAlignment: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  maxGeometryCount: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  maxInstanceCount: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
  maxTriangleCount: {
    byteOffset: 0x30,
    byteLength: 0x8
  },
  maxDescriptorSetAccelerationStructures: {
    byteOffset: 0x38,
    byteLength: 0x4
  },
};
/** VkDrmFormatModifierPropertiesListEXT **/
function VkDrmFormatModifierPropertiesListEXT(opts) {
  if (new.target !== VkDrmFormatModifierPropertiesListEXT) {
    _VkDrmFormatModifierPropertiesListEXT.reset();
    return _VkDrmFormatModifierPropertiesListEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDrmFormatModifierProperties = null;
    this._pDrmFormatModifierPropertiesNative = null;
  this.sType = 0x3B9D3330;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDrmFormatModifierPropertiesListEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrmFormatModifierPropertiesListEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDrmFormatModifierPropertiesListEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDrmFormatModifierPropertiesListEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifierCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "pDrmFormatModifierProperties": {
    get() {
    return this._pDrmFormatModifierProperties;
    },
    },
  
});

VkDrmFormatModifierPropertiesListEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pDrmFormatModifierProperties = null;
    this._pDrmFormatModifierPropertiesNative = null;
  this.sType = 0x3B9D3330;
};

VkDrmFormatModifierPropertiesListEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDrmFormatModifierPropertiesListEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkDrmFormatModifierPropertiesListEXT.byteLength = 0x20;

VkDrmFormatModifierPropertiesListEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  drmFormatModifierCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDrmFormatModifierProperties: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkDrmFormatModifierPropertiesEXT **/
function VkDrmFormatModifierPropertiesEXT(opts) {
  if (new.target !== VkDrmFormatModifierPropertiesEXT) {
    _VkDrmFormatModifierPropertiesEXT.reset();
    return _VkDrmFormatModifierPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDrmFormatModifierPropertiesEXT.prototype, {
  "drmFormatModifier": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    },
  "drmFormatModifierPlaneCount": {
    get() {
    return this.memoryViewUint32[0x2];
    },
    },
  "drmFormatModifierTilingFeatures": {
    get() {
    return this.memoryViewInt32[0x3];
    },
    },
  
});

VkDrmFormatModifierPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
  
};

VkDrmFormatModifierPropertiesEXT.prototype.flush = function flush() {
  
  return true;
};

VkDrmFormatModifierPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkDrmFormatModifierPropertiesEXT.byteLength = 0x10;

VkDrmFormatModifierPropertiesEXT.memoryLayout = {
  drmFormatModifier: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  drmFormatModifierPlaneCount: {
    byteOffset: 0x8,
    byteLength: 0x4
  },
  drmFormatModifierTilingFeatures: {
    byteOffset: 0xC,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceImageDrmFormatModifierInfoEXT **/
function VkPhysicalDeviceImageDrmFormatModifierInfoEXT(opts) {
  if (new.target !== VkPhysicalDeviceImageDrmFormatModifierInfoEXT) {
    _VkPhysicalDeviceImageDrmFormatModifierInfoEXT.reset();
    return _VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = 0x3B9D3332;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifier": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.drmFormatModifier': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  "sharingMode": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sharingMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkSharingMode(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sharingMode': '" + value + "' is not a value of 'VkSharingMode'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.queueFamilyIndexCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = 0x3B9D3332;
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.byteLength = 0x28;

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  drmFormatModifier: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  sharingMode: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  queueFamilyIndexCount: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  pQueueFamilyIndices: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkImageDrmFormatModifierListCreateInfoEXT **/
function VkImageDrmFormatModifierListCreateInfoEXT(opts) {
  if (new.target !== VkImageDrmFormatModifierListCreateInfoEXT) {
    _VkImageDrmFormatModifierListCreateInfoEXT.reset();
    return _VkImageDrmFormatModifierListCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pDrmFormatModifiers = null;
  this.sType = 0x3B9D3333;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifierCount !== void 0) this.drmFormatModifierCount = opts.drmFormatModifierCount;
    if (opts.pDrmFormatModifiers !== void 0) this.pDrmFormatModifiers = opts.pDrmFormatModifiers;
    
  }
};

Object.defineProperties(VkImageDrmFormatModifierListCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageDrmFormatModifierListCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageDrmFormatModifierListCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifierCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.drmFormatModifierCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pDrmFormatModifiers": {
    get() {
    return this._pDrmFormatModifiers;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pDrmFormatModifiers = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDrmFormatModifiers = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.pDrmFormatModifiers': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageDrmFormatModifierListCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pDrmFormatModifiers = null;
  this.sType = 0x3B9D3333;
};

VkImageDrmFormatModifierListCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageDrmFormatModifierListCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageDrmFormatModifierListCreateInfoEXT.byteLength = 0x20;

VkImageDrmFormatModifierListCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  drmFormatModifierCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pDrmFormatModifiers: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkImageDrmFormatModifierExplicitCreateInfoEXT **/
function VkImageDrmFormatModifierExplicitCreateInfoEXT(opts) {
  if (new.target !== VkImageDrmFormatModifierExplicitCreateInfoEXT) {
    _VkImageDrmFormatModifierExplicitCreateInfoEXT.reset();
    return _VkImageDrmFormatModifierExplicitCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this._pPlaneLayouts = null;
    this._pPlaneLayoutsNative = null;
  this.sType = 0x3B9D3334;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
    if (opts.drmFormatModifierPlaneCount !== void 0) this.drmFormatModifierPlaneCount = opts.drmFormatModifierPlaneCount;
    if (opts.pPlaneLayouts !== void 0) this.pPlaneLayouts = opts.pPlaneLayouts;
    
  }
};

Object.defineProperties(VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageDrmFormatModifierExplicitCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifier": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifier': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  "drmFormatModifierPlaneCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifierPlaneCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pPlaneLayouts": {
    get() {
    return this._pPlaneLayouts;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPlaneLayouts = value;
    } else if (value === null) {
      this._pPlaneLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts': Expected 'Array VkSubresourceLayout' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  
  
  this._pPlaneLayouts = null;
    this._pPlaneLayoutsNative = null;
  this.sType = 0x3B9D3334;
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPlaneLayouts !== null) {
    let array = this._pPlaneLayouts;
    
    if (array.length !== this.drmFormatModifierPlaneCount) {
      throw new RangeError("Invalid array length, expected length of 'drmFormatModifierPlaneCount' for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubresourceLayout)) {
        throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts[" + ii + "]': Expected 'VkSubresourceLayout' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPlaneLayoutsNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pPlaneLayoutsNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.byteLength = 0x28;

VkImageDrmFormatModifierExplicitCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  drmFormatModifier: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  drmFormatModifierPlaneCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pPlaneLayouts: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkImageDrmFormatModifierPropertiesEXT **/
function VkImageDrmFormatModifierPropertiesEXT(opts) {
  if (new.target !== VkImageDrmFormatModifierPropertiesEXT) {
    _VkImageDrmFormatModifierPropertiesEXT.reset();
    return _VkImageDrmFormatModifierPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D3335;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageDrmFormatModifierPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageDrmFormatModifierPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageDrmFormatModifierPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifier": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    },
  
});

VkImageDrmFormatModifierPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D3335;
};

VkImageDrmFormatModifierPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageDrmFormatModifierPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkImageDrmFormatModifierPropertiesEXT.byteLength = 0x18;

VkImageDrmFormatModifierPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  drmFormatModifier: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkImageStencilUsageCreateInfoEXT **/
function VkImageStencilUsageCreateInfoEXT(opts) {
  if (new.target !== VkImageStencilUsageCreateInfoEXT) {
    _VkImageStencilUsageCreateInfoEXT.reset();
    return _VkImageStencilUsageCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E8AF0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilUsage !== void 0) this.stencilUsage = opts.stencilUsage;
    
  }
};

Object.defineProperties(VkImageStencilUsageCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageStencilUsageCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageStencilUsageCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageStencilUsageCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "stencilUsage": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageStencilUsageCreateInfoEXT.stencilUsage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkImageStencilUsageCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E8AF0;
};

VkImageStencilUsageCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageStencilUsageCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageStencilUsageCreateInfoEXT.byteLength = 0x18;

VkImageStencilUsageCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  stencilUsage: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkDeviceMemoryOverallocationCreateInfoAMD **/
function VkDeviceMemoryOverallocationCreateInfoAMD(opts) {
  if (new.target !== VkDeviceMemoryOverallocationCreateInfoAMD) {
    _VkDeviceMemoryOverallocationCreateInfoAMD.reset();
    return _VkDeviceMemoryOverallocationCreateInfoAMD;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DAC48;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.overallocationBehavior !== void 0) this.overallocationBehavior = opts.overallocationBehavior;
    
  }
};

Object.defineProperties(VkDeviceMemoryOverallocationCreateInfoAMD.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceMemoryOverallocationCreateInfoAMD.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkDeviceMemoryOverallocationCreateInfoAMD.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceMemoryOverallocationCreateInfoAMD.pNext' isn't allowed to be filled");
    }
    },
  "overallocationBehavior": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceMemoryOverallocationCreateInfoAMD.overallocationBehavior': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkMemoryOverallocationBehaviorAMD(value)) {
      throw new RangeError("Invalid value for 'VkDeviceMemoryOverallocationCreateInfoAMD.overallocationBehavior': '" + value + "' is not a value of 'VkMemoryOverallocationBehaviorAMD'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DAC48;
};

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceMemoryOverallocationCreateInfoAMD.byteLength = 0x18;

VkDeviceMemoryOverallocationCreateInfoAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  overallocationBehavior: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFragmentDensityMapFeaturesEXT **/
function VkPhysicalDeviceFragmentDensityMapFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceFragmentDensityMapFeaturesEXT) {
    _VkPhysicalDeviceFragmentDensityMapFeaturesEXT.reset();
    return _VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E1D90;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentDensityMapFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFragmentDensityMapFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentDensityMapFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentDensityMap": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  "fragmentDensityMapDynamic": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  "fragmentDensityMapNonSubsampledImages": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    },
  
});

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E1D90;
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.byteLength = 0x20;

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fragmentDensityMap: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  fragmentDensityMapDynamic: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  fragmentDensityMapNonSubsampledImages: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFragmentDensityMapPropertiesEXT **/
function VkPhysicalDeviceFragmentDensityMapPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceFragmentDensityMapPropertiesEXT) {
    _VkPhysicalDeviceFragmentDensityMapPropertiesEXT.reset();
    return _VkPhysicalDeviceFragmentDensityMapPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._minFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this._maxFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x18 });
  
  this.sType = 0x3B9E1D91;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentDensityMapPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFragmentDensityMapPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentDensityMapPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "minFragmentDensityTexelSize": {
    get() {
    return this._minFragmentDensityTexelSize;
    },
    },
  "maxFragmentDensityTexelSize": {
    get() {
    return this._maxFragmentDensityTexelSize;
    },
    },
  "fragmentDensityInvocations": {
    get() {
    return this.memoryViewUint32[0x8] !== 0;
    },
    },
  
});

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._minFragmentDensityTexelSize = null;
  this._maxFragmentDensityTexelSize = null;
  
  this.sType = 0x3B9E1D91;
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.byteLength = 0x28;

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  minFragmentDensityTexelSize: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  maxFragmentDensityTexelSize: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
  fragmentDensityInvocations: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
};
/** VkRenderPassFragmentDensityMapCreateInfoEXT **/
function VkRenderPassFragmentDensityMapCreateInfoEXT(opts) {
  if (new.target !== VkRenderPassFragmentDensityMapCreateInfoEXT) {
    _VkRenderPassFragmentDensityMapCreateInfoEXT.reset();
    return _VkRenderPassFragmentDensityMapCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._fragmentDensityMapAttachment = new VkAttachmentReference({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x10 });
  this.sType = 0x3B9E1D92;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMapAttachment !== void 0) this.fragmentDensityMapAttachment = opts.fragmentDensityMapAttachment;
    
  }
};

Object.defineProperties(VkRenderPassFragmentDensityMapCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassFragmentDensityMapCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassFragmentDensityMapCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassFragmentDensityMapCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentDensityMapAttachment": {
    get() {
    return this._fragmentDensityMapAttachment;
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference) {
      value.flush();
      this._fragmentDensityMapAttachment = value;
      
      
    } else if (value === null) {
      this._fragmentDensityMapAttachment = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment': Expected 'VkAttachmentReference' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._fragmentDensityMapAttachment = null;
  this.sType = 0x3B9E1D92;
};

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._fragmentDensityMapAttachment !== null) {
    let fragmentDensityMapAttachment = this._fragmentDensityMapAttachment;
    fragmentDensityMapAttachment.flush();
    if (this.memoryBuffer !== fragmentDensityMapAttachment.memoryBuffer) {
      let srcView = new Uint8Array(fragmentDensityMapAttachment.memoryBuffer).subarray(fragmentDensityMapAttachment.$memoryOffset, fragmentDensityMapAttachment.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassFragmentDensityMapCreateInfoEXT.byteLength = 0x18;

VkRenderPassFragmentDensityMapCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fragmentDensityMapAttachment: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceScalarBlockLayoutFeaturesEXT **/
function VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceScalarBlockLayoutFeaturesEXT) {
    _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.reset();
    return _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E2948;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    
  }
};

Object.defineProperties(VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "scalarBlockLayout": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E2948;
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  scalarBlockLayout: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSurfaceProtectedCapabilitiesKHR **/
function VkSurfaceProtectedCapabilitiesKHR(opts) {
  if (new.target !== VkSurfaceProtectedCapabilitiesKHR) {
    _VkSurfaceProtectedCapabilitiesKHR.reset();
    return _VkSurfaceProtectedCapabilitiesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E6F98;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.supportsProtected !== void 0) this.supportsProtected = opts.supportsProtected;
    
  }
};

Object.defineProperties(VkSurfaceProtectedCapabilitiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceProtectedCapabilitiesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceProtectedCapabilitiesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceProtectedCapabilitiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "supportsProtected": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkSurfaceProtectedCapabilitiesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E6F98;
};

VkSurfaceProtectedCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceProtectedCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSurfaceProtectedCapabilitiesKHR.byteLength = 0x18;

VkSurfaceProtectedCapabilitiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  supportsProtected: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR **/
function VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR) {
    _VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.reset();
    return _VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9EA648;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    
  }
};

Object.defineProperties(VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "uniformBufferStandardLayout": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9EA648;
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  uniformBufferStandardLayout: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceDepthClipEnableFeaturesEXT **/
function VkPhysicalDeviceDepthClipEnableFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceDepthClipEnableFeaturesEXT) {
    _VkPhysicalDeviceDepthClipEnableFeaturesEXT.reset();
    return _VkPhysicalDeviceDepthClipEnableFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C5870;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDepthClipEnableFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceDepthClipEnableFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDepthClipEnableFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "depthClipEnable": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C5870;
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceDepthClipEnableFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  depthClipEnable: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineRasterizationDepthClipStateCreateInfoEXT **/
function VkPipelineRasterizationDepthClipStateCreateInfoEXT(opts) {
  if (new.target !== VkPipelineRasterizationDepthClipStateCreateInfoEXT) {
    _VkPipelineRasterizationDepthClipStateCreateInfoEXT.reset();
    return _VkPipelineRasterizationDepthClipStateCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C5871;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
    
  }
};

Object.defineProperties(VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationDepthClipStateCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineRasterizationDepthClipStateCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationDepthClipStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationDepthClipStateCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "depthClipEnable": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9C5871;
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.byteLength = 0x18;

VkPipelineRasterizationDepthClipStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  depthClipEnable: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceMemoryBudgetPropertiesEXT **/
function VkPhysicalDeviceMemoryBudgetPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceMemoryBudgetPropertiesEXT) {
    _VkPhysicalDeviceMemoryBudgetPropertiesEXT.reset();
    return _VkPhysicalDeviceMemoryBudgetPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x110) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x110) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x110) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x110) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x110);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._heapBudget = [...Array(16)].fill(0x0);
  this._heapUsage = [...Array(16)].fill(0x0);
  this.sType = 0x3B9E67C8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryBudgetPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMemoryBudgetPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMemoryBudgetPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "heapBudget": {
    get() {
    return [
      this.memoryViewBigUint64[0x2],
      this.memoryViewBigUint64[0x3],
      this.memoryViewBigUint64[0x4],
      this.memoryViewBigUint64[0x5],
      this.memoryViewBigUint64[0x6],
      this.memoryViewBigUint64[0x7],
      this.memoryViewBigUint64[0x8],
      this.memoryViewBigUint64[0x9],
      this.memoryViewBigUint64[0xA],
      this.memoryViewBigUint64[0xB],
      this.memoryViewBigUint64[0xC],
      this.memoryViewBigUint64[0xD],
      this.memoryViewBigUint64[0xE],
      this.memoryViewBigUint64[0xF],
      this.memoryViewBigUint64[0x10],
      this.memoryViewBigUint64[0x11]
    ];
    },
    },
  "heapUsage": {
    get() {
    return [
      this.memoryViewBigUint64[0x12],
      this.memoryViewBigUint64[0x13],
      this.memoryViewBigUint64[0x14],
      this.memoryViewBigUint64[0x15],
      this.memoryViewBigUint64[0x16],
      this.memoryViewBigUint64[0x17],
      this.memoryViewBigUint64[0x18],
      this.memoryViewBigUint64[0x19],
      this.memoryViewBigUint64[0x1A],
      this.memoryViewBigUint64[0x1B],
      this.memoryViewBigUint64[0x1C],
      this.memoryViewBigUint64[0x1D],
      this.memoryViewBigUint64[0x1E],
      this.memoryViewBigUint64[0x1F],
      this.memoryViewBigUint64[0x20],
      this.memoryViewBigUint64[0x21]
    ];
    },
    },
  
});

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x110], 0x0);
  
  this._pNext = null;
  this._heapBudget = null;
  this._heapUsage = null;
  this.sType = 0x3B9E67C8;
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x110));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x110), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.byteLength = 0x110;

VkPhysicalDeviceMemoryBudgetPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  heapBudget: {
    byteOffset: 0x10,
    byteLength: 0x80
  },
  heapUsage: {
    byteOffset: 0x90,
    byteLength: 0x80
  },
};
/** VkPhysicalDeviceMemoryPriorityFeaturesEXT **/
function VkPhysicalDeviceMemoryPriorityFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceMemoryPriorityFeaturesEXT) {
    _VkPhysicalDeviceMemoryPriorityFeaturesEXT.reset();
    return _VkPhysicalDeviceMemoryPriorityFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E6BB0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memoryPriority !== void 0) this.memoryPriority = opts.memoryPriority;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryPriorityFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceMemoryPriorityFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMemoryPriorityFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "memoryPriority": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E6BB0;
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceMemoryPriorityFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  memoryPriority: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkMemoryPriorityAllocateInfoEXT **/
function VkMemoryPriorityAllocateInfoEXT(opts) {
  if (new.target !== VkMemoryPriorityAllocateInfoEXT) {
    _VkMemoryPriorityAllocateInfoEXT.reset();
    return _VkMemoryPriorityAllocateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E6BB1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.priority !== void 0) this.priority = opts.priority;
    
  }
};

Object.defineProperties(VkMemoryPriorityAllocateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryPriorityAllocateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkMemoryPriorityAllocateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryPriorityAllocateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "priority": {
    get() {
    return this.memoryViewFloat32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryPriorityAllocateInfoEXT.priority': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x4] = value;
    }
    },
  
});

VkMemoryPriorityAllocateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E6BB1;
};

VkMemoryPriorityAllocateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryPriorityAllocateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryPriorityAllocateInfoEXT.byteLength = 0x18;

VkMemoryPriorityAllocateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  priority: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceBufferDeviceAddressFeaturesEXT **/
function VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) {
    _VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.reset();
    return _VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E8320;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E8320;
};

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.byteLength = 0x20;

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  bufferDeviceAddress: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceBufferAddressFeaturesEXT **/
function VkPhysicalDeviceBufferAddressFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceBufferAddressFeaturesEXT) {
    _VkPhysicalDeviceBufferAddressFeaturesEXT.reset();
    return _VkPhysicalDeviceBufferAddressFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E8320;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBufferAddressFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBufferAddressFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceBufferAddressFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBufferAddressFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E8320;
};

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceBufferAddressFeaturesEXT.byteLength = 0x20;

VkPhysicalDeviceBufferAddressFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  bufferDeviceAddress: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkBufferDeviceAddressInfoEXT **/
function VkBufferDeviceAddressInfoEXT(opts) {
  if (new.target !== VkBufferDeviceAddressInfoEXT) {
    _VkBufferDeviceAddressInfoEXT.reset();
    return _VkBufferDeviceAddressInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = 0x3B9E8321;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferDeviceAddressInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferDeviceAddressInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferDeviceAddressInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfoEXT.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferDeviceAddressInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = 0x3B9E8321;
};

VkBufferDeviceAddressInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferDeviceAddressInfoEXT.byteLength = 0x18;

VkBufferDeviceAddressInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  buffer: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkBufferDeviceAddressCreateInfoEXT **/
function VkBufferDeviceAddressCreateInfoEXT(opts) {
  if (new.target !== VkBufferDeviceAddressCreateInfoEXT) {
    _VkBufferDeviceAddressCreateInfoEXT.reset();
    return _VkBufferDeviceAddressCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E8322;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    
  }
};

Object.defineProperties(VkBufferDeviceAddressCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkBufferDeviceAddressCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferDeviceAddressCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "deviceAddress": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressCreateInfoEXT.deviceAddress': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  
});

VkBufferDeviceAddressCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E8322;
};

VkBufferDeviceAddressCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferDeviceAddressCreateInfoEXT.byteLength = 0x18;

VkBufferDeviceAddressCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  deviceAddress: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceImageViewImageFormatInfoEXT **/
function VkPhysicalDeviceImageViewImageFormatInfoEXT(opts) {
  if (new.target !== VkPhysicalDeviceImageViewImageFormatInfoEXT) {
    _VkPhysicalDeviceImageViewImageFormatInfoEXT.reset();
    return _VkPhysicalDeviceImageViewImageFormatInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D6210;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageViewType !== void 0) this.imageViewType = opts.imageViewType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageViewImageFormatInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageViewImageFormatInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImageViewImageFormatInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "imageViewType": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageViewImageFormatInfoEXT.imageViewType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkImageViewType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImageViewImageFormatInfoEXT.imageViewType': '" + value + "' is not a value of 'VkImageViewType'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D6210;
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.byteLength = 0x18;

VkPhysicalDeviceImageViewImageFormatInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imageViewType: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkFilterCubicImageViewImageFormatPropertiesEXT **/
function VkFilterCubicImageViewImageFormatPropertiesEXT(opts) {
  if (new.target !== VkFilterCubicImageViewImageFormatPropertiesEXT) {
    _VkFilterCubicImageViewImageFormatPropertiesEXT.reset();
    return _VkFilterCubicImageViewImageFormatPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D6211;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFilterCubicImageViewImageFormatPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFilterCubicImageViewImageFormatPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFilterCubicImageViewImageFormatPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFilterCubicImageViewImageFormatPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "filterCubic": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    },
  "filterCubicMinmax": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    },
  
});

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D6211;
};

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkFilterCubicImageViewImageFormatPropertiesEXT.byteLength = 0x18;

VkFilterCubicImageViewImageFormatPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  filterCubic: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  filterCubicMinmax: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceImagelessFramebufferFeaturesKHR **/
function VkPhysicalDeviceImagelessFramebufferFeaturesKHR(opts) {
  if (new.target !== VkPhysicalDeviceImagelessFramebufferFeaturesKHR) {
    _VkPhysicalDeviceImagelessFramebufferFeaturesKHR.reset();
    return _VkPhysicalDeviceImagelessFramebufferFeaturesKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9C6FE0;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImagelessFramebufferFeaturesKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceImagelessFramebufferFeaturesKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImagelessFramebufferFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "imagelessFramebuffer": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9C6FE0;
};

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imagelessFramebuffer: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkFramebufferAttachmentsCreateInfoKHR **/
function VkFramebufferAttachmentsCreateInfoKHR(opts) {
  if (new.target !== VkFramebufferAttachmentsCreateInfoKHR) {
    _VkFramebufferAttachmentsCreateInfoKHR.reset();
    return _VkFramebufferAttachmentsCreateInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAttachmentImageInfos = null;
    this._pAttachmentImageInfosNative = null;
  this.sType = 0x3B9C6FE1;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentImageInfoCount !== void 0) this.attachmentImageInfoCount = opts.attachmentImageInfoCount;
    if (opts.pAttachmentImageInfos !== void 0) this.pAttachmentImageInfos = opts.pAttachmentImageInfos;
    
  }
};

Object.defineProperties(VkFramebufferAttachmentsCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFramebufferAttachmentsCreateInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferAttachmentsCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "attachmentImageInfoCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfoKHR.attachmentImageInfoCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAttachmentImageInfos": {
    get() {
    return this._pAttachmentImageInfos;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachmentImageInfos = value;
    } else if (value === null) {
      this._pAttachmentImageInfos = null;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfoKHR.pAttachmentImageInfos': Expected 'Array VkFramebufferAttachmentImageInfoKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkFramebufferAttachmentsCreateInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pAttachmentImageInfos = null;
    this._pAttachmentImageInfosNative = null;
  this.sType = 0x3B9C6FE1;
};

VkFramebufferAttachmentsCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachmentImageInfos !== null) {
    let array = this._pAttachmentImageInfos;
    
    if (array.length !== this.attachmentImageInfoCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentImageInfoCount' for 'VkFramebufferAttachmentsCreateInfoKHR.pAttachmentImageInfos'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkFramebufferAttachmentImageInfoKHR)) {
        throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfoKHR.pAttachmentImageInfos[" + ii + "]': Expected 'VkFramebufferAttachmentImageInfoKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentImageInfosNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAttachmentImageInfosNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkFramebufferAttachmentsCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkFramebufferAttachmentsCreateInfoKHR.byteLength = 0x20;

VkFramebufferAttachmentsCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  attachmentImageInfoCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAttachmentImageInfos: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkFramebufferAttachmentImageInfoKHR **/
function VkFramebufferAttachmentImageInfoKHR(opts) {
  if (new.target !== VkFramebufferAttachmentImageInfoKHR) {
    _VkFramebufferAttachmentImageInfoKHR.reset();
    return _VkFramebufferAttachmentImageInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._pViewFormats = null;
  this.sType = 0x3B9C6FE2;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

Object.defineProperties(VkFramebufferAttachmentImageInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFramebufferAttachmentImageInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferAttachmentImageInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "usage": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.usage': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  "width": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.width': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "height": {
    get() {
    return this.memoryViewUint32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.height': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x7] = value;
    }
    },
  "layerCount": {
    get() {
    return this.memoryViewUint32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.layerCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x8] = value;
    }
    },
  "viewFormatCount": {
    get() {
    return this.memoryViewUint32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.viewFormatCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x9] = value;
    }
    },
  "pViewFormats": {
    get() {
    return this._pViewFormats;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.pViewFormats': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkFramebufferAttachmentImageInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this._pViewFormats = null;
  this.sType = 0x3B9C6FE2;
};

VkFramebufferAttachmentImageInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFramebufferAttachmentImageInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkFramebufferAttachmentImageInfoKHR.byteLength = 0x30;

VkFramebufferAttachmentImageInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  usage: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  width: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  height: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  layerCount: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  viewFormatCount: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  pViewFormats: {
    byteOffset: 0x28,
    byteLength: 0x8
  },
};
/** VkRenderPassAttachmentBeginInfoKHR **/
function VkRenderPassAttachmentBeginInfoKHR(opts) {
  if (new.target !== VkRenderPassAttachmentBeginInfoKHR) {
    _VkRenderPassAttachmentBeginInfoKHR.reset();
    return _VkRenderPassAttachmentBeginInfoKHR;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  this.sType = 0x3B9C6FE3;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    
  }
};

Object.defineProperties(VkRenderPassAttachmentBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfoKHR.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkRenderPassAttachmentBeginInfoKHR.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassAttachmentBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfoKHR.attachmentCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "pAttachments": {
    get() {
    return this._pAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfoKHR.pAttachments': Expected 'Array VkImageView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassAttachmentBeginInfoKHR.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  this._pAttachments = null;
    this._pAttachmentsNative = null;
  this.sType = 0x3B9C6FE3;
};

VkRenderPassAttachmentBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassAttachmentBeginInfoKHR.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageView)) {
        throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfoKHR.pAttachments[" + ii + "]': Expected 'VkImageView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryViewBigInt64[0x3] = nativeArray.address;
    } else {
      this._pAttachmentsNative = null;
      this.memoryViewBigInt64[0x3] = BI0;
    }
  }
  
  return true;
};

VkRenderPassAttachmentBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassAttachmentBeginInfoKHR.byteLength = 0x20;

VkRenderPassAttachmentBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  attachmentCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  pAttachments: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPhysicalDeviceCooperativeMatrixFeaturesNV **/
function VkPhysicalDeviceCooperativeMatrixFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceCooperativeMatrixFeaturesNV) {
    _VkPhysicalDeviceCooperativeMatrixFeaturesNV.reset();
    return _VkPhysicalDeviceCooperativeMatrixFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9E96A8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.cooperativeMatrix !== void 0) this.cooperativeMatrix = opts.cooperativeMatrix;
    if (opts.cooperativeMatrixRobustBufferAccess !== void 0) this.cooperativeMatrixRobustBufferAccess = opts.cooperativeMatrixRobustBufferAccess;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCooperativeMatrixFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceCooperativeMatrixFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCooperativeMatrixFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "cooperativeMatrix": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "cooperativeMatrixRobustBufferAccess": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  
});

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9E96A8;
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceCooperativeMatrixFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  cooperativeMatrix: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  cooperativeMatrixRobustBufferAccess: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceCooperativeMatrixPropertiesNV **/
function VkPhysicalDeviceCooperativeMatrixPropertiesNV(opts) {
  if (new.target !== VkPhysicalDeviceCooperativeMatrixPropertiesNV) {
    _VkPhysicalDeviceCooperativeMatrixPropertiesNV.reset();
    return _VkPhysicalDeviceCooperativeMatrixPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E96AA;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCooperativeMatrixPropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceCooperativeMatrixPropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCooperativeMatrixPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "cooperativeMatrixSupportedStages": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  
});

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E96AA;
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.byteLength = 0x18;

VkPhysicalDeviceCooperativeMatrixPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  cooperativeMatrixSupportedStages: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkCooperativeMatrixPropertiesNV **/
function VkCooperativeMatrixPropertiesNV(opts) {
  if (new.target !== VkCooperativeMatrixPropertiesNV) {
    _VkCooperativeMatrixPropertiesNV.reset();
    return _VkCooperativeMatrixPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = 0x3B9E96A9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.MSize !== void 0) this.MSize = opts.MSize;
    if (opts.NSize !== void 0) this.NSize = opts.NSize;
    if (opts.KSize !== void 0) this.KSize = opts.KSize;
    if (opts.AType !== void 0) this.AType = opts.AType;
    if (opts.BType !== void 0) this.BType = opts.BType;
    if (opts.CType !== void 0) this.CType = opts.CType;
    if (opts.DType !== void 0) this.DType = opts.DType;
    if (opts.scope !== void 0) this.scope = opts.scope;
    
  }
};

Object.defineProperties(VkCooperativeMatrixPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkCooperativeMatrixPropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCooperativeMatrixPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "MSize": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.MSize': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  "NSize": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.NSize': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x5] = value;
    }
    },
  "KSize": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.KSize': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "AType": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.AType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkCooperativeMatrixPropertiesNV.AType': '" + value + "' is not a value of 'VkComponentTypeNV'");
    }
    this.memoryViewInt32[0x7] = value;
    }
    },
  "BType": {
    get() {
    return this.memoryViewInt32[0x8];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.BType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkCooperativeMatrixPropertiesNV.BType': '" + value + "' is not a value of 'VkComponentTypeNV'");
    }
    this.memoryViewInt32[0x8] = value;
    }
    },
  "CType": {
    get() {
    return this.memoryViewInt32[0x9];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.CType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkCooperativeMatrixPropertiesNV.CType': '" + value + "' is not a value of 'VkComponentTypeNV'");
    }
    this.memoryViewInt32[0x9] = value;
    }
    },
  "DType": {
    get() {
    return this.memoryViewInt32[0xA];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.DType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkComponentTypeNV(value)) {
      throw new RangeError("Invalid value for 'VkCooperativeMatrixPropertiesNV.DType': '" + value + "' is not a value of 'VkComponentTypeNV'");
    }
    this.memoryViewInt32[0xA] = value;
    }
    },
  "scope": {
    get() {
    return this.memoryViewInt32[0xB];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.scope': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkScopeNV(value)) {
      throw new RangeError("Invalid value for 'VkCooperativeMatrixPropertiesNV.scope': '" + value + "' is not a value of 'VkScopeNV'");
    }
    this.memoryViewInt32[0xB] = value;
    }
    },
  
});

VkCooperativeMatrixPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = 0x3B9E96A9;
};

VkCooperativeMatrixPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCooperativeMatrixPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCooperativeMatrixPropertiesNV.byteLength = 0x30;

VkCooperativeMatrixPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  MSize: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  NSize: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  KSize: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  AType: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
  BType: {
    byteOffset: 0x20,
    byteLength: 0x4
  },
  CType: {
    byteOffset: 0x24,
    byteLength: 0x4
  },
  DType: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
  scope: {
    byteOffset: 0x2C,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceYcbcrImageArraysFeaturesEXT **/
function VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) {
    _VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.reset();
    return _VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9EA260;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.ycbcrImageArrays !== void 0) this.ycbcrImageArrays = opts.ycbcrImageArrays;
    
  }
};

Object.defineProperties(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "ycbcrImageArrays": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9EA260;
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  ycbcrImageArrays: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkImageViewHandleInfoNVX **/
function VkImageViewHandleInfoNVX(opts) {
  if (new.target !== VkImageViewHandleInfoNVX) {
    _VkImageViewHandleInfoNVX.reset();
    return _VkImageViewHandleInfoNVX;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._imageView = null;
  
  this._sampler = null;
  this.sType = 0x3B9B3F30;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageView !== void 0) this.imageView = opts.imageView;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.sampler !== void 0) this.sampler = opts.sampler;
    
  }
};

Object.defineProperties(VkImageViewHandleInfoNVX.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewHandleInfoNVX.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewHandleInfoNVX.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewHandleInfoNVX.pNext' isn't allowed to be filled");
    }
    },
  "imageView": {
    get() {
    return this._imageView;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageView) {
      
      this._imageView = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._imageView = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageViewHandleInfoNVX.imageView': Expected 'VkImageView' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "descriptorType": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewHandleInfoNVX.descriptorType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkDescriptorType(value)) {
      throw new RangeError("Invalid value for 'VkImageViewHandleInfoNVX.descriptorType': '" + value + "' is not a value of 'VkDescriptorType'");
    }
    this.memoryViewInt32[0x6] = value;
    }
    },
  "sampler": {
    get() {
    return this._sampler;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampler) {
      
      this._sampler = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sampler = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageViewHandleInfoNVX.sampler': Expected 'VkSampler' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageViewHandleInfoNVX.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._imageView = null;
  
  this._sampler = null;
  this.sType = 0x3B9B3F30;
};

VkImageViewHandleInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewHandleInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewHandleInfoNVX.byteLength = 0x28;

VkImageViewHandleInfoNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  imageView: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  descriptorType: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  sampler: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkPipelineCreationFeedbackEXT **/
function VkPipelineCreationFeedbackEXT(opts) {
  if (new.target !== VkPipelineCreationFeedbackEXT) {
    _VkPipelineCreationFeedbackEXT.reset();
    return _VkPipelineCreationFeedbackEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPipelineCreationFeedbackEXT.prototype, {
  "flags": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    },
  "duration": {
    get() {
    return this.memoryViewBigUint64[0x1];
    },
    },
  
});

VkPipelineCreationFeedbackEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  
  
};

VkPipelineCreationFeedbackEXT.prototype.flush = function flush() {
  
  return true;
};

VkPipelineCreationFeedbackEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkPipelineCreationFeedbackEXT.byteLength = 0x10;

VkPipelineCreationFeedbackEXT.memoryLayout = {
  flags: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  duration: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkPipelineCreationFeedbackCreateInfoEXT **/
function VkPipelineCreationFeedbackCreateInfoEXT(opts) {
  if (new.target !== VkPipelineCreationFeedbackCreateInfoEXT) {
    _VkPipelineCreationFeedbackCreateInfoEXT.reset();
    return _VkPipelineCreationFeedbackCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x28) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x28);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._pPipelineCreationFeedback = null;
  
  this._pPipelineStageCreationFeedbacks = null;
    this._pPipelineStageCreationFeedbacksNative = null;
  this.sType = 0x3B9DB800;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pPipelineCreationFeedback !== void 0) this.pPipelineCreationFeedback = opts.pPipelineCreationFeedback;
    if (opts.pipelineStageCreationFeedbackCount !== void 0) this.pipelineStageCreationFeedbackCount = opts.pipelineStageCreationFeedbackCount;
    if (opts.pPipelineStageCreationFeedbacks !== void 0) this.pPipelineStageCreationFeedbacks = opts.pPipelineStageCreationFeedbacks;
    
  }
};

Object.defineProperties(VkPipelineCreationFeedbackCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCreationFeedbackCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCreationFeedbackCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "pPipelineCreationFeedback": {
    get() {
    return this._pPipelineCreationFeedback;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineCreationFeedbackEXT) {
      value.flush();
      this._pPipelineCreationFeedback = value;
      this.memoryViewBigInt64[0x2] = value.memoryAddress;
      
    } else if (value === null) {
      this._pPipelineCreationFeedback = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineCreationFeedback': Expected 'VkPipelineCreationFeedbackEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pipelineStageCreationFeedbackCount": {
    get() {
    return this.memoryViewUint32[0x6];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pipelineStageCreationFeedbackCount': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x6] = value;
    }
    },
  "pPipelineStageCreationFeedbacks": {
    get() {
    return this._pPipelineStageCreationFeedbacks;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPipelineStageCreationFeedbacks = value;
    } else if (value === null) {
      this._pPipelineStageCreationFeedbacks = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineStageCreationFeedbacks': Expected 'Array VkPipelineCreationFeedbackEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineCreationFeedbackCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x28], 0x0);
  
  this._pNext = null;
  this._pPipelineCreationFeedback = null;
  
  this._pPipelineStageCreationFeedbacks = null;
    this._pPipelineStageCreationFeedbacksNative = null;
  this.sType = 0x3B9DB800;
};

VkPipelineCreationFeedbackCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPipelineStageCreationFeedbacks !== null) {
    let array = this._pPipelineStageCreationFeedbacks;
    
    if (array.length !== this.pipelineStageCreationFeedbackCount) {
      throw new RangeError("Invalid array length, expected length of 'pipelineStageCreationFeedbackCount' for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineStageCreationFeedbacks'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineCreationFeedbackEXT)) {
        throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineStageCreationFeedbacks[" + ii + "]': Expected 'VkPipelineCreationFeedbackEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPipelineStageCreationFeedbacksNative = nativeArray;
      this.memoryViewBigInt64[0x4] = nativeArray.address;
    } else {
      this._pPipelineStageCreationFeedbacksNative = null;
      this.memoryViewBigInt64[0x4] = BI0;
    }
  }
  
  return true;
};

VkPipelineCreationFeedbackCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineCreationFeedbackCreateInfoEXT.byteLength = 0x28;

VkPipelineCreationFeedbackCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pPipelineCreationFeedback: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  pipelineStageCreationFeedbackCount: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  pPipelineStageCreationFeedbacks: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
};
/** VkSurfaceFullScreenExclusiveInfoEXT **/
function VkSurfaceFullScreenExclusiveInfoEXT(opts) {
  if (new.target !== VkSurfaceFullScreenExclusiveInfoEXT) {
    _VkSurfaceFullScreenExclusiveInfoEXT.reset();
    return _VkSurfaceFullScreenExclusiveInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9EAE18;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fullScreenExclusive !== void 0) this.fullScreenExclusive = opts.fullScreenExclusive;
    
  }
};

Object.defineProperties(VkSurfaceFullScreenExclusiveInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceFullScreenExclusiveInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceFullScreenExclusiveInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceFullScreenExclusiveInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "fullScreenExclusive": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceFullScreenExclusiveInfoEXT.fullScreenExclusive': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkFullScreenExclusiveEXT(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceFullScreenExclusiveInfoEXT.fullScreenExclusive': '" + value + "' is not a value of 'VkFullScreenExclusiveEXT'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkSurfaceFullScreenExclusiveInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9EAE18;
};

VkSurfaceFullScreenExclusiveInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFullScreenExclusiveInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSurfaceFullScreenExclusiveInfoEXT.byteLength = 0x18;

VkSurfaceFullScreenExclusiveInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fullScreenExclusive: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkSurfaceFullScreenExclusiveWin32InfoEXT **/
function VkSurfaceFullScreenExclusiveWin32InfoEXT(opts) {
  if (new.target !== VkSurfaceFullScreenExclusiveWin32InfoEXT) {
    _VkSurfaceFullScreenExclusiveWin32InfoEXT.reset();
    return _VkSurfaceFullScreenExclusiveWin32InfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this.sType = 0x3B9EAE19;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceFullScreenExclusiveWin32InfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceFullScreenExclusiveWin32InfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceFullScreenExclusiveWin32InfoEXT.pNext' isn't allowed to be filled");
    }
    },
  
});

VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this.sType = 0x3B9EAE19;
};

VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSurfaceFullScreenExclusiveWin32InfoEXT.byteLength = 0x18;

VkSurfaceFullScreenExclusiveWin32InfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkSurfaceCapabilitiesFullScreenExclusiveEXT **/
function VkSurfaceCapabilitiesFullScreenExclusiveEXT(opts) {
  if (new.target !== VkSurfaceCapabilitiesFullScreenExclusiveEXT) {
    _VkSurfaceCapabilitiesFullScreenExclusiveEXT.reset();
    return _VkSurfaceCapabilitiesFullScreenExclusiveEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9EAE1A;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fullScreenExclusiveSupported !== void 0) this.fullScreenExclusiveSupported = opts.fullScreenExclusiveSupported;
    
  }
};

Object.defineProperties(VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilitiesFullScreenExclusiveEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkSurfaceCapabilitiesFullScreenExclusiveEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceCapabilitiesFullScreenExclusiveEXT.pNext' isn't allowed to be filled");
    }
    },
  "fullScreenExclusiveSupported": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9EAE1A;
};

VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSurfaceCapabilitiesFullScreenExclusiveEXT.byteLength = 0x18;

VkSurfaceCapabilitiesFullScreenExclusiveEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fullScreenExclusiveSupported: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkHeadlessSurfaceCreateInfoEXT **/
function VkHeadlessSurfaceCreateInfoEXT(opts) {
  if (new.target !== VkHeadlessSurfaceCreateInfoEXT) {
    _VkHeadlessSurfaceCreateInfoEXT.reset();
    return _VkHeadlessSurfaceCreateInfoEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9EB200;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkHeadlessSurfaceCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHeadlessSurfaceCreateInfoEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkHeadlessSurfaceCreateInfoEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkHeadlessSurfaceCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHeadlessSurfaceCreateInfoEXT.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkHeadlessSurfaceCreateInfoEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9EB200;
};

VkHeadlessSurfaceCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkHeadlessSurfaceCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkHeadlessSurfaceCreateInfoEXT.byteLength = 0x18;

VkHeadlessSurfaceCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceCoverageReductionModeFeaturesNV **/
function VkPhysicalDeviceCoverageReductionModeFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceCoverageReductionModeFeaturesNV) {
    _VkPhysicalDeviceCoverageReductionModeFeaturesNV.reset();
    return _VkPhysicalDeviceCoverageReductionModeFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9E9A90;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.coverageReductionMode !== void 0) this.coverageReductionMode = opts.coverageReductionMode;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCoverageReductionModeFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceCoverageReductionModeFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCoverageReductionModeFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "coverageReductionMode": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9E9A90;
};

VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceCoverageReductionModeFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceCoverageReductionModeFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  coverageReductionMode: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPipelineCoverageReductionStateCreateInfoNV **/
function VkPipelineCoverageReductionStateCreateInfoNV(opts) {
  if (new.target !== VkPipelineCoverageReductionStateCreateInfoNV) {
    _VkPipelineCoverageReductionStateCreateInfoNV.reset();
    return _VkPipelineCoverageReductionStateCreateInfoNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9E9A91;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageReductionMode !== void 0) this.coverageReductionMode = opts.coverageReductionMode;
    
  }
};

Object.defineProperties(VkPipelineCoverageReductionStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageReductionStateCreateInfoNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCoverageReductionStateCreateInfoNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCoverageReductionStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageReductionStateCreateInfoNV.flags': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "coverageReductionMode": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageReductionStateCreateInfoNV.coverageReductionMode': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkCoverageReductionModeNV(value)) {
      throw new RangeError("Invalid value for 'VkPipelineCoverageReductionStateCreateInfoNV.coverageReductionMode': '" + value + "' is not a value of 'VkCoverageReductionModeNV'");
    }
    this.memoryViewInt32[0x5] = value;
    }
    },
  
});

VkPipelineCoverageReductionStateCreateInfoNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9E9A91;
};

VkPipelineCoverageReductionStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageReductionStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCoverageReductionStateCreateInfoNV.byteLength = 0x18;

VkPipelineCoverageReductionStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  flags: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  coverageReductionMode: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkFramebufferMixedSamplesCombinationNV **/
function VkFramebufferMixedSamplesCombinationNV(opts) {
  if (new.target !== VkFramebufferMixedSamplesCombinationNV) {
    _VkFramebufferMixedSamplesCombinationNV.reset();
    return _VkFramebufferMixedSamplesCombinationNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9E9A92;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFramebufferMixedSamplesCombinationNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferMixedSamplesCombinationNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkFramebufferMixedSamplesCombinationNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferMixedSamplesCombinationNV.pNext' isn't allowed to be filled");
    }
    },
  "coverageReductionMode": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    },
  "rasterizationSamples": {
    get() {
    return this.memoryViewInt32[0x5];
    },
    },
  "depthStencilSamples": {
    get() {
    return this.memoryViewInt32[0x6];
    },
    },
  "colorSamples": {
    get() {
    return this.memoryViewInt32[0x7];
    },
    },
  
});

VkFramebufferMixedSamplesCombinationNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9E9A92;
};

VkFramebufferMixedSamplesCombinationNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFramebufferMixedSamplesCombinationNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkFramebufferMixedSamplesCombinationNV.byteLength = 0x20;

VkFramebufferMixedSamplesCombinationNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  coverageReductionMode: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  rasterizationSamples: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  depthStencilSamples: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  colorSamples: {
    byteOffset: 0x1C,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderIntegerFunctions2INTEL **/
function VkPhysicalDeviceShaderIntegerFunctions2INTEL(opts) {
  if (new.target !== VkPhysicalDeviceShaderIntegerFunctions2INTEL) {
    _VkPhysicalDeviceShaderIntegerFunctions2INTEL.reset();
    return _VkPhysicalDeviceShaderIntegerFunctions2INTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DFA68;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderIntegerFunctions2 !== void 0) this.shaderIntegerFunctions2 = opts.shaderIntegerFunctions2;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderIntegerFunctions2INTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderIntegerFunctions2INTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderIntegerFunctions2INTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderIntegerFunctions2INTEL.pNext' isn't allowed to be filled");
    }
    },
  "shaderIntegerFunctions2": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderIntegerFunctions2INTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DFA68;
};

VkPhysicalDeviceShaderIntegerFunctions2INTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderIntegerFunctions2INTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderIntegerFunctions2INTEL.byteLength = 0x18;

VkPhysicalDeviceShaderIntegerFunctions2INTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderIntegerFunctions2: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPerformanceValueINTEL **/
function VkPerformanceValueINTEL(opts) {
  if (new.target !== VkPerformanceValueINTEL) {
    _VkPerformanceValueINTEL.reset();
    return _VkPerformanceValueINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

  }
  
  this._data = new VkPerformanceValueDataINTEL({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x8 });
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

Object.defineProperties(VkPerformanceValueINTEL.prototype, {
  "type": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceValueINTEL.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPerformanceValueTypeINTEL(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceValueINTEL.type': '" + value + "' is not a value of 'VkPerformanceValueTypeINTEL'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "data": {
    get() {
    return this._data;
    },
    set(value) {
    if (value !== null && value.constructor === VkPerformanceValueDataINTEL) {
      value.flush();
      this._data = value;
      
      
    } else if (value === null) {
      this._data = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPerformanceValueINTEL.data': Expected 'VkPerformanceValueDataINTEL' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPerformanceValueINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  
  this._data = null;
  
};

VkPerformanceValueINTEL.prototype.flush = function flush() {
  
  
  if (this._data !== null) {
    let data = this._data;
    data.flush();
    if (this.memoryBuffer !== data.memoryBuffer) {
      let srcView = new Uint8Array(data.memoryBuffer).subarray(data.$memoryOffset, data.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPerformanceValueINTEL.data' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPerformanceValueINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPerformanceValueINTEL.byteLength = 0x10;

VkPerformanceValueINTEL.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  data: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
};
/** VkInitializePerformanceApiInfoINTEL **/
function VkInitializePerformanceApiInfoINTEL(opts) {
  if (new.target !== VkInitializePerformanceApiInfoINTEL) {
    _VkInitializePerformanceApiInfoINTEL.reset();
    return _VkInitializePerformanceApiInfoINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  this._pUserData = null;
  this.sType = 0x3B9DFE51;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkInitializePerformanceApiInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInitializePerformanceApiInfoINTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkInitializePerformanceApiInfoINTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkInitializePerformanceApiInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(value);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkInitializePerformanceApiInfoINTEL.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkInitializePerformanceApiInfoINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  this._pUserData = null;
  this.sType = 0x3B9DFE51;
};

VkInitializePerformanceApiInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkInitializePerformanceApiInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkInitializePerformanceApiInfoINTEL.byteLength = 0x18;

VkInitializePerformanceApiInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  pUserData: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkQueryPoolCreateInfoINTEL **/
function VkQueryPoolCreateInfoINTEL(opts) {
  if (new.target !== VkQueryPoolCreateInfoINTEL) {
    _VkQueryPoolCreateInfoINTEL.reset();
    return _VkQueryPoolCreateInfoINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE50;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCountersSampling !== void 0) this.performanceCountersSampling = opts.performanceCountersSampling;
    
  }
};

Object.defineProperties(VkQueryPoolCreateInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfoINTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkQueryPoolCreateInfoINTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueryPoolCreateInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "performanceCountersSampling": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfoINTEL.performanceCountersSampling': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkQueryPoolSamplingModeINTEL(value)) {
      throw new RangeError("Invalid value for 'VkQueryPoolCreateInfoINTEL.performanceCountersSampling': '" + value + "' is not a value of 'VkQueryPoolSamplingModeINTEL'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkQueryPoolCreateInfoINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE50;
};

VkQueryPoolCreateInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolCreateInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkQueryPoolCreateInfoINTEL.byteLength = 0x18;

VkQueryPoolCreateInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  performanceCountersSampling: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPerformanceMarkerInfoINTEL **/
function VkPerformanceMarkerInfoINTEL(opts) {
  if (new.target !== VkPerformanceMarkerInfoINTEL) {
    _VkPerformanceMarkerInfoINTEL.reset();
    return _VkPerformanceMarkerInfoINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE52;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.marker !== void 0) this.marker = opts.marker;
    
  }
};

Object.defineProperties(VkPerformanceMarkerInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceMarkerInfoINTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceMarkerInfoINTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceMarkerInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "marker": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceMarkerInfoINTEL.marker': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x2] = BigInt(value);
    }
    },
  
});

VkPerformanceMarkerInfoINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE52;
};

VkPerformanceMarkerInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceMarkerInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPerformanceMarkerInfoINTEL.byteLength = 0x18;

VkPerformanceMarkerInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  marker: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
};
/** VkPerformanceStreamMarkerInfoINTEL **/
function VkPerformanceStreamMarkerInfoINTEL(opts) {
  if (new.target !== VkPerformanceStreamMarkerInfoINTEL) {
    _VkPerformanceStreamMarkerInfoINTEL.reset();
    return _VkPerformanceStreamMarkerInfoINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE53;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.marker !== void 0) this.marker = opts.marker;
    
  }
};

Object.defineProperties(VkPerformanceStreamMarkerInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceStreamMarkerInfoINTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceStreamMarkerInfoINTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceStreamMarkerInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "marker": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceStreamMarkerInfoINTEL.marker': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x4] = value;
    }
    },
  
});

VkPerformanceStreamMarkerInfoINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE53;
};

VkPerformanceStreamMarkerInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceStreamMarkerInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPerformanceStreamMarkerInfoINTEL.byteLength = 0x18;

VkPerformanceStreamMarkerInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  marker: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPerformanceOverrideInfoINTEL **/
function VkPerformanceOverrideInfoINTEL(opts) {
  if (new.target !== VkPerformanceOverrideInfoINTEL) {
    _VkPerformanceOverrideInfoINTEL.reset();
    return _VkPerformanceOverrideInfoINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9DFE54;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.enable !== void 0) this.enable = opts.enable;
    if (opts.parameter !== void 0) this.parameter = opts.parameter;
    
  }
};

Object.defineProperties(VkPerformanceOverrideInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceOverrideInfoINTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceOverrideInfoINTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceOverrideInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceOverrideInfoINTEL.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPerformanceOverrideTypeINTEL(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceOverrideInfoINTEL.type': '" + value + "' is not a value of 'VkPerformanceOverrideTypeINTEL'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  "enable": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "parameter": {
    get() {
    return this.memoryViewBigUint64[0x3];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceOverrideInfoINTEL.parameter': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x3] = BigInt(value);
    }
    },
  
});

VkPerformanceOverrideInfoINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9DFE54;
};

VkPerformanceOverrideInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceOverrideInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPerformanceOverrideInfoINTEL.byteLength = 0x20;

VkPerformanceOverrideInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  type: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  enable: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  parameter: {
    byteOffset: 0x18,
    byteLength: 0x8
  },
};
/** VkPerformanceConfigurationAcquireInfoINTEL **/
function VkPerformanceConfigurationAcquireInfoINTEL(opts) {
  if (new.target !== VkPerformanceConfigurationAcquireInfoINTEL) {
    _VkPerformanceConfigurationAcquireInfoINTEL.reset();
    return _VkPerformanceConfigurationAcquireInfoINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE55;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    
  }
};

Object.defineProperties(VkPerformanceConfigurationAcquireInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceConfigurationAcquireInfoINTEL.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceConfigurationAcquireInfoINTEL.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceConfigurationAcquireInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryViewInt32[0x4];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceConfigurationAcquireInfoINTEL.type': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkPerformanceConfigurationTypeINTEL(value)) {
      throw new RangeError("Invalid value for 'VkPerformanceConfigurationAcquireInfoINTEL.type': '" + value + "' is not a value of 'VkPerformanceConfigurationTypeINTEL'");
    }
    this.memoryViewInt32[0x4] = value;
    }
    },
  
});

VkPerformanceConfigurationAcquireInfoINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9DFE55;
};

VkPerformanceConfigurationAcquireInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceConfigurationAcquireInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPerformanceConfigurationAcquireInfoINTEL.byteLength = 0x18;

VkPerformanceConfigurationAcquireInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  type: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderSMBuiltinsPropertiesNV **/
function VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(opts) {
  if (new.target !== VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) {
    _VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.reset();
    return _VkPhysicalDeviceShaderSMBuiltinsPropertiesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D2391;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "shaderSMCount": {
    get() {
    return this.memoryViewUint32[0x4];
    },
    },
  "shaderWarpsPerSM": {
    get() {
    return this.memoryViewUint32[0x5];
    },
    },
  
});

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  
  this.sType = 0x3B9D2391;
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.byteLength = 0x18;

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderSMCount: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  shaderWarpsPerSM: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderSMBuiltinsFeaturesNV **/
function VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(opts) {
  if (new.target !== VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) {
    _VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.reset();
    return _VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9D2390;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSMBuiltins !== void 0) this.shaderSMBuiltins = opts.shaderSMBuiltins;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "shaderSMBuiltins": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9D2390;
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderSMBuiltins: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT **/
function VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) {
    _VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.reset();
    return _VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x20) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x20);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E9E78;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShaderSampleInterlock !== void 0) this.fragmentShaderSampleInterlock = opts.fragmentShaderSampleInterlock;
    if (opts.fragmentShaderPixelInterlock !== void 0) this.fragmentShaderPixelInterlock = opts.fragmentShaderPixelInterlock;
    if (opts.fragmentShaderShadingRateInterlock !== void 0) this.fragmentShaderShadingRateInterlock = opts.fragmentShaderShadingRateInterlock;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentShaderSampleInterlock": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  "fragmentShaderPixelInterlock": {
    get() {
    return this.memoryViewUint32[0x5] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x5] = value | 0;
    }
    },
  "fragmentShaderShadingRateInterlock": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x6] = value | 0;
    }
    },
  
});

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x20], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = 0x3B9E9E78;
};

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.byteLength = 0x20;

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  fragmentShaderSampleInterlock: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
  fragmentShaderPixelInterlock: {
    byteOffset: 0x14,
    byteLength: 0x4
  },
  fragmentShaderShadingRateInterlock: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT **/
function VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT) {
    _VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.reset();
    return _VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9F0020;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDemoteToHelperInvocation !== void 0) this.shaderDemoteToHelperInvocation = opts.shaderDemoteToHelperInvocation;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "shaderDemoteToHelperInvocation": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9F0020;
};

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  shaderDemoteToHelperInvocation: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT **/
function VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(opts) {
  if (new.target !== VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) {
    _VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.reset();
    return _VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x18) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x18);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  this.sType = 0x3B9F13A8;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.texelBufferAlignment !== void 0) this.texelBufferAlignment = opts.texelBufferAlignment;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "texelBufferAlignment": {
    get() {
    return this.memoryViewUint32[0x4] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x4] = value | 0;
    }
    },
  
});

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x18], 0x0);
  
  this._pNext = null;
  
  this.sType = 0x3B9F13A8;
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  texelBufferAlignment: {
    byteOffset: 0x10,
    byteLength: 0x4
  },
};
/** VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT **/
function VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(opts) {
  if (new.target !== VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT) {
    _VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.reset();
    return _VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x30) / 0x1);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x30);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9F13A9;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryViewInt32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.sType': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    if (!$VAL_R_VkStructureType(value)) {
      throw new RangeError("Invalid value for 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.sType': '" + value + "' is not a value of 'VkStructureType'");
    }
    this.memoryViewInt32[0x0] = value;
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "storageTexelBufferOffsetAlignmentBytes": {
    get() {
    return this.memoryViewBigUint64[0x2];
    },
    },
  "storageTexelBufferOffsetSingleTexelAlignment": {
    get() {
    return this.memoryViewUint32[0x6] !== 0;
    },
    },
  "uniformTexelBufferOffsetAlignmentBytes": {
    get() {
    return this.memoryViewBigUint64[0x4];
    },
    },
  "uniformTexelBufferOffsetSingleTexelAlignment": {
    get() {
    return this.memoryViewUint32[0xA] !== 0;
    },
    },
  
});

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x30], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = 0x3B9F13A9;
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.byteLength = 0x30;

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  pNext: {
    byteOffset: 0x8,
    byteLength: 0x8
  },
  storageTexelBufferOffsetAlignmentBytes: {
    byteOffset: 0x10,
    byteLength: 0x8
  },
  storageTexelBufferOffsetSingleTexelAlignment: {
    byteOffset: 0x18,
    byteLength: 0x4
  },
  uniformTexelBufferOffsetAlignmentBytes: {
    byteOffset: 0x20,
    byteLength: 0x8
  },
  uniformTexelBufferOffsetSingleTexelAlignment: {
    byteOffset: 0x28,
    byteLength: 0x4
  },
};
/** VkClearColorValue **/
function VkClearColorValue(opts) {
  if (new.target !== VkClearColorValue) {
    _VkClearColorValue.reset();
    return _VkClearColorValue;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

  }
  this._float32 = null;
  this._int32 = null;
  this._uint32 = null;
  
  if (typeof opts === "object") {
    if (opts.float32 !== void 0) this.float32 = opts.float32;
    if (opts.int32 !== void 0) this.int32 = opts.int32;
    if (opts.uint32 !== void 0) this.uint32 = opts.uint32;
    
  }
};

Object.defineProperties(VkClearColorValue.prototype, {
  "float32": {
    get() {
    return this._float32;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._float32 = value;
    } else if (value === null) {
      this._float32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.float32': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "int32": {
    get() {
    return this._int32;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._int32 = value;
    } else if (value === null) {
      this._int32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.int32': Expected 'Array int32_t' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "uint32": {
    get() {
    return this._uint32;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._uint32 = value;
    } else if (value === null) {
      this._uint32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.uint32': Expected 'Array uint32_t' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkClearColorValue.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  this._float32 = null;
  this._int32 = null;
  this._uint32 = null;
  
};

VkClearColorValue.prototype.flush = function flush() {
  
  
  if (this._float32 !== null) {
    let array = this._float32;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.float32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkClearColorValue.float32[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0x0 + ii] = array[ii];
    };
  } else {
    
  }
  
  
  if (this._int32 !== null) {
    let array = this._int32;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.int32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkClearColorValue.int32[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewInt32[0x0 + ii] = array[ii];
    };
  } else {
    
  }
  
  
  if (this._uint32 !== null) {
    let array = this._uint32;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.uint32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkClearColorValue.uint32[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewUint32[0x0 + ii] = array[ii];
    };
  } else {
    
  }
  
  return true;
};

VkClearColorValue.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkClearColorValue.byteLength = 0x10;

VkClearColorValue.memoryLayout = {
  float32: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  int32: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  uint32: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
};
/** VkClearValue **/
function VkClearValue(opts) {
  if (new.target !== VkClearValue) {
    _VkClearValue.reset();
    return _VkClearValue;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x10) / 0x1);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x10);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

  }
  this._color = new VkClearColorValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._depthStencil = new VkClearDepthStencilValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.color !== void 0) this.color = opts.color;
    if (opts.depthStencil !== void 0) this.depthStencil = opts.depthStencil;
    
  }
};

Object.defineProperties(VkClearValue.prototype, {
  "color": {
    get() {
    return this._color;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearColorValue) {
      value.flush();
      this._color = value;
      
      
    } else if (value === null) {
      this._color = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearValue.color': Expected 'VkClearColorValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "depthStencil": {
    get() {
    return this._depthStencil;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearDepthStencilValue) {
      value.flush();
      this._depthStencil = value;
      
      
    } else if (value === null) {
      this._depthStencil = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearValue.depthStencil': Expected 'VkClearDepthStencilValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkClearValue.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x10], 0x0);
  this._color = null;
  this._depthStencil = null;
  
};

VkClearValue.prototype.flush = function flush() {
  
  
  if (this._color !== null) {
    let color = this._color;
    color.flush();
    if (this.memoryBuffer !== color.memoryBuffer) {
      let srcView = new Uint8Array(color.memoryBuffer).subarray(color.$memoryOffset, color.$memoryOffset + 0x10);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearValue.color' isn't used as shared-memory");
    }
  }
  
  
  if (this._depthStencil !== null) {
    let depthStencil = this._depthStencil;
    depthStencil.flush();
    if (this.memoryBuffer !== depthStencil.memoryBuffer) {
      let srcView = new Uint8Array(depthStencil.memoryBuffer).subarray(depthStencil.$memoryOffset, depthStencil.$memoryOffset + 0x8);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearValue.depthStencil' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkClearValue.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkClearValue.byteLength = 0x10;

VkClearValue.memoryLayout = {
  color: {
    byteOffset: 0x0,
    byteLength: 0x10
  },
  depthStencil: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
};
/** VkPerformanceValueDataINTEL **/
function VkPerformanceValueDataINTEL(opts) {
  if (new.target !== VkPerformanceValueDataINTEL) {
    _VkPerformanceValueDataINTEL.reset();
    return _VkPerformanceValueDataINTEL;
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x8) / 0x1);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x8) / 0x8);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x8) / 0x8);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
    this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
    this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
    this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

  }
  
  
  
  
  this._valueString = null;
  
  if (typeof opts === "object") {
    if (opts.value32 !== void 0) this.value32 = opts.value32;
    if (opts.value64 !== void 0) this.value64 = opts.value64;
    if (opts.valueFloat !== void 0) this.valueFloat = opts.valueFloat;
    if (opts.valueBool !== void 0) this.valueBool = opts.valueBool;
    if (opts.valueString !== void 0) this.valueString = opts.valueString;
    
  }
};

Object.defineProperties(VkPerformanceValueDataINTEL.prototype, {
  "value32": {
    get() {
    return this.memoryViewUint32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceValueDataINTEL.value32': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewUint32[0x0] = value;
    }
    },
  "value64": {
    get() {
    return this.memoryViewBigUint64[0x0];
    },
    set(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceValueDataINTEL.value64': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewBigUint64[0x0] = BigInt(value);
    }
    },
  "valueFloat": {
    get() {
    return this.memoryViewFloat32[0x0];
    },
    set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPerformanceValueDataINTEL.valueFloat': Expected 'Number' but got '" + typeToString(value) + "'");
    }
    this.memoryViewFloat32[0x0] = value;
    }
    },
  "valueBool": {
    get() {
    return this.memoryViewUint32[0x0] !== 0;
    },
    set(value) {
    this.memoryViewUint32[0x0] = value | 0;
    }
    },
  "valueString": {
    get() {
    if (this._valueString !== null) {
      let str = textDecoder.decode(this._valueString);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._valueString = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x0] = getAddressFromArrayBuffer(this._valueString);
    } else if (value === null) {
      this._valueString = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPerformanceValueDataINTEL.valueString': Expected 'String' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPerformanceValueDataINTEL.prototype.reset = function reset() {
  this.memoryViewUint8.set(STRUCT_RESET_CACHE[0x8], 0x0);
  
  
  
  
  this._valueString = null;
  
};

VkPerformanceValueDataINTEL.prototype.flush = function flush() {
  
  return true;
};

VkPerformanceValueDataINTEL.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPerformanceValueDataINTEL.byteLength = 0x8;

VkPerformanceValueDataINTEL.memoryLayout = {
  value32: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  value64: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
  valueFloat: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  valueBool: {
    byteOffset: 0x0,
    byteLength: 0x4
  },
  valueString: {
    byteOffset: 0x0,
    byteLength: 0x8
  },
};

let _VkBaseOutStructure = new VkBaseOutStructure();
let _VkBaseInStructure = new VkBaseInStructure();
let _VkOffset2D = new VkOffset2D();
let _VkOffset3D = new VkOffset3D();
let _VkExtent2D = new VkExtent2D();
let _VkExtent3D = new VkExtent3D();
let _VkViewport = new VkViewport();
let _VkRect2D = new VkRect2D();
let _VkClearRect = new VkClearRect();
let _VkComponentMapping = new VkComponentMapping();
let _VkPhysicalDeviceProperties = new VkPhysicalDeviceProperties();
let _VkExtensionProperties = new VkExtensionProperties();
let _VkLayerProperties = new VkLayerProperties();
let _VkApplicationInfo = new VkApplicationInfo();
let _VkAllocationCallbacks = new VkAllocationCallbacks();
let _VkDeviceQueueCreateInfo = new VkDeviceQueueCreateInfo();
let _VkDeviceCreateInfo = new VkDeviceCreateInfo();
let _VkInstanceCreateInfo = new VkInstanceCreateInfo();
let _VkQueueFamilyProperties = new VkQueueFamilyProperties();
let _VkPhysicalDeviceMemoryProperties = new VkPhysicalDeviceMemoryProperties();
let _VkMemoryAllocateInfo = new VkMemoryAllocateInfo();
let _VkMemoryRequirements = new VkMemoryRequirements();
let _VkSparseImageFormatProperties = new VkSparseImageFormatProperties();
let _VkSparseImageMemoryRequirements = new VkSparseImageMemoryRequirements();
let _VkMemoryType = new VkMemoryType();
let _VkMemoryHeap = new VkMemoryHeap();
let _VkMappedMemoryRange = new VkMappedMemoryRange();
let _VkFormatProperties = new VkFormatProperties();
let _VkImageFormatProperties = new VkImageFormatProperties();
let _VkDescriptorBufferInfo = new VkDescriptorBufferInfo();
let _VkDescriptorImageInfo = new VkDescriptorImageInfo();
let _VkWriteDescriptorSet = new VkWriteDescriptorSet();
let _VkCopyDescriptorSet = new VkCopyDescriptorSet();
let _VkBufferCreateInfo = new VkBufferCreateInfo();
let _VkBufferViewCreateInfo = new VkBufferViewCreateInfo();
let _VkImageSubresource = new VkImageSubresource();
let _VkImageSubresourceLayers = new VkImageSubresourceLayers();
let _VkImageSubresourceRange = new VkImageSubresourceRange();
let _VkMemoryBarrier = new VkMemoryBarrier();
let _VkBufferMemoryBarrier = new VkBufferMemoryBarrier();
let _VkImageMemoryBarrier = new VkImageMemoryBarrier();
let _VkImageCreateInfo = new VkImageCreateInfo();
let _VkSubresourceLayout = new VkSubresourceLayout();
let _VkImageViewCreateInfo = new VkImageViewCreateInfo();
let _VkBufferCopy = new VkBufferCopy();
let _VkSparseMemoryBind = new VkSparseMemoryBind();
let _VkSparseImageMemoryBind = new VkSparseImageMemoryBind();
let _VkSparseBufferMemoryBindInfo = new VkSparseBufferMemoryBindInfo();
let _VkSparseImageOpaqueMemoryBindInfo = new VkSparseImageOpaqueMemoryBindInfo();
let _VkSparseImageMemoryBindInfo = new VkSparseImageMemoryBindInfo();
let _VkBindSparseInfo = new VkBindSparseInfo();
let _VkImageCopy = new VkImageCopy();
let _VkImageBlit = new VkImageBlit();
let _VkBufferImageCopy = new VkBufferImageCopy();
let _VkImageResolve = new VkImageResolve();
let _VkShaderModuleCreateInfo = new VkShaderModuleCreateInfo();
let _VkDescriptorSetLayoutBinding = new VkDescriptorSetLayoutBinding();
let _VkDescriptorSetLayoutCreateInfo = new VkDescriptorSetLayoutCreateInfo();
let _VkDescriptorPoolSize = new VkDescriptorPoolSize();
let _VkDescriptorPoolCreateInfo = new VkDescriptorPoolCreateInfo();
let _VkDescriptorSetAllocateInfo = new VkDescriptorSetAllocateInfo();
let _VkSpecializationMapEntry = new VkSpecializationMapEntry();
let _VkSpecializationInfo = new VkSpecializationInfo();
let _VkPipelineShaderStageCreateInfo = new VkPipelineShaderStageCreateInfo();
let _VkComputePipelineCreateInfo = new VkComputePipelineCreateInfo();
let _VkVertexInputBindingDescription = new VkVertexInputBindingDescription();
let _VkVertexInputAttributeDescription = new VkVertexInputAttributeDescription();
let _VkPipelineVertexInputStateCreateInfo = new VkPipelineVertexInputStateCreateInfo();
let _VkPipelineInputAssemblyStateCreateInfo = new VkPipelineInputAssemblyStateCreateInfo();
let _VkPipelineTessellationStateCreateInfo = new VkPipelineTessellationStateCreateInfo();
let _VkPipelineViewportStateCreateInfo = new VkPipelineViewportStateCreateInfo();
let _VkPipelineRasterizationStateCreateInfo = new VkPipelineRasterizationStateCreateInfo();
let _VkPipelineMultisampleStateCreateInfo = new VkPipelineMultisampleStateCreateInfo();
let _VkPipelineColorBlendAttachmentState = new VkPipelineColorBlendAttachmentState();
let _VkPipelineColorBlendStateCreateInfo = new VkPipelineColorBlendStateCreateInfo();
let _VkPipelineDynamicStateCreateInfo = new VkPipelineDynamicStateCreateInfo();
let _VkStencilOpState = new VkStencilOpState();
let _VkPipelineDepthStencilStateCreateInfo = new VkPipelineDepthStencilStateCreateInfo();
let _VkGraphicsPipelineCreateInfo = new VkGraphicsPipelineCreateInfo();
let _VkPipelineCacheCreateInfo = new VkPipelineCacheCreateInfo();
let _VkPushConstantRange = new VkPushConstantRange();
let _VkPipelineLayoutCreateInfo = new VkPipelineLayoutCreateInfo();
let _VkSamplerCreateInfo = new VkSamplerCreateInfo();
let _VkCommandPoolCreateInfo = new VkCommandPoolCreateInfo();
let _VkCommandBufferAllocateInfo = new VkCommandBufferAllocateInfo();
let _VkCommandBufferInheritanceInfo = new VkCommandBufferInheritanceInfo();
let _VkCommandBufferBeginInfo = new VkCommandBufferBeginInfo();
let _VkRenderPassBeginInfo = new VkRenderPassBeginInfo();
let _VkClearDepthStencilValue = new VkClearDepthStencilValue();
let _VkClearAttachment = new VkClearAttachment();
let _VkAttachmentDescription = new VkAttachmentDescription();
let _VkAttachmentReference = new VkAttachmentReference();
let _VkSubpassDescription = new VkSubpassDescription();
let _VkSubpassDependency = new VkSubpassDependency();
let _VkRenderPassCreateInfo = new VkRenderPassCreateInfo();
let _VkEventCreateInfo = new VkEventCreateInfo();
let _VkFenceCreateInfo = new VkFenceCreateInfo();
let _VkPhysicalDeviceFeatures = new VkPhysicalDeviceFeatures();
let _VkPhysicalDeviceSparseProperties = new VkPhysicalDeviceSparseProperties();
let _VkPhysicalDeviceLimits = new VkPhysicalDeviceLimits();
let _VkSemaphoreCreateInfo = new VkSemaphoreCreateInfo();
let _VkQueryPoolCreateInfo = new VkQueryPoolCreateInfo();
let _VkFramebufferCreateInfo = new VkFramebufferCreateInfo();
let _VkDrawIndirectCommand = new VkDrawIndirectCommand();
let _VkDrawIndexedIndirectCommand = new VkDrawIndexedIndirectCommand();
let _VkDispatchIndirectCommand = new VkDispatchIndirectCommand();
let _VkSubmitInfo = new VkSubmitInfo();
let _VkDisplayPropertiesKHR = new VkDisplayPropertiesKHR();
let _VkDisplayPlanePropertiesKHR = new VkDisplayPlanePropertiesKHR();
let _VkDisplayModeParametersKHR = new VkDisplayModeParametersKHR();
let _VkDisplayModePropertiesKHR = new VkDisplayModePropertiesKHR();
let _VkDisplayModeCreateInfoKHR = new VkDisplayModeCreateInfoKHR();
let _VkDisplayPlaneCapabilitiesKHR = new VkDisplayPlaneCapabilitiesKHR();
let _VkDisplaySurfaceCreateInfoKHR = new VkDisplaySurfaceCreateInfoKHR();
let _VkDisplayPresentInfoKHR = new VkDisplayPresentInfoKHR();
let _VkSurfaceCapabilitiesKHR = new VkSurfaceCapabilitiesKHR();
let _VkWin32SurfaceCreateInfoKHR = new VkWin32SurfaceCreateInfoKHR();
let _VkSurfaceFormatKHR = new VkSurfaceFormatKHR();
let _VkSwapchainCreateInfoKHR = new VkSwapchainCreateInfoKHR();
let _VkPresentInfoKHR = new VkPresentInfoKHR();
let _VkDebugReportCallbackCreateInfoEXT = new VkDebugReportCallbackCreateInfoEXT();
let _VkValidationFlagsEXT = new VkValidationFlagsEXT();
let _VkValidationFeaturesEXT = new VkValidationFeaturesEXT();
let _VkPipelineRasterizationStateRasterizationOrderAMD = new VkPipelineRasterizationStateRasterizationOrderAMD();
let _VkDebugMarkerObjectNameInfoEXT = new VkDebugMarkerObjectNameInfoEXT();
let _VkDebugMarkerObjectTagInfoEXT = new VkDebugMarkerObjectTagInfoEXT();
let _VkDebugMarkerMarkerInfoEXT = new VkDebugMarkerMarkerInfoEXT();
let _VkDedicatedAllocationImageCreateInfoNV = new VkDedicatedAllocationImageCreateInfoNV();
let _VkDedicatedAllocationBufferCreateInfoNV = new VkDedicatedAllocationBufferCreateInfoNV();
let _VkDedicatedAllocationMemoryAllocateInfoNV = new VkDedicatedAllocationMemoryAllocateInfoNV();
let _VkExternalImageFormatPropertiesNV = new VkExternalImageFormatPropertiesNV();
let _VkExternalMemoryImageCreateInfoNV = new VkExternalMemoryImageCreateInfoNV();
let _VkExportMemoryAllocateInfoNV = new VkExportMemoryAllocateInfoNV();
let _VkImportMemoryWin32HandleInfoNV = new VkImportMemoryWin32HandleInfoNV();
let _VkExportMemoryWin32HandleInfoNV = new VkExportMemoryWin32HandleInfoNV();
let _VkWin32KeyedMutexAcquireReleaseInfoNV = new VkWin32KeyedMutexAcquireReleaseInfoNV();
let _VkDeviceGeneratedCommandsFeaturesNVX = new VkDeviceGeneratedCommandsFeaturesNVX();
let _VkDeviceGeneratedCommandsLimitsNVX = new VkDeviceGeneratedCommandsLimitsNVX();
let _VkIndirectCommandsTokenNVX = new VkIndirectCommandsTokenNVX();
let _VkIndirectCommandsLayoutTokenNVX = new VkIndirectCommandsLayoutTokenNVX();
let _VkIndirectCommandsLayoutCreateInfoNVX = new VkIndirectCommandsLayoutCreateInfoNVX();
let _VkCmdProcessCommandsInfoNVX = new VkCmdProcessCommandsInfoNVX();
let _VkCmdReserveSpaceForCommandsInfoNVX = new VkCmdReserveSpaceForCommandsInfoNVX();
let _VkObjectTableCreateInfoNVX = new VkObjectTableCreateInfoNVX();
let _VkObjectTableEntryNVX = new VkObjectTableEntryNVX();
let _VkObjectTablePipelineEntryNVX = new VkObjectTablePipelineEntryNVX();
let _VkObjectTableDescriptorSetEntryNVX = new VkObjectTableDescriptorSetEntryNVX();
let _VkObjectTableVertexBufferEntryNVX = new VkObjectTableVertexBufferEntryNVX();
let _VkObjectTableIndexBufferEntryNVX = new VkObjectTableIndexBufferEntryNVX();
let _VkObjectTablePushConstantEntryNVX = new VkObjectTablePushConstantEntryNVX();
let _VkPhysicalDeviceFeatures2 = new VkPhysicalDeviceFeatures2();
let _VkPhysicalDeviceFeatures2KHR = new VkPhysicalDeviceFeatures2KHR();
let _VkPhysicalDeviceProperties2 = new VkPhysicalDeviceProperties2();
let _VkPhysicalDeviceProperties2KHR = new VkPhysicalDeviceProperties2KHR();
let _VkFormatProperties2 = new VkFormatProperties2();
let _VkFormatProperties2KHR = new VkFormatProperties2KHR();
let _VkImageFormatProperties2 = new VkImageFormatProperties2();
let _VkImageFormatProperties2KHR = new VkImageFormatProperties2KHR();
let _VkPhysicalDeviceImageFormatInfo2 = new VkPhysicalDeviceImageFormatInfo2();
let _VkPhysicalDeviceImageFormatInfo2KHR = new VkPhysicalDeviceImageFormatInfo2KHR();
let _VkQueueFamilyProperties2 = new VkQueueFamilyProperties2();
let _VkQueueFamilyProperties2KHR = new VkQueueFamilyProperties2KHR();
let _VkPhysicalDeviceMemoryProperties2 = new VkPhysicalDeviceMemoryProperties2();
let _VkPhysicalDeviceMemoryProperties2KHR = new VkPhysicalDeviceMemoryProperties2KHR();
let _VkSparseImageFormatProperties2 = new VkSparseImageFormatProperties2();
let _VkSparseImageFormatProperties2KHR = new VkSparseImageFormatProperties2KHR();
let _VkPhysicalDeviceSparseImageFormatInfo2 = new VkPhysicalDeviceSparseImageFormatInfo2();
let _VkPhysicalDeviceSparseImageFormatInfo2KHR = new VkPhysicalDeviceSparseImageFormatInfo2KHR();
let _VkPhysicalDevicePushDescriptorPropertiesKHR = new VkPhysicalDevicePushDescriptorPropertiesKHR();
let _VkConformanceVersionKHR = new VkConformanceVersionKHR();
let _VkPhysicalDeviceDriverPropertiesKHR = new VkPhysicalDeviceDriverPropertiesKHR();
let _VkPresentRegionsKHR = new VkPresentRegionsKHR();
let _VkPresentRegionKHR = new VkPresentRegionKHR();
let _VkRectLayerKHR = new VkRectLayerKHR();
let _VkPhysicalDeviceVariablePointersFeatures = new VkPhysicalDeviceVariablePointersFeatures();
let _VkPhysicalDeviceVariablePointersFeaturesKHR = new VkPhysicalDeviceVariablePointersFeaturesKHR();
let _VkPhysicalDeviceVariablePointerFeaturesKHR = new VkPhysicalDeviceVariablePointerFeaturesKHR();
let _VkPhysicalDeviceVariablePointerFeatures = new VkPhysicalDeviceVariablePointerFeatures();
let _VkExternalMemoryProperties = new VkExternalMemoryProperties();
let _VkExternalMemoryPropertiesKHR = new VkExternalMemoryPropertiesKHR();
let _VkPhysicalDeviceExternalImageFormatInfo = new VkPhysicalDeviceExternalImageFormatInfo();
let _VkPhysicalDeviceExternalImageFormatInfoKHR = new VkPhysicalDeviceExternalImageFormatInfoKHR();
let _VkExternalImageFormatProperties = new VkExternalImageFormatProperties();
let _VkExternalImageFormatPropertiesKHR = new VkExternalImageFormatPropertiesKHR();
let _VkPhysicalDeviceExternalBufferInfo = new VkPhysicalDeviceExternalBufferInfo();
let _VkPhysicalDeviceExternalBufferInfoKHR = new VkPhysicalDeviceExternalBufferInfoKHR();
let _VkExternalBufferProperties = new VkExternalBufferProperties();
let _VkExternalBufferPropertiesKHR = new VkExternalBufferPropertiesKHR();
let _VkPhysicalDeviceIDProperties = new VkPhysicalDeviceIDProperties();
let _VkPhysicalDeviceIDPropertiesKHR = new VkPhysicalDeviceIDPropertiesKHR();
let _VkExternalMemoryImageCreateInfo = new VkExternalMemoryImageCreateInfo();
let _VkExternalMemoryImageCreateInfoKHR = new VkExternalMemoryImageCreateInfoKHR();
let _VkExternalMemoryBufferCreateInfo = new VkExternalMemoryBufferCreateInfo();
let _VkExternalMemoryBufferCreateInfoKHR = new VkExternalMemoryBufferCreateInfoKHR();
let _VkExportMemoryAllocateInfo = new VkExportMemoryAllocateInfo();
let _VkExportMemoryAllocateInfoKHR = new VkExportMemoryAllocateInfoKHR();
let _VkImportMemoryWin32HandleInfoKHR = new VkImportMemoryWin32HandleInfoKHR();
let _VkExportMemoryWin32HandleInfoKHR = new VkExportMemoryWin32HandleInfoKHR();
let _VkMemoryWin32HandlePropertiesKHR = new VkMemoryWin32HandlePropertiesKHR();
let _VkMemoryGetWin32HandleInfoKHR = new VkMemoryGetWin32HandleInfoKHR();
let _VkImportMemoryFdInfoKHR = new VkImportMemoryFdInfoKHR();
let _VkMemoryFdPropertiesKHR = new VkMemoryFdPropertiesKHR();
let _VkMemoryGetFdInfoKHR = new VkMemoryGetFdInfoKHR();
let _VkWin32KeyedMutexAcquireReleaseInfoKHR = new VkWin32KeyedMutexAcquireReleaseInfoKHR();
let _VkPhysicalDeviceExternalSemaphoreInfo = new VkPhysicalDeviceExternalSemaphoreInfo();
let _VkPhysicalDeviceExternalSemaphoreInfoKHR = new VkPhysicalDeviceExternalSemaphoreInfoKHR();
let _VkExternalSemaphoreProperties = new VkExternalSemaphoreProperties();
let _VkExternalSemaphorePropertiesKHR = new VkExternalSemaphorePropertiesKHR();
let _VkExportSemaphoreCreateInfo = new VkExportSemaphoreCreateInfo();
let _VkExportSemaphoreCreateInfoKHR = new VkExportSemaphoreCreateInfoKHR();
let _VkImportSemaphoreWin32HandleInfoKHR = new VkImportSemaphoreWin32HandleInfoKHR();
let _VkExportSemaphoreWin32HandleInfoKHR = new VkExportSemaphoreWin32HandleInfoKHR();
let _VkD3D12FenceSubmitInfoKHR = new VkD3D12FenceSubmitInfoKHR();
let _VkSemaphoreGetWin32HandleInfoKHR = new VkSemaphoreGetWin32HandleInfoKHR();
let _VkImportSemaphoreFdInfoKHR = new VkImportSemaphoreFdInfoKHR();
let _VkSemaphoreGetFdInfoKHR = new VkSemaphoreGetFdInfoKHR();
let _VkPhysicalDeviceExternalFenceInfo = new VkPhysicalDeviceExternalFenceInfo();
let _VkPhysicalDeviceExternalFenceInfoKHR = new VkPhysicalDeviceExternalFenceInfoKHR();
let _VkExternalFenceProperties = new VkExternalFenceProperties();
let _VkExternalFencePropertiesKHR = new VkExternalFencePropertiesKHR();
let _VkExportFenceCreateInfo = new VkExportFenceCreateInfo();
let _VkExportFenceCreateInfoKHR = new VkExportFenceCreateInfoKHR();
let _VkImportFenceWin32HandleInfoKHR = new VkImportFenceWin32HandleInfoKHR();
let _VkExportFenceWin32HandleInfoKHR = new VkExportFenceWin32HandleInfoKHR();
let _VkFenceGetWin32HandleInfoKHR = new VkFenceGetWin32HandleInfoKHR();
let _VkImportFenceFdInfoKHR = new VkImportFenceFdInfoKHR();
let _VkFenceGetFdInfoKHR = new VkFenceGetFdInfoKHR();
let _VkPhysicalDeviceMultiviewFeatures = new VkPhysicalDeviceMultiviewFeatures();
let _VkPhysicalDeviceMultiviewFeaturesKHR = new VkPhysicalDeviceMultiviewFeaturesKHR();
let _VkPhysicalDeviceMultiviewProperties = new VkPhysicalDeviceMultiviewProperties();
let _VkPhysicalDeviceMultiviewPropertiesKHR = new VkPhysicalDeviceMultiviewPropertiesKHR();
let _VkRenderPassMultiviewCreateInfo = new VkRenderPassMultiviewCreateInfo();
let _VkRenderPassMultiviewCreateInfoKHR = new VkRenderPassMultiviewCreateInfoKHR();
let _VkSurfaceCapabilities2EXT = new VkSurfaceCapabilities2EXT();
let _VkDisplayPowerInfoEXT = new VkDisplayPowerInfoEXT();
let _VkDeviceEventInfoEXT = new VkDeviceEventInfoEXT();
let _VkDisplayEventInfoEXT = new VkDisplayEventInfoEXT();
let _VkSwapchainCounterCreateInfoEXT = new VkSwapchainCounterCreateInfoEXT();
let _VkPhysicalDeviceGroupProperties = new VkPhysicalDeviceGroupProperties();
let _VkPhysicalDeviceGroupPropertiesKHR = new VkPhysicalDeviceGroupPropertiesKHR();
let _VkMemoryAllocateFlagsInfo = new VkMemoryAllocateFlagsInfo();
let _VkMemoryAllocateFlagsInfoKHR = new VkMemoryAllocateFlagsInfoKHR();
let _VkBindBufferMemoryInfo = new VkBindBufferMemoryInfo();
let _VkBindBufferMemoryInfoKHR = new VkBindBufferMemoryInfoKHR();
let _VkBindBufferMemoryDeviceGroupInfo = new VkBindBufferMemoryDeviceGroupInfo();
let _VkBindBufferMemoryDeviceGroupInfoKHR = new VkBindBufferMemoryDeviceGroupInfoKHR();
let _VkBindImageMemoryInfo = new VkBindImageMemoryInfo();
let _VkBindImageMemoryInfoKHR = new VkBindImageMemoryInfoKHR();
let _VkBindImageMemoryDeviceGroupInfo = new VkBindImageMemoryDeviceGroupInfo();
let _VkBindImageMemoryDeviceGroupInfoKHR = new VkBindImageMemoryDeviceGroupInfoKHR();
let _VkDeviceGroupRenderPassBeginInfo = new VkDeviceGroupRenderPassBeginInfo();
let _VkDeviceGroupRenderPassBeginInfoKHR = new VkDeviceGroupRenderPassBeginInfoKHR();
let _VkDeviceGroupCommandBufferBeginInfo = new VkDeviceGroupCommandBufferBeginInfo();
let _VkDeviceGroupCommandBufferBeginInfoKHR = new VkDeviceGroupCommandBufferBeginInfoKHR();
let _VkDeviceGroupSubmitInfo = new VkDeviceGroupSubmitInfo();
let _VkDeviceGroupSubmitInfoKHR = new VkDeviceGroupSubmitInfoKHR();
let _VkDeviceGroupBindSparseInfo = new VkDeviceGroupBindSparseInfo();
let _VkDeviceGroupBindSparseInfoKHR = new VkDeviceGroupBindSparseInfoKHR();
let _VkDeviceGroupPresentCapabilitiesKHR = new VkDeviceGroupPresentCapabilitiesKHR();
let _VkImageSwapchainCreateInfoKHR = new VkImageSwapchainCreateInfoKHR();
let _VkBindImageMemorySwapchainInfoKHR = new VkBindImageMemorySwapchainInfoKHR();
let _VkAcquireNextImageInfoKHR = new VkAcquireNextImageInfoKHR();
let _VkDeviceGroupPresentInfoKHR = new VkDeviceGroupPresentInfoKHR();
let _VkDeviceGroupDeviceCreateInfo = new VkDeviceGroupDeviceCreateInfo();
let _VkDeviceGroupDeviceCreateInfoKHR = new VkDeviceGroupDeviceCreateInfoKHR();
let _VkDeviceGroupSwapchainCreateInfoKHR = new VkDeviceGroupSwapchainCreateInfoKHR();
let _VkDescriptorUpdateTemplateEntry = new VkDescriptorUpdateTemplateEntry();
let _VkDescriptorUpdateTemplateEntryKHR = new VkDescriptorUpdateTemplateEntryKHR();
let _VkDescriptorUpdateTemplateCreateInfo = new VkDescriptorUpdateTemplateCreateInfo();
let _VkDescriptorUpdateTemplateCreateInfoKHR = new VkDescriptorUpdateTemplateCreateInfoKHR();
let _VkXYColorEXT = new VkXYColorEXT();
let _VkHdrMetadataEXT = new VkHdrMetadataEXT();
let _VkDisplayNativeHdrSurfaceCapabilitiesAMD = new VkDisplayNativeHdrSurfaceCapabilitiesAMD();
let _VkSwapchainDisplayNativeHdrCreateInfoAMD = new VkSwapchainDisplayNativeHdrCreateInfoAMD();
let _VkRefreshCycleDurationGOOGLE = new VkRefreshCycleDurationGOOGLE();
let _VkPastPresentationTimingGOOGLE = new VkPastPresentationTimingGOOGLE();
let _VkPresentTimesInfoGOOGLE = new VkPresentTimesInfoGOOGLE();
let _VkPresentTimeGOOGLE = new VkPresentTimeGOOGLE();
let _VkViewportWScalingNV = new VkViewportWScalingNV();
let _VkPipelineViewportWScalingStateCreateInfoNV = new VkPipelineViewportWScalingStateCreateInfoNV();
let _VkViewportSwizzleNV = new VkViewportSwizzleNV();
let _VkPipelineViewportSwizzleStateCreateInfoNV = new VkPipelineViewportSwizzleStateCreateInfoNV();
let _VkPhysicalDeviceDiscardRectanglePropertiesEXT = new VkPhysicalDeviceDiscardRectanglePropertiesEXT();
let _VkPipelineDiscardRectangleStateCreateInfoEXT = new VkPipelineDiscardRectangleStateCreateInfoEXT();
let _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = new VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
let _VkInputAttachmentAspectReference = new VkInputAttachmentAspectReference();
let _VkInputAttachmentAspectReferenceKHR = new VkInputAttachmentAspectReferenceKHR();
let _VkRenderPassInputAttachmentAspectCreateInfo = new VkRenderPassInputAttachmentAspectCreateInfo();
let _VkRenderPassInputAttachmentAspectCreateInfoKHR = new VkRenderPassInputAttachmentAspectCreateInfoKHR();
let _VkPhysicalDeviceSurfaceInfo2KHR = new VkPhysicalDeviceSurfaceInfo2KHR();
let _VkSurfaceCapabilities2KHR = new VkSurfaceCapabilities2KHR();
let _VkSurfaceFormat2KHR = new VkSurfaceFormat2KHR();
let _VkDisplayProperties2KHR = new VkDisplayProperties2KHR();
let _VkDisplayPlaneProperties2KHR = new VkDisplayPlaneProperties2KHR();
let _VkDisplayModeProperties2KHR = new VkDisplayModeProperties2KHR();
let _VkDisplayPlaneInfo2KHR = new VkDisplayPlaneInfo2KHR();
let _VkDisplayPlaneCapabilities2KHR = new VkDisplayPlaneCapabilities2KHR();
let _VkSharedPresentSurfaceCapabilitiesKHR = new VkSharedPresentSurfaceCapabilitiesKHR();
let _VkPhysicalDevice16BitStorageFeatures = new VkPhysicalDevice16BitStorageFeatures();
let _VkPhysicalDevice16BitStorageFeaturesKHR = new VkPhysicalDevice16BitStorageFeaturesKHR();
let _VkPhysicalDeviceSubgroupProperties = new VkPhysicalDeviceSubgroupProperties();
let _VkBufferMemoryRequirementsInfo2 = new VkBufferMemoryRequirementsInfo2();
let _VkBufferMemoryRequirementsInfo2KHR = new VkBufferMemoryRequirementsInfo2KHR();
let _VkImageMemoryRequirementsInfo2 = new VkImageMemoryRequirementsInfo2();
let _VkImageMemoryRequirementsInfo2KHR = new VkImageMemoryRequirementsInfo2KHR();
let _VkImageSparseMemoryRequirementsInfo2 = new VkImageSparseMemoryRequirementsInfo2();
let _VkImageSparseMemoryRequirementsInfo2KHR = new VkImageSparseMemoryRequirementsInfo2KHR();
let _VkMemoryRequirements2 = new VkMemoryRequirements2();
let _VkMemoryRequirements2KHR = new VkMemoryRequirements2KHR();
let _VkSparseImageMemoryRequirements2 = new VkSparseImageMemoryRequirements2();
let _VkSparseImageMemoryRequirements2KHR = new VkSparseImageMemoryRequirements2KHR();
let _VkPhysicalDevicePointClippingProperties = new VkPhysicalDevicePointClippingProperties();
let _VkPhysicalDevicePointClippingPropertiesKHR = new VkPhysicalDevicePointClippingPropertiesKHR();
let _VkMemoryDedicatedRequirements = new VkMemoryDedicatedRequirements();
let _VkMemoryDedicatedRequirementsKHR = new VkMemoryDedicatedRequirementsKHR();
let _VkMemoryDedicatedAllocateInfo = new VkMemoryDedicatedAllocateInfo();
let _VkMemoryDedicatedAllocateInfoKHR = new VkMemoryDedicatedAllocateInfoKHR();
let _VkImageViewUsageCreateInfo = new VkImageViewUsageCreateInfo();
let _VkImageViewUsageCreateInfoKHR = new VkImageViewUsageCreateInfoKHR();
let _VkPipelineTessellationDomainOriginStateCreateInfo = new VkPipelineTessellationDomainOriginStateCreateInfo();
let _VkPipelineTessellationDomainOriginStateCreateInfoKHR = new VkPipelineTessellationDomainOriginStateCreateInfoKHR();
let _VkSamplerYcbcrConversionInfo = new VkSamplerYcbcrConversionInfo();
let _VkSamplerYcbcrConversionInfoKHR = new VkSamplerYcbcrConversionInfoKHR();
let _VkSamplerYcbcrConversionCreateInfo = new VkSamplerYcbcrConversionCreateInfo();
let _VkSamplerYcbcrConversionCreateInfoKHR = new VkSamplerYcbcrConversionCreateInfoKHR();
let _VkBindImagePlaneMemoryInfo = new VkBindImagePlaneMemoryInfo();
let _VkBindImagePlaneMemoryInfoKHR = new VkBindImagePlaneMemoryInfoKHR();
let _VkImagePlaneMemoryRequirementsInfo = new VkImagePlaneMemoryRequirementsInfo();
let _VkImagePlaneMemoryRequirementsInfoKHR = new VkImagePlaneMemoryRequirementsInfoKHR();
let _VkPhysicalDeviceSamplerYcbcrConversionFeatures = new VkPhysicalDeviceSamplerYcbcrConversionFeatures();
let _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = new VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR();
let _VkSamplerYcbcrConversionImageFormatProperties = new VkSamplerYcbcrConversionImageFormatProperties();
let _VkSamplerYcbcrConversionImageFormatPropertiesKHR = new VkSamplerYcbcrConversionImageFormatPropertiesKHR();
let _VkTextureLODGatherFormatPropertiesAMD = new VkTextureLODGatherFormatPropertiesAMD();
let _VkConditionalRenderingBeginInfoEXT = new VkConditionalRenderingBeginInfoEXT();
let _VkProtectedSubmitInfo = new VkProtectedSubmitInfo();
let _VkPhysicalDeviceProtectedMemoryFeatures = new VkPhysicalDeviceProtectedMemoryFeatures();
let _VkPhysicalDeviceProtectedMemoryProperties = new VkPhysicalDeviceProtectedMemoryProperties();
let _VkDeviceQueueInfo2 = new VkDeviceQueueInfo2();
let _VkPipelineCoverageToColorStateCreateInfoNV = new VkPipelineCoverageToColorStateCreateInfoNV();
let _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = new VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT();
let _VkSampleLocationEXT = new VkSampleLocationEXT();
let _VkSampleLocationsInfoEXT = new VkSampleLocationsInfoEXT();
let _VkAttachmentSampleLocationsEXT = new VkAttachmentSampleLocationsEXT();
let _VkSubpassSampleLocationsEXT = new VkSubpassSampleLocationsEXT();
let _VkRenderPassSampleLocationsBeginInfoEXT = new VkRenderPassSampleLocationsBeginInfoEXT();
let _VkPipelineSampleLocationsStateCreateInfoEXT = new VkPipelineSampleLocationsStateCreateInfoEXT();
let _VkPhysicalDeviceSampleLocationsPropertiesEXT = new VkPhysicalDeviceSampleLocationsPropertiesEXT();
let _VkMultisamplePropertiesEXT = new VkMultisamplePropertiesEXT();
let _VkSamplerReductionModeCreateInfoEXT = new VkSamplerReductionModeCreateInfoEXT();
let _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = new VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
let _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = new VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
let _VkPipelineColorBlendAdvancedStateCreateInfoEXT = new VkPipelineColorBlendAdvancedStateCreateInfoEXT();
let _VkPhysicalDeviceInlineUniformBlockFeaturesEXT = new VkPhysicalDeviceInlineUniformBlockFeaturesEXT();
let _VkPhysicalDeviceInlineUniformBlockPropertiesEXT = new VkPhysicalDeviceInlineUniformBlockPropertiesEXT();
let _VkWriteDescriptorSetInlineUniformBlockEXT = new VkWriteDescriptorSetInlineUniformBlockEXT();
let _VkDescriptorPoolInlineUniformBlockCreateInfoEXT = new VkDescriptorPoolInlineUniformBlockCreateInfoEXT();
let _VkPipelineCoverageModulationStateCreateInfoNV = new VkPipelineCoverageModulationStateCreateInfoNV();
let _VkImageFormatListCreateInfoKHR = new VkImageFormatListCreateInfoKHR();
let _VkValidationCacheCreateInfoEXT = new VkValidationCacheCreateInfoEXT();
let _VkShaderModuleValidationCacheCreateInfoEXT = new VkShaderModuleValidationCacheCreateInfoEXT();
let _VkPhysicalDeviceMaintenance3Properties = new VkPhysicalDeviceMaintenance3Properties();
let _VkPhysicalDeviceMaintenance3PropertiesKHR = new VkPhysicalDeviceMaintenance3PropertiesKHR();
let _VkDescriptorSetLayoutSupport = new VkDescriptorSetLayoutSupport();
let _VkDescriptorSetLayoutSupportKHR = new VkDescriptorSetLayoutSupportKHR();
let _VkPhysicalDeviceShaderDrawParametersFeatures = new VkPhysicalDeviceShaderDrawParametersFeatures();
let _VkPhysicalDeviceShaderDrawParameterFeatures = new VkPhysicalDeviceShaderDrawParameterFeatures();
let _VkPhysicalDeviceFloat16Int8FeaturesKHR = new VkPhysicalDeviceFloat16Int8FeaturesKHR();
let _VkPhysicalDeviceFloatControlsPropertiesKHR = new VkPhysicalDeviceFloatControlsPropertiesKHR();
let _VkPhysicalDeviceHostQueryResetFeaturesEXT = new VkPhysicalDeviceHostQueryResetFeaturesEXT();
let _VkShaderResourceUsageAMD = new VkShaderResourceUsageAMD();
let _VkShaderStatisticsInfoAMD = new VkShaderStatisticsInfoAMD();
let _VkDeviceQueueGlobalPriorityCreateInfoEXT = new VkDeviceQueueGlobalPriorityCreateInfoEXT();
let _VkDebugUtilsObjectNameInfoEXT = new VkDebugUtilsObjectNameInfoEXT();
let _VkDebugUtilsObjectTagInfoEXT = new VkDebugUtilsObjectTagInfoEXT();
let _VkDebugUtilsLabelEXT = new VkDebugUtilsLabelEXT();
let _VkDebugUtilsMessengerCreateInfoEXT = new VkDebugUtilsMessengerCreateInfoEXT();
let _VkDebugUtilsMessengerCallbackDataEXT = new VkDebugUtilsMessengerCallbackDataEXT();
let _VkImportMemoryHostPointerInfoEXT = new VkImportMemoryHostPointerInfoEXT();
let _VkMemoryHostPointerPropertiesEXT = new VkMemoryHostPointerPropertiesEXT();
let _VkPhysicalDeviceExternalMemoryHostPropertiesEXT = new VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
let _VkPhysicalDeviceConservativeRasterizationPropertiesEXT = new VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
let _VkCalibratedTimestampInfoEXT = new VkCalibratedTimestampInfoEXT();
let _VkPhysicalDeviceShaderCorePropertiesAMD = new VkPhysicalDeviceShaderCorePropertiesAMD();
let _VkPipelineRasterizationConservativeStateCreateInfoEXT = new VkPipelineRasterizationConservativeStateCreateInfoEXT();
let _VkPhysicalDeviceDescriptorIndexingFeaturesEXT = new VkPhysicalDeviceDescriptorIndexingFeaturesEXT();
let _VkPhysicalDeviceDescriptorIndexingPropertiesEXT = new VkPhysicalDeviceDescriptorIndexingPropertiesEXT();
let _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = new VkDescriptorSetLayoutBindingFlagsCreateInfoEXT();
let _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = new VkDescriptorSetVariableDescriptorCountAllocateInfoEXT();
let _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = new VkDescriptorSetVariableDescriptorCountLayoutSupportEXT();
let _VkAttachmentDescription2KHR = new VkAttachmentDescription2KHR();
let _VkAttachmentReference2KHR = new VkAttachmentReference2KHR();
let _VkSubpassDescription2KHR = new VkSubpassDescription2KHR();
let _VkSubpassDependency2KHR = new VkSubpassDependency2KHR();
let _VkRenderPassCreateInfo2KHR = new VkRenderPassCreateInfo2KHR();
let _VkSubpassBeginInfoKHR = new VkSubpassBeginInfoKHR();
let _VkSubpassEndInfoKHR = new VkSubpassEndInfoKHR();
let _VkVertexInputBindingDivisorDescriptionEXT = new VkVertexInputBindingDivisorDescriptionEXT();
let _VkPipelineVertexInputDivisorStateCreateInfoEXT = new VkPipelineVertexInputDivisorStateCreateInfoEXT();
let _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = new VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
let _VkPhysicalDevicePCIBusInfoPropertiesEXT = new VkPhysicalDevicePCIBusInfoPropertiesEXT();
let _VkCommandBufferInheritanceConditionalRenderingInfoEXT = new VkCommandBufferInheritanceConditionalRenderingInfoEXT();
let _VkPhysicalDevice8BitStorageFeaturesKHR = new VkPhysicalDevice8BitStorageFeaturesKHR();
let _VkPhysicalDeviceConditionalRenderingFeaturesEXT = new VkPhysicalDeviceConditionalRenderingFeaturesEXT();
let _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = new VkPhysicalDeviceVulkanMemoryModelFeaturesKHR();
let _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = new VkPhysicalDeviceShaderAtomicInt64FeaturesKHR();
let _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = new VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
let _VkQueueFamilyCheckpointPropertiesNV = new VkQueueFamilyCheckpointPropertiesNV();
let _VkCheckpointDataNV = new VkCheckpointDataNV();
let _VkPhysicalDeviceDepthStencilResolvePropertiesKHR = new VkPhysicalDeviceDepthStencilResolvePropertiesKHR();
let _VkSubpassDescriptionDepthStencilResolveKHR = new VkSubpassDescriptionDepthStencilResolveKHR();
let _VkImageViewASTCDecodeModeEXT = new VkImageViewASTCDecodeModeEXT();
let _VkPhysicalDeviceASTCDecodeFeaturesEXT = new VkPhysicalDeviceASTCDecodeFeaturesEXT();
let _VkPhysicalDeviceTransformFeedbackFeaturesEXT = new VkPhysicalDeviceTransformFeedbackFeaturesEXT();
let _VkPhysicalDeviceTransformFeedbackPropertiesEXT = new VkPhysicalDeviceTransformFeedbackPropertiesEXT();
let _VkPipelineRasterizationStateStreamCreateInfoEXT = new VkPipelineRasterizationStateStreamCreateInfoEXT();
let _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = new VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
let _VkPipelineRepresentativeFragmentTestStateCreateInfoNV = new VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
let _VkPhysicalDeviceExclusiveScissorFeaturesNV = new VkPhysicalDeviceExclusiveScissorFeaturesNV();
let _VkPipelineViewportExclusiveScissorStateCreateInfoNV = new VkPipelineViewportExclusiveScissorStateCreateInfoNV();
let _VkPhysicalDeviceCornerSampledImageFeaturesNV = new VkPhysicalDeviceCornerSampledImageFeaturesNV();
let _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = new VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
let _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = new VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV();
let _VkPhysicalDeviceShaderImageFootprintFeaturesNV = new VkPhysicalDeviceShaderImageFootprintFeaturesNV();
let _VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = new VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
let _VkShadingRatePaletteNV = new VkShadingRatePaletteNV();
let _VkPipelineViewportShadingRateImageStateCreateInfoNV = new VkPipelineViewportShadingRateImageStateCreateInfoNV();
let _VkPhysicalDeviceShadingRateImageFeaturesNV = new VkPhysicalDeviceShadingRateImageFeaturesNV();
let _VkPhysicalDeviceShadingRateImagePropertiesNV = new VkPhysicalDeviceShadingRateImagePropertiesNV();
let _VkCoarseSampleLocationNV = new VkCoarseSampleLocationNV();
let _VkCoarseSampleOrderCustomNV = new VkCoarseSampleOrderCustomNV();
let _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = new VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
let _VkPhysicalDeviceMeshShaderFeaturesNV = new VkPhysicalDeviceMeshShaderFeaturesNV();
let _VkPhysicalDeviceMeshShaderPropertiesNV = new VkPhysicalDeviceMeshShaderPropertiesNV();
let _VkDrawMeshTasksIndirectCommandNV = new VkDrawMeshTasksIndirectCommandNV();
let _VkRayTracingShaderGroupCreateInfoNV = new VkRayTracingShaderGroupCreateInfoNV();
let _VkRayTracingPipelineCreateInfoNV = new VkRayTracingPipelineCreateInfoNV();
let _VkGeometryTrianglesNV = new VkGeometryTrianglesNV();
let _VkGeometryAABBNV = new VkGeometryAABBNV();
let _VkGeometryDataNV = new VkGeometryDataNV();
let _VkGeometryNV = new VkGeometryNV();
let _VkAccelerationStructureInfoNV = new VkAccelerationStructureInfoNV();
let _VkAccelerationStructureCreateInfoNV = new VkAccelerationStructureCreateInfoNV();
let _VkBindAccelerationStructureMemoryInfoNV = new VkBindAccelerationStructureMemoryInfoNV();
let _VkWriteDescriptorSetAccelerationStructureNV = new VkWriteDescriptorSetAccelerationStructureNV();
let _VkAccelerationStructureMemoryRequirementsInfoNV = new VkAccelerationStructureMemoryRequirementsInfoNV();
let _VkPhysicalDeviceRayTracingPropertiesNV = new VkPhysicalDeviceRayTracingPropertiesNV();
let _VkDrmFormatModifierPropertiesListEXT = new VkDrmFormatModifierPropertiesListEXT();
let _VkDrmFormatModifierPropertiesEXT = new VkDrmFormatModifierPropertiesEXT();
let _VkPhysicalDeviceImageDrmFormatModifierInfoEXT = new VkPhysicalDeviceImageDrmFormatModifierInfoEXT();
let _VkImageDrmFormatModifierListCreateInfoEXT = new VkImageDrmFormatModifierListCreateInfoEXT();
let _VkImageDrmFormatModifierExplicitCreateInfoEXT = new VkImageDrmFormatModifierExplicitCreateInfoEXT();
let _VkImageDrmFormatModifierPropertiesEXT = new VkImageDrmFormatModifierPropertiesEXT();
let _VkImageStencilUsageCreateInfoEXT = new VkImageStencilUsageCreateInfoEXT();
let _VkDeviceMemoryOverallocationCreateInfoAMD = new VkDeviceMemoryOverallocationCreateInfoAMD();
let _VkPhysicalDeviceFragmentDensityMapFeaturesEXT = new VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
let _VkPhysicalDeviceFragmentDensityMapPropertiesEXT = new VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
let _VkRenderPassFragmentDensityMapCreateInfoEXT = new VkRenderPassFragmentDensityMapCreateInfoEXT();
let _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = new VkPhysicalDeviceScalarBlockLayoutFeaturesEXT();
let _VkSurfaceProtectedCapabilitiesKHR = new VkSurfaceProtectedCapabilitiesKHR();
let _VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = new VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR();
let _VkPhysicalDeviceDepthClipEnableFeaturesEXT = new VkPhysicalDeviceDepthClipEnableFeaturesEXT();
let _VkPipelineRasterizationDepthClipStateCreateInfoEXT = new VkPipelineRasterizationDepthClipStateCreateInfoEXT();
let _VkPhysicalDeviceMemoryBudgetPropertiesEXT = new VkPhysicalDeviceMemoryBudgetPropertiesEXT();
let _VkPhysicalDeviceMemoryPriorityFeaturesEXT = new VkPhysicalDeviceMemoryPriorityFeaturesEXT();
let _VkMemoryPriorityAllocateInfoEXT = new VkMemoryPriorityAllocateInfoEXT();
let _VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = new VkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
let _VkPhysicalDeviceBufferAddressFeaturesEXT = new VkPhysicalDeviceBufferAddressFeaturesEXT();
let _VkBufferDeviceAddressInfoEXT = new VkBufferDeviceAddressInfoEXT();
let _VkBufferDeviceAddressCreateInfoEXT = new VkBufferDeviceAddressCreateInfoEXT();
let _VkPhysicalDeviceImageViewImageFormatInfoEXT = new VkPhysicalDeviceImageViewImageFormatInfoEXT();
let _VkFilterCubicImageViewImageFormatPropertiesEXT = new VkFilterCubicImageViewImageFormatPropertiesEXT();
let _VkPhysicalDeviceImagelessFramebufferFeaturesKHR = new VkPhysicalDeviceImagelessFramebufferFeaturesKHR();
let _VkFramebufferAttachmentsCreateInfoKHR = new VkFramebufferAttachmentsCreateInfoKHR();
let _VkFramebufferAttachmentImageInfoKHR = new VkFramebufferAttachmentImageInfoKHR();
let _VkRenderPassAttachmentBeginInfoKHR = new VkRenderPassAttachmentBeginInfoKHR();
let _VkPhysicalDeviceCooperativeMatrixFeaturesNV = new VkPhysicalDeviceCooperativeMatrixFeaturesNV();
let _VkPhysicalDeviceCooperativeMatrixPropertiesNV = new VkPhysicalDeviceCooperativeMatrixPropertiesNV();
let _VkCooperativeMatrixPropertiesNV = new VkCooperativeMatrixPropertiesNV();
let _VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = new VkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
let _VkImageViewHandleInfoNVX = new VkImageViewHandleInfoNVX();
let _VkPipelineCreationFeedbackEXT = new VkPipelineCreationFeedbackEXT();
let _VkPipelineCreationFeedbackCreateInfoEXT = new VkPipelineCreationFeedbackCreateInfoEXT();
let _VkSurfaceFullScreenExclusiveInfoEXT = new VkSurfaceFullScreenExclusiveInfoEXT();
let _VkSurfaceFullScreenExclusiveWin32InfoEXT = new VkSurfaceFullScreenExclusiveWin32InfoEXT();
let _VkSurfaceCapabilitiesFullScreenExclusiveEXT = new VkSurfaceCapabilitiesFullScreenExclusiveEXT();
let _VkHeadlessSurfaceCreateInfoEXT = new VkHeadlessSurfaceCreateInfoEXT();
let _VkPhysicalDeviceCoverageReductionModeFeaturesNV = new VkPhysicalDeviceCoverageReductionModeFeaturesNV();
let _VkPipelineCoverageReductionStateCreateInfoNV = new VkPipelineCoverageReductionStateCreateInfoNV();
let _VkFramebufferMixedSamplesCombinationNV = new VkFramebufferMixedSamplesCombinationNV();
let _VkPhysicalDeviceShaderIntegerFunctions2INTEL = new VkPhysicalDeviceShaderIntegerFunctions2INTEL();
let _VkPerformanceValueINTEL = new VkPerformanceValueINTEL();
let _VkInitializePerformanceApiInfoINTEL = new VkInitializePerformanceApiInfoINTEL();
let _VkQueryPoolCreateInfoINTEL = new VkQueryPoolCreateInfoINTEL();
let _VkPerformanceMarkerInfoINTEL = new VkPerformanceMarkerInfoINTEL();
let _VkPerformanceStreamMarkerInfoINTEL = new VkPerformanceStreamMarkerInfoINTEL();
let _VkPerformanceOverrideInfoINTEL = new VkPerformanceOverrideInfoINTEL();
let _VkPerformanceConfigurationAcquireInfoINTEL = new VkPerformanceConfigurationAcquireInfoINTEL();
let _VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = new VkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
let _VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = new VkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
let _VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = new VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
let _VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = new VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT();
let _VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = new VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
let _VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = new VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT();
let _VkClearColorValue = new VkClearColorValue();
let _VkClearValue = new VkClearValue();
let _VkPerformanceValueDataINTEL = new VkPerformanceValueDataINTEL();


module.exports = {
  ...VK_ENUMERATIONS,
  VK_MAKE_VERSION: nvk.VK_MAKE_VERSION,
  VK_VERSION_MAJOR: nvk.VK_VERSION_MAJOR,
  VK_VERSION_MINOR: nvk.VK_VERSION_MINOR,
  VK_VERSION_PATCH: nvk.VK_VERSION_PATCH,
  VK_API_VERSION_1_0: nvk.VK_API_VERSION_1_0,
  VK_API_VERSION_1_1: nvk.VK_API_VERSION_1_1,
  vkUseDevice: nvk.vkUseDevice,
  vkUseInstance: nvk.vkUseInstance,
  VulkanWindow: nvk.VulkanWindow,
  vkCreateInstance: nvk.vkCreateInstance,
  vkDestroyInstance: nvk.vkDestroyInstance,
  vkEnumeratePhysicalDevices: nvk.vkEnumeratePhysicalDevices,
  vkGetDeviceProcAddr: nvk.vkGetDeviceProcAddr,
  vkGetInstanceProcAddr: nvk.vkGetInstanceProcAddr,
  vkGetPhysicalDeviceProperties: nvk.vkGetPhysicalDeviceProperties,
  vkGetPhysicalDeviceQueueFamilyProperties: nvk.vkGetPhysicalDeviceQueueFamilyProperties,
  vkGetPhysicalDeviceMemoryProperties: nvk.vkGetPhysicalDeviceMemoryProperties,
  vkGetPhysicalDeviceFeatures: nvk.vkGetPhysicalDeviceFeatures,
  vkGetPhysicalDeviceFormatProperties: nvk.vkGetPhysicalDeviceFormatProperties,
  vkGetPhysicalDeviceImageFormatProperties: nvk.vkGetPhysicalDeviceImageFormatProperties,
  vkCreateDevice: nvk.vkCreateDevice,
  vkDestroyDevice: nvk.vkDestroyDevice,
  vkEnumerateInstanceVersion: nvk.vkEnumerateInstanceVersion,
  vkEnumerateInstanceLayerProperties: nvk.vkEnumerateInstanceLayerProperties,
  vkEnumerateInstanceExtensionProperties: nvk.vkEnumerateInstanceExtensionProperties,
  vkEnumerateDeviceLayerProperties: nvk.vkEnumerateDeviceLayerProperties,
  vkEnumerateDeviceExtensionProperties: nvk.vkEnumerateDeviceExtensionProperties,
  vkGetDeviceQueue: nvk.vkGetDeviceQueue,
  vkQueueSubmit: nvk.vkQueueSubmit,
  vkQueueWaitIdle: nvk.vkQueueWaitIdle,
  vkDeviceWaitIdle: nvk.vkDeviceWaitIdle,
  vkAllocateMemory: nvk.vkAllocateMemory,
  vkFreeMemory: nvk.vkFreeMemory,
  vkMapMemory: nvk.vkMapMemory,
  vkUnmapMemory: nvk.vkUnmapMemory,
  vkFlushMappedMemoryRanges: nvk.vkFlushMappedMemoryRanges,
  vkInvalidateMappedMemoryRanges: nvk.vkInvalidateMappedMemoryRanges,
  vkGetDeviceMemoryCommitment: nvk.vkGetDeviceMemoryCommitment,
  vkGetBufferMemoryRequirements: nvk.vkGetBufferMemoryRequirements,
  vkBindBufferMemory: nvk.vkBindBufferMemory,
  vkGetImageMemoryRequirements: nvk.vkGetImageMemoryRequirements,
  vkBindImageMemory: nvk.vkBindImageMemory,
  vkGetImageSparseMemoryRequirements: nvk.vkGetImageSparseMemoryRequirements,
  vkGetPhysicalDeviceSparseImageFormatProperties: nvk.vkGetPhysicalDeviceSparseImageFormatProperties,
  vkQueueBindSparse: nvk.vkQueueBindSparse,
  vkCreateFence: nvk.vkCreateFence,
  vkDestroyFence: nvk.vkDestroyFence,
  vkResetFences: nvk.vkResetFences,
  vkGetFenceStatus: nvk.vkGetFenceStatus,
  vkWaitForFences: nvk.vkWaitForFences,
  vkCreateSemaphore: nvk.vkCreateSemaphore,
  vkDestroySemaphore: nvk.vkDestroySemaphore,
  vkCreateEvent: nvk.vkCreateEvent,
  vkDestroyEvent: nvk.vkDestroyEvent,
  vkGetEventStatus: nvk.vkGetEventStatus,
  vkSetEvent: nvk.vkSetEvent,
  vkResetEvent: nvk.vkResetEvent,
  vkCreateQueryPool: nvk.vkCreateQueryPool,
  vkDestroyQueryPool: nvk.vkDestroyQueryPool,
  vkGetQueryPoolResults: nvk.vkGetQueryPoolResults,
  vkResetQueryPoolEXT: nvk.vkResetQueryPoolEXT,
  vkCreateBuffer: nvk.vkCreateBuffer,
  vkDestroyBuffer: nvk.vkDestroyBuffer,
  vkCreateBufferView: nvk.vkCreateBufferView,
  vkDestroyBufferView: nvk.vkDestroyBufferView,
  vkCreateImage: nvk.vkCreateImage,
  vkDestroyImage: nvk.vkDestroyImage,
  vkGetImageSubresourceLayout: nvk.vkGetImageSubresourceLayout,
  vkCreateImageView: nvk.vkCreateImageView,
  vkDestroyImageView: nvk.vkDestroyImageView,
  vkCreateShaderModule: nvk.vkCreateShaderModule,
  vkDestroyShaderModule: nvk.vkDestroyShaderModule,
  vkCreatePipelineCache: nvk.vkCreatePipelineCache,
  vkDestroyPipelineCache: nvk.vkDestroyPipelineCache,
  vkGetPipelineCacheData: nvk.vkGetPipelineCacheData,
  vkMergePipelineCaches: nvk.vkMergePipelineCaches,
  vkCreateGraphicsPipelines: nvk.vkCreateGraphicsPipelines,
  vkCreateComputePipelines: nvk.vkCreateComputePipelines,
  vkDestroyPipeline: nvk.vkDestroyPipeline,
  vkCreatePipelineLayout: nvk.vkCreatePipelineLayout,
  vkDestroyPipelineLayout: nvk.vkDestroyPipelineLayout,
  vkCreateSampler: nvk.vkCreateSampler,
  vkDestroySampler: nvk.vkDestroySampler,
  vkCreateDescriptorSetLayout: nvk.vkCreateDescriptorSetLayout,
  vkDestroyDescriptorSetLayout: nvk.vkDestroyDescriptorSetLayout,
  vkCreateDescriptorPool: nvk.vkCreateDescriptorPool,
  vkDestroyDescriptorPool: nvk.vkDestroyDescriptorPool,
  vkResetDescriptorPool: nvk.vkResetDescriptorPool,
  vkAllocateDescriptorSets: nvk.vkAllocateDescriptorSets,
  vkFreeDescriptorSets: nvk.vkFreeDescriptorSets,
  vkUpdateDescriptorSets: nvk.vkUpdateDescriptorSets,
  vkCreateFramebuffer: nvk.vkCreateFramebuffer,
  vkDestroyFramebuffer: nvk.vkDestroyFramebuffer,
  vkCreateRenderPass: nvk.vkCreateRenderPass,
  vkDestroyRenderPass: nvk.vkDestroyRenderPass,
  vkGetRenderAreaGranularity: nvk.vkGetRenderAreaGranularity,
  vkCreateCommandPool: nvk.vkCreateCommandPool,
  vkDestroyCommandPool: nvk.vkDestroyCommandPool,
  vkResetCommandPool: nvk.vkResetCommandPool,
  vkAllocateCommandBuffers: nvk.vkAllocateCommandBuffers,
  vkFreeCommandBuffers: nvk.vkFreeCommandBuffers,
  vkBeginCommandBuffer: nvk.vkBeginCommandBuffer,
  vkEndCommandBuffer: nvk.vkEndCommandBuffer,
  vkResetCommandBuffer: nvk.vkResetCommandBuffer,
  vkCmdBindPipeline: nvk.vkCmdBindPipeline,
  vkCmdSetViewport: nvk.vkCmdSetViewport,
  vkCmdSetScissor: nvk.vkCmdSetScissor,
  vkCmdSetLineWidth: nvk.vkCmdSetLineWidth,
  vkCmdSetDepthBias: nvk.vkCmdSetDepthBias,
  vkCmdSetBlendConstants: nvk.vkCmdSetBlendConstants,
  vkCmdSetDepthBounds: nvk.vkCmdSetDepthBounds,
  vkCmdSetStencilCompareMask: nvk.vkCmdSetStencilCompareMask,
  vkCmdSetStencilWriteMask: nvk.vkCmdSetStencilWriteMask,
  vkCmdSetStencilReference: nvk.vkCmdSetStencilReference,
  vkCmdBindDescriptorSets: nvk.vkCmdBindDescriptorSets,
  vkCmdBindIndexBuffer: nvk.vkCmdBindIndexBuffer,
  vkCmdBindVertexBuffers: nvk.vkCmdBindVertexBuffers,
  vkCmdDraw: nvk.vkCmdDraw,
  vkCmdDrawIndexed: nvk.vkCmdDrawIndexed,
  vkCmdDrawIndirect: nvk.vkCmdDrawIndirect,
  vkCmdDrawIndexedIndirect: nvk.vkCmdDrawIndexedIndirect,
  vkCmdDispatch: nvk.vkCmdDispatch,
  vkCmdDispatchIndirect: nvk.vkCmdDispatchIndirect,
  vkCmdCopyBuffer: nvk.vkCmdCopyBuffer,
  vkCmdCopyImage: nvk.vkCmdCopyImage,
  vkCmdBlitImage: nvk.vkCmdBlitImage,
  vkCmdCopyBufferToImage: nvk.vkCmdCopyBufferToImage,
  vkCmdCopyImageToBuffer: nvk.vkCmdCopyImageToBuffer,
  vkCmdUpdateBuffer: nvk.vkCmdUpdateBuffer,
  vkCmdFillBuffer: nvk.vkCmdFillBuffer,
  vkCmdClearColorImage: nvk.vkCmdClearColorImage,
  vkCmdClearDepthStencilImage: nvk.vkCmdClearDepthStencilImage,
  vkCmdClearAttachments: nvk.vkCmdClearAttachments,
  vkCmdResolveImage: nvk.vkCmdResolveImage,
  vkCmdSetEvent: nvk.vkCmdSetEvent,
  vkCmdResetEvent: nvk.vkCmdResetEvent,
  vkCmdWaitEvents: nvk.vkCmdWaitEvents,
  vkCmdPipelineBarrier: nvk.vkCmdPipelineBarrier,
  vkCmdBeginQuery: nvk.vkCmdBeginQuery,
  vkCmdEndQuery: nvk.vkCmdEndQuery,
  vkCmdBeginConditionalRenderingEXT: nvk.vkCmdBeginConditionalRenderingEXT,
  vkCmdEndConditionalRenderingEXT: nvk.vkCmdEndConditionalRenderingEXT,
  vkCmdResetQueryPool: nvk.vkCmdResetQueryPool,
  vkCmdWriteTimestamp: nvk.vkCmdWriteTimestamp,
  vkCmdCopyQueryPoolResults: nvk.vkCmdCopyQueryPoolResults,
  vkCmdPushConstants: nvk.vkCmdPushConstants,
  vkCmdBeginRenderPass: nvk.vkCmdBeginRenderPass,
  vkCmdNextSubpass: nvk.vkCmdNextSubpass,
  vkCmdEndRenderPass: nvk.vkCmdEndRenderPass,
  vkCmdExecuteCommands: nvk.vkCmdExecuteCommands,
  vkGetPhysicalDeviceDisplayPropertiesKHR: nvk.vkGetPhysicalDeviceDisplayPropertiesKHR,
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR: nvk.vkGetPhysicalDeviceDisplayPlanePropertiesKHR,
  vkGetDisplayPlaneSupportedDisplaysKHR: nvk.vkGetDisplayPlaneSupportedDisplaysKHR,
  vkGetDisplayModePropertiesKHR: nvk.vkGetDisplayModePropertiesKHR,
  vkCreateDisplayModeKHR: nvk.vkCreateDisplayModeKHR,
  vkGetDisplayPlaneCapabilitiesKHR: nvk.vkGetDisplayPlaneCapabilitiesKHR,
  vkCreateDisplayPlaneSurfaceKHR: nvk.vkCreateDisplayPlaneSurfaceKHR,
  vkCreateSharedSwapchainsKHR: nvk.vkCreateSharedSwapchainsKHR,
  vkDestroySurfaceKHR: nvk.vkDestroySurfaceKHR,
  vkGetPhysicalDeviceSurfaceSupportKHR: nvk.vkGetPhysicalDeviceSurfaceSupportKHR,
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR: nvk.vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
  vkGetPhysicalDeviceSurfaceFormatsKHR: nvk.vkGetPhysicalDeviceSurfaceFormatsKHR,
  vkGetPhysicalDeviceSurfacePresentModesKHR: nvk.vkGetPhysicalDeviceSurfacePresentModesKHR,
  vkCreateSwapchainKHR: nvk.vkCreateSwapchainKHR,
  vkDestroySwapchainKHR: nvk.vkDestroySwapchainKHR,
  vkGetSwapchainImagesKHR: nvk.vkGetSwapchainImagesKHR,
  vkAcquireNextImageKHR: nvk.vkAcquireNextImageKHR,
  vkQueuePresentKHR: nvk.vkQueuePresentKHR,
  vkCreateWin32SurfaceKHR: nvk.vkCreateWin32SurfaceKHR,
  vkGetPhysicalDeviceWin32PresentationSupportKHR: nvk.vkGetPhysicalDeviceWin32PresentationSupportKHR,
  vkCreateDebugReportCallbackEXT: nvk.vkCreateDebugReportCallbackEXT,
  vkDestroyDebugReportCallbackEXT: nvk.vkDestroyDebugReportCallbackEXT,
  vkDebugReportMessageEXT: nvk.vkDebugReportMessageEXT,
  vkDebugMarkerSetObjectNameEXT: nvk.vkDebugMarkerSetObjectNameEXT,
  vkDebugMarkerSetObjectTagEXT: nvk.vkDebugMarkerSetObjectTagEXT,
  vkCmdDebugMarkerBeginEXT: nvk.vkCmdDebugMarkerBeginEXT,
  vkCmdDebugMarkerEndEXT: nvk.vkCmdDebugMarkerEndEXT,
  vkCmdDebugMarkerInsertEXT: nvk.vkCmdDebugMarkerInsertEXT,
  vkGetPhysicalDeviceExternalImageFormatPropertiesNV: nvk.vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
  vkGetMemoryWin32HandleNV: nvk.vkGetMemoryWin32HandleNV,
  vkCmdProcessCommandsNVX: nvk.vkCmdProcessCommandsNVX,
  vkCmdReserveSpaceForCommandsNVX: nvk.vkCmdReserveSpaceForCommandsNVX,
  vkCreateIndirectCommandsLayoutNVX: nvk.vkCreateIndirectCommandsLayoutNVX,
  vkDestroyIndirectCommandsLayoutNVX: nvk.vkDestroyIndirectCommandsLayoutNVX,
  vkCreateObjectTableNVX: nvk.vkCreateObjectTableNVX,
  vkDestroyObjectTableNVX: nvk.vkDestroyObjectTableNVX,
  vkRegisterObjectsNVX: nvk.vkRegisterObjectsNVX,
  vkUnregisterObjectsNVX: nvk.vkUnregisterObjectsNVX,
  vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX: nvk.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX,
  vkGetPhysicalDeviceFeatures2: nvk.vkGetPhysicalDeviceFeatures2,
  vkGetPhysicalDeviceProperties2: nvk.vkGetPhysicalDeviceProperties2,
  vkGetPhysicalDeviceFormatProperties2: nvk.vkGetPhysicalDeviceFormatProperties2,
  vkGetPhysicalDeviceImageFormatProperties2: nvk.vkGetPhysicalDeviceImageFormatProperties2,
  vkGetPhysicalDeviceQueueFamilyProperties2: nvk.vkGetPhysicalDeviceQueueFamilyProperties2,
  vkGetPhysicalDeviceMemoryProperties2: nvk.vkGetPhysicalDeviceMemoryProperties2,
  vkGetPhysicalDeviceSparseImageFormatProperties2: nvk.vkGetPhysicalDeviceSparseImageFormatProperties2,
  vkCmdPushDescriptorSetKHR: nvk.vkCmdPushDescriptorSetKHR,
  vkTrimCommandPool: nvk.vkTrimCommandPool,
  vkGetPhysicalDeviceExternalBufferProperties: nvk.vkGetPhysicalDeviceExternalBufferProperties,
  vkGetMemoryWin32HandleKHR: nvk.vkGetMemoryWin32HandleKHR,
  vkGetMemoryWin32HandlePropertiesKHR: nvk.vkGetMemoryWin32HandlePropertiesKHR,
  vkGetMemoryFdKHR: nvk.vkGetMemoryFdKHR,
  vkGetMemoryFdPropertiesKHR: nvk.vkGetMemoryFdPropertiesKHR,
  vkGetPhysicalDeviceExternalSemaphoreProperties: nvk.vkGetPhysicalDeviceExternalSemaphoreProperties,
  vkGetSemaphoreWin32HandleKHR: nvk.vkGetSemaphoreWin32HandleKHR,
  vkImportSemaphoreWin32HandleKHR: nvk.vkImportSemaphoreWin32HandleKHR,
  vkGetSemaphoreFdKHR: nvk.vkGetSemaphoreFdKHR,
  vkImportSemaphoreFdKHR: nvk.vkImportSemaphoreFdKHR,
  vkGetPhysicalDeviceExternalFenceProperties: nvk.vkGetPhysicalDeviceExternalFenceProperties,
  vkGetFenceWin32HandleKHR: nvk.vkGetFenceWin32HandleKHR,
  vkImportFenceWin32HandleKHR: nvk.vkImportFenceWin32HandleKHR,
  vkGetFenceFdKHR: nvk.vkGetFenceFdKHR,
  vkImportFenceFdKHR: nvk.vkImportFenceFdKHR,
  vkReleaseDisplayEXT: nvk.vkReleaseDisplayEXT,
  vkDisplayPowerControlEXT: nvk.vkDisplayPowerControlEXT,
  vkRegisterDeviceEventEXT: nvk.vkRegisterDeviceEventEXT,
  vkRegisterDisplayEventEXT: nvk.vkRegisterDisplayEventEXT,
  vkGetSwapchainCounterEXT: nvk.vkGetSwapchainCounterEXT,
  vkGetPhysicalDeviceSurfaceCapabilities2EXT: nvk.vkGetPhysicalDeviceSurfaceCapabilities2EXT,
  vkEnumeratePhysicalDeviceGroups: nvk.vkEnumeratePhysicalDeviceGroups,
  vkGetDeviceGroupPeerMemoryFeatures: nvk.vkGetDeviceGroupPeerMemoryFeatures,
  vkBindBufferMemory2: nvk.vkBindBufferMemory2,
  vkBindImageMemory2: nvk.vkBindImageMemory2,
  vkCmdSetDeviceMask: nvk.vkCmdSetDeviceMask,
  vkGetDeviceGroupPresentCapabilitiesKHR: nvk.vkGetDeviceGroupPresentCapabilitiesKHR,
  vkGetDeviceGroupSurfacePresentModesKHR: nvk.vkGetDeviceGroupSurfacePresentModesKHR,
  vkAcquireNextImage2KHR: nvk.vkAcquireNextImage2KHR,
  vkCmdDispatchBase: nvk.vkCmdDispatchBase,
  vkGetPhysicalDevicePresentRectanglesKHR: nvk.vkGetPhysicalDevicePresentRectanglesKHR,
  vkCreateDescriptorUpdateTemplate: nvk.vkCreateDescriptorUpdateTemplate,
  vkDestroyDescriptorUpdateTemplate: nvk.vkDestroyDescriptorUpdateTemplate,
  vkUpdateDescriptorSetWithTemplate: nvk.vkUpdateDescriptorSetWithTemplate,
  vkCmdPushDescriptorSetWithTemplateKHR: nvk.vkCmdPushDescriptorSetWithTemplateKHR,
  vkSetHdrMetadataEXT: nvk.vkSetHdrMetadataEXT,
  vkGetSwapchainStatusKHR: nvk.vkGetSwapchainStatusKHR,
  vkGetRefreshCycleDurationGOOGLE: nvk.vkGetRefreshCycleDurationGOOGLE,
  vkGetPastPresentationTimingGOOGLE: nvk.vkGetPastPresentationTimingGOOGLE,
  vkCmdSetViewportWScalingNV: nvk.vkCmdSetViewportWScalingNV,
  vkCmdSetDiscardRectangleEXT: nvk.vkCmdSetDiscardRectangleEXT,
  vkCmdSetSampleLocationsEXT: nvk.vkCmdSetSampleLocationsEXT,
  vkGetPhysicalDeviceMultisamplePropertiesEXT: nvk.vkGetPhysicalDeviceMultisamplePropertiesEXT,
  vkGetPhysicalDeviceSurfaceCapabilities2KHR: nvk.vkGetPhysicalDeviceSurfaceCapabilities2KHR,
  vkGetPhysicalDeviceSurfaceFormats2KHR: nvk.vkGetPhysicalDeviceSurfaceFormats2KHR,
  vkGetPhysicalDeviceDisplayProperties2KHR: nvk.vkGetPhysicalDeviceDisplayProperties2KHR,
  vkGetPhysicalDeviceDisplayPlaneProperties2KHR: nvk.vkGetPhysicalDeviceDisplayPlaneProperties2KHR,
  vkGetDisplayModeProperties2KHR: nvk.vkGetDisplayModeProperties2KHR,
  vkGetDisplayPlaneCapabilities2KHR: nvk.vkGetDisplayPlaneCapabilities2KHR,
  vkGetBufferMemoryRequirements2: nvk.vkGetBufferMemoryRequirements2,
  vkGetImageMemoryRequirements2: nvk.vkGetImageMemoryRequirements2,
  vkGetImageSparseMemoryRequirements2: nvk.vkGetImageSparseMemoryRequirements2,
  vkCreateSamplerYcbcrConversion: nvk.vkCreateSamplerYcbcrConversion,
  vkDestroySamplerYcbcrConversion: nvk.vkDestroySamplerYcbcrConversion,
  vkGetDeviceQueue2: nvk.vkGetDeviceQueue2,
  vkCreateValidationCacheEXT: nvk.vkCreateValidationCacheEXT,
  vkDestroyValidationCacheEXT: nvk.vkDestroyValidationCacheEXT,
  vkGetValidationCacheDataEXT: nvk.vkGetValidationCacheDataEXT,
  vkMergeValidationCachesEXT: nvk.vkMergeValidationCachesEXT,
  vkGetDescriptorSetLayoutSupport: nvk.vkGetDescriptorSetLayoutSupport,
  vkGetShaderInfoAMD: nvk.vkGetShaderInfoAMD,
  vkSetLocalDimmingAMD: nvk.vkSetLocalDimmingAMD,
  vkGetPhysicalDeviceCalibrateableTimeDomainsEXT: nvk.vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
  vkGetCalibratedTimestampsEXT: nvk.vkGetCalibratedTimestampsEXT,
  vkSetDebugUtilsObjectNameEXT: nvk.vkSetDebugUtilsObjectNameEXT,
  vkSetDebugUtilsObjectTagEXT: nvk.vkSetDebugUtilsObjectTagEXT,
  vkQueueBeginDebugUtilsLabelEXT: nvk.vkQueueBeginDebugUtilsLabelEXT,
  vkQueueEndDebugUtilsLabelEXT: nvk.vkQueueEndDebugUtilsLabelEXT,
  vkQueueInsertDebugUtilsLabelEXT: nvk.vkQueueInsertDebugUtilsLabelEXT,
  vkCmdBeginDebugUtilsLabelEXT: nvk.vkCmdBeginDebugUtilsLabelEXT,
  vkCmdEndDebugUtilsLabelEXT: nvk.vkCmdEndDebugUtilsLabelEXT,
  vkCmdInsertDebugUtilsLabelEXT: nvk.vkCmdInsertDebugUtilsLabelEXT,
  vkCreateDebugUtilsMessengerEXT: nvk.vkCreateDebugUtilsMessengerEXT,
  vkDestroyDebugUtilsMessengerEXT: nvk.vkDestroyDebugUtilsMessengerEXT,
  vkSubmitDebugUtilsMessageEXT: nvk.vkSubmitDebugUtilsMessageEXT,
  vkGetMemoryHostPointerPropertiesEXT: nvk.vkGetMemoryHostPointerPropertiesEXT,
  vkCmdWriteBufferMarkerAMD: nvk.vkCmdWriteBufferMarkerAMD,
  vkCreateRenderPass2KHR: nvk.vkCreateRenderPass2KHR,
  vkCmdBeginRenderPass2KHR: nvk.vkCmdBeginRenderPass2KHR,
  vkCmdNextSubpass2KHR: nvk.vkCmdNextSubpass2KHR,
  vkCmdEndRenderPass2KHR: nvk.vkCmdEndRenderPass2KHR,
  vkCmdDrawIndirectCountKHR: nvk.vkCmdDrawIndirectCountKHR,
  vkCmdDrawIndexedIndirectCountKHR: nvk.vkCmdDrawIndexedIndirectCountKHR,
  vkCmdSetCheckpointNV: nvk.vkCmdSetCheckpointNV,
  vkGetQueueCheckpointDataNV: nvk.vkGetQueueCheckpointDataNV,
  vkCmdBindTransformFeedbackBuffersEXT: nvk.vkCmdBindTransformFeedbackBuffersEXT,
  vkCmdBeginTransformFeedbackEXT: nvk.vkCmdBeginTransformFeedbackEXT,
  vkCmdEndTransformFeedbackEXT: nvk.vkCmdEndTransformFeedbackEXT,
  vkCmdBeginQueryIndexedEXT: nvk.vkCmdBeginQueryIndexedEXT,
  vkCmdEndQueryIndexedEXT: nvk.vkCmdEndQueryIndexedEXT,
  vkCmdDrawIndirectByteCountEXT: nvk.vkCmdDrawIndirectByteCountEXT,
  vkCmdSetExclusiveScissorNV: nvk.vkCmdSetExclusiveScissorNV,
  vkCmdBindShadingRateImageNV: nvk.vkCmdBindShadingRateImageNV,
  vkCmdSetViewportShadingRatePaletteNV: nvk.vkCmdSetViewportShadingRatePaletteNV,
  vkCmdSetCoarseSampleOrderNV: nvk.vkCmdSetCoarseSampleOrderNV,
  vkCmdDrawMeshTasksNV: nvk.vkCmdDrawMeshTasksNV,
  vkCmdDrawMeshTasksIndirectNV: nvk.vkCmdDrawMeshTasksIndirectNV,
  vkCmdDrawMeshTasksIndirectCountNV: nvk.vkCmdDrawMeshTasksIndirectCountNV,
  vkCompileDeferredNV: nvk.vkCompileDeferredNV,
  vkCreateAccelerationStructureNV: nvk.vkCreateAccelerationStructureNV,
  vkDestroyAccelerationStructureNV: nvk.vkDestroyAccelerationStructureNV,
  vkGetAccelerationStructureMemoryRequirementsNV: nvk.vkGetAccelerationStructureMemoryRequirementsNV,
  vkBindAccelerationStructureMemoryNV: nvk.vkBindAccelerationStructureMemoryNV,
  vkCmdCopyAccelerationStructureNV: nvk.vkCmdCopyAccelerationStructureNV,
  vkCmdWriteAccelerationStructuresPropertiesNV: nvk.vkCmdWriteAccelerationStructuresPropertiesNV,
  vkCmdBuildAccelerationStructureNV: nvk.vkCmdBuildAccelerationStructureNV,
  vkCmdTraceRaysNV: nvk.vkCmdTraceRaysNV,
  vkGetRayTracingShaderGroupHandlesNV: nvk.vkGetRayTracingShaderGroupHandlesNV,
  vkGetAccelerationStructureHandleNV: nvk.vkGetAccelerationStructureHandleNV,
  vkCreateRayTracingPipelinesNV: nvk.vkCreateRayTracingPipelinesNV,
  vkGetImageDrmFormatModifierPropertiesEXT: nvk.vkGetImageDrmFormatModifierPropertiesEXT,
  vkGetBufferDeviceAddressEXT: nvk.vkGetBufferDeviceAddressEXT,
  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV: nvk.vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
  vkGetImageViewHandleNVX: nvk.vkGetImageViewHandleNVX,
  vkGetPhysicalDeviceSurfacePresentModes2EXT: nvk.vkGetPhysicalDeviceSurfacePresentModes2EXT,
  vkGetDeviceGroupSurfacePresentModes2EXT: nvk.vkGetDeviceGroupSurfacePresentModes2EXT,
  vkAcquireFullScreenExclusiveModeEXT: nvk.vkAcquireFullScreenExclusiveModeEXT,
  vkReleaseFullScreenExclusiveModeEXT: nvk.vkReleaseFullScreenExclusiveModeEXT,
  vkCreateHeadlessSurfaceEXT: nvk.vkCreateHeadlessSurfaceEXT,
  vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: nvk.vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
  vkInitializePerformanceApiINTEL: nvk.vkInitializePerformanceApiINTEL,
  vkUninitializePerformanceApiINTEL: nvk.vkUninitializePerformanceApiINTEL,
  vkCmdSetPerformanceMarkerINTEL: nvk.vkCmdSetPerformanceMarkerINTEL,
  vkCmdSetPerformanceStreamMarkerINTEL: nvk.vkCmdSetPerformanceStreamMarkerINTEL,
  vkCmdSetPerformanceOverrideINTEL: nvk.vkCmdSetPerformanceOverrideINTEL,
  vkAcquirePerformanceConfigurationINTEL: nvk.vkAcquirePerformanceConfigurationINTEL,
  vkReleasePerformanceConfigurationINTEL: nvk.vkReleasePerformanceConfigurationINTEL,
  vkQueueSetPerformanceConfigurationINTEL: nvk.vkQueueSetPerformanceConfigurationINTEL,
  vkGetPerformanceParameterINTEL: nvk.vkGetPerformanceParameterINTEL,
  VkInstance,
  VkPhysicalDevice,
  VkDevice,
  VkQueue,
  VkCommandBuffer,
  VkDeviceMemory,
  VkCommandPool,
  VkBuffer,
  VkBufferView,
  VkImage,
  VkImageView,
  VkShaderModule,
  VkPipeline,
  VkPipelineLayout,
  VkSampler,
  VkDescriptorSet,
  VkDescriptorSetLayout,
  VkDescriptorPool,
  VkFence,
  VkSemaphore,
  VkEvent,
  VkQueryPool,
  VkFramebuffer,
  VkRenderPass,
  VkPipelineCache,
  VkObjectTableNVX,
  VkIndirectCommandsLayoutNVX,
  VkDescriptorUpdateTemplate,
  VkSamplerYcbcrConversion,
  VkValidationCacheEXT,
  VkAccelerationStructureNV,
  VkPerformanceConfigurationINTEL,
  VkDisplayKHR,
  VkDisplayModeKHR,
  VkSurfaceKHR,
  VkSwapchainKHR,
  VkDebugReportCallbackEXT,
  VkDebugUtilsMessengerEXT,
  VkBaseOutStructure,
  VkBaseInStructure,
  VkOffset2D,
  VkOffset3D,
  VkExtent2D,
  VkExtent3D,
  VkViewport,
  VkRect2D,
  VkClearRect,
  VkComponentMapping,
  VkPhysicalDeviceProperties,
  VkExtensionProperties,
  VkLayerProperties,
  VkApplicationInfo,
  VkAllocationCallbacks,
  VkDeviceQueueCreateInfo,
  VkDeviceCreateInfo,
  VkInstanceCreateInfo,
  VkQueueFamilyProperties,
  VkPhysicalDeviceMemoryProperties,
  VkMemoryAllocateInfo,
  VkMemoryRequirements,
  VkSparseImageFormatProperties,
  VkSparseImageMemoryRequirements,
  VkMemoryType,
  VkMemoryHeap,
  VkMappedMemoryRange,
  VkFormatProperties,
  VkImageFormatProperties,
  VkDescriptorBufferInfo,
  VkDescriptorImageInfo,
  VkWriteDescriptorSet,
  VkCopyDescriptorSet,
  VkBufferCreateInfo,
  VkBufferViewCreateInfo,
  VkImageSubresource,
  VkImageSubresourceLayers,
  VkImageSubresourceRange,
  VkMemoryBarrier,
  VkBufferMemoryBarrier,
  VkImageMemoryBarrier,
  VkImageCreateInfo,
  VkSubresourceLayout,
  VkImageViewCreateInfo,
  VkBufferCopy,
  VkSparseMemoryBind,
  VkSparseImageMemoryBind,
  VkSparseBufferMemoryBindInfo,
  VkSparseImageOpaqueMemoryBindInfo,
  VkSparseImageMemoryBindInfo,
  VkBindSparseInfo,
  VkImageCopy,
  VkImageBlit,
  VkBufferImageCopy,
  VkImageResolve,
  VkShaderModuleCreateInfo,
  VkDescriptorSetLayoutBinding,
  VkDescriptorSetLayoutCreateInfo,
  VkDescriptorPoolSize,
  VkDescriptorPoolCreateInfo,
  VkDescriptorSetAllocateInfo,
  VkSpecializationMapEntry,
  VkSpecializationInfo,
  VkPipelineShaderStageCreateInfo,
  VkComputePipelineCreateInfo,
  VkVertexInputBindingDescription,
  VkVertexInputAttributeDescription,
  VkPipelineVertexInputStateCreateInfo,
  VkPipelineInputAssemblyStateCreateInfo,
  VkPipelineTessellationStateCreateInfo,
  VkPipelineViewportStateCreateInfo,
  VkPipelineRasterizationStateCreateInfo,
  VkPipelineMultisampleStateCreateInfo,
  VkPipelineColorBlendAttachmentState,
  VkPipelineColorBlendStateCreateInfo,
  VkPipelineDynamicStateCreateInfo,
  VkStencilOpState,
  VkPipelineDepthStencilStateCreateInfo,
  VkGraphicsPipelineCreateInfo,
  VkPipelineCacheCreateInfo,
  VkPushConstantRange,
  VkPipelineLayoutCreateInfo,
  VkSamplerCreateInfo,
  VkCommandPoolCreateInfo,
  VkCommandBufferAllocateInfo,
  VkCommandBufferInheritanceInfo,
  VkCommandBufferBeginInfo,
  VkRenderPassBeginInfo,
  VkClearDepthStencilValue,
  VkClearAttachment,
  VkAttachmentDescription,
  VkAttachmentReference,
  VkSubpassDescription,
  VkSubpassDependency,
  VkRenderPassCreateInfo,
  VkEventCreateInfo,
  VkFenceCreateInfo,
  VkPhysicalDeviceFeatures,
  VkPhysicalDeviceSparseProperties,
  VkPhysicalDeviceLimits,
  VkSemaphoreCreateInfo,
  VkQueryPoolCreateInfo,
  VkFramebufferCreateInfo,
  VkDrawIndirectCommand,
  VkDrawIndexedIndirectCommand,
  VkDispatchIndirectCommand,
  VkSubmitInfo,
  VkDisplayPropertiesKHR,
  VkDisplayPlanePropertiesKHR,
  VkDisplayModeParametersKHR,
  VkDisplayModePropertiesKHR,
  VkDisplayModeCreateInfoKHR,
  VkDisplayPlaneCapabilitiesKHR,
  VkDisplaySurfaceCreateInfoKHR,
  VkDisplayPresentInfoKHR,
  VkSurfaceCapabilitiesKHR,
  VkWin32SurfaceCreateInfoKHR,
  VkSurfaceFormatKHR,
  VkSwapchainCreateInfoKHR,
  VkPresentInfoKHR,
  VkDebugReportCallbackCreateInfoEXT,
  VkValidationFlagsEXT,
  VkValidationFeaturesEXT,
  VkPipelineRasterizationStateRasterizationOrderAMD,
  VkDebugMarkerObjectNameInfoEXT,
  VkDebugMarkerObjectTagInfoEXT,
  VkDebugMarkerMarkerInfoEXT,
  VkDedicatedAllocationImageCreateInfoNV,
  VkDedicatedAllocationBufferCreateInfoNV,
  VkDedicatedAllocationMemoryAllocateInfoNV,
  VkExternalImageFormatPropertiesNV,
  VkExternalMemoryImageCreateInfoNV,
  VkExportMemoryAllocateInfoNV,
  VkImportMemoryWin32HandleInfoNV,
  VkExportMemoryWin32HandleInfoNV,
  VkWin32KeyedMutexAcquireReleaseInfoNV,
  VkDeviceGeneratedCommandsFeaturesNVX,
  VkDeviceGeneratedCommandsLimitsNVX,
  VkIndirectCommandsTokenNVX,
  VkIndirectCommandsLayoutTokenNVX,
  VkIndirectCommandsLayoutCreateInfoNVX,
  VkCmdProcessCommandsInfoNVX,
  VkCmdReserveSpaceForCommandsInfoNVX,
  VkObjectTableCreateInfoNVX,
  VkObjectTableEntryNVX,
  VkObjectTablePipelineEntryNVX,
  VkObjectTableDescriptorSetEntryNVX,
  VkObjectTableVertexBufferEntryNVX,
  VkObjectTableIndexBufferEntryNVX,
  VkObjectTablePushConstantEntryNVX,
  VkPhysicalDeviceFeatures2,
  VkPhysicalDeviceFeatures2KHR,
  VkPhysicalDeviceProperties2,
  VkPhysicalDeviceProperties2KHR,
  VkFormatProperties2,
  VkFormatProperties2KHR,
  VkImageFormatProperties2,
  VkImageFormatProperties2KHR,
  VkPhysicalDeviceImageFormatInfo2,
  VkPhysicalDeviceImageFormatInfo2KHR,
  VkQueueFamilyProperties2,
  VkQueueFamilyProperties2KHR,
  VkPhysicalDeviceMemoryProperties2,
  VkPhysicalDeviceMemoryProperties2KHR,
  VkSparseImageFormatProperties2,
  VkSparseImageFormatProperties2KHR,
  VkPhysicalDeviceSparseImageFormatInfo2,
  VkPhysicalDeviceSparseImageFormatInfo2KHR,
  VkPhysicalDevicePushDescriptorPropertiesKHR,
  VkConformanceVersionKHR,
  VkPhysicalDeviceDriverPropertiesKHR,
  VkPresentRegionsKHR,
  VkPresentRegionKHR,
  VkRectLayerKHR,
  VkPhysicalDeviceVariablePointersFeatures,
  VkPhysicalDeviceVariablePointersFeaturesKHR,
  VkPhysicalDeviceVariablePointerFeaturesKHR,
  VkPhysicalDeviceVariablePointerFeatures,
  VkExternalMemoryProperties,
  VkExternalMemoryPropertiesKHR,
  VkPhysicalDeviceExternalImageFormatInfo,
  VkPhysicalDeviceExternalImageFormatInfoKHR,
  VkExternalImageFormatProperties,
  VkExternalImageFormatPropertiesKHR,
  VkPhysicalDeviceExternalBufferInfo,
  VkPhysicalDeviceExternalBufferInfoKHR,
  VkExternalBufferProperties,
  VkExternalBufferPropertiesKHR,
  VkPhysicalDeviceIDProperties,
  VkPhysicalDeviceIDPropertiesKHR,
  VkExternalMemoryImageCreateInfo,
  VkExternalMemoryImageCreateInfoKHR,
  VkExternalMemoryBufferCreateInfo,
  VkExternalMemoryBufferCreateInfoKHR,
  VkExportMemoryAllocateInfo,
  VkExportMemoryAllocateInfoKHR,
  VkImportMemoryWin32HandleInfoKHR,
  VkExportMemoryWin32HandleInfoKHR,
  VkMemoryWin32HandlePropertiesKHR,
  VkMemoryGetWin32HandleInfoKHR,
  VkImportMemoryFdInfoKHR,
  VkMemoryFdPropertiesKHR,
  VkMemoryGetFdInfoKHR,
  VkWin32KeyedMutexAcquireReleaseInfoKHR,
  VkPhysicalDeviceExternalSemaphoreInfo,
  VkPhysicalDeviceExternalSemaphoreInfoKHR,
  VkExternalSemaphoreProperties,
  VkExternalSemaphorePropertiesKHR,
  VkExportSemaphoreCreateInfo,
  VkExportSemaphoreCreateInfoKHR,
  VkImportSemaphoreWin32HandleInfoKHR,
  VkExportSemaphoreWin32HandleInfoKHR,
  VkD3D12FenceSubmitInfoKHR,
  VkSemaphoreGetWin32HandleInfoKHR,
  VkImportSemaphoreFdInfoKHR,
  VkSemaphoreGetFdInfoKHR,
  VkPhysicalDeviceExternalFenceInfo,
  VkPhysicalDeviceExternalFenceInfoKHR,
  VkExternalFenceProperties,
  VkExternalFencePropertiesKHR,
  VkExportFenceCreateInfo,
  VkExportFenceCreateInfoKHR,
  VkImportFenceWin32HandleInfoKHR,
  VkExportFenceWin32HandleInfoKHR,
  VkFenceGetWin32HandleInfoKHR,
  VkImportFenceFdInfoKHR,
  VkFenceGetFdInfoKHR,
  VkPhysicalDeviceMultiviewFeatures,
  VkPhysicalDeviceMultiviewFeaturesKHR,
  VkPhysicalDeviceMultiviewProperties,
  VkPhysicalDeviceMultiviewPropertiesKHR,
  VkRenderPassMultiviewCreateInfo,
  VkRenderPassMultiviewCreateInfoKHR,
  VkSurfaceCapabilities2EXT,
  VkDisplayPowerInfoEXT,
  VkDeviceEventInfoEXT,
  VkDisplayEventInfoEXT,
  VkSwapchainCounterCreateInfoEXT,
  VkPhysicalDeviceGroupProperties,
  VkPhysicalDeviceGroupPropertiesKHR,
  VkMemoryAllocateFlagsInfo,
  VkMemoryAllocateFlagsInfoKHR,
  VkBindBufferMemoryInfo,
  VkBindBufferMemoryInfoKHR,
  VkBindBufferMemoryDeviceGroupInfo,
  VkBindBufferMemoryDeviceGroupInfoKHR,
  VkBindImageMemoryInfo,
  VkBindImageMemoryInfoKHR,
  VkBindImageMemoryDeviceGroupInfo,
  VkBindImageMemoryDeviceGroupInfoKHR,
  VkDeviceGroupRenderPassBeginInfo,
  VkDeviceGroupRenderPassBeginInfoKHR,
  VkDeviceGroupCommandBufferBeginInfo,
  VkDeviceGroupCommandBufferBeginInfoKHR,
  VkDeviceGroupSubmitInfo,
  VkDeviceGroupSubmitInfoKHR,
  VkDeviceGroupBindSparseInfo,
  VkDeviceGroupBindSparseInfoKHR,
  VkDeviceGroupPresentCapabilitiesKHR,
  VkImageSwapchainCreateInfoKHR,
  VkBindImageMemorySwapchainInfoKHR,
  VkAcquireNextImageInfoKHR,
  VkDeviceGroupPresentInfoKHR,
  VkDeviceGroupDeviceCreateInfo,
  VkDeviceGroupDeviceCreateInfoKHR,
  VkDeviceGroupSwapchainCreateInfoKHR,
  VkDescriptorUpdateTemplateEntry,
  VkDescriptorUpdateTemplateEntryKHR,
  VkDescriptorUpdateTemplateCreateInfo,
  VkDescriptorUpdateTemplateCreateInfoKHR,
  VkXYColorEXT,
  VkHdrMetadataEXT,
  VkDisplayNativeHdrSurfaceCapabilitiesAMD,
  VkSwapchainDisplayNativeHdrCreateInfoAMD,
  VkRefreshCycleDurationGOOGLE,
  VkPastPresentationTimingGOOGLE,
  VkPresentTimesInfoGOOGLE,
  VkPresentTimeGOOGLE,
  VkViewportWScalingNV,
  VkPipelineViewportWScalingStateCreateInfoNV,
  VkViewportSwizzleNV,
  VkPipelineViewportSwizzleStateCreateInfoNV,
  VkPhysicalDeviceDiscardRectanglePropertiesEXT,
  VkPipelineDiscardRectangleStateCreateInfoEXT,
  VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
  VkInputAttachmentAspectReference,
  VkInputAttachmentAspectReferenceKHR,
  VkRenderPassInputAttachmentAspectCreateInfo,
  VkRenderPassInputAttachmentAspectCreateInfoKHR,
  VkPhysicalDeviceSurfaceInfo2KHR,
  VkSurfaceCapabilities2KHR,
  VkSurfaceFormat2KHR,
  VkDisplayProperties2KHR,
  VkDisplayPlaneProperties2KHR,
  VkDisplayModeProperties2KHR,
  VkDisplayPlaneInfo2KHR,
  VkDisplayPlaneCapabilities2KHR,
  VkSharedPresentSurfaceCapabilitiesKHR,
  VkPhysicalDevice16BitStorageFeatures,
  VkPhysicalDevice16BitStorageFeaturesKHR,
  VkPhysicalDeviceSubgroupProperties,
  VkBufferMemoryRequirementsInfo2,
  VkBufferMemoryRequirementsInfo2KHR,
  VkImageMemoryRequirementsInfo2,
  VkImageMemoryRequirementsInfo2KHR,
  VkImageSparseMemoryRequirementsInfo2,
  VkImageSparseMemoryRequirementsInfo2KHR,
  VkMemoryRequirements2,
  VkMemoryRequirements2KHR,
  VkSparseImageMemoryRequirements2,
  VkSparseImageMemoryRequirements2KHR,
  VkPhysicalDevicePointClippingProperties,
  VkPhysicalDevicePointClippingPropertiesKHR,
  VkMemoryDedicatedRequirements,
  VkMemoryDedicatedRequirementsKHR,
  VkMemoryDedicatedAllocateInfo,
  VkMemoryDedicatedAllocateInfoKHR,
  VkImageViewUsageCreateInfo,
  VkImageViewUsageCreateInfoKHR,
  VkPipelineTessellationDomainOriginStateCreateInfo,
  VkPipelineTessellationDomainOriginStateCreateInfoKHR,
  VkSamplerYcbcrConversionInfo,
  VkSamplerYcbcrConversionInfoKHR,
  VkSamplerYcbcrConversionCreateInfo,
  VkSamplerYcbcrConversionCreateInfoKHR,
  VkBindImagePlaneMemoryInfo,
  VkBindImagePlaneMemoryInfoKHR,
  VkImagePlaneMemoryRequirementsInfo,
  VkImagePlaneMemoryRequirementsInfoKHR,
  VkPhysicalDeviceSamplerYcbcrConversionFeatures,
  VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR,
  VkSamplerYcbcrConversionImageFormatProperties,
  VkSamplerYcbcrConversionImageFormatPropertiesKHR,
  VkTextureLODGatherFormatPropertiesAMD,
  VkConditionalRenderingBeginInfoEXT,
  VkProtectedSubmitInfo,
  VkPhysicalDeviceProtectedMemoryFeatures,
  VkPhysicalDeviceProtectedMemoryProperties,
  VkDeviceQueueInfo2,
  VkPipelineCoverageToColorStateCreateInfoNV,
  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
  VkSampleLocationEXT,
  VkSampleLocationsInfoEXT,
  VkAttachmentSampleLocationsEXT,
  VkSubpassSampleLocationsEXT,
  VkRenderPassSampleLocationsBeginInfoEXT,
  VkPipelineSampleLocationsStateCreateInfoEXT,
  VkPhysicalDeviceSampleLocationsPropertiesEXT,
  VkMultisamplePropertiesEXT,
  VkSamplerReductionModeCreateInfoEXT,
  VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
  VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
  VkPipelineColorBlendAdvancedStateCreateInfoEXT,
  VkPhysicalDeviceInlineUniformBlockFeaturesEXT,
  VkPhysicalDeviceInlineUniformBlockPropertiesEXT,
  VkWriteDescriptorSetInlineUniformBlockEXT,
  VkDescriptorPoolInlineUniformBlockCreateInfoEXT,
  VkPipelineCoverageModulationStateCreateInfoNV,
  VkImageFormatListCreateInfoKHR,
  VkValidationCacheCreateInfoEXT,
  VkShaderModuleValidationCacheCreateInfoEXT,
  VkPhysicalDeviceMaintenance3Properties,
  VkPhysicalDeviceMaintenance3PropertiesKHR,
  VkDescriptorSetLayoutSupport,
  VkDescriptorSetLayoutSupportKHR,
  VkPhysicalDeviceShaderDrawParametersFeatures,
  VkPhysicalDeviceShaderDrawParameterFeatures,
  VkPhysicalDeviceFloat16Int8FeaturesKHR,
  VkPhysicalDeviceFloatControlsPropertiesKHR,
  VkPhysicalDeviceHostQueryResetFeaturesEXT,
  VkShaderResourceUsageAMD,
  VkShaderStatisticsInfoAMD,
  VkDeviceQueueGlobalPriorityCreateInfoEXT,
  VkDebugUtilsObjectNameInfoEXT,
  VkDebugUtilsObjectTagInfoEXT,
  VkDebugUtilsLabelEXT,
  VkDebugUtilsMessengerCreateInfoEXT,
  VkDebugUtilsMessengerCallbackDataEXT,
  VkImportMemoryHostPointerInfoEXT,
  VkMemoryHostPointerPropertiesEXT,
  VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
  VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
  VkCalibratedTimestampInfoEXT,
  VkPhysicalDeviceShaderCorePropertiesAMD,
  VkPipelineRasterizationConservativeStateCreateInfoEXT,
  VkPhysicalDeviceDescriptorIndexingFeaturesEXT,
  VkPhysicalDeviceDescriptorIndexingPropertiesEXT,
  VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,
  VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,
  VkDescriptorSetVariableDescriptorCountLayoutSupportEXT,
  VkAttachmentDescription2KHR,
  VkAttachmentReference2KHR,
  VkSubpassDescription2KHR,
  VkSubpassDependency2KHR,
  VkRenderPassCreateInfo2KHR,
  VkSubpassBeginInfoKHR,
  VkSubpassEndInfoKHR,
  VkVertexInputBindingDivisorDescriptionEXT,
  VkPipelineVertexInputDivisorStateCreateInfoEXT,
  VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
  VkPhysicalDevicePCIBusInfoPropertiesEXT,
  VkCommandBufferInheritanceConditionalRenderingInfoEXT,
  VkPhysicalDevice8BitStorageFeaturesKHR,
  VkPhysicalDeviceConditionalRenderingFeaturesEXT,
  VkPhysicalDeviceVulkanMemoryModelFeaturesKHR,
  VkPhysicalDeviceShaderAtomicInt64FeaturesKHR,
  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
  VkQueueFamilyCheckpointPropertiesNV,
  VkCheckpointDataNV,
  VkPhysicalDeviceDepthStencilResolvePropertiesKHR,
  VkSubpassDescriptionDepthStencilResolveKHR,
  VkImageViewASTCDecodeModeEXT,
  VkPhysicalDeviceASTCDecodeFeaturesEXT,
  VkPhysicalDeviceTransformFeedbackFeaturesEXT,
  VkPhysicalDeviceTransformFeedbackPropertiesEXT,
  VkPipelineRasterizationStateStreamCreateInfoEXT,
  VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
  VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
  VkPhysicalDeviceExclusiveScissorFeaturesNV,
  VkPipelineViewportExclusiveScissorStateCreateInfoNV,
  VkPhysicalDeviceCornerSampledImageFeaturesNV,
  VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
  VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,
  VkPhysicalDeviceShaderImageFootprintFeaturesNV,
  VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
  VkShadingRatePaletteNV,
  VkPipelineViewportShadingRateImageStateCreateInfoNV,
  VkPhysicalDeviceShadingRateImageFeaturesNV,
  VkPhysicalDeviceShadingRateImagePropertiesNV,
  VkCoarseSampleLocationNV,
  VkCoarseSampleOrderCustomNV,
  VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
  VkPhysicalDeviceMeshShaderFeaturesNV,
  VkPhysicalDeviceMeshShaderPropertiesNV,
  VkDrawMeshTasksIndirectCommandNV,
  VkRayTracingShaderGroupCreateInfoNV,
  VkRayTracingPipelineCreateInfoNV,
  VkGeometryTrianglesNV,
  VkGeometryAABBNV,
  VkGeometryDataNV,
  VkGeometryNV,
  VkAccelerationStructureInfoNV,
  VkAccelerationStructureCreateInfoNV,
  VkBindAccelerationStructureMemoryInfoNV,
  VkWriteDescriptorSetAccelerationStructureNV,
  VkAccelerationStructureMemoryRequirementsInfoNV,
  VkPhysicalDeviceRayTracingPropertiesNV,
  VkDrmFormatModifierPropertiesListEXT,
  VkDrmFormatModifierPropertiesEXT,
  VkPhysicalDeviceImageDrmFormatModifierInfoEXT,
  VkImageDrmFormatModifierListCreateInfoEXT,
  VkImageDrmFormatModifierExplicitCreateInfoEXT,
  VkImageDrmFormatModifierPropertiesEXT,
  VkImageStencilUsageCreateInfoEXT,
  VkDeviceMemoryOverallocationCreateInfoAMD,
  VkPhysicalDeviceFragmentDensityMapFeaturesEXT,
  VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
  VkRenderPassFragmentDensityMapCreateInfoEXT,
  VkPhysicalDeviceScalarBlockLayoutFeaturesEXT,
  VkSurfaceProtectedCapabilitiesKHR,
  VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR,
  VkPhysicalDeviceDepthClipEnableFeaturesEXT,
  VkPipelineRasterizationDepthClipStateCreateInfoEXT,
  VkPhysicalDeviceMemoryBudgetPropertiesEXT,
  VkPhysicalDeviceMemoryPriorityFeaturesEXT,
  VkMemoryPriorityAllocateInfoEXT,
  VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
  VkPhysicalDeviceBufferAddressFeaturesEXT,
  VkBufferDeviceAddressInfoEXT,
  VkBufferDeviceAddressCreateInfoEXT,
  VkPhysicalDeviceImageViewImageFormatInfoEXT,
  VkFilterCubicImageViewImageFormatPropertiesEXT,
  VkPhysicalDeviceImagelessFramebufferFeaturesKHR,
  VkFramebufferAttachmentsCreateInfoKHR,
  VkFramebufferAttachmentImageInfoKHR,
  VkRenderPassAttachmentBeginInfoKHR,
  VkPhysicalDeviceCooperativeMatrixFeaturesNV,
  VkPhysicalDeviceCooperativeMatrixPropertiesNV,
  VkCooperativeMatrixPropertiesNV,
  VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,
  VkImageViewHandleInfoNVX,
  VkPipelineCreationFeedbackEXT,
  VkPipelineCreationFeedbackCreateInfoEXT,
  VkSurfaceFullScreenExclusiveInfoEXT,
  VkSurfaceFullScreenExclusiveWin32InfoEXT,
  VkSurfaceCapabilitiesFullScreenExclusiveEXT,
  VkHeadlessSurfaceCreateInfoEXT,
  VkPhysicalDeviceCoverageReductionModeFeaturesNV,
  VkPipelineCoverageReductionStateCreateInfoNV,
  VkFramebufferMixedSamplesCombinationNV,
  VkPhysicalDeviceShaderIntegerFunctions2INTEL,
  VkPerformanceValueINTEL,
  VkInitializePerformanceApiInfoINTEL,
  VkQueryPoolCreateInfoINTEL,
  VkPerformanceMarkerInfoINTEL,
  VkPerformanceStreamMarkerInfoINTEL,
  VkPerformanceOverrideInfoINTEL,
  VkPerformanceConfigurationAcquireInfoINTEL,
  VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,
  VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,
  VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
  VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,
  VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
  VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT,
  VkClearColorValue,
  VkClearValue,
  VkPerformanceValueDataINTEL
};
