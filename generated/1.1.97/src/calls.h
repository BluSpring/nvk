/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.2.1
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#define NAPI_EXPERIMENTAL
#include <napi.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "source.h"

#include <map>
#include <string>

VkDevice currentDevice = VK_NULL_HANDLE;
VkInstance currentInstance = VK_NULL_HANDLE;

PFN_vkCmdBeginConditionalRenderingEXT $vkCmdBeginConditionalRenderingEXT = nullptr;
PFN_vkCmdEndConditionalRenderingEXT $vkCmdEndConditionalRenderingEXT = nullptr;
PFN_vkGetPhysicalDeviceDisplayPropertiesKHR $vkGetPhysicalDeviceDisplayPropertiesKHR = nullptr;
PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR $vkGetPhysicalDeviceDisplayPlanePropertiesKHR = nullptr;
PFN_vkGetDisplayPlaneSupportedDisplaysKHR $vkGetDisplayPlaneSupportedDisplaysKHR = nullptr;
PFN_vkGetDisplayModePropertiesKHR $vkGetDisplayModePropertiesKHR = nullptr;
PFN_vkCreateDisplayModeKHR $vkCreateDisplayModeKHR = nullptr;
PFN_vkGetDisplayPlaneCapabilitiesKHR $vkGetDisplayPlaneCapabilitiesKHR = nullptr;
PFN_vkCreateDisplayPlaneSurfaceKHR $vkCreateDisplayPlaneSurfaceKHR = nullptr;
PFN_vkCreateSharedSwapchainsKHR $vkCreateSharedSwapchainsKHR = nullptr;
PFN_vkDestroySurfaceKHR $vkDestroySurfaceKHR = nullptr;
PFN_vkGetPhysicalDeviceSurfaceSupportKHR $vkGetPhysicalDeviceSurfaceSupportKHR = nullptr;
PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR $vkGetPhysicalDeviceSurfaceCapabilitiesKHR = nullptr;
PFN_vkGetPhysicalDeviceSurfaceFormatsKHR $vkGetPhysicalDeviceSurfaceFormatsKHR = nullptr;
PFN_vkGetPhysicalDeviceSurfacePresentModesKHR $vkGetPhysicalDeviceSurfacePresentModesKHR = nullptr;
PFN_vkCreateSwapchainKHR $vkCreateSwapchainKHR = nullptr;
PFN_vkDestroySwapchainKHR $vkDestroySwapchainKHR = nullptr;
PFN_vkGetSwapchainImagesKHR $vkGetSwapchainImagesKHR = nullptr;
PFN_vkAcquireNextImageKHR $vkAcquireNextImageKHR = nullptr;
PFN_vkQueuePresentKHR $vkQueuePresentKHR = nullptr;
PFN_vkCreateWin32SurfaceKHR $vkCreateWin32SurfaceKHR = nullptr;
PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR $vkGetPhysicalDeviceWin32PresentationSupportKHR = nullptr;
PFN_vkCreateDebugReportCallbackEXT $vkCreateDebugReportCallbackEXT = nullptr;
PFN_vkDestroyDebugReportCallbackEXT $vkDestroyDebugReportCallbackEXT = nullptr;
PFN_vkDebugReportMessageEXT $vkDebugReportMessageEXT = nullptr;
PFN_vkDebugMarkerSetObjectNameEXT $vkDebugMarkerSetObjectNameEXT = nullptr;
PFN_vkDebugMarkerSetObjectTagEXT $vkDebugMarkerSetObjectTagEXT = nullptr;
PFN_vkCmdDebugMarkerBeginEXT $vkCmdDebugMarkerBeginEXT = nullptr;
PFN_vkCmdDebugMarkerEndEXT $vkCmdDebugMarkerEndEXT = nullptr;
PFN_vkCmdDebugMarkerInsertEXT $vkCmdDebugMarkerInsertEXT = nullptr;
PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV $vkGetPhysicalDeviceExternalImageFormatPropertiesNV = nullptr;
PFN_vkGetMemoryWin32HandleNV $vkGetMemoryWin32HandleNV = nullptr;
PFN_vkCmdDrawIndirectCountAMD $vkCmdDrawIndirectCountAMD = nullptr;
PFN_vkCmdDrawIndexedIndirectCountAMD $vkCmdDrawIndexedIndirectCountAMD = nullptr;
PFN_vkCmdProcessCommandsNVX $vkCmdProcessCommandsNVX = nullptr;
PFN_vkCmdReserveSpaceForCommandsNVX $vkCmdReserveSpaceForCommandsNVX = nullptr;
PFN_vkCreateIndirectCommandsLayoutNVX $vkCreateIndirectCommandsLayoutNVX = nullptr;
PFN_vkDestroyIndirectCommandsLayoutNVX $vkDestroyIndirectCommandsLayoutNVX = nullptr;
PFN_vkCreateObjectTableNVX $vkCreateObjectTableNVX = nullptr;
PFN_vkDestroyObjectTableNVX $vkDestroyObjectTableNVX = nullptr;
PFN_vkRegisterObjectsNVX $vkRegisterObjectsNVX = nullptr;
PFN_vkUnregisterObjectsNVX $vkUnregisterObjectsNVX = nullptr;
PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX $vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = nullptr;
PFN_vkCmdPushDescriptorSetKHR $vkCmdPushDescriptorSetKHR = nullptr;
PFN_vkGetMemoryWin32HandleKHR $vkGetMemoryWin32HandleKHR = nullptr;
PFN_vkGetMemoryWin32HandlePropertiesKHR $vkGetMemoryWin32HandlePropertiesKHR = nullptr;
PFN_vkGetMemoryFdKHR $vkGetMemoryFdKHR = nullptr;
PFN_vkGetMemoryFdPropertiesKHR $vkGetMemoryFdPropertiesKHR = nullptr;
PFN_vkGetSemaphoreWin32HandleKHR $vkGetSemaphoreWin32HandleKHR = nullptr;
PFN_vkImportSemaphoreWin32HandleKHR $vkImportSemaphoreWin32HandleKHR = nullptr;
PFN_vkGetSemaphoreFdKHR $vkGetSemaphoreFdKHR = nullptr;
PFN_vkImportSemaphoreFdKHR $vkImportSemaphoreFdKHR = nullptr;
PFN_vkGetFenceWin32HandleKHR $vkGetFenceWin32HandleKHR = nullptr;
PFN_vkImportFenceWin32HandleKHR $vkImportFenceWin32HandleKHR = nullptr;
PFN_vkGetFenceFdKHR $vkGetFenceFdKHR = nullptr;
PFN_vkImportFenceFdKHR $vkImportFenceFdKHR = nullptr;
PFN_vkReleaseDisplayEXT $vkReleaseDisplayEXT = nullptr;
PFN_vkDisplayPowerControlEXT $vkDisplayPowerControlEXT = nullptr;
PFN_vkRegisterDeviceEventEXT $vkRegisterDeviceEventEXT = nullptr;
PFN_vkRegisterDisplayEventEXT $vkRegisterDisplayEventEXT = nullptr;
PFN_vkGetSwapchainCounterEXT $vkGetSwapchainCounterEXT = nullptr;
PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT $vkGetPhysicalDeviceSurfaceCapabilities2EXT = nullptr;
PFN_vkGetDeviceGroupPresentCapabilitiesKHR $vkGetDeviceGroupPresentCapabilitiesKHR = nullptr;
PFN_vkGetDeviceGroupSurfacePresentModesKHR $vkGetDeviceGroupSurfacePresentModesKHR = nullptr;
PFN_vkAcquireNextImage2KHR $vkAcquireNextImage2KHR = nullptr;
PFN_vkGetPhysicalDevicePresentRectanglesKHR $vkGetPhysicalDevicePresentRectanglesKHR = nullptr;
PFN_vkCmdPushDescriptorSetWithTemplateKHR $vkCmdPushDescriptorSetWithTemplateKHR = nullptr;
PFN_vkSetHdrMetadataEXT $vkSetHdrMetadataEXT = nullptr;
PFN_vkGetSwapchainStatusKHR $vkGetSwapchainStatusKHR = nullptr;
PFN_vkGetRefreshCycleDurationGOOGLE $vkGetRefreshCycleDurationGOOGLE = nullptr;
PFN_vkGetPastPresentationTimingGOOGLE $vkGetPastPresentationTimingGOOGLE = nullptr;
PFN_vkCmdSetViewportWScalingNV $vkCmdSetViewportWScalingNV = nullptr;
PFN_vkCmdSetDiscardRectangleEXT $vkCmdSetDiscardRectangleEXT = nullptr;
PFN_vkCmdSetSampleLocationsEXT $vkCmdSetSampleLocationsEXT = nullptr;
PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT $vkGetPhysicalDeviceMultisamplePropertiesEXT = nullptr;
PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR $vkGetPhysicalDeviceSurfaceCapabilities2KHR = nullptr;
PFN_vkGetPhysicalDeviceSurfaceFormats2KHR $vkGetPhysicalDeviceSurfaceFormats2KHR = nullptr;
PFN_vkGetPhysicalDeviceDisplayProperties2KHR $vkGetPhysicalDeviceDisplayProperties2KHR = nullptr;
PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR $vkGetPhysicalDeviceDisplayPlaneProperties2KHR = nullptr;
PFN_vkGetDisplayModeProperties2KHR $vkGetDisplayModeProperties2KHR = nullptr;
PFN_vkGetDisplayPlaneCapabilities2KHR $vkGetDisplayPlaneCapabilities2KHR = nullptr;
PFN_vkCreateValidationCacheEXT $vkCreateValidationCacheEXT = nullptr;
PFN_vkDestroyValidationCacheEXT $vkDestroyValidationCacheEXT = nullptr;
PFN_vkGetValidationCacheDataEXT $vkGetValidationCacheDataEXT = nullptr;
PFN_vkMergeValidationCachesEXT $vkMergeValidationCachesEXT = nullptr;
PFN_vkGetShaderInfoAMD $vkGetShaderInfoAMD = nullptr;
PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT $vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = nullptr;
PFN_vkGetCalibratedTimestampsEXT $vkGetCalibratedTimestampsEXT = nullptr;
PFN_vkSetDebugUtilsObjectNameEXT $vkSetDebugUtilsObjectNameEXT = nullptr;
PFN_vkSetDebugUtilsObjectTagEXT $vkSetDebugUtilsObjectTagEXT = nullptr;
PFN_vkQueueBeginDebugUtilsLabelEXT $vkQueueBeginDebugUtilsLabelEXT = nullptr;
PFN_vkQueueEndDebugUtilsLabelEXT $vkQueueEndDebugUtilsLabelEXT = nullptr;
PFN_vkQueueInsertDebugUtilsLabelEXT $vkQueueInsertDebugUtilsLabelEXT = nullptr;
PFN_vkCmdBeginDebugUtilsLabelEXT $vkCmdBeginDebugUtilsLabelEXT = nullptr;
PFN_vkCmdEndDebugUtilsLabelEXT $vkCmdEndDebugUtilsLabelEXT = nullptr;
PFN_vkCmdInsertDebugUtilsLabelEXT $vkCmdInsertDebugUtilsLabelEXT = nullptr;
PFN_vkCreateDebugUtilsMessengerEXT $vkCreateDebugUtilsMessengerEXT = nullptr;
PFN_vkDestroyDebugUtilsMessengerEXT $vkDestroyDebugUtilsMessengerEXT = nullptr;
PFN_vkSubmitDebugUtilsMessageEXT $vkSubmitDebugUtilsMessageEXT = nullptr;
PFN_vkGetMemoryHostPointerPropertiesEXT $vkGetMemoryHostPointerPropertiesEXT = nullptr;
PFN_vkCmdWriteBufferMarkerAMD $vkCmdWriteBufferMarkerAMD = nullptr;
PFN_vkCreateRenderPass2KHR $vkCreateRenderPass2KHR = nullptr;
PFN_vkCmdBeginRenderPass2KHR $vkCmdBeginRenderPass2KHR = nullptr;
PFN_vkCmdNextSubpass2KHR $vkCmdNextSubpass2KHR = nullptr;
PFN_vkCmdEndRenderPass2KHR $vkCmdEndRenderPass2KHR = nullptr;
PFN_vkCmdDrawIndirectCountKHR $vkCmdDrawIndirectCountKHR = nullptr;
PFN_vkCmdDrawIndexedIndirectCountKHR $vkCmdDrawIndexedIndirectCountKHR = nullptr;
PFN_vkCmdSetCheckpointNV $vkCmdSetCheckpointNV = nullptr;
PFN_vkGetQueueCheckpointDataNV $vkGetQueueCheckpointDataNV = nullptr;
PFN_vkCmdBindTransformFeedbackBuffersEXT $vkCmdBindTransformFeedbackBuffersEXT = nullptr;
PFN_vkCmdBeginTransformFeedbackEXT $vkCmdBeginTransformFeedbackEXT = nullptr;
PFN_vkCmdEndTransformFeedbackEXT $vkCmdEndTransformFeedbackEXT = nullptr;
PFN_vkCmdBeginQueryIndexedEXT $vkCmdBeginQueryIndexedEXT = nullptr;
PFN_vkCmdEndQueryIndexedEXT $vkCmdEndQueryIndexedEXT = nullptr;
PFN_vkCmdDrawIndirectByteCountEXT $vkCmdDrawIndirectByteCountEXT = nullptr;
PFN_vkCmdSetExclusiveScissorNV $vkCmdSetExclusiveScissorNV = nullptr;
PFN_vkCmdBindShadingRateImageNV $vkCmdBindShadingRateImageNV = nullptr;
PFN_vkCmdSetViewportShadingRatePaletteNV $vkCmdSetViewportShadingRatePaletteNV = nullptr;
PFN_vkCmdSetCoarseSampleOrderNV $vkCmdSetCoarseSampleOrderNV = nullptr;
PFN_vkCmdDrawMeshTasksNV $vkCmdDrawMeshTasksNV = nullptr;
PFN_vkCmdDrawMeshTasksIndirectNV $vkCmdDrawMeshTasksIndirectNV = nullptr;
PFN_vkCmdDrawMeshTasksIndirectCountNV $vkCmdDrawMeshTasksIndirectCountNV = nullptr;
PFN_vkCompileDeferredNV $vkCompileDeferredNV = nullptr;
PFN_vkCreateAccelerationStructureNV $vkCreateAccelerationStructureNV = nullptr;
PFN_vkDestroyAccelerationStructureNV $vkDestroyAccelerationStructureNV = nullptr;
PFN_vkGetAccelerationStructureMemoryRequirementsNV $vkGetAccelerationStructureMemoryRequirementsNV = nullptr;
PFN_vkBindAccelerationStructureMemoryNV $vkBindAccelerationStructureMemoryNV = nullptr;
PFN_vkCmdCopyAccelerationStructureNV $vkCmdCopyAccelerationStructureNV = nullptr;
PFN_vkCmdWriteAccelerationStructuresPropertiesNV $vkCmdWriteAccelerationStructuresPropertiesNV = nullptr;
PFN_vkCmdBuildAccelerationStructureNV $vkCmdBuildAccelerationStructureNV = nullptr;
PFN_vkCmdTraceRaysNV $vkCmdTraceRaysNV = nullptr;
PFN_vkGetRayTracingShaderGroupHandlesNV $vkGetRayTracingShaderGroupHandlesNV = nullptr;
PFN_vkGetAccelerationStructureHandleNV $vkGetAccelerationStructureHandleNV = nullptr;
PFN_vkCreateRayTracingPipelinesNV $vkCreateRayTracingPipelinesNV = nullptr;
PFN_vkGetImageDrmFormatModifierPropertiesEXT $vkGetImageDrmFormatModifierPropertiesEXT = nullptr;
PFN_vkGetBufferDeviceAddressEXT $vkGetBufferDeviceAddressEXT = nullptr;

void vkUseDevice(VkDevice pDevice) {
  currentDevice = pDevice;
  $vkCmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginConditionalRenderingEXT");
  $vkCmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdEndConditionalRenderingEXT");
  $vkCreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR) vkGetDeviceProcAddr(currentDevice, "vkCreateSharedSwapchainsKHR");
  $vkCreateSwapchainKHR = (PFN_vkCreateSwapchainKHR) vkGetDeviceProcAddr(currentDevice, "vkCreateSwapchainKHR");
  $vkDestroySwapchainKHR = (PFN_vkDestroySwapchainKHR) vkGetDeviceProcAddr(currentDevice, "vkDestroySwapchainKHR");
  $vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSwapchainImagesKHR");
  $vkAcquireNextImageKHR = (PFN_vkAcquireNextImageKHR) vkGetDeviceProcAddr(currentDevice, "vkAcquireNextImageKHR");
  $vkQueuePresentKHR = (PFN_vkQueuePresentKHR) vkGetDeviceProcAddr(currentDevice, "vkQueuePresentKHR");
  $vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT) vkGetDeviceProcAddr(currentDevice, "vkDebugMarkerSetObjectNameEXT");
  $vkDebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT) vkGetDeviceProcAddr(currentDevice, "vkDebugMarkerSetObjectTagEXT");
  $vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDebugMarkerBeginEXT");
  $vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDebugMarkerEndEXT");
  $vkCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDebugMarkerInsertEXT");
  $vkGetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryWin32HandleNV");
  $vkCmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndirectCountAMD");
  $vkCmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndexedIndirectCountAMD");
  $vkCmdProcessCommandsNVX = (PFN_vkCmdProcessCommandsNVX) vkGetDeviceProcAddr(currentDevice, "vkCmdProcessCommandsNVX");
  $vkCmdReserveSpaceForCommandsNVX = (PFN_vkCmdReserveSpaceForCommandsNVX) vkGetDeviceProcAddr(currentDevice, "vkCmdReserveSpaceForCommandsNVX");
  $vkCreateIndirectCommandsLayoutNVX = (PFN_vkCreateIndirectCommandsLayoutNVX) vkGetDeviceProcAddr(currentDevice, "vkCreateIndirectCommandsLayoutNVX");
  $vkDestroyIndirectCommandsLayoutNVX = (PFN_vkDestroyIndirectCommandsLayoutNVX) vkGetDeviceProcAddr(currentDevice, "vkDestroyIndirectCommandsLayoutNVX");
  $vkCreateObjectTableNVX = (PFN_vkCreateObjectTableNVX) vkGetDeviceProcAddr(currentDevice, "vkCreateObjectTableNVX");
  $vkDestroyObjectTableNVX = (PFN_vkDestroyObjectTableNVX) vkGetDeviceProcAddr(currentDevice, "vkDestroyObjectTableNVX");
  $vkRegisterObjectsNVX = (PFN_vkRegisterObjectsNVX) vkGetDeviceProcAddr(currentDevice, "vkRegisterObjectsNVX");
  $vkUnregisterObjectsNVX = (PFN_vkUnregisterObjectsNVX) vkGetDeviceProcAddr(currentDevice, "vkUnregisterObjectsNVX");
  $vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = (PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");
  $vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdPushDescriptorSetKHR");
  $vkGetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryWin32HandleKHR");
  $vkGetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryWin32HandlePropertiesKHR");
  $vkGetMemoryFdKHR = (PFN_vkGetMemoryFdKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryFdKHR");
  $vkGetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryFdPropertiesKHR");
  $vkGetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSemaphoreWin32HandleKHR");
  $vkImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkImportSemaphoreWin32HandleKHR");
  $vkGetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSemaphoreFdKHR");
  $vkImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR) vkGetDeviceProcAddr(currentDevice, "vkImportSemaphoreFdKHR");
  $vkGetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkGetFenceWin32HandleKHR");
  $vkImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkImportFenceWin32HandleKHR");
  $vkGetFenceFdKHR = (PFN_vkGetFenceFdKHR) vkGetDeviceProcAddr(currentDevice, "vkGetFenceFdKHR");
  $vkImportFenceFdKHR = (PFN_vkImportFenceFdKHR) vkGetDeviceProcAddr(currentDevice, "vkImportFenceFdKHR");
  $vkDisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT) vkGetDeviceProcAddr(currentDevice, "vkDisplayPowerControlEXT");
  $vkRegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT) vkGetDeviceProcAddr(currentDevice, "vkRegisterDeviceEventEXT");
  $vkRegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT) vkGetDeviceProcAddr(currentDevice, "vkRegisterDisplayEventEXT");
  $vkGetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT) vkGetDeviceProcAddr(currentDevice, "vkGetSwapchainCounterEXT");
  $vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetDeviceGroupPresentCapabilitiesKHR");
  $vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetDeviceGroupSurfacePresentModesKHR");
  $vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR) vkGetDeviceProcAddr(currentDevice, "vkAcquireNextImage2KHR");
  $vkGetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDevicePresentRectanglesKHR");
  $vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdPushDescriptorSetWithTemplateKHR");
  $vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT) vkGetDeviceProcAddr(currentDevice, "vkSetHdrMetadataEXT");
  $vkGetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSwapchainStatusKHR");
  $vkGetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE) vkGetDeviceProcAddr(currentDevice, "vkGetRefreshCycleDurationGOOGLE");
  $vkGetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE) vkGetDeviceProcAddr(currentDevice, "vkGetPastPresentationTimingGOOGLE");
  $vkCmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetViewportWScalingNV");
  $vkCmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdSetDiscardRectangleEXT");
  $vkCmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdSetSampleLocationsEXT");
  $vkGetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
  $vkCreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT) vkGetDeviceProcAddr(currentDevice, "vkCreateValidationCacheEXT");
  $vkDestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT) vkGetDeviceProcAddr(currentDevice, "vkDestroyValidationCacheEXT");
  $vkGetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT) vkGetDeviceProcAddr(currentDevice, "vkGetValidationCacheDataEXT");
  $vkMergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT) vkGetDeviceProcAddr(currentDevice, "vkMergeValidationCachesEXT");
  $vkGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD) vkGetDeviceProcAddr(currentDevice, "vkGetShaderInfoAMD");
  $vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
  $vkGetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT) vkGetDeviceProcAddr(currentDevice, "vkGetCalibratedTimestampsEXT");
  $vkGetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryHostPointerPropertiesEXT");
  $vkCmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD) vkGetDeviceProcAddr(currentDevice, "vkCmdWriteBufferMarkerAMD");
  $vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCreateRenderPass2KHR");
  $vkCmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginRenderPass2KHR");
  $vkCmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCmdNextSubpass2KHR");
  $vkCmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCmdEndRenderPass2KHR");
  $vkCmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndirectCountKHR");
  $vkCmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndexedIndirectCountKHR");
  $vkCmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetCheckpointNV");
  $vkGetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV) vkGetDeviceProcAddr(currentDevice, "vkGetQueueCheckpointDataNV");
  $vkCmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBindTransformFeedbackBuffersEXT");
  $vkCmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginTransformFeedbackEXT");
  $vkCmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdEndTransformFeedbackEXT");
  $vkCmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginQueryIndexedEXT");
  $vkCmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdEndQueryIndexedEXT");
  $vkCmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndirectByteCountEXT");
  $vkCmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetExclusiveScissorNV");
  $vkCmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV) vkGetDeviceProcAddr(currentDevice, "vkCmdBindShadingRateImageNV");
  $vkCmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetViewportShadingRatePaletteNV");
  $vkCmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetCoarseSampleOrderNV");
  $vkCmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawMeshTasksNV");
  $vkCmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawMeshTasksIndirectNV");
  $vkCmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawMeshTasksIndirectCountNV");
  $vkCompileDeferredNV = (PFN_vkCompileDeferredNV) vkGetDeviceProcAddr(currentDevice, "vkCompileDeferredNV");
  $vkCreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkCreateAccelerationStructureNV");
  $vkDestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkDestroyAccelerationStructureNV");
  $vkGetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV) vkGetDeviceProcAddr(currentDevice, "vkGetAccelerationStructureMemoryRequirementsNV");
  $vkBindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV) vkGetDeviceProcAddr(currentDevice, "vkBindAccelerationStructureMemoryNV");
  $vkCmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkCmdCopyAccelerationStructureNV");
  $vkCmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV) vkGetDeviceProcAddr(currentDevice, "vkCmdWriteAccelerationStructuresPropertiesNV");
  $vkCmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkCmdBuildAccelerationStructureNV");
  $vkCmdTraceRaysNV = (PFN_vkCmdTraceRaysNV) vkGetDeviceProcAddr(currentDevice, "vkCmdTraceRaysNV");
  $vkGetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV) vkGetDeviceProcAddr(currentDevice, "vkGetRayTracingShaderGroupHandlesNV");
  $vkGetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV) vkGetDeviceProcAddr(currentDevice, "vkGetAccelerationStructureHandleNV");
  $vkCreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV) vkGetDeviceProcAddr(currentDevice, "vkCreateRayTracingPipelinesNV");
  $vkGetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT) vkGetDeviceProcAddr(currentDevice, "vkGetImageDrmFormatModifierPropertiesEXT");
  $vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT) vkGetDeviceProcAddr(currentDevice, "vkGetBufferDeviceAddressEXT");
};

void vkUseInstance(VkInstance pInstance) {
  currentInstance = pInstance;
  $vkGetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
  $vkGetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
  $vkGetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayPlaneSupportedDisplaysKHR");
  $vkGetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayModePropertiesKHR");
  $vkCreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR) vkGetInstanceProcAddr(currentInstance, "vkCreateDisplayModeKHR");
  $vkGetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayPlaneCapabilitiesKHR");
  $vkCreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR) vkGetInstanceProcAddr(currentInstance, "vkCreateDisplayPlaneSurfaceKHR");
  $vkDestroySurfaceKHR = (PFN_vkDestroySurfaceKHR) vkGetInstanceProcAddr(currentInstance, "vkDestroySurfaceKHR");
  $vkGetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceSupportKHR");
  $vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
  $vkGetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceFormatsKHR");
  $vkGetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfacePresentModesKHR");
  $vkCreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(currentInstance, "vkCreateWin32SurfaceKHR");
  $vkGetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
  $vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT) vkGetInstanceProcAddr(currentInstance, "vkCreateDebugReportCallbackEXT");
  $vkDestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT) vkGetInstanceProcAddr(currentInstance, "vkDestroyDebugReportCallbackEXT");
  $vkDebugReportMessageEXT = (PFN_vkDebugReportMessageEXT) vkGetInstanceProcAddr(currentInstance, "vkDebugReportMessageEXT");
  $vkGetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
  $vkReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT) vkGetInstanceProcAddr(currentInstance, "vkReleaseDisplayEXT");
  $vkGetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
  $vkGetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
  $vkGetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceFormats2KHR");
  $vkGetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayProperties2KHR");
  $vkGetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
  $vkGetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayModeProperties2KHR");
  $vkGetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayPlaneCapabilities2KHR");
  $vkSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT) vkGetInstanceProcAddr(currentInstance, "vkSetDebugUtilsObjectNameEXT");
  $vkSetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT) vkGetInstanceProcAddr(currentInstance, "vkSetDebugUtilsObjectTagEXT");
  $vkQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkQueueBeginDebugUtilsLabelEXT");
  $vkQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkQueueEndDebugUtilsLabelEXT");
  $vkQueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkQueueInsertDebugUtilsLabelEXT");
  $vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkCmdBeginDebugUtilsLabelEXT");
  $vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkCmdEndDebugUtilsLabelEXT");
  $vkCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkCmdInsertDebugUtilsLabelEXT");
  $vkCreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(currentInstance, "vkCreateDebugUtilsMessengerEXT");
  $vkDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(currentInstance, "vkDestroyDebugUtilsMessengerEXT");
  $vkSubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT) vkGetInstanceProcAddr(currentInstance, "vkSubmitDebugUtilsMessageEXT");
};

Napi::Value _vkUseDevice(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info[0].IsObject()) {
    _VkDevice* obj = Napi::ObjectWrap<_VkDevice>::Unwrap(info[0].As<Napi::Object>());
    vkUseDevice(obj->instance);
  } else if (info[0].IsNull()) {
    currentDevice = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'pDevice'").ThrowAsJavaScriptException();
  }
  return env.Undefined();
};

void _vkUseInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info[0].IsObject()) {
    _VkInstance* obj = Napi::ObjectWrap<_VkInstance>::Unwrap(info[0].As<Napi::Object>());
    vkUseInstance(obj->instance);
  } else if (info[0].IsNull()) {
    currentInstance = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'pInstance'").ThrowAsJavaScriptException();
  }
  return env.Undefined();
};

void _vkCreateInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstanceCreateInfo* obj0;
  VkInstanceCreateInfo *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstanceCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstanceCreateInfo]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstanceCreateInfo>::Unwrap(obj);
    if (!obj0->flush()) return;
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkInstance* obj2;
  VkInstance *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkInstance]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pInstance'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  
  vkUseInstance(obj2->instance);
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

vkDestroyInstance(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkEnumeratePhysicalDevices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPhysicalDeviceCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkPhysicalDevice>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkPhysicalDevice> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPhysicalDevice* result = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkPhysicalDevice>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pPhysicalDevices'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkEnumeratePhysicalDevices(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkPhysicalDevice *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkPhysicalDevice* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPhysicalDevice* target = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDeviceProcAddr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  char* $p1;
  if (info[1].IsString()) {
    $p1 = copyV8String(info[1]);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 2 'pName'").ThrowAsJavaScriptException();
    return;
  }
  PFN_vkVoidFunction out = vkGetDeviceProcAddr(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, 0);
  
};

void _vkGetInstanceProcAddr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  char* $p1;
  if (info[1].IsString()) {
    $p1 = copyV8String(info[1]);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 2 'pName'").ThrowAsJavaScriptException();
    return;
  }
  PFN_vkVoidFunction out = vkGetInstanceProcAddr(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, 0);
  
};

void _vkGetPhysicalDeviceProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceProperties* obj1;
  VkPhysicalDeviceProperties *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceProperties::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceProperties]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceProperties>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect string
    Napi::String str1 = Napi::String::New(env, (&obj1->instance)->deviceName);
    obj1->deviceName.Reset(str1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 16);
    // populate array
    for (unsigned int ii = 0; ii < 16; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&obj1->instance)->pipelineCacheUUID[ii]));
    };
    obj1->pipelineCacheUUID.Reset(arr1);
  }
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceLimits::constructor.New(args);
    _VkPhysicalDeviceLimits* 6 = Napi::ObjectWrap<_VkPhysicalDeviceLimits>::Unwrap(inst);
    obj1->limits.Reset(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.limits, sizeof(VkPhysicalDeviceLimits));
    
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->maxComputeWorkGroupCount[ii]));
    };
    unwrapped6->maxComputeWorkGroupCount.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->maxComputeWorkGroupSize[ii]));
    };
    unwrapped6->maxComputeWorkGroupSize.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->maxViewportDimensions[ii]));
    };
    unwrapped6->maxViewportDimensions.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->viewportBoundsRange[ii]));
    };
    unwrapped6->viewportBoundsRange.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->pointSizeRange[ii]));
    };
    unwrapped6->pointSizeRange.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->lineWidthRange[ii]));
    };
    unwrapped6->lineWidthRange.Reset(arr1);
  }
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceSparseProperties::constructor.New(args);
    _VkPhysicalDeviceSparseProperties* 6 = Napi::ObjectWrap<_VkPhysicalDeviceSparseProperties>::Unwrap(inst);
    obj1->sparseProperties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.sparseProperties, sizeof(VkPhysicalDeviceSparseProperties));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pQueueFamilyPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkQueueFamilyProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkQueueFamilyProperties* result = Napi::ObjectWrap<_VkQueueFamilyProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkQueueFamilyProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkQueueFamilyProperties* result = Napi::ObjectWrap<_VkQueueFamilyProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkQueueFamilyProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pQueueFamilyProperties'").ThrowAsJavaScriptException();
    return;
  }

vkGetPhysicalDeviceQueueFamilyProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkQueueFamilyProperties *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkQueueFamilyProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkQueueFamilyProperties* result = Napi::ObjectWrap<_VkQueueFamilyProperties>::Unwrap(obj);
      VkQueueFamilyProperties *instance = &result->instance;
      VkQueueFamilyProperties *copy = &$pdata[ii];
      
      instance->queueFlags = copy->queueFlags;
      instance->queueCount = copy->queueCount;
      instance->timestampValidBits = copy->timestampValidBits;
      instance->minImageTransferGranularity = copy->minImageTransferGranularity;
      if (&copy->minImageTransferGranularity != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkExtent3D::constructor.New(args);
        _VkExtent3D* unwrapped = Napi::ObjectWrap<_VkExtent3D>::Unwrap(inst);
        result->minImageTransferGranularity.Reset(inst);
        unwrapped->instance = copy->minImageTransferGranularity;
      }
    };
  }
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceMemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceMemoryProperties* obj1;
  VkPhysicalDeviceMemoryProperties *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceMemoryProperties::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceMemoryProperties]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceMemoryProperties>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pMemoryProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceMemoryProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect array
    unsigned int len = obj1->instance.memoryTypeCount;
    Napi::Array arr = Napi::Array::New(env, len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      Napi::Object inst = _VkMemoryType::constructor.New(args);
      _VkMemoryType* unwrapped = Napi::ObjectWrap<_VkMemoryType>::Unwrap(inst);
      memcpy(&unwrapped->instance, &obj1->instance.memoryTypes[ii], sizeof(VkMemoryType));
      arr.Set(ii, inst);
    };
    obj1->memoryTypes.Reset(arr);
  }
  {
    // back reflect array
    unsigned int len = obj1->instance.memoryHeapCount;
    Napi::Array arr = Napi::Array::New(env, len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      Napi::Object inst = _VkMemoryHeap::constructor.New(args);
      _VkMemoryHeap* unwrapped = Napi::ObjectWrap<_VkMemoryHeap>::Unwrap(inst);
      memcpy(&unwrapped->instance, &obj1->instance.memoryHeaps[ii], sizeof(VkMemoryHeap));
      arr.Set(ii, inst);
    };
    obj1->memoryHeaps.Reset(arr);
  }
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceFeatures* obj1;
  VkPhysicalDeviceFeatures *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceFeatures::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceFeatures]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pFeatures'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceFeatures(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  _VkFormatProperties* obj2;
  VkFormatProperties *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFormatProperties::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkFormatProperties]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkFormatProperties>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFormatProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceFormatProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceImageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  VkImageType $p2 = static_cast<VkImageType>(info[2].As<Napi::Number>().Int64Value());

  VkImageTiling $p3 = static_cast<VkImageTiling>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  int32_t $p5 = static_cast<int32_t>(info[5].As<Napi::Number>().Int64Value());

  _VkImageFormatProperties* obj6;
  VkImageFormatProperties *$p6;
  if (info[6].IsObject()) {
    Napi::Object obj = info[6].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageFormatProperties::constructor.Value()))) {
      NanObjectTypeError(info[6], "argument 7", "[object VkImageFormatProperties]");
      return;
    }
    obj6 = Napi::ObjectWrap<_VkImageFormatProperties>::Unwrap(obj);
    if (!obj6->flush()) return;
    $p6 = &obj6->instance;
  } else if (info[6].IsNull()) {
    $p6 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 7 'pImageFormatProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = vkGetPhysicalDeviceImageFormatProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    static_cast<VkImageUsageFlags>($p4),
    static_cast<VkImageCreateFlags>($p5),
    $p6
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent3D::constructor.New(args);
    _VkExtent3D* 6 = Napi::ObjectWrap<_VkExtent3D>::Unwrap(inst);
    obj6->maxExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj6->instance.maxExtent, sizeof(VkExtent3D));
    
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateDevice(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDeviceCreateInfo* obj1;
  VkDeviceCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDevice* obj3;
  VkDevice *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDevice]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pDevice'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateDevice(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  vkUseDevice(obj3->instance);
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyDevice(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

vkDestroyDevice(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkEnumerateInstanceVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  uint32_t $p0;
  if (info[0].IsObject()) {
    obj0 = info[0].As<Napi::Object>();
    if (!obj0.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 1").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p0 = static_cast<uint32_t>(info[0].As<Napi::Number>().Int64Value());
  } else if (!info[0].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'pApiVersion'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = vkEnumerateInstanceVersion(
    &$p0
  );
    obj0.Set("$", $p0);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkEnumerateInstanceLayerProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  uint32_t $p0;
  if (info[0].IsObject()) {
    obj0 = info[0].As<Napi::Object>();
    if (!obj0.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 1").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p0 = static_cast<uint32_t>(info[0].As<Napi::Number>().Int64Value());
  } else if (!info[0].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkLayerProperties>> $p1 = nullptr;

  if (info[1].IsArray()) {

  {
    Napi::Array array = info[1].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkLayerProperties* result = Napi::ObjectWrap<_VkLayerProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[1].As<Napi::Array>();
    std::vector<VkLayerProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkLayerProperties* result = Napi::ObjectWrap<_VkLayerProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p1 = std::make_shared<std::vector<VkLayerProperties>>(data);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 2 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkEnumerateInstanceLayerProperties(
    &$p0,
    $p1 ? (VkLayerProperties *) $p1.get()->data() : nullptr
  );
    obj0.Set("$", $p0);
  if (info[1].IsArray()) {
    VkLayerProperties* $pdata = $p1.get()->data();
    Napi::Array array = info[1].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkLayerProperties* result = Napi::ObjectWrap<_VkLayerProperties>::Unwrap(obj);
      VkLayerProperties *instance = &result->instance;
      VkLayerProperties *copy = &$pdata[ii];
      
      {
        std::string stri(copy->layerName);
        Napi::String str = Napi::String::New(env, stri);
        result->layerName.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->layerName), copy->layerName);
      }
      instance->specVersion = copy->specVersion;
      instance->implementationVersion = copy->implementationVersion;
      {
        std::string stri(copy->description);
        Napi::String str = Napi::String::New(env, stri);
        result->description.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->description), copy->description);
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkEnumerateInstanceExtensionProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  char* $p0;
  if (info[0].IsString()) {
    $p0 = copyV8String(info[0]);
  } else if (!info[0].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 1 'pLayerName'").ThrowAsJavaScriptException();
    return;
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkExtensionProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkExtensionProperties* result = Napi::ObjectWrap<_VkExtensionProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkExtensionProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkExtensionProperties* result = Napi::ObjectWrap<_VkExtensionProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkExtensionProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkEnumerateInstanceExtensionProperties(
    $p0,
    &$p1,
    $p2 ? (VkExtensionProperties *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkExtensionProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkExtensionProperties* result = Napi::ObjectWrap<_VkExtensionProperties>::Unwrap(obj);
      VkExtensionProperties *instance = &result->instance;
      VkExtensionProperties *copy = &$pdata[ii];
      
      {
        std::string stri(copy->extensionName);
        Napi::String str = Napi::String::New(env, stri);
        result->extensionName.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->extensionName), copy->extensionName);
      }
      instance->specVersion = copy->specVersion;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkEnumerateDeviceLayerProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkLayerProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkLayerProperties* result = Napi::ObjectWrap<_VkLayerProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkLayerProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkLayerProperties* result = Napi::ObjectWrap<_VkLayerProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkLayerProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkEnumerateDeviceLayerProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkLayerProperties *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkLayerProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkLayerProperties* result = Napi::ObjectWrap<_VkLayerProperties>::Unwrap(obj);
      VkLayerProperties *instance = &result->instance;
      VkLayerProperties *copy = &$pdata[ii];
      
      {
        std::string stri(copy->layerName);
        Napi::String str = Napi::String::New(env, stri);
        result->layerName.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->layerName), copy->layerName);
      }
      instance->specVersion = copy->specVersion;
      instance->implementationVersion = copy->implementationVersion;
      {
        std::string stri(copy->description);
        Napi::String str = Napi::String::New(env, stri);
        result->description.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->description), copy->description);
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkEnumerateDeviceExtensionProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  char* $p1;
  if (info[1].IsString()) {
    $p1 = copyV8String(info[1]);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 2 'pLayerName'").ThrowAsJavaScriptException();
    return;
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkExtensionProperties>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkExtensionProperties* result = Napi::ObjectWrap<_VkExtensionProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkExtensionProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkExtensionProperties* result = Napi::ObjectWrap<_VkExtensionProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkExtensionProperties>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkEnumerateDeviceExtensionProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkExtensionProperties *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkExtensionProperties* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkExtensionProperties* result = Napi::ObjectWrap<_VkExtensionProperties>::Unwrap(obj);
      VkExtensionProperties *instance = &result->instance;
      VkExtensionProperties *copy = &$pdata[ii];
      
      {
        std::string stri(copy->extensionName);
        Napi::String str = Napi::String::New(env, stri);
        result->extensionName.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->extensionName), copy->extensionName);
      }
      instance->specVersion = copy->specVersion;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDeviceQueue(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  _VkQueue* obj3;
  VkQueue *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkQueue]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pQueue'").ThrowAsJavaScriptException();
  }
vkGetDeviceQueue(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkQueueSubmit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkSubmitInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSubmitInfo* result = Napi::ObjectWrap<_VkSubmitInfo>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkSubmitInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSubmitInfo* result = Napi::ObjectWrap<_VkSubmitInfo>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkSubmitInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pSubmits'").ThrowAsJavaScriptException();
    return;
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'fence'").ThrowAsJavaScriptException();
  }
  int32_t out = vkQueueSubmit(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkSubmitInfo *) $p2.get()->data() : nullptr,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkQueueWaitIdle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }
  int32_t out = vkQueueWaitIdle(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDeviceWaitIdle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }
  int32_t out = vkDeviceWaitIdle(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkAllocateMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkMemoryAllocateInfo* obj1;
  VkMemoryAllocateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryAllocateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkMemoryAllocateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkMemoryAllocateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pAllocateInfo'").ThrowAsJavaScriptException();
  }


  _VkDeviceMemory* obj3;
  VkDeviceMemory *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDeviceMemory]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pMemory'").ThrowAsJavaScriptException();
  }
  int32_t out = vkAllocateMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkFreeMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
  }

vkFreeMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkMapMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  Napi::Object obj5 = info[5].As<Napi::Object>();
  void *$p5;
  int32_t out = vkMapMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    static_cast<VkMemoryMapFlags>($p4),
    &$p5
  );
  Napi::BigInt ptr5 = Napi::BigInt::New(env, (int64_t)$p5);
  obj5.Set("$", ptr5);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkUnmapMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
  }
vkUnmapMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return env.Undefined();
  
};

void _vkFlushMappedMemoryRanges(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMappedMemoryRange>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMappedMemoryRange* result = Napi::ObjectWrap<_VkMappedMemoryRange>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkMappedMemoryRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMappedMemoryRange* result = Napi::ObjectWrap<_VkMappedMemoryRange>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkMappedMemoryRange>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pMemoryRanges'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkFlushMappedMemoryRanges(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkMappedMemoryRange *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkInvalidateMappedMemoryRanges(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMappedMemoryRange>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMappedMemoryRange* result = Napi::ObjectWrap<_VkMappedMemoryRange>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkMappedMemoryRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMappedMemoryRange* result = Napi::ObjectWrap<_VkMappedMemoryRange>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkMappedMemoryRange>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pMemoryRanges'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkInvalidateMappedMemoryRanges(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkMappedMemoryRange *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDeviceMemoryCommitment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint64_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pCommittedMemoryInBytes'").ThrowAsJavaScriptException();
    return;
  }
vkGetDeviceMemoryCommitment(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2
  );
    Napi::BigInt pnum2 = Napi::BigInt::New(env, (uint64_t)$p2);
    obj2.Set("$", pnum2);
  
  
  return env.Undefined();
  
};

void _vkGetBufferMemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  _VkMemoryRequirements* obj2;
  VkMemoryRequirements *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryRequirements::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkMemoryRequirements>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
  }
vkGetBufferMemoryRequirements(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkBindBufferMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj2;
  VkDeviceMemory *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDeviceMemory]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'memory'").ThrowAsJavaScriptException();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());
  int32_t out = vkBindBufferMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetImageMemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  _VkMemoryRequirements* obj2;
  VkMemoryRequirements *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryRequirements::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkMemoryRequirements>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
  }
vkGetImageMemoryRequirements(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkBindImageMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj2;
  VkDeviceMemory *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDeviceMemory]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'memory'").ThrowAsJavaScriptException();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());
  int32_t out = vkBindImageMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetImageSparseMemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSparseMemoryRequirementCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkSparseImageMemoryRequirements>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageMemoryRequirements* result = Napi::ObjectWrap<_VkSparseImageMemoryRequirements>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSparseImageMemoryRequirements> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageMemoryRequirements* result = Napi::ObjectWrap<_VkSparseImageMemoryRequirements>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkSparseImageMemoryRequirements>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSparseMemoryRequirements'").ThrowAsJavaScriptException();
    return;
  }

vkGetImageSparseMemoryRequirements(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkSparseImageMemoryRequirements *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSparseImageMemoryRequirements* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageMemoryRequirements* result = Napi::ObjectWrap<_VkSparseImageMemoryRequirements>::Unwrap(obj);
      VkSparseImageMemoryRequirements *instance = &result->instance;
      VkSparseImageMemoryRequirements *copy = &$pdata[ii];
      
      instance->formatProperties = copy->formatProperties;
      if (&copy->formatProperties != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkSparseImageFormatProperties::constructor.New(args);
        _VkSparseImageFormatProperties* unwrapped = Napi::ObjectWrap<_VkSparseImageFormatProperties>::Unwrap(inst);
        result->formatProperties.Reset(inst);
        unwrapped->instance = copy->formatProperties;
      }
      instance->imageMipTailFirstLod = copy->imageMipTailFirstLod;
      instance->imageMipTailSize = copy->imageMipTailSize;
      instance->imageMipTailOffset = copy->imageMipTailOffset;
      instance->imageMipTailStride = copy->imageMipTailStride;
    };
  }
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceSparseImageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  VkImageType $p2 = static_cast<VkImageType>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  VkImageTiling $p5 = static_cast<VkImageTiling>(info[5].As<Napi::Number>().Int64Value());

  Napi::Object obj6;
  uint32_t $p6;
  if (info[6].IsObject()) {
    obj6 = info[6].As<Napi::Object>();
    if (!obj6.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 7").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 7 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkSparseImageFormatProperties>> $p7 = nullptr;

  if (info[7].IsArray()) {

  {
    Napi::Array array = info[7].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageFormatProperties* result = Napi::ObjectWrap<_VkSparseImageFormatProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[7].As<Napi::Array>();
    std::vector<VkSparseImageFormatProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageFormatProperties* result = Napi::ObjectWrap<_VkSparseImageFormatProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p7 = std::make_shared<std::vector<VkSparseImageFormatProperties>>(data);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 8 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

vkGetPhysicalDeviceSparseImageFormatProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    static_cast<VkSampleCountFlagBits>($p3),
    static_cast<VkImageUsageFlags>($p4),
    $p5,
    &$p6,
    $p7 ? (VkSparseImageFormatProperties *) $p7.get()->data() : nullptr
  );
    obj6.Set("$", $p6);
  if (info[7].IsArray()) {
    VkSparseImageFormatProperties* $pdata = $p7.get()->data();
    Napi::Array array = info[7].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageFormatProperties* result = Napi::ObjectWrap<_VkSparseImageFormatProperties>::Unwrap(obj);
      VkSparseImageFormatProperties *instance = &result->instance;
      VkSparseImageFormatProperties *copy = &$pdata[ii];
      
      instance->aspectMask = copy->aspectMask;
      instance->imageGranularity = copy->imageGranularity;
      if (&copy->imageGranularity != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkExtent3D::constructor.New(args);
        _VkExtent3D* unwrapped = Napi::ObjectWrap<_VkExtent3D>::Unwrap(inst);
        result->imageGranularity.Reset(inst);
        unwrapped->instance = copy->imageGranularity;
      }
      instance->flags = copy->flags;
    };
  }
  
  
  return env.Undefined();
  
};

void _vkQueueBindSparse(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindSparseInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindSparseInfo* result = Napi::ObjectWrap<_VkBindSparseInfo>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindSparseInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindSparseInfo* result = Napi::ObjectWrap<_VkBindSparseInfo>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkBindSparseInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfo'").ThrowAsJavaScriptException();
    return;
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'fence'").ThrowAsJavaScriptException();
  }
  int32_t out = vkQueueBindSparse(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindSparseInfo *) $p2.get()->data() : nullptr,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateFence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFenceCreateInfo* obj1;
  VkFenceCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFenceCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFenceCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFenceCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pFence'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateFence(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyFence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFence* obj1;
  VkFence *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFence]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'fence'").ThrowAsJavaScriptException();
  }

vkDestroyFence(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkResetFences(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkFence>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkFence> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkFence* result = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkFence>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pFences'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkResetFences(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkFence *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetFenceStatus(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFence* obj1;
  VkFence *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFence]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'fence'").ThrowAsJavaScriptException();
  }
  int32_t out = vkGetFenceStatus(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkWaitForFences(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkFence>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkFence> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkFence* result = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkFence>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pFences'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());
  int32_t out = vkWaitForFences(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkFence *) $p2.get()->data() : nullptr,
    $p3,
    $p4
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateSemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSemaphoreCreateInfo* obj1;
  VkSemaphoreCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSemaphoreCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSemaphoreCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSemaphoreCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSemaphore]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSemaphore'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateSemaphore(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroySemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSemaphore* obj1;
  VkSemaphore *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSemaphore]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'semaphore'").ThrowAsJavaScriptException();
  }

vkDestroySemaphore(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkEventCreateInfo* obj1;
  VkEventCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEventCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEventCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEventCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkEvent* obj3;
  VkEvent *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkEvent]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pEvent'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
  }

vkDestroyEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetEventStatus(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
  }
  int32_t out = vkGetEventStatus(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkSetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
  }
  int32_t out = vkSetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkResetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
  }
  int32_t out = vkResetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateQueryPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkQueryPoolCreateInfo* obj1;
  VkQueryPoolCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPoolCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPoolCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPoolCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkQueryPool* obj3;
  VkQueryPool *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkQueryPool]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pQueryPool'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateQueryPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyQueryPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

vkDestroyQueryPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetQueryPoolResults(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  size_t $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());

  void* $p5;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pData'").ThrowAsJavaScriptException();
    return;
  }

  uint64_t $p6 = static_cast<uint64_t>(info[6].As<Napi::Number>().Int64Value());

  int32_t $p7 = static_cast<int32_t>(info[7].As<Napi::Number>().Int64Value());
  int32_t out = vkGetQueryPoolResults(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    info[5].IsNull() ? nullptr : $p5,
    $p6,
    static_cast<VkQueryResultFlags>($p7)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBufferCreateInfo* obj1;
  VkBufferCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBufferCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBufferCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBufferCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pBuffer'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

vkDestroyBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateBufferView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBufferViewCreateInfo* obj1;
  VkBufferViewCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBufferViewCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBufferViewCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBufferViewCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkBufferView* obj3;
  VkBufferView *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBufferView::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBufferView]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBufferView>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pView'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateBufferView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyBufferView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBufferView* obj1;
  VkBufferView *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBufferView::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBufferView]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBufferView>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'bufferView'").ThrowAsJavaScriptException();
  }

vkDestroyBufferView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImageCreateInfo* obj1;
  VkImageCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImageCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImageCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkImage* obj3;
  VkImage *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pImage'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

vkDestroyImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetImageSubresourceLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  _VkImageSubresource* obj2;
  VkImageSubresource *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageSubresource::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkImageSubresource]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkImageSubresource>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSubresource'").ThrowAsJavaScriptException();
  }

  _VkSubresourceLayout* obj3;
  VkSubresourceLayout *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSubresourceLayout::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSubresourceLayout]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSubresourceLayout>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pLayout'").ThrowAsJavaScriptException();
  }
vkGetImageSubresourceLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCreateImageView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImageViewCreateInfo* obj1;
  VkImageViewCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageViewCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImageViewCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImageViewCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkImageView* obj3;
  VkImageView *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageView::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkImageView]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkImageView>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pView'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateImageView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyImageView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImageView* obj1;
  VkImageView *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageView::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImageView]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImageView>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'imageView'").ThrowAsJavaScriptException();
  }

vkDestroyImageView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateShaderModule(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkShaderModuleCreateInfo* obj1;
  VkShaderModuleCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkShaderModuleCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkShaderModuleCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkShaderModuleCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkShaderModule* obj3;
  VkShaderModule *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkShaderModule::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkShaderModule]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkShaderModule>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pShaderModule'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateShaderModule(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyShaderModule(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkShaderModule* obj1;
  VkShaderModule *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkShaderModule::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkShaderModule]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkShaderModule>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'shaderModule'").ThrowAsJavaScriptException();
  }

vkDestroyShaderModule(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreatePipelineCache(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCacheCreateInfo* obj1;
  VkPipelineCacheCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCacheCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCacheCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCacheCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkPipelineCache* obj3;
  VkPipelineCache *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkPipelineCache]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pPipelineCache'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreatePipelineCache(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyPipelineCache(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
  }

vkDestroyPipelineCache(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetPipelineCacheData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  size_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<size_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDataSize'").ThrowAsJavaScriptException();
    return;
  }

  void* $p3;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = vkGetPipelineCacheData(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    info[3].IsNull() ? nullptr : $p3
  );
    Napi::BigInt pnum2 = Napi::BigInt::New(env, (uint64_t)$p2);
    obj2.Set("$", pnum2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkMergePipelineCaches(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'dstCache'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkPipelineCache>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkPipelineCache> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipelineCache* result = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkPipelineCache>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSrcCaches'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkMergePipelineCaches(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkPipelineCache *) $p3.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateGraphicsPipelines(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkGraphicsPipelineCreateInfo>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkGraphicsPipelineCreateInfo* result = Napi::ObjectWrap<_VkGraphicsPipelineCreateInfo>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkGraphicsPipelineCreateInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkGraphicsPipelineCreateInfo* result = Napi::ObjectWrap<_VkGraphicsPipelineCreateInfo>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkGraphicsPipelineCreateInfo>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCreateInfos'").ThrowAsJavaScriptException();
    return;
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkPipeline> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipeline* result = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pPipelines'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkCreateGraphicsPipelines(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkGraphicsPipelineCreateInfo *) $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? (VkPipeline *) $p5.get()->data() : nullptr
  );
  if (info[5].IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipeline* target = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateComputePipelines(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkComputePipelineCreateInfo>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkComputePipelineCreateInfo* result = Napi::ObjectWrap<_VkComputePipelineCreateInfo>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkComputePipelineCreateInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkComputePipelineCreateInfo* result = Napi::ObjectWrap<_VkComputePipelineCreateInfo>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkComputePipelineCreateInfo>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCreateInfos'").ThrowAsJavaScriptException();
    return;
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkPipeline> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipeline* result = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pPipelines'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkCreateComputePipelines(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkComputePipelineCreateInfo *) $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? (VkPipeline *) $p5.get()->data() : nullptr
  );
  if (info[5].IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipeline* target = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyPipeline(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipeline* obj1;
  VkPipeline *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipeline::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
  }

vkDestroyPipeline(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreatePipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineLayoutCreateInfo* obj1;
  VkPipelineLayoutCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayoutCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineLayoutCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineLayoutCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkPipelineLayout* obj3;
  VkPipelineLayout *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayout::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkPipelineLayout]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pPipelineLayout'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreatePipelineLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyPipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineLayout* obj1;
  VkPipelineLayout *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayout::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineLayout]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipelineLayout'").ThrowAsJavaScriptException();
  }

vkDestroyPipelineLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateSampler(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSamplerCreateInfo* obj1;
  VkSamplerCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSamplerCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSamplerCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSamplerCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkSampler* obj3;
  VkSampler *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSampler::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSampler]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSampler>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSampler'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateSampler(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroySampler(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSampler* obj1;
  VkSampler *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSampler::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSampler]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSampler>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'sampler'").ThrowAsJavaScriptException();
  }

vkDestroySampler(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateDescriptorSetLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorSetLayoutCreateInfo* obj1;
  VkDescriptorSetLayoutCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSetLayoutCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetLayoutCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorSetLayoutCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDescriptorSetLayout* obj3;
  VkDescriptorSetLayout *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSetLayout::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDescriptorSetLayout]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDescriptorSetLayout>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSetLayout'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateDescriptorSetLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyDescriptorSetLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorSetLayout* obj1;
  VkDescriptorSetLayout *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSetLayout::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetLayout]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorSetLayout>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorSetLayout'").ThrowAsJavaScriptException();
  }

vkDestroyDescriptorSetLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateDescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorPoolCreateInfo* obj1;
  VkDescriptorPoolCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorPoolCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorPoolCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorPoolCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDescriptorPool* obj3;
  VkDescriptorPool *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorPool::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDescriptorPool]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDescriptorPool>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pDescriptorPool'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateDescriptorPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyDescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorPool* obj1;
  VkDescriptorPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorPool'").ThrowAsJavaScriptException();
  }

vkDestroyDescriptorPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkResetDescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorPool* obj1;
  VkDescriptorPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorPool'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
  int32_t out = vkResetDescriptorPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkDescriptorPoolResetFlags>($p2)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkAllocateDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorSetAllocateInfo* obj1;
  VkDescriptorSetAllocateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSetAllocateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetAllocateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorSetAllocateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pAllocateInfo'").ThrowAsJavaScriptException();
  }

  std::shared_ptr<std::vector<VkDescriptorSet>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDescriptorSet* result = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pDescriptorSets'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkAllocateDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (VkDescriptorSet *) $p2.get()->data() : nullptr
  );
  if (info[2].IsArray()) {
    VkDescriptorSet* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDescriptorSet* target = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkFreeDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorPool* obj1;
  VkDescriptorPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkDescriptorSet>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDescriptorSet* result = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pDescriptorSets'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkFreeDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkDescriptorSet *) $p3.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkUpdateDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkWriteDescriptorSet>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkWriteDescriptorSet* result = Napi::ObjectWrap<_VkWriteDescriptorSet>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkWriteDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkWriteDescriptorSet* result = Napi::ObjectWrap<_VkWriteDescriptorSet>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkWriteDescriptorSet>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pDescriptorWrites'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCopyDescriptorSet>> $p4 = nullptr;

  if (info[4].IsArray()) {

  {
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCopyDescriptorSet* result = Napi::ObjectWrap<_VkCopyDescriptorSet>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkCopyDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCopyDescriptorSet* result = Napi::ObjectWrap<_VkCopyDescriptorSet>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p4 = std::make_shared<std::vector<VkCopyDescriptorSet>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pDescriptorCopies'").ThrowAsJavaScriptException();
    return;
  }

vkUpdateDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkWriteDescriptorSet *) $p2.get()->data() : nullptr,
    $p3,
    $p4 ? (const VkCopyDescriptorSet *) $p4.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateFramebuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFramebufferCreateInfo* obj1;
  VkFramebufferCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFramebufferCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFramebufferCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFramebufferCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkFramebuffer* obj3;
  VkFramebuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFramebuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkFramebuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkFramebuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pFramebuffer'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateFramebuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyFramebuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFramebuffer* obj1;
  VkFramebuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFramebuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFramebuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFramebuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'framebuffer'").ThrowAsJavaScriptException();
  }

vkDestroyFramebuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkRenderPassCreateInfo* obj1;
  VkRenderPassCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPassCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkRenderPassCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkRenderPassCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkRenderPass* obj3;
  VkRenderPass *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPass::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkRenderPass]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pRenderPass'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkRenderPass* obj1;
  VkRenderPass *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPass::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkRenderPass]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'renderPass'").ThrowAsJavaScriptException();
  }

vkDestroyRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetRenderAreaGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkRenderPass* obj1;
  VkRenderPass *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPass::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkRenderPass]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'renderPass'").ThrowAsJavaScriptException();
  }

  _VkExtent2D* obj2;
  VkExtent2D *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkExtent2D::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkExtent2D]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pGranularity'").ThrowAsJavaScriptException();
  }
vkGetRenderAreaGranularity(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCreateCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkCommandPoolCreateInfo* obj1;
  VkCommandPoolCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandPoolCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandPoolCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandPoolCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkCommandPool* obj3;
  VkCommandPool *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandPool::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkCommandPool]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkCommandPool>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pCommandPool'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
  }

vkDestroyCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkResetCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
  int32_t out = vkResetCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkCommandPoolResetFlags>($p2)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkAllocateCommandBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkCommandBufferAllocateInfo* obj1;
  VkCommandBufferAllocateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBufferAllocateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandBufferAllocateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandBufferAllocateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pAllocateInfo'").ThrowAsJavaScriptException();
  }

  std::shared_ptr<std::vector<VkCommandBuffer>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCommandBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCommandBuffer* result = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCommandBuffers'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkAllocateCommandBuffers(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (VkCommandBuffer *) $p2.get()->data() : nullptr
  );
  if (info[2].IsArray()) {
    VkCommandBuffer* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCommandBuffer* target = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkFreeCommandBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCommandBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkCommandBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCommandBuffer* result = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCommandBuffers'").ThrowAsJavaScriptException();
    return;
  }

vkFreeCommandBuffers(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkCommandBuffer *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkBeginCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkCommandBufferBeginInfo* obj1;
  VkCommandBufferBeginInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBufferBeginInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandBufferBeginInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandBufferBeginInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pBeginInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = vkBeginCommandBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkEndCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }
  int32_t out = vkEndCommandBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkResetCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());
  int32_t out = vkResetCommandBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkCommandBufferResetFlags>($p1)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdBindPipeline(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1].As<Napi::Number>().Int64Value());

  _VkPipeline* obj2;
  VkPipeline *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipeline::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkPipeline]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pipeline'").ThrowAsJavaScriptException();
  }
vkCmdBindPipeline(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetViewport(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkViewport>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkViewport* result = Napi::ObjectWrap<_VkViewport>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkViewport> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkViewport* result = Napi::ObjectWrap<_VkViewport>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkViewport>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pViewports'").ThrowAsJavaScriptException();
    return;
  }

vkCmdSetViewport(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkViewport *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetScissor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pScissors'").ThrowAsJavaScriptException();
    return;
  }

vkCmdSetScissor(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkRect2D *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetLineWidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  float $p1 = static_cast<float>(info[1].As<Napi::Number>().Int64Value());
vkCmdSetLineWidth(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetDepthBias(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  float $p1 = static_cast<float>(info[1].As<Napi::Number>().Int64Value());

  float $p2 = static_cast<float>(info[2].As<Napi::Number>().Int64Value());

  float $p3 = static_cast<float>(info[3].As<Napi::Number>().Int64Value());
vkCmdSetDepthBias(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetBlendConstants(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

    std::shared_ptr<std::vector<float>> $p1 = nullptr;
    if (info[1].IsArray()) {
      // validate length
      if (info[1].As<Napi::Array>.Length() != 4) {
        Napi::RangeError::New(env, "Invalid array length for argument 2 'blendConstants'").ThrowAsJavaScriptException();
        return;
      } else {
        std::vector<float> data = createArrayOfV8Numbers<float>(info[1]);
        $p1 = std::make_shared<std::vector<float>>(data);
      }
    } else if (!info[1].IsNull()) {
      Napi::TypeError::New(env, "Invalid type for argument 2 'blendConstants'").ThrowAsJavaScriptException();
      return;
    }
vkCmdSetBlendConstants(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1 ? $p1.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetDepthBounds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  float $p1 = static_cast<float>(info[1].As<Napi::Number>().Int64Value());

  float $p2 = static_cast<float>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetDepthBounds(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetStencilCompareMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetStencilCompareMask(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkStencilFaceFlags>($p1),
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetStencilWriteMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetStencilWriteMask(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkStencilFaceFlags>($p1),
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetStencilReference(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetStencilReference(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkStencilFaceFlags>($p1),
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBindDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1].As<Napi::Number>().Int64Value());

  _VkPipelineLayout* obj2;
  VkPipelineLayout *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayout::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkPipelineLayout]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'layout'").ThrowAsJavaScriptException();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkDescriptorSet>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDescriptorSet* result = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pDescriptorSets'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());

  std::shared_ptr<uint32_t*> $p7 = nullptr;

  if (info[7].IsTypedArray()) {

    if (info[7].As<Napi::TypedArray>().TypedArrayType() != napi_uint32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 8 'pDynamicOffsets'").ThrowAsJavaScriptException();
      return;
    }
    uint32_t* data = getTypedArrayData<uint32_t>(info[7]);
    $p7 = std::make_shared<uint32_t*>(data);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 8 'pDynamicOffsets'").ThrowAsJavaScriptException();
    return;
  }

vkCmdBindDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? (const VkDescriptorSet *) $p5.get()->data() : nullptr,
    $p6,
    $p7 ? *$p7.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBindIndexBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  VkIndexType $p3 = static_cast<VkIndexType>(info[3].As<Napi::Number>().Int64Value());
vkCmdBindIndexBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBindVertexBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBuffer* result = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pBuffers'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
      return;
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
    return;
  }

vkCmdBindVertexBuffers(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDraw(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdDraw(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndexed(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());
vkCmdDrawIndexed(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdDrawIndirect(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndexedIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdDrawIndexedIndirect(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDispatch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdDispatch(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDispatchIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdDispatchIndirect(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdCopyBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'srcBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj2;
  VkBuffer *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkBuffer]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'dstBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferCopy>> $p4 = nullptr;

  if (info[4].IsArray()) {

  {
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferCopy* result = Napi::ObjectWrap<_VkBufferCopy>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkBufferCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferCopy* result = Napi::ObjectWrap<_VkBufferCopy>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p4 = std::make_shared<std::vector<VkBufferCopy>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pRegions'").ThrowAsJavaScriptException();
    return;
  }

vkCmdCopyBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4 ? (const VkBufferCopy *) $p4.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdCopyImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  _VkImage* obj3;
  VkImage *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'dstImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p4 = static_cast<VkImageLayout>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageCopy>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageCopy* result = Napi::ObjectWrap<_VkImageCopy>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkImageCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageCopy* result = Napi::ObjectWrap<_VkImageCopy>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p6 = std::make_shared<std::vector<VkImageCopy>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pRegions'").ThrowAsJavaScriptException();
    return;
  }

vkCmdCopyImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6 ? (const VkImageCopy *) $p6.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBlitImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  _VkImage* obj3;
  VkImage *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'dstImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p4 = static_cast<VkImageLayout>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageBlit>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageBlit* result = Napi::ObjectWrap<_VkImageBlit>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkImageBlit> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageBlit* result = Napi::ObjectWrap<_VkImageBlit>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p6 = std::make_shared<std::vector<VkImageBlit>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pRegions'").ThrowAsJavaScriptException();
    return;
  }


  VkFilter $p7 = static_cast<VkFilter>(info[7].As<Napi::Number>().Int64Value());
vkCmdBlitImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6 ? (const VkImageBlit *) $p6.get()->data() : nullptr,
    $p7
  );
  
  
  return env.Undefined();
  
};

void _vkCmdCopyBufferToImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'srcBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj2;
  VkImage *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkImage]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'dstImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p3 = static_cast<VkImageLayout>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferImageCopy>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferImageCopy* result = Napi::ObjectWrap<_VkBufferImageCopy>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkBufferImageCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferImageCopy* result = Napi::ObjectWrap<_VkBufferImageCopy>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkBufferImageCopy>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRegions'").ThrowAsJavaScriptException();
    return;
  }

vkCmdCopyBufferToImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? (const VkBufferImageCopy *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdCopyImageToBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'dstBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferImageCopy>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferImageCopy* result = Napi::ObjectWrap<_VkBufferImageCopy>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkBufferImageCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferImageCopy* result = Napi::ObjectWrap<_VkBufferImageCopy>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkBufferImageCopy>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRegions'").ThrowAsJavaScriptException();
    return;
  }

vkCmdCopyImageToBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5 ? (const VkBufferImageCopy *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdUpdateBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'dstBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  void* $p4;
  if (info[4].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[4].As<Napi::ArrayBuffer>();
    $p4 = buf.Data();
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 5 'pData'").ThrowAsJavaScriptException();
    return;
  }
vkCmdUpdateBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    info[4].IsNull() ? nullptr : $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdFillBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'dstBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdFillBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdClearColorImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  _VkClearColorValue* obj3;
  VkClearColorValue *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkClearColorValue::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkClearColorValue]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkClearColorValue>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pColor'").ThrowAsJavaScriptException();
  }

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageSubresourceRange>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageSubresourceRange* result = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkImageSubresourceRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageSubresourceRange* result = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkImageSubresourceRange>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRanges'").ThrowAsJavaScriptException();
    return;
  }

vkCmdClearColorImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    $p5 ? (const VkImageSubresourceRange *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdClearDepthStencilImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  _VkClearDepthStencilValue* obj3;
  VkClearDepthStencilValue *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkClearDepthStencilValue::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkClearDepthStencilValue]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkClearDepthStencilValue>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pDepthStencil'").ThrowAsJavaScriptException();
  }

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageSubresourceRange>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageSubresourceRange* result = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkImageSubresourceRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageSubresourceRange* result = Napi::ObjectWrap<_VkImageSubresourceRange>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkImageSubresourceRange>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRanges'").ThrowAsJavaScriptException();
    return;
  }

vkCmdClearDepthStencilImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    $p5 ? (const VkImageSubresourceRange *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdClearAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkClearAttachment>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkClearAttachment* result = Napi::ObjectWrap<_VkClearAttachment>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkClearAttachment> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkClearAttachment* result = Napi::ObjectWrap<_VkClearAttachment>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkClearAttachment>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pAttachments'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkClearRect>> $p4 = nullptr;

  if (info[4].IsArray()) {

  {
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkClearRect* result = Napi::ObjectWrap<_VkClearRect>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkClearRect> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkClearRect* result = Napi::ObjectWrap<_VkClearRect>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p4 = std::make_shared<std::vector<VkClearRect>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pRects'").ThrowAsJavaScriptException();
    return;
  }

vkCmdClearAttachments(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkClearAttachment *) $p2.get()->data() : nullptr,
    $p3,
    $p4 ? (const VkClearRect *) $p4.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdResolveImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  _VkImage* obj3;
  VkImage *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'dstImage'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p4 = static_cast<VkImageLayout>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageResolve>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageResolve* result = Napi::ObjectWrap<_VkImageResolve>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkImageResolve> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageResolve* result = Napi::ObjectWrap<_VkImageResolve>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p6 = std::make_shared<std::vector<VkImageResolve>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pRegions'").ThrowAsJavaScriptException();
    return;
  }

vkCmdResolveImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6 ? (const VkImageResolve *) $p6.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkPipelineStageFlags>($p2)
  );
  
  
  return env.Undefined();
  
};

void _vkCmdResetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkEvent::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdResetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkPipelineStageFlags>($p2)
  );
  
  
  return env.Undefined();
  
};

void _vkCmdWaitEvents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkEvent>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkEvent> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkEvent* result = Napi::ObjectWrap<_VkEvent>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkEvent>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pEvents'").ThrowAsJavaScriptException();
    return;
  }


  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMemoryBarrier>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMemoryBarrier* result = Napi::ObjectWrap<_VkMemoryBarrier>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMemoryBarrier* result = Napi::ObjectWrap<_VkMemoryBarrier>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p6 = std::make_shared<std::vector<VkMemoryBarrier>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pMemoryBarriers'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p7 = static_cast<uint32_t>(info[7].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferMemoryBarrier>> $p8 = nullptr;

  if (info[8].IsArray()) {

  {
    Napi::Array array = info[8].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferMemoryBarrier* result = Napi::ObjectWrap<_VkBufferMemoryBarrier>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[8].As<Napi::Array>();
    std::vector<VkBufferMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferMemoryBarrier* result = Napi::ObjectWrap<_VkBufferMemoryBarrier>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p8 = std::make_shared<std::vector<VkBufferMemoryBarrier>>(data);
  } else if (!info[8].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 9 'pBufferMemoryBarriers'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p9 = static_cast<uint32_t>(info[9].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageMemoryBarrier>> $p10 = nullptr;

  if (info[10].IsArray()) {

  {
    Napi::Array array = info[10].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageMemoryBarrier* result = Napi::ObjectWrap<_VkImageMemoryBarrier>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[10].As<Napi::Array>();
    std::vector<VkImageMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageMemoryBarrier* result = Napi::ObjectWrap<_VkImageMemoryBarrier>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p10 = std::make_shared<std::vector<VkImageMemoryBarrier>>(data);
  } else if (!info[10].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 11 'pImageMemoryBarriers'").ThrowAsJavaScriptException();
    return;
  }

vkCmdWaitEvents(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkEvent *) $p2.get()->data() : nullptr,
    static_cast<VkPipelineStageFlags>($p3),
    static_cast<VkPipelineStageFlags>($p4),
    $p5,
    $p6 ? (const VkMemoryBarrier *) $p6.get()->data() : nullptr,
    $p7,
    $p8 ? (const VkBufferMemoryBarrier *) $p8.get()->data() : nullptr,
    $p9,
    $p10 ? (const VkImageMemoryBarrier *) $p10.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdPipelineBarrier(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMemoryBarrier>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMemoryBarrier* result = Napi::ObjectWrap<_VkMemoryBarrier>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkMemoryBarrier* result = Napi::ObjectWrap<_VkMemoryBarrier>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkMemoryBarrier>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pMemoryBarriers'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferMemoryBarrier>> $p7 = nullptr;

  if (info[7].IsArray()) {

  {
    Napi::Array array = info[7].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferMemoryBarrier* result = Napi::ObjectWrap<_VkBufferMemoryBarrier>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[7].As<Napi::Array>();
    std::vector<VkBufferMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBufferMemoryBarrier* result = Napi::ObjectWrap<_VkBufferMemoryBarrier>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p7 = std::make_shared<std::vector<VkBufferMemoryBarrier>>(data);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 8 'pBufferMemoryBarriers'").ThrowAsJavaScriptException();
    return;
  }


  uint32_t $p8 = static_cast<uint32_t>(info[8].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageMemoryBarrier>> $p9 = nullptr;

  if (info[9].IsArray()) {

  {
    Napi::Array array = info[9].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageMemoryBarrier* result = Napi::ObjectWrap<_VkImageMemoryBarrier>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[9].As<Napi::Array>();
    std::vector<VkImageMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImageMemoryBarrier* result = Napi::ObjectWrap<_VkImageMemoryBarrier>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p9 = std::make_shared<std::vector<VkImageMemoryBarrier>>(data);
  } else if (!info[9].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 10 'pImageMemoryBarriers'").ThrowAsJavaScriptException();
    return;
  }

vkCmdPipelineBarrier(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkPipelineStageFlags>($p1),
    static_cast<VkPipelineStageFlags>($p2),
    static_cast<VkDependencyFlags>($p3),
    $p4,
    $p5 ? (const VkMemoryBarrier *) $p5.get()->data() : nullptr,
    $p6,
    $p7 ? (const VkBufferMemoryBarrier *) $p7.get()->data() : nullptr,
    $p8,
    $p9 ? (const VkImageMemoryBarrier *) $p9.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBeginQuery(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdBeginQuery(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    static_cast<VkQueryControlFlags>($p3)
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndQuery(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdEndQuery(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBeginConditionalRenderingEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkConditionalRenderingBeginInfoEXT* obj1;
  VkConditionalRenderingBeginInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkConditionalRenderingBeginInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkConditionalRenderingBeginInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkConditionalRenderingBeginInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pConditionalRenderingBegin'").ThrowAsJavaScriptException();
  }
$vkCmdBeginConditionalRenderingEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndConditionalRenderingEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }
$vkCmdEndConditionalRenderingEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

void _vkCmdResetQueryPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdResetQueryPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdWriteTimestamp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  _VkQueryPool* obj2;
  VkQueryPool *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkQueryPool]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdWriteTimestamp(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkPipelineStageFlagBits>($p1),
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdCopyQueryPoolResults(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  _VkBuffer* obj4;
  VkBuffer *$p4;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[4], "argument 5", "[object VkBuffer]");
      return;
    }
    obj4 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p4 = &obj4->instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'dstBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p5 = static_cast<uint64_t>(info[5].As<Napi::Number>().Int64Value());

  uint64_t $p6 = static_cast<uint64_t>(info[6].As<Napi::Number>().Int64Value());

  int32_t $p7 = static_cast<int32_t>(info[7].As<Napi::Number>().Int64Value());
vkCmdCopyQueryPoolResults(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    info[4].IsNull() ? VK_NULL_HANDLE : *$p4,
    $p5,
    $p6,
    static_cast<VkQueryResultFlags>($p7)
  );
  
  
  return env.Undefined();
  
};

void _vkCmdPushConstants(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkPipelineLayout* obj1;
  VkPipelineLayout *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayout::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineLayout]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'layout'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  void* $p5;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pValues'").ThrowAsJavaScriptException();
    return;
  }
vkCmdPushConstants(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkShaderStageFlags>($p2),
    $p3,
    $p4,
    info[5].IsNull() ? nullptr : $p5
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBeginRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkRenderPassBeginInfo* obj1;
  VkRenderPassBeginInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPassBeginInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkRenderPassBeginInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkRenderPassBeginInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pRenderPassBegin'").ThrowAsJavaScriptException();
  }

  VkSubpassContents $p2 = static_cast<VkSubpassContents>(info[2].As<Napi::Number>().Int64Value());
vkCmdBeginRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdNextSubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  VkSubpassContents $p1 = static_cast<VkSubpassContents>(info[1].As<Napi::Number>().Int64Value());
vkCmdNextSubpass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }
vkCmdEndRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

void _vkCmdExecuteCommands(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCommandBuffer>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCommandBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCommandBuffer* result = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCommandBuffers'").ThrowAsJavaScriptException();
    return;
  }

vkCmdExecuteCommands(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkCommandBuffer *) $p2.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceDisplayPropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayPropertiesKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPropertiesKHR* result = Napi::ObjectWrap<_VkDisplayPropertiesKHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayPropertiesKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPropertiesKHR* result = Napi::ObjectWrap<_VkDisplayPropertiesKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayPropertiesKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceDisplayPropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayPropertiesKHR *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayPropertiesKHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPropertiesKHR* result = Napi::ObjectWrap<_VkDisplayPropertiesKHR>::Unwrap(obj);
      VkDisplayPropertiesKHR *instance = &result->instance;
      VkDisplayPropertiesKHR *copy = &$pdata[ii];
      
      {
        std::string stri(copy->displayName);
        Napi::String str = Napi::String::New(env, stri);
        result->displayName.Reset(str.ToObject());
        strcpy(const_cast<char *>(instance->displayName), copy->displayName);
      }
      instance->physicalDimensions = copy->physicalDimensions;
      if (&copy->physicalDimensions != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkExtent2D::constructor.New(args);
        _VkExtent2D* unwrapped = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
        result->physicalDimensions.Reset(inst);
        unwrapped->instance = copy->physicalDimensions;
      }
      instance->physicalResolution = copy->physicalResolution;
      if (&copy->physicalResolution != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkExtent2D::constructor.New(args);
        _VkExtent2D* unwrapped = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
        result->physicalResolution.Reset(inst);
        unwrapped->instance = copy->physicalResolution;
      }
      instance->supportedTransforms = copy->supportedTransforms;
      instance->planeReorderPossible = copy->planeReorderPossible;
      instance->persistentContent = copy->persistentContent;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceDisplayPlanePropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayPlanePropertiesKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPlanePropertiesKHR* result = Napi::ObjectWrap<_VkDisplayPlanePropertiesKHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayPlanePropertiesKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPlanePropertiesKHR* result = Napi::ObjectWrap<_VkDisplayPlanePropertiesKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayPlanePropertiesKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayPlanePropertiesKHR *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayPlanePropertiesKHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPlanePropertiesKHR* result = Napi::ObjectWrap<_VkDisplayPlanePropertiesKHR>::Unwrap(obj);
      VkDisplayPlanePropertiesKHR *instance = &result->instance;
      VkDisplayPlanePropertiesKHR *copy = &$pdata[ii];
      
      instance->currentStackIndex = copy->currentStackIndex;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDisplayPlaneSupportedDisplaysKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDisplayCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayKHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDisplayKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayKHR* result = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkDisplayKHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pDisplays'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetDisplayPlaneSupportedDisplaysKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkDisplayKHR *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkDisplayKHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayKHR* target = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDisplayModePropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDisplayKHR* obj1;
  VkDisplayKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayModePropertiesKHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayModePropertiesKHR* result = Napi::ObjectWrap<_VkDisplayModePropertiesKHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDisplayModePropertiesKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayModePropertiesKHR* result = Napi::ObjectWrap<_VkDisplayModePropertiesKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkDisplayModePropertiesKHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetDisplayModePropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkDisplayModePropertiesKHR *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkDisplayModePropertiesKHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayModePropertiesKHR* result = Napi::ObjectWrap<_VkDisplayModePropertiesKHR>::Unwrap(obj);
      VkDisplayModePropertiesKHR *instance = &result->instance;
      VkDisplayModePropertiesKHR *copy = &$pdata[ii];
      
      instance->parameters = copy->parameters;
      if (&copy->parameters != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkDisplayModeParametersKHR::constructor.New(args);
        _VkDisplayModeParametersKHR* unwrapped = Napi::ObjectWrap<_VkDisplayModeParametersKHR>::Unwrap(inst);
        result->parameters.Reset(inst);
        unwrapped->instance = copy->parameters;
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateDisplayModeKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDisplayKHR* obj1;
  VkDisplayKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
  }

  _VkDisplayModeCreateInfoKHR* obj2;
  VkDisplayModeCreateInfoKHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayModeCreateInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDisplayModeCreateInfoKHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDisplayModeCreateInfoKHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDisplayModeKHR* obj4;
  VkDisplayModeKHR *$p4;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayModeKHR::constructor.Value()))) {
      NanObjectTypeError(info[4], "argument 5", "[object VkDisplayModeKHR]");
      return;
    }
    obj4 = Napi::ObjectWrap<_VkDisplayModeKHR>::Unwrap(obj);
    
    $p4 = &obj4->instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pMode'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateDisplayModeKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    nullptr,
    $p4
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDisplayPlaneCapabilitiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDisplayModeKHR* obj1;
  VkDisplayModeKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayModeKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayModeKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayModeKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'mode'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  _VkDisplayPlaneCapabilitiesKHR* obj3;
  VkDisplayPlaneCapabilitiesKHR *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayPlaneCapabilitiesKHR::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDisplayPlaneCapabilitiesKHR]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDisplayPlaneCapabilitiesKHR>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pCapabilities'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetDisplayPlaneCapabilitiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 6 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    obj3->minSrcPosition.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.minSrcPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 6 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    obj3->maxSrcPosition.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.maxSrcPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj3->minSrcExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.minSrcExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj3->maxSrcExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.maxSrcExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 6 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    obj3->minDstPosition.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.minDstPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 6 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    obj3->maxDstPosition.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.maxDstPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj3->minDstExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.minDstExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj3->maxDstExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj3->instance.maxDstExtent, sizeof(VkExtent2D));
    
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateDisplayPlaneSurfaceKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkDisplaySurfaceCreateInfoKHR* obj1;
  VkDisplaySurfaceCreateInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplaySurfaceCreateInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplaySurfaceCreateInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplaySurfaceCreateInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkSurfaceKHR* obj3;
  VkSurfaceKHR *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSurfaceKHR]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSurface'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateDisplayPlaneSurfaceKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateSharedSwapchainsKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkSwapchainCreateInfoKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSwapchainCreateInfoKHR* result = Napi::ObjectWrap<_VkSwapchainCreateInfoKHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkSwapchainCreateInfoKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSwapchainCreateInfoKHR* result = Napi::ObjectWrap<_VkSwapchainCreateInfoKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkSwapchainCreateInfoKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCreateInfos'").ThrowAsJavaScriptException();
    return;
  }



  std::shared_ptr<std::vector<VkSwapchainKHR>> $p4 = nullptr;

  if (info[4].IsArray()) {

    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkSwapchainKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSwapchainKHR* result = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p4 = std::make_shared<std::vector<VkSwapchainKHR>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pSwapchains'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkCreateSharedSwapchainsKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkSwapchainCreateInfoKHR *) $p2.get()->data() : nullptr,
    nullptr,
    $p4 ? (VkSwapchainKHR *) $p4.get()->data() : nullptr
  );
  if (info[4].IsArray()) {
    VkSwapchainKHR* $pdata = $p4.get()->data();
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSwapchainKHR* target = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroySurfaceKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

$vkDestroySurfaceKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceSurfaceSupportKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  _VkSurfaceKHR* obj2;
  VkSurfaceKHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkSurfaceKHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'surface'").ThrowAsJavaScriptException();
  }

  Napi::Object obj3;
  uint32_t $p3;
  if (info[3].IsObject()) {
    obj3 = info[3].As<Napi::Object>();
    if (!obj3.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 4").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSupported'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceSupportKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    &$p3
  );
    obj3.Set("$", $p3);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceSurfaceCapabilitiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

  _VkSurfaceCapabilitiesKHR* obj2;
  VkSurfaceCapabilitiesKHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceCapabilitiesKHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkSurfaceCapabilitiesKHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkSurfaceCapabilitiesKHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceCapabilities'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->currentExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->minImageExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->maxImageExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceSurfaceFormatsKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceFormatCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkSurfaceFormatKHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSurfaceFormatKHR* result = Napi::ObjectWrap<_VkSurfaceFormatKHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSurfaceFormatKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSurfaceFormatKHR* result = Napi::ObjectWrap<_VkSurfaceFormatKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkSurfaceFormatKHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSurfaceFormats'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceSurfaceFormatsKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkSurfaceFormatKHR *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSurfaceFormatKHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSurfaceFormatKHR* result = Napi::ObjectWrap<_VkSurfaceFormatKHR>::Unwrap(obj);
      VkSurfaceFormatKHR *instance = &result->instance;
      VkSurfaceFormatKHR *copy = &$pdata[ii];
      
      instance->format = copy->format;
      instance->colorSpace = copy->colorSpace;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceSurfacePresentModesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPresentModeCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<int32_t*> $p3 = nullptr;

  if (info[3].IsTypedArray()) {

    if (info[3].As<Napi::TypedArray>().TypedArrayType() != napi_int32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 4 'pPresentModes'").ThrowAsJavaScriptException();
      return;
    }
    int32_t* data = getTypedArrayData<int32_t>(info[3]);
    $p3 = std::make_shared<int32_t*>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pPresentModes'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceSurfacePresentModesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkPresentModeKHR *) *$p3.get() : nullptr
  );
    obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateSwapchainKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainCreateInfoKHR* obj1;
  VkSwapchainCreateInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainCreateInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainCreateInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainCreateInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkSwapchainKHR* obj3;
  VkSwapchainKHR *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSwapchainKHR]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSwapchain'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateSwapchainKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroySwapchainKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }

$vkDestroySwapchainKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetSwapchainImagesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSwapchainImageCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkImage>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkImage> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImage* result = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkImage>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSwapchainImages'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetSwapchainImagesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkImage *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkImage* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkImage* target = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkAcquireNextImageKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSemaphore::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSemaphore]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSemaphore>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'semaphore'").ThrowAsJavaScriptException();
  }

  _VkFence* obj4;
  VkFence *$p4;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[4], "argument 5", "[object VkFence]");
      return;
    }
    obj4 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p4 = &obj4->instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'fence'").ThrowAsJavaScriptException();
  }

  Napi::Object obj5;
  uint32_t $p5;
  if (info[5].IsObject()) {
    obj5 = info[5].As<Napi::Object>();
    if (!obj5.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 6").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 6 'pImageIndex'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkAcquireNextImageKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    info[4].IsNull() ? VK_NULL_HANDLE : *$p4,
    &$p5
  );
    obj5.Set("$", $p5);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkQueuePresentKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }

  _VkPresentInfoKHR* obj1;
  VkPresentInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPresentInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPresentInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPresentInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPresentInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkQueuePresentKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateWin32SurfaceKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkWin32SurfaceCreateInfoKHR* obj1;
  VkWin32SurfaceCreateInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkWin32SurfaceCreateInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkWin32SurfaceCreateInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkWin32SurfaceCreateInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkSurfaceKHR* obj3;
  VkSurfaceKHR *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSurfaceKHR]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSurface'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateWin32SurfaceKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceWin32PresentationSupportKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  uint32_t out = $vkGetPhysicalDeviceWin32PresentationSupportKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateDebugReportCallbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkDebugReportCallbackCreateInfoEXT* obj1;
  VkDebugReportCallbackCreateInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugReportCallbackCreateInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugReportCallbackCreateInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugReportCallbackCreateInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDebugReportCallbackEXT* obj3;
  VkDebugReportCallbackEXT *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugReportCallbackEXT::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDebugReportCallbackEXT]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDebugReportCallbackEXT>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pCallback'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateDebugReportCallbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyDebugReportCallbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkDebugReportCallbackEXT* obj1;
  VkDebugReportCallbackEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugReportCallbackEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugReportCallbackEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugReportCallbackEXT>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'callback'").ThrowAsJavaScriptException();
  }

$vkDestroyDebugReportCallbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkDebugReportMessageEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  VkDebugReportObjectTypeEXT $p2 = static_cast<VkDebugReportObjectTypeEXT>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  size_t $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());

  int32_t $p5 = static_cast<int32_t>(info[5].As<Napi::Number>().Int64Value());

  char* $p6;
  if (info[6].IsString()) {
    $p6 = copyV8String(info[6]);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 7 'pLayerPrefix'").ThrowAsJavaScriptException();
    return;
  }

  char* $p7;
  if (info[7].IsString()) {
    $p7 = copyV8String(info[7]);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 8 'pMessage'").ThrowAsJavaScriptException();
    return;
  }
$vkDebugReportMessageEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkDebugReportFlagsEXT>($p1),
    $p2,
    $p3,
    $p4,
    $p5,
    $p6,
    $p7
  );
  
  
  return env.Undefined();
  
};

void _vkDebugMarkerSetObjectNameEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDebugMarkerObjectNameInfoEXT* obj1;
  VkDebugMarkerObjectNameInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugMarkerObjectNameInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerObjectNameInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugMarkerObjectNameInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pNameInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkDebugMarkerSetObjectNameEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDebugMarkerSetObjectTagEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDebugMarkerObjectTagInfoEXT* obj1;
  VkDebugMarkerObjectTagInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugMarkerObjectTagInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerObjectTagInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugMarkerObjectTagInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pTagInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkDebugMarkerSetObjectTagEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdDebugMarkerBeginEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkDebugMarkerMarkerInfoEXT* obj1;
  VkDebugMarkerMarkerInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugMarkerMarkerInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerMarkerInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugMarkerMarkerInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pMarkerInfo'").ThrowAsJavaScriptException();
  }
$vkCmdDebugMarkerBeginEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDebugMarkerEndEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }
$vkCmdDebugMarkerEndEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDebugMarkerInsertEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkDebugMarkerMarkerInfoEXT* obj1;
  VkDebugMarkerMarkerInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugMarkerMarkerInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerMarkerInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugMarkerMarkerInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pMarkerInfo'").ThrowAsJavaScriptException();
  }
$vkCmdDebugMarkerInsertEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceExternalImageFormatPropertiesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  VkImageType $p2 = static_cast<VkImageType>(info[2].As<Napi::Number>().Int64Value());

  VkImageTiling $p3 = static_cast<VkImageTiling>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  int32_t $p5 = static_cast<int32_t>(info[5].As<Napi::Number>().Int64Value());

  int32_t $p6 = static_cast<int32_t>(info[6].As<Napi::Number>().Int64Value());

  _VkExternalImageFormatPropertiesNV* obj7;
  VkExternalImageFormatPropertiesNV *$p7;
  if (info[7].IsObject()) {
    Napi::Object obj = info[7].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkExternalImageFormatPropertiesNV::constructor.Value()))) {
      NanObjectTypeError(info[7], "argument 8", "[object VkExternalImageFormatPropertiesNV]");
      return;
    }
    obj7 = Napi::ObjectWrap<_VkExternalImageFormatPropertiesNV>::Unwrap(obj);
    if (!obj7->flush()) return;
    $p7 = &obj7->instance;
  } else if (info[7].IsNull()) {
    $p7 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 8 'pExternalImageFormatProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    static_cast<VkImageUsageFlags>($p4),
    static_cast<VkImageCreateFlags>($p5),
    static_cast<VkExternalMemoryHandleTypeFlagsNV>($p6),
    $p7
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkImageFormatProperties::constructor.New(args);
    _VkImageFormatProperties* 6 = Napi::ObjectWrap<_VkImageFormatProperties>::Unwrap(inst);
    obj7->imageFormatProperties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj7->instance.imageFormatProperties, sizeof(VkImageFormatProperties));
    
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent3D::constructor.New(args);
    _VkExtent3D* 12 = Napi::ObjectWrap<_VkExtent3D>::Unwrap(inst);
    unwrapped6->maxExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxExtent, sizeof(VkExtent3D));
    
  }
      
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetMemoryWin32HandleNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceMemory::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceMemory>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t out = $vkGetMemoryWin32HandleNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkExternalMemoryHandleTypeFlagsNV>($p2),
nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdDrawIndirectCountAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndirectCountAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndexedIndirectCountAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndexedIndirectCountAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkCmdProcessCommandsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkCmdProcessCommandsInfoNVX* obj1;
  VkCmdProcessCommandsInfoNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCmdProcessCommandsInfoNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCmdProcessCommandsInfoNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCmdProcessCommandsInfoNVX>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pProcessCommandsInfo'").ThrowAsJavaScriptException();
  }
$vkCmdProcessCommandsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdReserveSpaceForCommandsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkCmdReserveSpaceForCommandsInfoNVX* obj1;
  VkCmdReserveSpaceForCommandsInfoNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCmdReserveSpaceForCommandsInfoNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCmdReserveSpaceForCommandsInfoNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCmdReserveSpaceForCommandsInfoNVX>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pReserveSpaceInfo'").ThrowAsJavaScriptException();
  }
$vkCmdReserveSpaceForCommandsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCreateIndirectCommandsLayoutNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkIndirectCommandsLayoutCreateInfoNVX* obj1;
  VkIndirectCommandsLayoutCreateInfoNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkIndirectCommandsLayoutCreateInfoNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkIndirectCommandsLayoutCreateInfoNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkIndirectCommandsLayoutCreateInfoNVX>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkIndirectCommandsLayoutNVX* obj3;
  VkIndirectCommandsLayoutNVX *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkIndirectCommandsLayoutNVX::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkIndirectCommandsLayoutNVX]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkIndirectCommandsLayoutNVX>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pIndirectCommandsLayout'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateIndirectCommandsLayoutNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyIndirectCommandsLayoutNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkIndirectCommandsLayoutNVX* obj1;
  VkIndirectCommandsLayoutNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkIndirectCommandsLayoutNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkIndirectCommandsLayoutNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkIndirectCommandsLayoutNVX>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'indirectCommandsLayout'").ThrowAsJavaScriptException();
  }

$vkDestroyIndirectCommandsLayoutNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCreateObjectTableNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkObjectTableCreateInfoNVX* obj1;
  VkObjectTableCreateInfoNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkObjectTableCreateInfoNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkObjectTableCreateInfoNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkObjectTableCreateInfoNVX>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkObjectTableNVX* obj3;
  VkObjectTableNVX *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkObjectTableNVX::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkObjectTableNVX]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkObjectTableNVX>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pObjectTable'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateObjectTableNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyObjectTableNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkObjectTableNVX* obj1;
  VkObjectTableNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkObjectTableNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkObjectTableNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkObjectTableNVX>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'objectTable'").ThrowAsJavaScriptException();
  }

$vkDestroyObjectTableNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkRegisterObjectsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkObjectTableNVX* obj1;
  VkObjectTableNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkObjectTableNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkObjectTableNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkObjectTableNVX>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'objectTable'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkObjectTableEntryNVX>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkObjectTableEntryNVX* result = Napi::ObjectWrap<_VkObjectTableEntryNVX>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkObjectTableEntryNVX> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkObjectTableEntryNVX* result = Napi::ObjectWrap<_VkObjectTableEntryNVX>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkObjectTableEntryNVX>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'ppObjectTableEntries'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint32_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_uint32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
      return;
    }
    uint32_t* data = getTypedArrayData<uint32_t>(info[4]);
    $p4 = std::make_shared<uint32_t*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkRegisterObjectsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkObjectTableEntryNVX * const*) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkUnregisterObjectsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkObjectTableNVX* obj1;
  VkObjectTableNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkObjectTableNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkObjectTableNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkObjectTableNVX>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'objectTable'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<int32_t*> $p3 = nullptr;

  if (info[3].IsTypedArray()) {

    if (info[3].As<Napi::TypedArray>().TypedArrayType() != napi_int32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 4 'pObjectEntryTypes'").ThrowAsJavaScriptException();
      return;
    }
    int32_t* data = getTypedArrayData<int32_t>(info[3]);
    $p3 = std::make_shared<int32_t*>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pObjectEntryTypes'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint32_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_uint32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
      return;
    }
    uint32_t* data = getTypedArrayData<uint32_t>(info[4]);
    $p4 = std::make_shared<uint32_t*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkUnregisterObjectsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (VkObjectEntryTypeNVX *) *$p3.get() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDeviceGeneratedCommandsFeaturesNVX* obj1;
  VkDeviceGeneratedCommandsFeaturesNVX *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceGeneratedCommandsFeaturesNVX::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceGeneratedCommandsFeaturesNVX]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceGeneratedCommandsFeaturesNVX>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pFeatures'").ThrowAsJavaScriptException();
  }

  _VkDeviceGeneratedCommandsLimitsNVX* obj2;
  VkDeviceGeneratedCommandsLimitsNVX *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceGeneratedCommandsLimitsNVX::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDeviceGeneratedCommandsLimitsNVX]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDeviceGeneratedCommandsLimitsNVX>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pLimits'").ThrowAsJavaScriptException();
  }
$vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceFeatures2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceFeatures2* obj1;
  VkPhysicalDeviceFeatures2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceFeatures2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceFeatures2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceFeatures2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pFeatures'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceFeatures2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceFeatures::constructor.New(args);
    _VkPhysicalDeviceFeatures* 6 = Napi::ObjectWrap<_VkPhysicalDeviceFeatures>::Unwrap(inst);
    obj1->features.Reset(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.features, sizeof(VkPhysicalDeviceFeatures));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceProperties2* obj1;
  VkPhysicalDeviceProperties2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceProperties2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceProperties2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceProperties2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceProperties::constructor.New(args);
    _VkPhysicalDeviceProperties* 6 = Napi::ObjectWrap<_VkPhysicalDeviceProperties>::Unwrap(inst);
    obj1->properties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.properties, sizeof(VkPhysicalDeviceProperties));
    
  {
    // back reflect string
    Napi::String str1 = Napi::String::New(env, (&unwrapped6->instance)->deviceName);
    unwrapped6->deviceName.Reset(str1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 16);
    // populate array
    for (unsigned int ii = 0; ii < 16; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped6->instance)->pipelineCacheUUID[ii]));
    };
    unwrapped6->pipelineCacheUUID.Reset(arr1);
  }
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceLimits::constructor.New(args);
    _VkPhysicalDeviceLimits* 12 = Napi::ObjectWrap<_VkPhysicalDeviceLimits>::Unwrap(inst);
    unwrapped6->limits.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.limits, sizeof(VkPhysicalDeviceLimits));
    
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped12->instance)->maxComputeWorkGroupCount[ii]));
    };
    unwrapped12->maxComputeWorkGroupCount.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped12->instance)->maxComputeWorkGroupSize[ii]));
    };
    unwrapped12->maxComputeWorkGroupSize.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped12->instance)->maxViewportDimensions[ii]));
    };
    unwrapped12->maxViewportDimensions.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped12->instance)->viewportBoundsRange[ii]));
    };
    unwrapped12->viewportBoundsRange.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped12->instance)->pointSizeRange[ii]));
    };
    unwrapped12->pointSizeRange.Reset(arr1);
  }
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&unwrapped12->instance)->lineWidthRange[ii]));
    };
    unwrapped12->lineWidthRange.Reset(arr1);
  }
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceSparseProperties::constructor.New(args);
    _VkPhysicalDeviceSparseProperties* 12 = Napi::ObjectWrap<_VkPhysicalDeviceSparseProperties>::Unwrap(inst);
    unwrapped6->sparseProperties.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.sparseProperties, sizeof(VkPhysicalDeviceSparseProperties));
    
  }
      
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceFormatProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  _VkFormatProperties2* obj2;
  VkFormatProperties2 *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFormatProperties2::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkFormatProperties2]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkFormatProperties2>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFormatProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceFormatProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkFormatProperties::constructor.New(args);
    _VkFormatProperties* 6 = Napi::ObjectWrap<_VkFormatProperties>::Unwrap(inst);
    obj2->formatProperties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.formatProperties, sizeof(VkFormatProperties));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceImageFormatProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceImageFormatInfo2* obj1;
  VkPhysicalDeviceImageFormatInfo2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceImageFormatInfo2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceImageFormatInfo2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceImageFormatInfo2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pImageFormatInfo'").ThrowAsJavaScriptException();
  }

  _VkImageFormatProperties2* obj2;
  VkImageFormatProperties2 *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageFormatProperties2::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkImageFormatProperties2]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkImageFormatProperties2>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pImageFormatProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = vkGetPhysicalDeviceImageFormatProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkImageFormatProperties::constructor.New(args);
    _VkImageFormatProperties* 6 = Napi::ObjectWrap<_VkImageFormatProperties>::Unwrap(inst);
    obj2->imageFormatProperties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.imageFormatProperties, sizeof(VkImageFormatProperties));
    
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent3D::constructor.New(args);
    _VkExtent3D* 12 = Napi::ObjectWrap<_VkExtent3D>::Unwrap(inst);
    unwrapped6->maxExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxExtent, sizeof(VkExtent3D));
    
  }
      
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pQueueFamilyPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkQueueFamilyProperties2>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkQueueFamilyProperties2* result = Napi::ObjectWrap<_VkQueueFamilyProperties2>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkQueueFamilyProperties2> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkQueueFamilyProperties2* result = Napi::ObjectWrap<_VkQueueFamilyProperties2>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkQueueFamilyProperties2>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pQueueFamilyProperties'").ThrowAsJavaScriptException();
    return;
  }

vkGetPhysicalDeviceQueueFamilyProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkQueueFamilyProperties2 *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkQueueFamilyProperties2* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkQueueFamilyProperties2* result = Napi::ObjectWrap<_VkQueueFamilyProperties2>::Unwrap(obj);
      VkQueueFamilyProperties2 *instance = &result->instance;
      VkQueueFamilyProperties2 *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->queueFamilyProperties = copy->queueFamilyProperties;
      if (&copy->queueFamilyProperties != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkQueueFamilyProperties::constructor.New(args);
        _VkQueueFamilyProperties* unwrapped = Napi::ObjectWrap<_VkQueueFamilyProperties>::Unwrap(inst);
        result->queueFamilyProperties.Reset(inst);
        unwrapped->instance = copy->queueFamilyProperties;
      }
    };
  }
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceMemoryProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceMemoryProperties2* obj1;
  VkPhysicalDeviceMemoryProperties2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceMemoryProperties2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceMemoryProperties2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceMemoryProperties2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pMemoryProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceMemoryProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkPhysicalDeviceMemoryProperties::constructor.New(args);
    _VkPhysicalDeviceMemoryProperties* 6 = Napi::ObjectWrap<_VkPhysicalDeviceMemoryProperties>::Unwrap(inst);
    obj1->memoryProperties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.memoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
    
  {
    // back reflect array
    unsigned int len = unwrapped6->instance.memoryTypeCount;
    Napi::Array arr = Napi::Array::New(env, len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      Napi::Object inst = _VkMemoryType::constructor.New(args);
      _VkMemoryType* unwrapped = Napi::ObjectWrap<_VkMemoryType>::Unwrap(inst);
      memcpy(&unwrapped->instance, &unwrapped6->instance.memoryTypes[ii], sizeof(VkMemoryType));
      arr.Set(ii, inst);
    };
    unwrapped6->memoryTypes.Reset(arr);
  }
  {
    // back reflect array
    unsigned int len = unwrapped6->instance.memoryHeapCount;
    Napi::Array arr = Napi::Array::New(env, len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      Napi::Object inst = _VkMemoryHeap::constructor.New(args);
      _VkMemoryHeap* unwrapped = Napi::ObjectWrap<_VkMemoryHeap>::Unwrap(inst);
      memcpy(&unwrapped->instance, &unwrapped6->instance.memoryHeaps[ii], sizeof(VkMemoryHeap));
      arr.Set(ii, inst);
    };
    unwrapped6->memoryHeaps.Reset(arr);
  }
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceSparseImageFormatProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceSparseImageFormatInfo2* obj1;
  VkPhysicalDeviceSparseImageFormatInfo2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceSparseImageFormatInfo2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceSparseImageFormatInfo2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceSparseImageFormatInfo2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pFormatInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkSparseImageFormatProperties2>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageFormatProperties2* result = Napi::ObjectWrap<_VkSparseImageFormatProperties2>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSparseImageFormatProperties2> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageFormatProperties2* result = Napi::ObjectWrap<_VkSparseImageFormatProperties2>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkSparseImageFormatProperties2>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

vkGetPhysicalDeviceSparseImageFormatProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkSparseImageFormatProperties2 *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSparseImageFormatProperties2* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageFormatProperties2* result = Napi::ObjectWrap<_VkSparseImageFormatProperties2>::Unwrap(obj);
      VkSparseImageFormatProperties2 *instance = &result->instance;
      VkSparseImageFormatProperties2 *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->properties = copy->properties;
      if (&copy->properties != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkSparseImageFormatProperties::constructor.New(args);
        _VkSparseImageFormatProperties* unwrapped = Napi::ObjectWrap<_VkSparseImageFormatProperties>::Unwrap(inst);
        result->properties.Reset(inst);
        unwrapped->instance = copy->properties;
      }
    };
  }
  
  
  return env.Undefined();
  
};

void _vkCmdPushDescriptorSetKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1].As<Napi::Number>().Int64Value());

  _VkPipelineLayout* obj2;
  VkPipelineLayout *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayout::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkPipelineLayout]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'layout'").ThrowAsJavaScriptException();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkWriteDescriptorSet>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkWriteDescriptorSet* result = Napi::ObjectWrap<_VkWriteDescriptorSet>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkWriteDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkWriteDescriptorSet* result = Napi::ObjectWrap<_VkWriteDescriptorSet>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkWriteDescriptorSet>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pDescriptorWrites'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdPushDescriptorSetKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? (const VkWriteDescriptorSet *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkTrimCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkCommandPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
vkTrimCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkCommandPoolTrimFlags>($p2)
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceExternalBufferProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceExternalBufferInfo* obj1;
  VkPhysicalDeviceExternalBufferInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceExternalBufferInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceExternalBufferInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceExternalBufferInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pExternalBufferInfo'").ThrowAsJavaScriptException();
  }

  _VkExternalBufferProperties* obj2;
  VkExternalBufferProperties *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkExternalBufferProperties::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkExternalBufferProperties]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkExternalBufferProperties>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pExternalBufferProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceExternalBufferProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExternalMemoryProperties::constructor.New(args);
    _VkExternalMemoryProperties* 6 = Napi::ObjectWrap<_VkExternalMemoryProperties>::Unwrap(inst);
    obj2->externalMemoryProperties.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.externalMemoryProperties, sizeof(VkExternalMemoryProperties));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetMemoryWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkMemoryGetWin32HandleInfoKHR* obj1;
  VkMemoryGetWin32HandleInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryGetWin32HandleInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkMemoryGetWin32HandleInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkMemoryGetWin32HandleInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pGetWin32HandleInfo'").ThrowAsJavaScriptException();
  }

  int32_t out = $vkGetMemoryWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetMemoryWin32HandlePropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());


  _VkMemoryWin32HandlePropertiesKHR* obj3;
  VkMemoryWin32HandlePropertiesKHR *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryWin32HandlePropertiesKHR::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkMemoryWin32HandlePropertiesKHR]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkMemoryWin32HandlePropertiesKHR>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pMemoryWin32HandleProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetMemoryWin32HandlePropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkExternalMemoryHandleTypeFlagBits>($p1),
nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetMemoryFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkMemoryGetFdInfoKHR* obj1;
  VkMemoryGetFdInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryGetFdInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkMemoryGetFdInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkMemoryGetFdInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pGetFdInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  int $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<int>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFd'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetMemoryFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetMemoryFdPropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  int $p2 = static_cast<int>(info[2].As<Napi::Number>().Int64Value());

  _VkMemoryFdPropertiesKHR* obj3;
  VkMemoryFdPropertiesKHR *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryFdPropertiesKHR::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkMemoryFdPropertiesKHR]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkMemoryFdPropertiesKHR>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pMemoryFdProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetMemoryFdPropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkExternalMemoryHandleTypeFlagBits>($p1),
    $p2,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceExternalSemaphoreProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceExternalSemaphoreInfo* obj1;
  VkPhysicalDeviceExternalSemaphoreInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceExternalSemaphoreInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceExternalSemaphoreInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceExternalSemaphoreInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pExternalSemaphoreInfo'").ThrowAsJavaScriptException();
  }

  _VkExternalSemaphoreProperties* obj2;
  VkExternalSemaphoreProperties *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkExternalSemaphoreProperties::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkExternalSemaphoreProperties]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkExternalSemaphoreProperties>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pExternalSemaphoreProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceExternalSemaphoreProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkGetSemaphoreWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSemaphoreGetWin32HandleInfoKHR* obj1;
  VkSemaphoreGetWin32HandleInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSemaphoreGetWin32HandleInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSemaphoreGetWin32HandleInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSemaphoreGetWin32HandleInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pGetWin32HandleInfo'").ThrowAsJavaScriptException();
  }

  int32_t out = $vkGetSemaphoreWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkImportSemaphoreWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImportSemaphoreWin32HandleInfoKHR* obj1;
  VkImportSemaphoreWin32HandleInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImportSemaphoreWin32HandleInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImportSemaphoreWin32HandleInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImportSemaphoreWin32HandleInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pImportSemaphoreWin32HandleInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkImportSemaphoreWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetSemaphoreFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSemaphoreGetFdInfoKHR* obj1;
  VkSemaphoreGetFdInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSemaphoreGetFdInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSemaphoreGetFdInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSemaphoreGetFdInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pGetFdInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  int $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<int>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFd'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetSemaphoreFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkImportSemaphoreFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImportSemaphoreFdInfoKHR* obj1;
  VkImportSemaphoreFdInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImportSemaphoreFdInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImportSemaphoreFdInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImportSemaphoreFdInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pImportSemaphoreFdInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkImportSemaphoreFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceExternalFenceProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceExternalFenceInfo* obj1;
  VkPhysicalDeviceExternalFenceInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceExternalFenceInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceExternalFenceInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceExternalFenceInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pExternalFenceInfo'").ThrowAsJavaScriptException();
  }

  _VkExternalFenceProperties* obj2;
  VkExternalFenceProperties *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkExternalFenceProperties::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkExternalFenceProperties]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkExternalFenceProperties>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pExternalFenceProperties'").ThrowAsJavaScriptException();
  }
vkGetPhysicalDeviceExternalFenceProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkGetFenceWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFenceGetWin32HandleInfoKHR* obj1;
  VkFenceGetWin32HandleInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFenceGetWin32HandleInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFenceGetWin32HandleInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFenceGetWin32HandleInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pGetWin32HandleInfo'").ThrowAsJavaScriptException();
  }

  int32_t out = $vkGetFenceWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkImportFenceWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImportFenceWin32HandleInfoKHR* obj1;
  VkImportFenceWin32HandleInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImportFenceWin32HandleInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImportFenceWin32HandleInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImportFenceWin32HandleInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pImportFenceWin32HandleInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkImportFenceWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetFenceFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkFenceGetFdInfoKHR* obj1;
  VkFenceGetFdInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFenceGetFdInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkFenceGetFdInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkFenceGetFdInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pGetFdInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  int $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<int>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFd'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetFenceFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkImportFenceFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImportFenceFdInfoKHR* obj1;
  VkImportFenceFdInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImportFenceFdInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImportFenceFdInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImportFenceFdInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pImportFenceFdInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkImportFenceFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkReleaseDisplayEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDisplayKHR* obj1;
  VkDisplayKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkReleaseDisplayEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDisplayPowerControlEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDisplayKHR* obj1;
  VkDisplayKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
  }

  _VkDisplayPowerInfoEXT* obj2;
  VkDisplayPowerInfoEXT *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayPowerInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDisplayPowerInfoEXT]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDisplayPowerInfoEXT>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDisplayPowerInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkDisplayPowerControlEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkRegisterDeviceEventEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceEventInfoEXT* obj1;
  VkDeviceEventInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceEventInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceEventInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceEventInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pDeviceEventInfo'").ThrowAsJavaScriptException();
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pFence'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkRegisterDeviceEventEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkRegisterDisplayEventEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDisplayKHR* obj1;
  VkDisplayKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
  }

  _VkDisplayEventInfoEXT* obj2;
  VkDisplayEventInfoEXT *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayEventInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDisplayEventInfoEXT]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDisplayEventInfoEXT>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDisplayEventInfo'").ThrowAsJavaScriptException();
  }


  _VkFence* obj4;
  VkFence *$p4;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkFence::constructor.Value()))) {
      NanObjectTypeError(info[4], "argument 5", "[object VkFence]");
      return;
    }
    obj4 = Napi::ObjectWrap<_VkFence>::Unwrap(obj);
    
    $p4 = &obj4->instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pFence'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkRegisterDisplayEventEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    nullptr,
    $p4
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetSwapchainCounterEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  uint64_t $p3;
  if (info[3].IsObject()) {
    obj3 = info[3].As<Napi::Object>();
    if (!obj3.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 4").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pCounterValue'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetSwapchainCounterEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkSurfaceCounterFlagBitsEXT>($p2),
    &$p3
  );
    Napi::BigInt pnum3 = Napi::BigInt::New(env, (uint64_t)$p3);
    obj3.Set("$", pnum3);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceSurfaceCapabilities2EXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

  _VkSurfaceCapabilities2EXT* obj2;
  VkSurfaceCapabilities2EXT *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceCapabilities2EXT::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkSurfaceCapabilities2EXT]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkSurfaceCapabilities2EXT>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceCapabilities'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->currentExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->minImageExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->maxImageExtent.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkEnumeratePhysicalDeviceGroups(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPhysicalDeviceGroupCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkPhysicalDeviceGroupProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPhysicalDeviceGroupProperties* result = Napi::ObjectWrap<_VkPhysicalDeviceGroupProperties>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkPhysicalDeviceGroupProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPhysicalDeviceGroupProperties* result = Napi::ObjectWrap<_VkPhysicalDeviceGroupProperties>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkPhysicalDeviceGroupProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pPhysicalDeviceGroupProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkEnumeratePhysicalDeviceGroups(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkPhysicalDeviceGroupProperties *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkPhysicalDeviceGroupProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPhysicalDeviceGroupProperties* result = Napi::ObjectWrap<_VkPhysicalDeviceGroupProperties>::Unwrap(obj);
      VkPhysicalDeviceGroupProperties *instance = &result->instance;
      VkPhysicalDeviceGroupProperties *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->physicalDeviceCount = copy->physicalDeviceCount;
      instance->subsetAllocation = copy->subsetAllocation;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDeviceGroupPeerMemoryFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  Napi::Object obj4;
  int32_t $p4;
  if (info[4].IsObject()) {
    obj4 = info[4].As<Napi::Object>();
    if (!obj4.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 5").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pPeerMemoryFeatures'").ThrowAsJavaScriptException();
    return;
  }
vkGetDeviceGroupPeerMemoryFeatures(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    reinterpret_cast<VkPeerMemoryFeatureFlags *>(&$p4)
  );
    obj4.Set("$", $p4);
  
  
  return env.Undefined();
  
};

void _vkBindBufferMemory2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindBufferMemoryInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindBufferMemoryInfo* result = Napi::ObjectWrap<_VkBindBufferMemoryInfo>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindBufferMemoryInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindBufferMemoryInfo* result = Napi::ObjectWrap<_VkBindBufferMemoryInfo>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkBindBufferMemoryInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfos'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkBindBufferMemory2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindBufferMemoryInfo *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkBindImageMemory2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindImageMemoryInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindImageMemoryInfo* result = Napi::ObjectWrap<_VkBindImageMemoryInfo>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindImageMemoryInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindImageMemoryInfo* result = Napi::ObjectWrap<_VkBindImageMemoryInfo>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkBindImageMemoryInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfos'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = vkBindImageMemory2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindImageMemoryInfo *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdSetDeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
vkCmdSetDeviceMask(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkGetDeviceGroupPresentCapabilitiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceGroupPresentCapabilitiesKHR* obj1;
  VkDeviceGroupPresentCapabilitiesKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceGroupPresentCapabilitiesKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceGroupPresentCapabilitiesKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceGroupPresentCapabilitiesKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pDeviceGroupPresentCapabilities'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetDeviceGroupPresentCapabilitiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect array
    Napi::Array arr1 = Napi::Array::New(env, 32);
    // populate array
    for (unsigned int ii = 0; ii < 32; ++ii) {
      arr1.Set(ii, Napi::Number::New(env, (&obj1->instance)->presentMask[ii]));
    };
    obj1->presentMask.Reset(arr1);
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDeviceGroupSurfacePresentModesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  int32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pModes'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetDeviceGroupSurfacePresentModesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    reinterpret_cast<VkDeviceGroupPresentModeFlagsKHR *>(&$p2)
  );
    obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkAcquireNextImage2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkAcquireNextImageInfoKHR* obj1;
  VkAcquireNextImageInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAcquireNextImageInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAcquireNextImageInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAcquireNextImageInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pAcquireInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pImageIndex'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkAcquireNextImage2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdDispatchBase(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
vkCmdDispatchBase(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDevicePresentRectanglesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSurfaceKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pRectCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pRects'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDevicePresentRectanglesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkRect2D *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkRect2D* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      VkRect2D *instance = &result->instance;
      VkRect2D *copy = &$pdata[ii];
      
      instance->offset = copy->offset;
      if (&copy->offset != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkOffset2D::constructor.New(args);
        _VkOffset2D* unwrapped = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
        result->offset.Reset(inst);
        unwrapped->instance = copy->offset;
      }
      instance->extent = copy->extent;
      if (&copy->extent != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkExtent2D::constructor.New(args);
        _VkExtent2D* unwrapped = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
        result->extent.Reset(inst);
        unwrapped->instance = copy->extent;
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateDescriptorUpdateTemplate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorUpdateTemplateCreateInfo* obj1;
  VkDescriptorUpdateTemplateCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorUpdateTemplateCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorUpdateTemplateCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorUpdateTemplateCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDescriptorUpdateTemplate* obj3;
  VkDescriptorUpdateTemplate *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorUpdateTemplate::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDescriptorUpdateTemplate]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDescriptorUpdateTemplate>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pDescriptorUpdateTemplate'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateDescriptorUpdateTemplate(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyDescriptorUpdateTemplate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorUpdateTemplate* obj1;
  VkDescriptorUpdateTemplate *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorUpdateTemplate::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorUpdateTemplate]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorUpdateTemplate>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorUpdateTemplate'").ThrowAsJavaScriptException();
  }

vkDestroyDescriptorUpdateTemplate(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkUpdateDescriptorSetWithTemplate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorSet* obj1;
  VkDescriptorSet *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSet::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorSet]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorSet>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorSet'").ThrowAsJavaScriptException();
  }

  _VkDescriptorUpdateTemplate* obj2;
  VkDescriptorUpdateTemplate *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorUpdateTemplate::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDescriptorUpdateTemplate]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDescriptorUpdateTemplate>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'descriptorUpdateTemplate'").ThrowAsJavaScriptException();
  }

  void* $p3;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return;
  }
vkUpdateDescriptorSetWithTemplate(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    info[3].IsNull() ? nullptr : $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdPushDescriptorSetWithTemplateKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkDescriptorUpdateTemplate* obj1;
  VkDescriptorUpdateTemplate *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorUpdateTemplate::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorUpdateTemplate]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorUpdateTemplate>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'descriptorUpdateTemplate'").ThrowAsJavaScriptException();
  }

  _VkPipelineLayout* obj2;
  VkPipelineLayout *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineLayout::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkPipelineLayout]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkPipelineLayout>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'layout'").ThrowAsJavaScriptException();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  void* $p4;
  if (info[4].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[4].As<Napi::ArrayBuffer>();
    $p4 = buf.Data();
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 5 'pData'").ThrowAsJavaScriptException();
    return;
  }
$vkCmdPushDescriptorSetWithTemplateKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    info[4].IsNull() ? nullptr : $p4
  );
  
  
  return env.Undefined();
  
};

void _vkSetHdrMetadataEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkSwapchainKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkSwapchainKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSwapchainKHR* result = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkSwapchainKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pSwapchains'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<std::vector<VkHdrMetadataEXT>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkHdrMetadataEXT* result = Napi::ObjectWrap<_VkHdrMetadataEXT>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkHdrMetadataEXT> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkHdrMetadataEXT* result = Napi::ObjectWrap<_VkHdrMetadataEXT>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkHdrMetadataEXT>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pMetadata'").ThrowAsJavaScriptException();
    return;
  }

$vkSetHdrMetadataEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkSwapchainKHR *) $p2.get()->data() : nullptr,
    $p3 ? (const VkHdrMetadataEXT *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetSwapchainStatusKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetSwapchainStatusKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetRefreshCycleDurationGOOGLE(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }

  _VkRefreshCycleDurationGOOGLE* obj2;
  VkRefreshCycleDurationGOOGLE *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRefreshCycleDurationGOOGLE::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkRefreshCycleDurationGOOGLE]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkRefreshCycleDurationGOOGLE>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDisplayTimingProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetRefreshCycleDurationGOOGLE(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPastPresentationTimingGOOGLE(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSwapchainKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSwapchainKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPresentationTimingCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkPastPresentationTimingGOOGLE>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPastPresentationTimingGOOGLE* result = Napi::ObjectWrap<_VkPastPresentationTimingGOOGLE>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkPastPresentationTimingGOOGLE> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPastPresentationTimingGOOGLE* result = Napi::ObjectWrap<_VkPastPresentationTimingGOOGLE>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkPastPresentationTimingGOOGLE>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pPresentationTimings'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPastPresentationTimingGOOGLE(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkPastPresentationTimingGOOGLE *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkPastPresentationTimingGOOGLE* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPastPresentationTimingGOOGLE* result = Napi::ObjectWrap<_VkPastPresentationTimingGOOGLE>::Unwrap(obj);
      VkPastPresentationTimingGOOGLE *instance = &result->instance;
      VkPastPresentationTimingGOOGLE *copy = &$pdata[ii];
      
      instance->presentID = copy->presentID;
      instance->desiredPresentTime = copy->desiredPresentTime;
      instance->actualPresentTime = copy->actualPresentTime;
      instance->earliestPresentTime = copy->earliestPresentTime;
      instance->presentMargin = copy->presentMargin;
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdSetViewportWScalingNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkViewportWScalingNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkViewportWScalingNV* result = Napi::ObjectWrap<_VkViewportWScalingNV>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkViewportWScalingNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkViewportWScalingNV* result = Napi::ObjectWrap<_VkViewportWScalingNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkViewportWScalingNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pViewportWScalings'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdSetViewportWScalingNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkViewportWScalingNV *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetDiscardRectangleEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pDiscardRectangles'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdSetDiscardRectangleEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkRect2D *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetSampleLocationsEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkSampleLocationsInfoEXT* obj1;
  VkSampleLocationsInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSampleLocationsInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSampleLocationsInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSampleLocationsInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pSampleLocationsInfo'").ThrowAsJavaScriptException();
  }
$vkCmdSetSampleLocationsEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceMultisamplePropertiesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  _VkMultisamplePropertiesEXT* obj2;
  VkMultisamplePropertiesEXT *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMultisamplePropertiesEXT::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkMultisamplePropertiesEXT]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkMultisamplePropertiesEXT>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pMultisampleProperties'").ThrowAsJavaScriptException();
  }
$vkGetPhysicalDeviceMultisamplePropertiesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkSampleCountFlagBits>($p1),
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 6 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    obj2->maxSampleLocationGridSize.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxSampleLocationGridSize, sizeof(VkExtent2D));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetPhysicalDeviceSurfaceCapabilities2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceSurfaceInfo2KHR* obj1;
  VkPhysicalDeviceSurfaceInfo2KHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceSurfaceInfo2KHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceSurfaceInfo2KHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceSurfaceInfo2KHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pSurfaceInfo'").ThrowAsJavaScriptException();
  }

  _VkSurfaceCapabilities2KHR* obj2;
  VkSurfaceCapabilities2KHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSurfaceCapabilities2KHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkSurfaceCapabilities2KHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkSurfaceCapabilities2KHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceCapabilities'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkSurfaceCapabilitiesKHR::constructor.New(args);
    _VkSurfaceCapabilitiesKHR* 6 = Napi::ObjectWrap<_VkSurfaceCapabilitiesKHR>::Unwrap(inst);
    obj2->surfaceCapabilities.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.surfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
    
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->currentExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->minImageExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->maxImageExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceSurfaceFormats2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkPhysicalDeviceSurfaceInfo2KHR* obj1;
  VkPhysicalDeviceSurfaceInfo2KHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDeviceSurfaceInfo2KHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceSurfaceInfo2KHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPhysicalDeviceSurfaceInfo2KHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pSurfaceInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceFormatCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkSurfaceFormat2KHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSurfaceFormat2KHR* result = Napi::ObjectWrap<_VkSurfaceFormat2KHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSurfaceFormat2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSurfaceFormat2KHR* result = Napi::ObjectWrap<_VkSurfaceFormat2KHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkSurfaceFormat2KHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSurfaceFormats'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceSurfaceFormats2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkSurfaceFormat2KHR *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSurfaceFormat2KHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSurfaceFormat2KHR* result = Napi::ObjectWrap<_VkSurfaceFormat2KHR>::Unwrap(obj);
      VkSurfaceFormat2KHR *instance = &result->instance;
      VkSurfaceFormat2KHR *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->surfaceFormat = copy->surfaceFormat;
      if (&copy->surfaceFormat != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkSurfaceFormatKHR::constructor.New(args);
        _VkSurfaceFormatKHR* unwrapped = Napi::ObjectWrap<_VkSurfaceFormatKHR>::Unwrap(inst);
        result->surfaceFormat.Reset(inst);
        unwrapped->instance = copy->surfaceFormat;
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceDisplayProperties2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayProperties2KHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayProperties2KHR* result = Napi::ObjectWrap<_VkDisplayProperties2KHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayProperties2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayProperties2KHR* result = Napi::ObjectWrap<_VkDisplayProperties2KHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayProperties2KHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceDisplayProperties2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayProperties2KHR *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayProperties2KHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayProperties2KHR* result = Napi::ObjectWrap<_VkDisplayProperties2KHR>::Unwrap(obj);
      VkDisplayProperties2KHR *instance = &result->instance;
      VkDisplayProperties2KHR *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->displayProperties = copy->displayProperties;
      if (&copy->displayProperties != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkDisplayPropertiesKHR::constructor.New(args);
        _VkDisplayPropertiesKHR* unwrapped = Napi::ObjectWrap<_VkDisplayPropertiesKHR>::Unwrap(inst);
        result->displayProperties.Reset(inst);
        unwrapped->instance = copy->displayProperties;
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceDisplayPlaneProperties2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayPlaneProperties2KHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPlaneProperties2KHR* result = Napi::ObjectWrap<_VkDisplayPlaneProperties2KHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayPlaneProperties2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPlaneProperties2KHR* result = Napi::ObjectWrap<_VkDisplayPlaneProperties2KHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayPlaneProperties2KHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayPlaneProperties2KHR *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayPlaneProperties2KHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayPlaneProperties2KHR* result = Napi::ObjectWrap<_VkDisplayPlaneProperties2KHR>::Unwrap(obj);
      VkDisplayPlaneProperties2KHR *instance = &result->instance;
      VkDisplayPlaneProperties2KHR *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->displayPlaneProperties = copy->displayPlaneProperties;
      if (&copy->displayPlaneProperties != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkDisplayPlanePropertiesKHR::constructor.New(args);
        _VkDisplayPlanePropertiesKHR* unwrapped = Napi::ObjectWrap<_VkDisplayPlanePropertiesKHR>::Unwrap(inst);
        result->displayPlaneProperties.Reset(inst);
        unwrapped->instance = copy->displayPlaneProperties;
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDisplayModeProperties2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDisplayKHR* obj1;
  VkDisplayKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayKHR>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkDisplayModeProperties2KHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayModeProperties2KHR* result = Napi::ObjectWrap<_VkDisplayModeProperties2KHR>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDisplayModeProperties2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayModeProperties2KHR* result = Napi::ObjectWrap<_VkDisplayModeProperties2KHR>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkDisplayModeProperties2KHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetDisplayModeProperties2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkDisplayModeProperties2KHR *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkDisplayModeProperties2KHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkDisplayModeProperties2KHR* result = Napi::ObjectWrap<_VkDisplayModeProperties2KHR>::Unwrap(obj);
      VkDisplayModeProperties2KHR *instance = &result->instance;
      VkDisplayModeProperties2KHR *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->displayModeProperties = copy->displayModeProperties;
      if (&copy->displayModeProperties != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkDisplayModePropertiesKHR::constructor.New(args);
        _VkDisplayModePropertiesKHR* unwrapped = Napi::ObjectWrap<_VkDisplayModePropertiesKHR>::Unwrap(inst);
        result->displayModeProperties.Reset(inst);
        unwrapped->instance = copy->displayModeProperties;
      }
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDisplayPlaneCapabilities2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  _VkDisplayPlaneInfo2KHR* obj1;
  VkDisplayPlaneInfo2KHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayPlaneInfo2KHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDisplayPlaneInfo2KHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDisplayPlaneInfo2KHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pDisplayPlaneInfo'").ThrowAsJavaScriptException();
  }

  _VkDisplayPlaneCapabilities2KHR* obj2;
  VkDisplayPlaneCapabilities2KHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDisplayPlaneCapabilities2KHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDisplayPlaneCapabilities2KHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDisplayPlaneCapabilities2KHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pCapabilities'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetDisplayPlaneCapabilities2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkDisplayPlaneCapabilitiesKHR::constructor.New(args);
    _VkDisplayPlaneCapabilitiesKHR* 6 = Napi::ObjectWrap<_VkDisplayPlaneCapabilitiesKHR>::Unwrap(inst);
    obj2->capabilities.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.capabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
    
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 12 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    unwrapped6->minSrcPosition.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.minSrcPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 12 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    unwrapped6->maxSrcPosition.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxSrcPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->minSrcExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.minSrcExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->maxSrcExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxSrcExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 12 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    unwrapped6->minDstPosition.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.minDstPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkOffset2D::constructor.New(args);
    _VkOffset2D* 12 = Napi::ObjectWrap<_VkOffset2D>::Unwrap(inst);
    unwrapped6->maxDstPosition.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxDstPosition, sizeof(VkOffset2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->minDstExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.minDstExtent, sizeof(VkExtent2D));
    
  }
      
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkExtent2D::constructor.New(args);
    _VkExtent2D* 12 = Napi::ObjectWrap<_VkExtent2D>::Unwrap(inst);
    unwrapped6->maxDstExtent.Reset(inst);
    memcpy((&unwrapped12->instance), &unwrapped6->instance.maxDstExtent, sizeof(VkExtent2D));
    
  }
      
  }
      
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetBufferMemoryRequirements2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBufferMemoryRequirementsInfo2* obj1;
  VkBufferMemoryRequirementsInfo2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBufferMemoryRequirementsInfo2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBufferMemoryRequirementsInfo2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBufferMemoryRequirementsInfo2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
  }

  _VkMemoryRequirements2* obj2;
  VkMemoryRequirements2 *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryRequirements2::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements2]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkMemoryRequirements2>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
  }
vkGetBufferMemoryRequirements2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkMemoryRequirements::constructor.New(args);
    _VkMemoryRequirements* 6 = Napi::ObjectWrap<_VkMemoryRequirements>::Unwrap(inst);
    obj2->memoryRequirements.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.memoryRequirements, sizeof(VkMemoryRequirements));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetImageMemoryRequirements2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImageMemoryRequirementsInfo2* obj1;
  VkImageMemoryRequirementsInfo2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageMemoryRequirementsInfo2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImageMemoryRequirementsInfo2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImageMemoryRequirementsInfo2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
  }

  _VkMemoryRequirements2* obj2;
  VkMemoryRequirements2 *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryRequirements2::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements2]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkMemoryRequirements2>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
  }
vkGetImageMemoryRequirements2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkMemoryRequirements::constructor.New(args);
    _VkMemoryRequirements* 6 = Napi::ObjectWrap<_VkMemoryRequirements>::Unwrap(inst);
    obj2->memoryRequirements.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.memoryRequirements, sizeof(VkMemoryRequirements));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkGetImageSparseMemoryRequirements2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImageSparseMemoryRequirementsInfo2* obj1;
  VkImageSparseMemoryRequirementsInfo2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageSparseMemoryRequirementsInfo2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImageSparseMemoryRequirementsInfo2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImageSparseMemoryRequirementsInfo2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  uint32_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSparseMemoryRequirementCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkSparseImageMemoryRequirements2>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageMemoryRequirements2* result = Napi::ObjectWrap<_VkSparseImageMemoryRequirements2>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSparseImageMemoryRequirements2> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageMemoryRequirements2* result = Napi::ObjectWrap<_VkSparseImageMemoryRequirements2>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkSparseImageMemoryRequirements2>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSparseMemoryRequirements'").ThrowAsJavaScriptException();
    return;
  }

vkGetImageSparseMemoryRequirements2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkSparseImageMemoryRequirements2 *) $p3.get()->data() : nullptr
  );
    obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSparseImageMemoryRequirements2* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkSparseImageMemoryRequirements2* result = Napi::ObjectWrap<_VkSparseImageMemoryRequirements2>::Unwrap(obj);
      VkSparseImageMemoryRequirements2 *instance = &result->instance;
      VkSparseImageMemoryRequirements2 *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->memoryRequirements = copy->memoryRequirements;
      if (&copy->memoryRequirements != nullptr) {
        std::vector<napi_value> args;
        Napi::Object inst = _VkSparseImageMemoryRequirements::constructor.New(args);
        _VkSparseImageMemoryRequirements* unwrapped = Napi::ObjectWrap<_VkSparseImageMemoryRequirements>::Unwrap(inst);
        result->memoryRequirements.Reset(inst);
        unwrapped->instance = copy->memoryRequirements;
      }
    };
  }
  
  
  return env.Undefined();
  
};

void _vkCreateSamplerYcbcrConversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSamplerYcbcrConversionCreateInfo* obj1;
  VkSamplerYcbcrConversionCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSamplerYcbcrConversionCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSamplerYcbcrConversionCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSamplerYcbcrConversionCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkSamplerYcbcrConversion* obj3;
  VkSamplerYcbcrConversion *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSamplerYcbcrConversion::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkSamplerYcbcrConversion]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkSamplerYcbcrConversion>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pYcbcrConversion'").ThrowAsJavaScriptException();
  }
  int32_t out = vkCreateSamplerYcbcrConversion(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroySamplerYcbcrConversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkSamplerYcbcrConversion* obj1;
  VkSamplerYcbcrConversion *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSamplerYcbcrConversion::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSamplerYcbcrConversion]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSamplerYcbcrConversion>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'ycbcrConversion'").ThrowAsJavaScriptException();
  }

vkDestroySamplerYcbcrConversion(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetDeviceQueue2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDeviceQueueInfo2* obj1;
  VkDeviceQueueInfo2 *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDeviceQueueInfo2::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDeviceQueueInfo2]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDeviceQueueInfo2>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pQueueInfo'").ThrowAsJavaScriptException();
  }

  _VkQueue* obj2;
  VkQueue *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkQueue]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pQueue'").ThrowAsJavaScriptException();
  }
vkGetDeviceQueue2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCreateValidationCacheEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkValidationCacheCreateInfoEXT* obj1;
  VkValidationCacheCreateInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkValidationCacheCreateInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkValidationCacheCreateInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkValidationCacheCreateInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkValidationCacheEXT* obj3;
  VkValidationCacheEXT *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkValidationCacheEXT::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkValidationCacheEXT]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkValidationCacheEXT>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pValidationCache'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateValidationCacheEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyValidationCacheEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkValidationCacheEXT* obj1;
  VkValidationCacheEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkValidationCacheEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkValidationCacheEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkValidationCacheEXT>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'validationCache'").ThrowAsJavaScriptException();
  }

$vkDestroyValidationCacheEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetValidationCacheDataEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkValidationCacheEXT* obj1;
  VkValidationCacheEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkValidationCacheEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkValidationCacheEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkValidationCacheEXT>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'validationCache'").ThrowAsJavaScriptException();
  }

  Napi::Object obj2;
  size_t $p2;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p2 = static_cast<size_t>(info[2].As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDataSize'").ThrowAsJavaScriptException();
    return;
  }

  void* $p3;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetValidationCacheDataEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    info[3].IsNull() ? nullptr : $p3
  );
    Napi::BigInt pnum2 = Napi::BigInt::New(env, (uint64_t)$p2);
    obj2.Set("$", pnum2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkMergeValidationCachesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkValidationCacheEXT* obj1;
  VkValidationCacheEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkValidationCacheEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkValidationCacheEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkValidationCacheEXT>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'dstCache'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkValidationCacheEXT>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkValidationCacheEXT> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkValidationCacheEXT* result = Napi::ObjectWrap<_VkValidationCacheEXT>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkValidationCacheEXT>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSrcCaches'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkMergeValidationCachesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkValidationCacheEXT *) $p3.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetDescriptorSetLayoutSupport(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDescriptorSetLayoutCreateInfo* obj1;
  VkDescriptorSetLayoutCreateInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSetLayoutCreateInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetLayoutCreateInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDescriptorSetLayoutCreateInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }

  _VkDescriptorSetLayoutSupport* obj2;
  VkDescriptorSetLayoutSupport *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDescriptorSetLayoutSupport::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkDescriptorSetLayoutSupport]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkDescriptorSetLayoutSupport>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSupport'").ThrowAsJavaScriptException();
  }
vkGetDescriptorSetLayoutSupport(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkGetShaderInfoAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipeline* obj1;
  VkPipeline *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipeline::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  VkShaderInfoTypeAMD $p3 = static_cast<VkShaderInfoTypeAMD>(info[3].As<Napi::Number>().Int64Value());

  Napi::Object obj4;
  size_t $p4;
  if (info[4].IsObject()) {
    obj4 = info[4].As<Napi::Object>();
    if (!obj4.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 5").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pInfoSize'").ThrowAsJavaScriptException();
    return;
  }

  void* $p5;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pInfo'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetShaderInfoAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkShaderStageFlagBits>($p2),
    $p3,
    &$p4,
    info[5].IsNull() ? nullptr : $p5
  );
    Napi::BigInt pnum4 = Napi::BigInt::New(env, (uint64_t)$p4);
    obj4.Set("$", pnum4);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPhysicalDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkPhysicalDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pTimeDomainCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<int32_t*> $p2 = nullptr;

  if (info[2].IsTypedArray()) {

    if (info[2].As<Napi::TypedArray>().TypedArrayType() != napi_int32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 3 'pTimeDomains'").ThrowAsJavaScriptException();
      return;
    }
    int32_t* data = getTypedArrayData<int32_t>(info[2]);
    $p2 = std::make_shared<int32_t*>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pTimeDomains'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkTimeDomainEXT *) *$p2.get() : nullptr
  );
    obj1.Set("$", $p1);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetCalibratedTimestampsEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCalibratedTimestampInfoEXT>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCalibratedTimestampInfoEXT* result = Napi::ObjectWrap<_VkCalibratedTimestampInfoEXT>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCalibratedTimestampInfoEXT> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCalibratedTimestampInfoEXT* result = Napi::ObjectWrap<_VkCalibratedTimestampInfoEXT>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkCalibratedTimestampInfoEXT>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pTimestampInfos'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint64_t*> $p3 = nullptr;

  if (info[3].IsTypedArray()) {

    if (info[3].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 4 'pTimestamps'").ThrowAsJavaScriptException();
      return;
    }
    uint64_t* data = getTypedArrayData<uint64_t>(info[3]);
    $p3 = std::make_shared<uint64_t*>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pTimestamps'").ThrowAsJavaScriptException();
    return;
  }


  Napi::Object obj4;
  uint64_t $p4;
  if (info[4].IsObject()) {
    obj4 = info[4].As<Napi::Object>();
    if (!obj4.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 5").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pMaxDeviation'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetCalibratedTimestampsEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkCalibratedTimestampInfoEXT *) $p2.get()->data() : nullptr,
    $p3 ? *$p3.get() : nullptr,
    &$p4
  );
    Napi::BigInt pnum4 = Napi::BigInt::New(env, (uint64_t)$p4);
    obj4.Set("$", pnum4);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkSetDebugUtilsObjectNameEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsObjectNameInfoEXT* obj1;
  VkDebugUtilsObjectNameInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsObjectNameInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsObjectNameInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsObjectNameInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pNameInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkSetDebugUtilsObjectNameEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkSetDebugUtilsObjectTagEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsObjectTagInfoEXT* obj1;
  VkDebugUtilsObjectTagInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsObjectTagInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsObjectTagInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsObjectTagInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pTagInfo'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkSetDebugUtilsObjectTagEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkQueueBeginDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsLabelEXT* obj1;
  VkDebugUtilsLabelEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsLabelEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsLabelEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
  }
$vkQueueBeginDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkQueueEndDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }
$vkQueueEndDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

void _vkQueueInsertDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsLabelEXT* obj1;
  VkDebugUtilsLabelEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsLabelEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsLabelEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
  }
$vkQueueInsertDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBeginDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsLabelEXT* obj1;
  VkDebugUtilsLabelEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsLabelEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsLabelEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
  }
$vkCmdBeginDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }
$vkCmdEndDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

void _vkCmdInsertDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsLabelEXT* obj1;
  VkDebugUtilsLabelEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsLabelEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsLabelEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
  }
$vkCmdInsertDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCreateDebugUtilsMessengerEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsMessengerCreateInfoEXT* obj1;
  VkDebugUtilsMessengerCreateInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsMessengerCreateInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsMessengerCreateInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsMessengerCreateInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkDebugUtilsMessengerEXT* obj3;
  VkDebugUtilsMessengerEXT *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsMessengerEXT::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDebugUtilsMessengerEXT]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDebugUtilsMessengerEXT>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pMessenger'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateDebugUtilsMessengerEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyDebugUtilsMessengerEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  _VkDebugUtilsMessengerEXT* obj1;
  VkDebugUtilsMessengerEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsMessengerEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsMessengerEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkDebugUtilsMessengerEXT>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'messenger'").ThrowAsJavaScriptException();
  }

$vkDestroyDebugUtilsMessengerEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkSubmitDebugUtilsMessageEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkInstance::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkInstance>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  _VkDebugUtilsMessengerCallbackDataEXT* obj3;
  VkDebugUtilsMessengerCallbackDataEXT *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDebugUtilsMessengerCallbackDataEXT::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkDebugUtilsMessengerCallbackDataEXT]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkDebugUtilsMessengerCallbackDataEXT>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pCallbackData'").ThrowAsJavaScriptException();
  }
$vkSubmitDebugUtilsMessageEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>($p1),
    static_cast<VkDebugUtilsMessageTypeFlagsEXT>($p2),
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkGetMemoryHostPointerPropertiesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  void* $p2;
  if (info[2].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[2].As<Napi::ArrayBuffer>();
    $p2 = buf.Data();
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 3 'pHostPointer'").ThrowAsJavaScriptException();
    return;
  }

  _VkMemoryHostPointerPropertiesEXT* obj3;
  VkMemoryHostPointerPropertiesEXT *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryHostPointerPropertiesEXT::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkMemoryHostPointerPropertiesEXT]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkMemoryHostPointerPropertiesEXT>::Unwrap(obj);
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pMemoryHostPointerProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetMemoryHostPointerPropertiesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkExternalMemoryHandleTypeFlagBits>($p1),
    info[2].IsNull() ? nullptr : $p2,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdWriteBufferMarkerAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  _VkBuffer* obj2;
  VkBuffer *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkBuffer]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'dstBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
$vkCmdWriteBufferMarkerAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkPipelineStageFlagBits>($p1),
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCreateRenderPass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkRenderPassCreateInfo2KHR* obj1;
  VkRenderPassCreateInfo2KHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPassCreateInfo2KHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkRenderPassCreateInfo2KHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkRenderPassCreateInfo2KHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkRenderPass* obj3;
  VkRenderPass *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPass::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkRenderPass]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkRenderPass>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pRenderPass'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateRenderPass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdBeginRenderPass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkRenderPassBeginInfo* obj1;
  VkRenderPassBeginInfo *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkRenderPassBeginInfo::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkRenderPassBeginInfo]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkRenderPassBeginInfo>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pRenderPassBegin'").ThrowAsJavaScriptException();
  }

  _VkSubpassBeginInfoKHR* obj2;
  VkSubpassBeginInfoKHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSubpassBeginInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkSubpassBeginInfoKHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkSubpassBeginInfoKHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSubpassBeginInfo'").ThrowAsJavaScriptException();
  }
$vkCmdBeginRenderPass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdNextSubpass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkSubpassBeginInfoKHR* obj1;
  VkSubpassBeginInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSubpassBeginInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSubpassBeginInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSubpassBeginInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pSubpassBeginInfo'").ThrowAsJavaScriptException();
  }

  _VkSubpassEndInfoKHR* obj2;
  VkSubpassEndInfoKHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSubpassEndInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkSubpassEndInfoKHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkSubpassEndInfoKHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSubpassEndInfo'").ThrowAsJavaScriptException();
  }
$vkCmdNextSubpass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndRenderPass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkSubpassEndInfoKHR* obj1;
  VkSubpassEndInfoKHR *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkSubpassEndInfoKHR::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkSubpassEndInfoKHR]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkSubpassEndInfoKHR>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pSubpassEndInfo'").ThrowAsJavaScriptException();
  }
$vkCmdEndRenderPass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndirectCountKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndirectCountKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndexedIndirectCountKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndexedIndirectCountKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetCheckpointNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  void* $p1;
  if (info[1].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[1].As<Napi::ArrayBuffer>();
    $p1 = buf.Data();
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 2 'pCheckpointMarker'").ThrowAsJavaScriptException();
    return;
  }
$vkCmdSetCheckpointNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? nullptr : $p1
  );
  
  
  return env.Undefined();
  
};

void _vkGetQueueCheckpointDataNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueue::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkQueue>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
  }

  Napi::Object obj1;
  uint32_t $p1;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::ReferenceError::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return;
    }
    Napi::Value val = obj.Get("$");
    $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCheckpointDataCount'").ThrowAsJavaScriptException();
    return;
  }

  std::shared_ptr<std::vector<VkCheckpointDataNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCheckpointDataNV* result = Napi::ObjectWrap<_VkCheckpointDataNV>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCheckpointDataNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCheckpointDataNV* result = Napi::ObjectWrap<_VkCheckpointDataNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkCheckpointDataNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCheckpointData'").ThrowAsJavaScriptException();
    return;
  }

$vkGetQueueCheckpointDataNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkCheckpointDataNV *) $p2.get()->data() : nullptr
  );
    obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkCheckpointDataNV* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCheckpointDataNV* result = Napi::ObjectWrap<_VkCheckpointDataNV>::Unwrap(obj);
      VkCheckpointDataNV *instance = &result->instance;
      VkCheckpointDataNV *copy = &$pdata[ii];
      
      instance->sType = copy->sType;
      instance->stage = copy->stage;
    };
  }
  
  
  return env.Undefined();
  
};

void _vkCmdBindTransformFeedbackBuffersEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBuffer* result = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pBuffers'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
      return;
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint64_t*> $p5 = nullptr;

  if (info[5].IsTypedArray()) {

    if (info[5].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 6 'pSizes'").ThrowAsJavaScriptException();
      return;
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[5]);
    $p5 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pSizes'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdBindTransformFeedbackBuffersEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr,
    $p5 ? *$p5.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBeginTransformFeedbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBuffer* result = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCounterBuffers'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
      return;
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdBeginTransformFeedbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndTransformFeedbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBuffer* result = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCounterBuffers'").ThrowAsJavaScriptException();
    return;
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
      return;
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdEndTransformFeedbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBeginQueryIndexedEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
$vkCmdBeginQueryIndexedEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    static_cast<VkQueryControlFlags>($p3),
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdEndQueryIndexedEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
$vkCmdEndQueryIndexedEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawIndirectByteCountEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'counterBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndirectByteCountEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetExclusiveScissorNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRect2D* result = Napi::ObjectWrap<_VkRect2D>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pExclusiveScissors'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdSetExclusiveScissorNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkRect2D *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBindShadingRateImageNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkImageView* obj1;
  VkImageView *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageView::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImageView]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImageView>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'imageView'").ThrowAsJavaScriptException();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());
$vkCmdBindShadingRateImageNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetViewportShadingRatePaletteNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkShadingRatePaletteNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkShadingRatePaletteNV* result = Napi::ObjectWrap<_VkShadingRatePaletteNV>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkShadingRatePaletteNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkShadingRatePaletteNV* result = Napi::ObjectWrap<_VkShadingRatePaletteNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkShadingRatePaletteNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pShadingRatePalettes'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdSetViewportShadingRatePaletteNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkShadingRatePaletteNV *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdSetCoarseSampleOrderNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  VkCoarseSampleOrderTypeNV $p1 = static_cast<VkCoarseSampleOrderTypeNV>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCoarseSampleOrderCustomNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCoarseSampleOrderCustomNV* result = Napi::ObjectWrap<_VkCoarseSampleOrderCustomNV>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkCoarseSampleOrderCustomNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkCoarseSampleOrderCustomNV* result = Napi::ObjectWrap<_VkCoarseSampleOrderCustomNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkCoarseSampleOrderCustomNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCustomSampleOrders'").ThrowAsJavaScriptException();
    return;
  }

$vkCmdSetCoarseSampleOrderNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkCoarseSampleOrderCustomNV *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawMeshTasksNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
$vkCmdDrawMeshTasksNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawMeshTasksIndirectNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
$vkCmdDrawMeshTasksIndirectNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

void _vkCmdDrawMeshTasksIndirectCountNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawMeshTasksIndirectCountNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

void _vkCompileDeferredNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipeline* obj1;
  VkPipeline *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipeline::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  int32_t out = $vkCompileDeferredNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureCreateInfoNV* obj1;
  VkAccelerationStructureCreateInfoNV *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureCreateInfoNV::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureCreateInfoNV]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAccelerationStructureCreateInfoNV>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
  }


  _VkAccelerationStructureNV* obj3;
  VkAccelerationStructureNV *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkAccelerationStructureNV]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pAccelerationStructure'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkCreateAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkDestroyAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureNV* obj1;
  VkAccelerationStructureNV *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureNV]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'accelerationStructure'").ThrowAsJavaScriptException();
  }

$vkDestroyAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

void _vkGetAccelerationStructureMemoryRequirementsNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureMemoryRequirementsInfoNV* obj1;
  VkAccelerationStructureMemoryRequirementsInfoNV *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureMemoryRequirementsInfoNV::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureMemoryRequirementsInfoNV]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAccelerationStructureMemoryRequirementsInfoNV>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
  }

  _VkMemoryRequirements2KHR* obj2;
  VkMemoryRequirements2KHR *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkMemoryRequirements2KHR::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements2KHR]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkMemoryRequirements2KHR>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
  }
$vkGetAccelerationStructureMemoryRequirementsNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  {
    std::vector<napi_value> args;
    Napi::Object inst = _VkMemoryRequirements::constructor.New(args);
    _VkMemoryRequirements* 6 = Napi::ObjectWrap<_VkMemoryRequirements>::Unwrap(inst);
    obj2->memoryRequirements.Reset(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.memoryRequirements, sizeof(VkMemoryRequirements));
    
  }
      
  
  
  return env.Undefined();
  
};

void _vkBindAccelerationStructureMemoryNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindAccelerationStructureMemoryInfoNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindAccelerationStructureMemoryInfoNV* result = Napi::ObjectWrap<_VkBindAccelerationStructureMemoryInfoNV>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindAccelerationStructureMemoryInfoNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkBindAccelerationStructureMemoryInfoNV* result = Napi::ObjectWrap<_VkBindAccelerationStructureMemoryInfoNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkBindAccelerationStructureMemoryInfoNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfos'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkBindAccelerationStructureMemoryNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindAccelerationStructureMemoryInfoNV *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCmdCopyAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureNV* obj1;
  VkAccelerationStructureNV *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureNV]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'dst'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureNV* obj2;
  VkAccelerationStructureNV *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkAccelerationStructureNV]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'src'").ThrowAsJavaScriptException();
  }

  VkCopyAccelerationStructureModeNV $p3 = static_cast<VkCopyAccelerationStructureModeNV>(info[3].As<Napi::Number>().Int64Value());
$vkCmdCopyAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

void _vkCmdWriteAccelerationStructuresPropertiesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkAccelerationStructureNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkAccelerationStructureNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkAccelerationStructureNV* result = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkAccelerationStructureNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pAccelerationStructures'").ThrowAsJavaScriptException();
    return;
  }


  VkQueryType $p3 = static_cast<VkQueryType>(info[3].As<Napi::Number>().Int64Value());

  _VkQueryPool* obj4;
  VkQueryPool *$p4;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkQueryPool::constructor.Value()))) {
      NanObjectTypeError(info[4], "argument 5", "[object VkQueryPool]");
      return;
    }
    obj4 = Napi::ObjectWrap<_VkQueryPool>::Unwrap(obj);
    
    $p4 = &obj4->instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'queryPool'").ThrowAsJavaScriptException();
  }

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());
$vkCmdWriteAccelerationStructuresPropertiesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkAccelerationStructureNV *) $p2.get()->data() : nullptr,
    $p3,
    info[4].IsNull() ? VK_NULL_HANDLE : *$p4,
    $p5
  );
  
  
  return env.Undefined();
  
};

void _vkCmdBuildAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureInfoNV* obj1;
  VkAccelerationStructureInfoNV *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureInfoNV::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureInfoNV]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAccelerationStructureInfoNV>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj2;
  VkBuffer *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkBuffer]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'instanceData'").ThrowAsJavaScriptException();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  _VkAccelerationStructureNV* obj5;
  VkAccelerationStructureNV *$p5;
  if (info[5].IsObject()) {
    Napi::Object obj = info[5].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[5], "argument 6", "[object VkAccelerationStructureNV]");
      return;
    }
    obj5 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p5 = &obj5->instance;
  } else if (info[5].IsNull()) {
    $p5 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 6 'dst'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureNV* obj6;
  VkAccelerationStructureNV *$p6;
  if (info[6].IsObject()) {
    Napi::Object obj = info[6].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[6], "argument 7", "[object VkAccelerationStructureNV]");
      return;
    }
    obj6 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p6 = &obj6->instance;
  } else if (info[6].IsNull()) {
    $p6 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 7 'src'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj7;
  VkBuffer *$p7;
  if (info[7].IsObject()) {
    Napi::Object obj = info[7].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[7], "argument 8", "[object VkBuffer]");
      return;
    }
    obj7 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p7 = &obj7->instance;
  } else if (info[7].IsNull()) {
    $p7 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 8 'scratch'").ThrowAsJavaScriptException();
  }

  uint64_t $p8 = static_cast<uint64_t>(info[8].As<Napi::Number>().Int64Value());
$vkCmdBuildAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    info[5].IsNull() ? VK_NULL_HANDLE : *$p5,
    info[6].IsNull() ? VK_NULL_HANDLE : *$p6,
    info[7].IsNull() ? VK_NULL_HANDLE : *$p7,
    $p8
  );
  
  
  return env.Undefined();
  
};

void _vkCmdTraceRaysNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkCommandBuffer::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkCommandBuffer>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'raygenShaderBindingTableBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return;
    }
    obj3 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p3 = &obj3->instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'missShaderBindingTableBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint64_t $p5 = static_cast<uint64_t>(info[5].As<Napi::Number>().Int64Value());

  _VkBuffer* obj6;
  VkBuffer *$p6;
  if (info[6].IsObject()) {
    Napi::Object obj = info[6].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[6], "argument 7", "[object VkBuffer]");
      return;
    }
    obj6 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p6 = &obj6->instance;
  } else if (info[6].IsNull()) {
    $p6 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 7 'hitShaderBindingTableBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p7 = static_cast<uint64_t>(info[7].As<Napi::Number>().Int64Value());

  uint64_t $p8 = static_cast<uint64_t>(info[8].As<Napi::Number>().Int64Value());

  _VkBuffer* obj9;
  VkBuffer *$p9;
  if (info[9].IsObject()) {
    Napi::Object obj = info[9].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBuffer::constructor.Value()))) {
      NanObjectTypeError(info[9], "argument 10", "[object VkBuffer]");
      return;
    }
    obj9 = Napi::ObjectWrap<_VkBuffer>::Unwrap(obj);
    
    $p9 = &obj9->instance;
  } else if (info[9].IsNull()) {
    $p9 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 10 'callableShaderBindingTableBuffer'").ThrowAsJavaScriptException();
  }

  uint64_t $p10 = static_cast<uint64_t>(info[10].As<Napi::Number>().Int64Value());

  uint64_t $p11 = static_cast<uint64_t>(info[11].As<Napi::Number>().Int64Value());

  uint32_t $p12 = static_cast<uint32_t>(info[12].As<Napi::Number>().Int64Value());

  uint32_t $p13 = static_cast<uint32_t>(info[13].As<Napi::Number>().Int64Value());

  uint32_t $p14 = static_cast<uint32_t>(info[14].As<Napi::Number>().Int64Value());
$vkCmdTraceRaysNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    info[6].IsNull() ? VK_NULL_HANDLE : *$p6,
    $p7,
    $p8,
    info[9].IsNull() ? VK_NULL_HANDLE : *$p9,
    $p10,
    $p11,
    $p12,
    $p13,
    $p14
  );
  
  
  return env.Undefined();
  
};

void _vkGetRayTracingShaderGroupHandlesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipeline* obj1;
  VkPipeline *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipeline::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  size_t $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());

  void* $p5;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pData'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetRayTracingShaderGroupHandlesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    info[5].IsNull() ? nullptr : $p5
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetAccelerationStructureHandleNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkAccelerationStructureNV* obj1;
  VkAccelerationStructureNV *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkAccelerationStructureNV::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureNV]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkAccelerationStructureNV>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'accelerationStructure'").ThrowAsJavaScriptException();
  }

  size_t $p2 = static_cast<size_t>(info[2].As<Napi::Number>().Int64Value());

  void* $p3;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return;
  }
  int32_t out = $vkGetAccelerationStructureHandleNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? nullptr : $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkCreateRayTracingPipelinesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkPipelineCache::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkPipelineCache>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRayTracingPipelineCreateInfoNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRayTracingPipelineCreateInfoNV* result = Napi::ObjectWrap<_VkRayTracingPipelineCreateInfoNV>::Unwrap(obj);
      if (!result->flush()) return;
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRayTracingPipelineCreateInfoNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkRayTracingPipelineCreateInfoNV* result = Napi::ObjectWrap<_VkRayTracingPipelineCreateInfoNV>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkRayTracingPipelineCreateInfoNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCreateInfos'").ThrowAsJavaScriptException();
    return;
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkPipeline> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipeline* result = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pPipelines'").ThrowAsJavaScriptException();
    return;
  }

  int32_t out = $vkCreateRayTracingPipelinesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkRayTracingPipelineCreateInfoNV *) $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? (VkPipeline *) $p5.get()->data() : nullptr
  );
  if (info[5].IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      _VkPipeline* target = Napi::ObjectWrap<_VkPipeline>::Unwrap(obj);
      target->instance = $pdata[ii];
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetImageDrmFormatModifierPropertiesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImage::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkImage>::Unwrap(obj);
    
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
  }

  _VkImageDrmFormatModifierPropertiesEXT* obj2;
  VkImageDrmFormatModifierPropertiesEXT *$p2;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkImageDrmFormatModifierPropertiesEXT::constructor.Value()))) {
      NanObjectTypeError(info[2], "argument 3", "[object VkImageDrmFormatModifierPropertiesEXT]");
      return;
    }
    obj2 = Napi::ObjectWrap<_VkImageDrmFormatModifierPropertiesEXT>::Unwrap(obj);
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pProperties'").ThrowAsJavaScriptException();
  }
  int32_t out = $vkGetImageDrmFormatModifierPropertiesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

void _vkGetBufferDeviceAddressEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkDevice::constructor.Value()))) {
      NanObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return;
    }
    obj0 = Napi::ObjectWrap<_VkDevice>::Unwrap(obj);
    
    $p0 = &obj0->instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
  }

  _VkBufferDeviceAddressInfoEXT* obj1;
  VkBufferDeviceAddressInfoEXT *$p1;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (!(obj.InstanceOf(_VkBufferDeviceAddressInfoEXT::constructor.Value()))) {
      NanObjectTypeError(info[1], "argument 2", "[object VkBufferDeviceAddressInfoEXT]");
      return;
    }
    obj1 = Napi::ObjectWrap<_VkBufferDeviceAddressInfoEXT>::Unwrap(obj);
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
  }
  uint64_t out = $vkGetBufferDeviceAddressEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::BigInt::New(env, static_cast<int64_t>(out));
  
};



#endif
