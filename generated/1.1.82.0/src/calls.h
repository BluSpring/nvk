/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY node-vulkan v0.0.1
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#include <nan.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "index.h"

#include <map>
#include <string>

void _vkCreateInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstanceCreateInfo* obj0 = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info[0]->ToObject());
  VkInstanceCreateInfo *$p0 = &obj0->instance;


  _VkInstance* obj2 = Nan::ObjectWrap::Unwrap<_VkInstance>(info[2]->ToObject());
  VkInstance *$p2 = &obj2->instance;
  VkResult out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumeratePhysicalDevices(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(info[0]->ToObject());
  VkInstance *$p0 = &obj0->instance;

  v8::Local<v8::Object> obj1 = info[1]->ToObject();
  uint32_t $p1 = static_cast<uint32_t>(obj1->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkPhysicalDevice *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Objects<VkPhysicalDevice, _VkPhysicalDevice>(info[2]);
  }

  VkResult out = vkEnumeratePhysicalDevices(
    *$p0,
    &$p1,
    $p2
  );
  obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkPhysicalDeviceProperties* obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info[1]->ToObject());
  VkPhysicalDeviceProperties *$p1 = &obj1->instance;
  vkGetPhysicalDeviceProperties(
    *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  v8::Local<v8::Object> obj1 = info[1]->ToObject();
  uint32_t $p1 = static_cast<uint32_t>(obj1->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkQueueFamilyProperties *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = copyArrayOfV8Objects<VkQueueFamilyProperties, _VkQueueFamilyProperties>(info[2]);
  }

  vkGetPhysicalDeviceQueueFamilyProperties(
    *$p0,
    &$p1,
    $p2
  );
  obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(item->ToObject());
      VkQueueFamilyProperties *instance = &result->instance;
      VkQueueFamilyProperties *copy = &$p2[ii];
      
      instance->queueFlags = copy->queueFlags;
      instance->queueCount = copy->queueCount;
      instance->timestampValidBits = copy->timestampValidBits;
      instance->minImageTransferGranularity = copy->minImageTransferGranularity;
    };
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceFeatures(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkPhysicalDeviceFeatures* obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info[1]->ToObject());
  VkPhysicalDeviceFeatures *$p1 = &obj1->instance;
  vkGetPhysicalDeviceFeatures(
    *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};



#endif
