/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY node-vulkan v0.0.1
 * I CANT STOP SCREAMING
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#include <nan.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "index.h"

#include <map>
#include <string>

void _vkCreateInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstanceCreateInfo* obj0;
  VkInstanceCreateInfo *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = nullptr;
  }


  _VkInstance* obj2;
  VkInstance *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkInstance>(info[2]->ToObject());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumeratePhysicalDevices(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj1;
  uint32_t $p1;
  if (!(info[1]->IsNull())) {
    obj1 = info[1]->ToObject();
    $p1 = static_cast<uint32_t>(obj1->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }

  VkPhysicalDevice *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Objects<VkPhysicalDevice, _VkPhysicalDevice>(info[2]);
  }

  int32_t out = vkEnumeratePhysicalDevices(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceProperties* obj1;
  VkPhysicalDeviceProperties *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect string
    v8::Local<v8::String> str1 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), (&obj1->instance)->deviceName);
    obj1->deviceName = Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>>(str1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 16);
    // populate array
    for (unsigned int ii = 0; ii < 16; ++ii) {
      arr1->Set(ii, Nan::New((&obj1->instance)->pipelineCacheUUID[ii]));
    };
    obj1->pipelineCacheUUID = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceLimits::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceLimits* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(inst);
    obj1->limits = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.limits, sizeof(VkPhysicalDeviceLimits));
    
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupCount[ii]));
    };
    unwrapped6->maxComputeWorkGroupCount = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupSize[ii]));
    };
    unwrapped6->maxComputeWorkGroupSize = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxViewportDimensions[ii]));
    };
    unwrapped6->maxViewportDimensions = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->viewportBoundsRange[ii]));
    };
    unwrapped6->viewportBoundsRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->pointSizeRange[ii]));
    };
    unwrapped6->pointSizeRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->lineWidthRange[ii]));
    };
    unwrapped6->lineWidthRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceSparseProperties::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceSparseProperties* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(inst);
    obj1->sparseProperties = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.sparseProperties, sizeof(VkPhysicalDeviceSparseProperties));
    
  }
      
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj1;
  uint32_t $p1;
  if (!(info[1]->IsNull())) {
    obj1 = info[1]->ToObject();
    $p1 = static_cast<uint32_t>(obj1->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }

  VkQueueFamilyProperties *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = copyArrayOfV8Objects<VkQueueFamilyProperties, _VkQueueFamilyProperties>(info[2]);
  }

  vkGetPhysicalDeviceQueueFamilyProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = item->ToObject();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(obj);
      VkQueueFamilyProperties *instance = &result->instance;
      VkQueueFamilyProperties *copy = &$p2[ii];
      
      instance->minImageTransferGranularity = copy->minImageTransferGranularity;
      if (&copy->minImageTransferGranularity != nullptr) {
        
  v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent3D::constructor)).ToLocalChecked();
  v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
  _VkExtent3D* unwrapped = Nan::ObjectWrap::Unwrap<_VkExtent3D>(inst);
        result->minImageTransferGranularity = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
        unwrapped->instance = copy->minImageTransferGranularity;
      }
    };
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceMemoryProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceMemoryProperties* obj1;
  VkPhysicalDeviceMemoryProperties *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceMemoryProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceFeatures(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceFeatures* obj1;
  VkPhysicalDeviceFeatures *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceFeatures(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateDevice(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceCreateInfo* obj1;
  VkDeviceCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDevice* obj3;
  VkDevice *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDevice(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumerateInstanceLayerProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  v8::Local<v8::Object> obj0;
  uint32_t $p0;
  if (!(info[0]->IsNull())) {
    obj0 = info[0]->ToObject();
    $p0 = static_cast<uint32_t>(obj0->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }

  VkLayerProperties *$p1 = nullptr;

  if (info[1]->IsArray()) {

    $p1 = copyArrayOfV8Objects<VkLayerProperties, _VkLayerProperties>(info[1]);
  }

  int32_t out = vkEnumerateInstanceLayerProperties(
    &$p0,
    $p1
  );
    obj0->Set(Nan::New("$").ToLocalChecked(), Nan::New($p0));
  if (info[1]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[1]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = item->ToObject();
      _VkLayerProperties* result = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(obj);
      VkLayerProperties *instance = &result->instance;
      VkLayerProperties *copy = &$p1[ii];
      
      {
        std::string stri(copy->layerName);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->layerName = str;
        strcpy(instance->layerName, copy->layerName);
      }
      {
        std::string stri(copy->description);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->description = str;
        strcpy(instance->description, copy->description);
      }
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetDeviceQueue(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1]->NumberValue());

  uint32_t $p2 = static_cast<uint32_t>(info[2]->NumberValue());

  _VkQueue* obj3;
  VkQueue *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkQueue>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  vkGetDeviceQueue(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkQueueSubmit(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1]->NumberValue());

  VkSubmitInfo *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Objects<VkSubmitInfo, _VkSubmitInfo>(info[2]);
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkFence>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkQueueSubmit(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    info[3]->IsNull() ? VK_NULL_HANDLE : *$p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateSemaphore(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSemaphoreCreateInfo* obj1;
  VkSemaphoreCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSemaphore(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateImageView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageViewCreateInfo* obj1;
  VkImageViewCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkImageView* obj3;
  VkImageView *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkImageView>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateImageView(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateShaderModule(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkShaderModuleCreateInfo* obj1;
  VkShaderModuleCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkShaderModule* obj3;
  VkShaderModule *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkShaderModule>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateShaderModule(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateGraphicsPipelines(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineCache>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2]->NumberValue());

  VkGraphicsPipelineCreateInfo *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = createArrayOfV8Objects<VkGraphicsPipelineCreateInfo, _VkGraphicsPipelineCreateInfo>(info[3]);
  }



  VkPipeline *$p5 = nullptr;

  if (info[5]->IsArray()) {

    $p5 = createArrayOfV8Handles<VkPipeline, _VkPipeline>(info[5]);
  }

  int32_t out = vkCreateGraphicsPipelines(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    nullptr,
    $p5
  );
  if (info[5]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPipeline* target = Nan::ObjectWrap::Unwrap<_VkPipeline>(item->ToObject());
      target->instance = $p5[ii];
    };
    delete[] $p5;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreatePipelineLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineLayoutCreateInfo* obj1;
  VkPipelineLayoutCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkPipelineLayout* obj3;
  VkPipelineLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreatePipelineLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateFramebuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkFramebufferCreateInfo* obj1;
  VkFramebufferCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkFramebuffer* obj3;
  VkFramebuffer *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateFramebuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPassCreateInfo* obj1;
  VkRenderPassCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkRenderPass* obj3;
  VkRenderPass *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkRenderPass>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateCommandPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPoolCreateInfo* obj1;
  VkCommandPoolCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkCommandPool* obj3;
  VkCommandPool *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateCommandPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAllocateCommandBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandBufferAllocateInfo* obj1;
  VkCommandBufferAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  VkCommandBuffer *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Handles<VkCommandBuffer, _VkCommandBuffer>(info[2]);
  }

  int32_t out = vkAllocateCommandBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCommandBuffer* target = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(item->ToObject());
      target->instance = $p2[ii];
    };
    delete[] $p2;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkBeginCommandBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandBufferBeginInfo* obj1;
  VkCommandBufferBeginInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  int32_t out = vkBeginCommandBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEndCommandBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkEndCommandBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCmdBindPipeline(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1]->Uint32Value());

  _VkPipeline* obj2;
  VkPipeline *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkPipeline>(info[2]->ToObject());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }
  vkCmdBindPipeline(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdDraw(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1]->NumberValue());

  uint32_t $p2 = static_cast<uint32_t>(info[2]->NumberValue());

  uint32_t $p3 = static_cast<uint32_t>(info[3]->NumberValue());

  uint32_t $p4 = static_cast<uint32_t>(info[4]->NumberValue());
  vkCmdDraw(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBeginRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPassBeginInfo* obj1;
  VkRenderPassBeginInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  VkSubpassContents $p2 = static_cast<VkSubpassContents>(info[2]->Uint32Value());
  vkCmdBeginRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdEndRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  vkCmdEndRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceSurfaceSupportKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1]->NumberValue());

  _VkSurfaceKHR* obj2;
  VkSurfaceKHR *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[2]->ToObject());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj3;
  uint32_t $p3;
  if (!(info[3]->IsNull())) {
    obj3 = info[3]->ToObject();
    $p3 = static_cast<uint32_t>(obj3->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }
  int32_t out = vkGetPhysicalDeviceSurfaceSupportKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    &$p3
  );
    obj3->Set(Nan::New("$").ToLocalChecked(), Nan::New($p3));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceCapabilitiesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkSurfaceCapabilitiesKHR* obj2;
  VkSurfaceCapabilitiesKHR *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info[2]->ToObject());
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  int32_t out = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->currentExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->minImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->maxImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceFormatsKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = info[2]->ToObject();
    $p2 = static_cast<uint32_t>(obj2->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }

  VkSurfaceFormatKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkSurfaceFormatKHR, _VkSurfaceFormatKHR>(info[3]);
  }

  int32_t out = vkGetPhysicalDeviceSurfaceFormatsKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = item->ToObject();
      _VkSurfaceFormatKHR* result = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(obj);
      VkSurfaceFormatKHR *instance = &result->instance;
      VkSurfaceFormatKHR *copy = &$p3[ii];
      
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfacePresentModesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = info[2]->ToObject();
    $p2 = static_cast<uint32_t>(obj2->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }

  VkPresentModeKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    VkPresentModeKHR * arr3 = new VkPresentModeKHR[array->Length()];
    $p3 = arr3;
  }

  int32_t out = vkGetPhysicalDeviceSurfacePresentModesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      array->Set(ii, Nan::New($p3[ii]));
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateSwapchainKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainCreateInfoKHR* obj1;
  VkSwapchainCreateInfoKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSwapchainKHR* obj3;
  VkSwapchainKHR *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSwapchainKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetSwapchainImagesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = info[2]->ToObject();
    $p2 = static_cast<uint32_t>(obj2->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }

  VkImage *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = createArrayOfV8Handles<VkImage, _VkImage>(info[3]);
  }

  int32_t out = vkGetSwapchainImagesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImage* target = Nan::ObjectWrap::Unwrap<_VkImage>(item->ToObject());
      target->instance = $p3[ii];
    };
    delete[] $p3;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAcquireNextImageKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2]->NumberValue());

  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(info[3]->ToObject());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }

  _VkFence* obj4;
  VkFence *$p4;
  if (!(info[4]->IsNull())) {
    obj4 = Nan::ObjectWrap::Unwrap<_VkFence>(info[4]->ToObject());
    $p4 = &obj4->instance;
  } else {
    $p4 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj5;
  uint32_t $p5;
  if (!(info[5]->IsNull())) {
    obj5 = info[5]->ToObject();
    $p5 = static_cast<uint32_t>(obj5->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  }
  int32_t out = vkAcquireNextImageKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3]->IsNull() ? VK_NULL_HANDLE : *$p3,
    info[4]->IsNull() ? VK_NULL_HANDLE : *$p4,
    &$p5
  );
    obj5->Set(Nan::New("$").ToLocalChecked(), Nan::New($p5));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkQueuePresentKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(info[0]->ToObject());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPresentInfoKHR* obj1;
  VkPresentInfoKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info[1]->ToObject());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  int32_t out = vkQueuePresentKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};



#endif
