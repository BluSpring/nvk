/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY node-vulkan v0.0.1
 * I CANT STOP SCREAMING
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#include <nan.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "index.h"

#include <map>
#include <string>

void _vkCreateInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstanceCreateInfo* obj0 = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info[0]->ToObject());
  VkInstanceCreateInfo *$p0 = &obj0->instance;


  _VkInstance* obj2 = Nan::ObjectWrap::Unwrap<_VkInstance>(info[2]->ToObject());
  VkInstance *$p2 = &obj2->instance;
  int32_t out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumeratePhysicalDevices(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(info[0]->ToObject());
  VkInstance *$p0 = &obj0->instance;

  v8::Local<v8::Object> obj1 = info[1]->ToObject();
  uint32_t $p1 = static_cast<uint32_t>(obj1->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkPhysicalDevice *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Objects<VkPhysicalDevice, _VkPhysicalDevice>(info[2]);
  }

  int32_t out = vkEnumeratePhysicalDevices(
    *$p0,
    &$p1,
    $p2
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkPhysicalDeviceProperties* obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info[1]->ToObject());
  VkPhysicalDeviceProperties *$p1 = &obj1->instance;
  vkGetPhysicalDeviceProperties(
    *$p0,
    $p1
  );
  {
    // back reflect string
    v8::Local<v8::String> str1 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), (&obj1->instance)->deviceName);
    obj1->deviceName = Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>>(str1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 16);
    // populate array
    for (unsigned int ii = 0; ii < 16; ++ii) {
      arr1->Set(ii, Nan::New((&obj1->instance)->pipelineCacheUUID[ii]));
    };
    obj1->pipelineCacheUUID = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceLimits::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceLimits* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(inst);
    obj1->limits = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.limits, sizeof(VkPhysicalDeviceLimits));
    
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupCount[ii]));
    };
    unwrapped6->maxComputeWorkGroupCount = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupSize[ii]));
    };
    unwrapped6->maxComputeWorkGroupSize = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxViewportDimensions[ii]));
    };
    unwrapped6->maxViewportDimensions = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->viewportBoundsRange[ii]));
    };
    unwrapped6->viewportBoundsRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->pointSizeRange[ii]));
    };
    unwrapped6->pointSizeRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->lineWidthRange[ii]));
    };
    unwrapped6->lineWidthRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceSparseProperties::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceSparseProperties* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(inst);
    obj1->sparseProperties = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.sparseProperties, sizeof(VkPhysicalDeviceSparseProperties));
    
  }
      
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  v8::Local<v8::Object> obj1 = info[1]->ToObject();
  uint32_t $p1 = static_cast<uint32_t>(obj1->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkQueueFamilyProperties *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = copyArrayOfV8Objects<VkQueueFamilyProperties, _VkQueueFamilyProperties>(info[2]);
  }

  vkGetPhysicalDeviceQueueFamilyProperties(
    *$p0,
    &$p1,
    $p2
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = item->ToObject();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(obj);
      VkQueueFamilyProperties *instance = &result->instance;
      VkQueueFamilyProperties *copy = &$p2[ii];
      
      instance->minImageTransferGranularity = copy->minImageTransferGranularity;
      if (&copy->minImageTransferGranularity != nullptr) {
        
  v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent3D::constructor)).ToLocalChecked();
  v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
  _VkExtent3D* unwrapped = Nan::ObjectWrap::Unwrap<_VkExtent3D>(inst);
        result->minImageTransferGranularity = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
        unwrapped->instance = copy->minImageTransferGranularity;
      }
    };
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceMemoryProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkPhysicalDeviceMemoryProperties* obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(info[1]->ToObject());
  VkPhysicalDeviceMemoryProperties *$p1 = &obj1->instance;
  vkGetPhysicalDeviceMemoryProperties(
    *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceFeatures(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkPhysicalDeviceFeatures* obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info[1]->ToObject());
  VkPhysicalDeviceFeatures *$p1 = &obj1->instance;
  vkGetPhysicalDeviceFeatures(
    *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateDevice(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkDeviceCreateInfo* obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info[1]->ToObject());
  VkDeviceCreateInfo *$p1 = &obj1->instance;


  _VkDevice* obj3 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[3]->ToObject());
  VkDevice *$p3 = &obj3->instance;
  int32_t out = vkCreateDevice(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumerateInstanceLayerProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  v8::Local<v8::Object> obj0 = info[0]->ToObject();
  uint32_t $p0 = static_cast<uint32_t>(obj0->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkLayerProperties *$p1 = nullptr;

  if (info[1]->IsArray()) {

    $p1 = copyArrayOfV8Objects<VkLayerProperties, _VkLayerProperties>(info[1]);
  }

  int32_t out = vkEnumerateInstanceLayerProperties(
    &$p0,
    $p1
  );
    obj0->Set(Nan::New("$").ToLocalChecked(), Nan::New($p0));
  if (info[1]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[1]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = item->ToObject();
      _VkLayerProperties* result = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(obj);
      VkLayerProperties *instance = &result->instance;
      VkLayerProperties *copy = &$p1[ii];
      
      {
        std::string stri(copy->layerName);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->layerName = str;
        strcpy(instance->layerName, copy->layerName);
      }
      {
        std::string stri(copy->description);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->description = str;
        strcpy(instance->description, copy->description);
      }
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetDeviceQueue(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  uint32_t $p1 = static_cast<uint32_t>(info[1]->NumberValue());

  uint32_t $p2 = static_cast<uint32_t>(info[2]->NumberValue());

  _VkQueue* obj3 = Nan::ObjectWrap::Unwrap<_VkQueue>(info[3]->ToObject());
  VkQueue *$p3 = &obj3->instance;
  vkGetDeviceQueue(
    *$p0,
    $p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateImageView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkImageViewCreateInfo* obj1 = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info[1]->ToObject());
  VkImageViewCreateInfo *$p1 = &obj1->instance;


  _VkImageView* obj3 = Nan::ObjectWrap::Unwrap<_VkImageView>(info[3]->ToObject());
  VkImageView *$p3 = &obj3->instance;
  int32_t out = vkCreateImageView(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateShaderModule(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkShaderModuleCreateInfo* obj1 = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info[1]->ToObject());
  VkShaderModuleCreateInfo *$p1 = &obj1->instance;


  _VkShaderModule* obj3 = Nan::ObjectWrap::Unwrap<_VkShaderModule>(info[3]->ToObject());
  VkShaderModule *$p3 = &obj3->instance;
  int32_t out = vkCreateShaderModule(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateGraphicsPipelines(const Nan::FunctionCallbackInfo<v8::Value>& info) {

  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  uint32_t $p2 = static_cast<uint32_t>(info[2]->NumberValue());

  VkGraphicsPipelineCreateInfo *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkGraphicsPipelineCreateInfo, _VkGraphicsPipelineCreateInfo>(info[3]);
  }

  VkPipeline *$p5 = nullptr;

  if (info[5]->IsArray()) {

    $p5 = createArrayOfV8Handles<VkPipeline, _VkPipeline>(info[5]);
  }

  int32_t out = vkCreateGraphicsPipelines(
    *$p0,
    VK_NULL_HANDLE,
    $p2,
    $p3,
    nullptr,
    $p5
  );

  if (info[5]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();

      _VkPipeline* target = Nan::ObjectWrap::Unwrap<_VkPipeline>(item->ToObject());
      target->instance = $p5[ii];
    };
    delete[] $p5;
  }

  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreatePipelineLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkPipelineLayoutCreateInfo* obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info[1]->ToObject());
  VkPipelineLayoutCreateInfo *$p1 = &obj1->instance;


  _VkPipelineLayout* obj3 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(info[3]->ToObject());
  VkPipelineLayout *$p3 = &obj3->instance;
  int32_t out = vkCreatePipelineLayout(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateFramebuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkFramebufferCreateInfo* obj1 = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info[1]->ToObject());
  VkFramebufferCreateInfo *$p1 = &obj1->instance;


  _VkFramebuffer* obj3 = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(info[3]->ToObject());
  VkFramebuffer *$p3 = &obj3->instance;
  int32_t out = vkCreateFramebuffer(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkRenderPassCreateInfo* obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info[1]->ToObject());
  VkRenderPassCreateInfo *$p1 = &obj1->instance;


  _VkRenderPass* obj3 = Nan::ObjectWrap::Unwrap<_VkRenderPass>(info[3]->ToObject());
  VkRenderPass *$p3 = &obj3->instance;
  int32_t out = vkCreateRenderPass(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceSupportKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  uint32_t $p1 = static_cast<uint32_t>(info[1]->NumberValue());

  _VkSurfaceKHR* obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[2]->ToObject());
  VkSurfaceKHR *$p2 = &obj2->instance;

  v8::Local<v8::Object> obj3 = info[3]->ToObject();
  uint32_t $p3 = static_cast<uint32_t>(obj3->Get(Nan::New("$").ToLocalChecked())->NumberValue());
  int32_t out = vkGetPhysicalDeviceSurfaceSupportKHR(
    *$p0,
    $p1,
    *$p2,
    &$p3
  );
    obj3->Set(Nan::New("$").ToLocalChecked(), Nan::New($p3));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceCapabilitiesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkSurfaceKHR* obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[1]->ToObject());
  VkSurfaceKHR *$p1 = &obj1->instance;

  _VkSurfaceCapabilitiesKHR* obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info[2]->ToObject());
  VkSurfaceCapabilitiesKHR *$p2 = &obj2->instance;
  int32_t out = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    *$p0,
    *$p1,
    $p2
  );
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->currentExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->minImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->maxImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceFormatsKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkSurfaceKHR* obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[1]->ToObject());
  VkSurfaceKHR *$p1 = &obj1->instance;

  v8::Local<v8::Object> obj2 = info[2]->ToObject();
  uint32_t $p2 = static_cast<uint32_t>(obj2->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkSurfaceFormatKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkSurfaceFormatKHR, _VkSurfaceFormatKHR>(info[3]);
  }

  int32_t out = vkGetPhysicalDeviceSurfaceFormatsKHR(
    *$p0,
    *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = item->ToObject();
      _VkSurfaceFormatKHR* result = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(obj);
      VkSurfaceFormatKHR *instance = &result->instance;
      VkSurfaceFormatKHR *copy = &$p3[ii];
      
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfacePresentModesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(info[0]->ToObject());
  VkPhysicalDevice *$p0 = &obj0->instance;

  _VkSurfaceKHR* obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(info[1]->ToObject());
  VkSurfaceKHR *$p1 = &obj1->instance;

  v8::Local<v8::Object> obj2 = info[2]->ToObject();
  uint32_t $p2 = static_cast<uint32_t>(obj2->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkPresentModeKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    VkPresentModeKHR * arr3 = new VkPresentModeKHR[array->Length()];
    $p3 = arr3;
  }

  int32_t out = vkGetPhysicalDeviceSurfacePresentModesKHR(
    *$p0,
    *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      array->Set(ii, Nan::New($p3[ii]));
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateSwapchainKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkSwapchainCreateInfoKHR* obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info[1]->ToObject());
  VkSwapchainCreateInfoKHR *$p1 = &obj1->instance;


  _VkSwapchainKHR* obj3 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(info[3]->ToObject());
  VkSwapchainKHR *$p3 = &obj3->instance;
  int32_t out = vkCreateSwapchainKHR(
    *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetSwapchainImagesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(info[0]->ToObject());
  VkDevice *$p0 = &obj0->instance;

  _VkSwapchainKHR* obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(info[1]->ToObject());
  VkSwapchainKHR *$p1 = &obj1->instance;

  v8::Local<v8::Object> obj2 = info[2]->ToObject();
  uint32_t $p2 = static_cast<uint32_t>(obj2->Get(Nan::New("$").ToLocalChecked())->NumberValue());

  VkImage *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = createArrayOfV8Handles<VkImage, _VkImage>(info[3]);
  }

  int32_t out = vkGetSwapchainImagesKHR(
    *$p0,
    *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImage* target = Nan::ObjectWrap::Unwrap<_VkImage>(item->ToObject());
      target->instance = $p3[ii];
    };
    delete[] $p3;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};



#endif
